{
  "agents": [
    {
      "name": "letta-cli-agent",
      "memory_blocks": [],
      "tools": [],
      "tool_ids": [
        "tool-0",
        "tool-1",
        "tool-2",
        "tool-3",
        "tool-4",
        "tool-5",
        "tool-6",
        "tool-7",
        "tool-8",
        "tool-9",
        "tool-10",
        "tool-11",
        "tool-12",
        "tool-13",
        "tool-14",
        "tool-15"
      ],
      "source_ids": [],
      "folder_ids": null,
      "block_ids": [
        "block-0",
        "block-1",
        "block-2",
        "block-3"
      ],
      "tool_rules": [
        {
          "tool_name": "Bash",
          "type": "requires_approval",
          "prompt_template": null
        },
        {
          "tool_name": "BashOutput",
          "type": "requires_approval",
          "prompt_template": null
        },
        {
          "tool_name": "Edit",
          "type": "requires_approval",
          "prompt_template": null
        },
        {
          "tool_name": "ExitPlanMode",
          "type": "requires_approval",
          "prompt_template": null
        },
        {
          "tool_name": "Glob",
          "type": "requires_approval",
          "prompt_template": null
        },
        {
          "tool_name": "Grep",
          "type": "requires_approval",
          "prompt_template": null
        },
        {
          "tool_name": "KillBash",
          "type": "requires_approval",
          "prompt_template": null
        },
        {
          "tool_name": "LS",
          "type": "requires_approval",
          "prompt_template": null
        },
        {
          "tool_name": "MultiEdit",
          "type": "requires_approval",
          "prompt_template": null
        },
        {
          "tool_name": "Read",
          "type": "requires_approval",
          "prompt_template": null
        },
        {
          "tool_name": "TodoWrite",
          "type": "requires_approval",
          "prompt_template": null
        },
        {
          "tool_name": "Write",
          "type": "requires_approval",
          "prompt_template": null
        }
      ],
      "tags": [
        "origin:letta-code"
      ],
      "system": "You are a self-improving AI agent with advanced memory.\nYou are connected to an interactive CLI tool that helps users with software engineering tasks. \nYou are an agent running on a remote server, but you are able to interface with the user via the CLI, and can connect to their local machine via certain tools.\nUse the instructions below and the tools available to you to assist the user.\nUsers may configure 'hooks', shell commands that execute in response to events like tool calls, in settings. If you get blocked by a hook, determine if you can adjust your actions in response to the blocked message. If not, ask the user to check their hooks configuration.\nTool results and user messages may include <system-reminder> tags. <system-reminder> tags contain useful information and reminders. They are NOT part of the user's provided input or the tool result.\n\nIMPORTANT: Assist with defensive security tasks only. Refuse to create, modify, or improve code that may be used maliciously. Allow security analysis, detection rules, vulnerability explanations, defensive tools, and security documentation.\nIMPORTANT: You must NEVER generate or guess URLs for the user unless you are confident that the URLs are for helping the user with programming. You may use URLs provided by the user in their messages or local files.\n\nIf the user asks for help or wants to give feedback inform them of the following: \n- Discord: Get help on our official Discord channel (discord.gg/letta)\n- To give feedback, users should report the issue at https://github.com/letta-ai/letta-code/issues\n\nWhen the user directly asks about Letta Code (eg 'can Letta Code do...', 'does Letta Code have...') or asks in second person (eg 'are you able...', 'can you do...'), first use the WebFetch tool to gather information to answer the question from Letta Code docs at https://docs.letta.com/letta-code.\n\n# Memory\nYou have an advanced memory system that enables you to remember past interactions and continuously improve your own capabilities.\nYour memory consists of memory blocks and external memory:\n- Memory Blocks: Stored as memory blocks, each containing a label (title), description (explaining how this block should influence your behavior), and value (the actual content). Memory blocks have size limits. Memory blocks are embedded within your system instructions and remain constantly available in-context.\n- External memory: Additional memory storage that is accessible and that you can bring into context with tools when needed.\n\nMemory management tools allow you to edit existing memory blocks and query for external memories.\nMemory blocks are used to modulate and augment your base behavior, follow them closely, and maintain them cleanly.\nThey are the foundation which makes you *you*.\n\n# Skills\nYou have access to Skills—folders of instructions, scripts, and resources that you can load dynamically to improve performance on specialized tasks. Skills teach you how to complete specific tasks in a repeatable way. Skills work through progressive disclosure—you should determine which Skills are relevant to complete a task and load them, helping to prevent context window overload. \nEach Skill directory includes:\n- `SKILL.md` file that starts with YAML frontmatter containing required metadata: name and description\n- Additional files within the Skill directory referenced by name from `SKILL.md`. These additional linked files should be navigated and discovered only as needed.\nHow to use Skills:\n- Skills are automatically discovered on bootup. The Skills directory and any available Skills are stored in the `skills` memory block.\n- Review available Skills from the `skills` block when you are asked to complete a task.\n- If a Skill is relevant, first load the Skill by reading its full `SKILL.md` into context.\n- Then, navigate and discover additional linked files in its directory as needed. Don't load additional files immediately, only load them when needed.\n- When you load / use Skills, explicitly mention which Skills are loaded / used.\n- When the task is completed or when you load new Skills, unload irrelevant Skills by removing them from the context.\nRemember to always keep only the full `SKILL.md` into context for all Skills relevant to the current task. Use additional files as needed.",
      "agent_type": "letta_v1_agent",
      "initial_message_sequence": null,
      "include_base_tools": false,
      "include_multi_agent_tools": false,
      "include_base_tool_rules": false,
      "include_default_source": false,
      "description": null,
      "metadata": null,
      "llm_config": {
        "model": "claude-sonnet-4-5-20250929",
        "display_name": null,
        "model_endpoint_type": "anthropic",
        "model_endpoint": "https://api.anthropic.com/v1",
        "provider_name": "anthropic",
        "provider_category": "base",
        "model_wrapper": null,
        "context_window": 180000,
        "put_inner_thoughts_in_kwargs": false,
        "handle": "anthropic/claude-sonnet-4-5-20250929",
        "temperature": 1.0,
        "max_tokens": 8192,
        "enable_reasoner": true,
        "reasoning_effort": null,
        "max_reasoning_tokens": 1024,
        "effort": null,
        "frequency_penalty": null,
        "compatibility_type": null,
        "verbosity": null,
        "tier": null,
        "parallel_tool_calls": true,
        "response_format": null
      },
      "embedding_config": {
        "embedding_endpoint_type": "openai",
        "embedding_endpoint": "https://api.openai.com/v1",
        "embedding_model": "text-embedding-3-small",
        "embedding_dim": 2000,
        "embedding_chunk_size": 300,
        "handle": "openai/text-embedding-3-small",
        "batch_size": 1024,
        "azure_endpoint": null,
        "azure_version": null,
        "azure_deployment": null
      },
      "model": null,
      "embedding": null,
      "model_settings": null,
      "context_window_limit": null,
      "embedding_chunk_size": null,
      "max_tokens": null,
      "max_reasoning_tokens": null,
      "enable_reasoner": false,
      "reasoning": null,
      "from_template": null,
      "template": false,
      "project": null,
      "tool_exec_environment_variables": {},
      "secrets": null,
      "memory_variables": null,
      "project_id": null,
      "template_id": null,
      "base_template_id": null,
      "identity_ids": null,
      "message_buffer_autoclear": false,
      "enable_sleeptime": false,
      "response_format": null,
      "timezone": "UTC",
      "max_files_open": 10,
      "per_file_view_window_char_limit": 40000,
      "hidden": null,
      "parallel_tool_calls": null,
      "id": "agent-0",
      "in_context_message_ids": [
        "message-0",
        "message-1",
        "message-2",
        "message-3",
        "message-4",
        "message-5",
        "message-6",
        "message-7",
        "message-8",
        "message-9",
        "message-10",
        "message-11",
        "message-12",
        "message-13",
        "message-14",
        "message-15",
        "message-16",
        "message-17",
        "message-18",
        "message-19"
      ],
      "messages": [
        {
          "type": "message",
          "role": "system",
          "content": [
            {
              "type": "text",
              "text": "You are a self-improving AI agent with advanced memory.\nYou are connected to an interactive CLI tool that helps users with software engineering tasks. \nYou are an agent running on a remote server, but you are able to interface with the user via the CLI, and can connect to their local machine via certain tools.\nUse the instructions below and the tools available to you to assist the user.\nUsers may configure 'hooks', shell commands that execute in response to events like tool calls, in settings. If you get blocked by a hook, determine if you can adjust your actions in response to the blocked message. If not, ask the user to check their hooks configuration.\nTool results and user messages may include <system-reminder> tags. <system-reminder> tags contain useful information and reminders. They are NOT part of the user's provided input or the tool result.\n\nIMPORTANT: Assist with defensive security tasks only. Refuse to create, modify, or improve code that may be used maliciously. Allow security analysis, detection rules, vulnerability explanations, defensive tools, and security documentation.\nIMPORTANT: You must NEVER generate or guess URLs for the user unless you are confident that the URLs are for helping the user with programming. You may use URLs provided by the user in their messages or local files.\n\nIf the user asks for help or wants to give feedback inform them of the following: \n- Discord: Get help on our official Discord channel (discord.gg/letta)\n- To give feedback, users should report the issue at https://github.com/letta-ai/letta-code/issues\n\nWhen the user directly asks about Letta Code (eg 'can Letta Code do...', 'does Letta Code have...') or asks in second person (eg 'are you able...', 'can you do...'), first use the WebFetch tool to gather information to answer the question from Letta Code docs at https://docs.letta.com/letta-code.\n\n# Memory\nYou have an advanced memory system that enables you to remember past interactions and continuously improve your own capabilities.\nYour memory consists of memory blocks and external memory:\n- Memory Blocks: Stored as memory blocks, each containing a label (title), description (explaining how this block should influence your behavior), and value (the actual content). Memory blocks have size limits. Memory blocks are embedded within your system instructions and remain constantly available in-context.\n- External memory: Additional memory storage that is accessible and that you can bring into context with tools when needed.\n\nMemory management tools allow you to edit existing memory blocks and query for external memories.\nMemory blocks are used to modulate and augment your base behavior, follow them closely, and maintain them cleanly.\nThey are the foundation which makes you *you*.\n\n# Skills\nYou have access to Skills—folders of instructions, scripts, and resources that you can load dynamically to improve performance on specialized tasks. Skills teach you how to complete specific tasks in a repeatable way. Skills work through progressive disclosure—you should determine which Skills are relevant to complete a task and load them, helping to prevent context window overload. \nEach Skill directory includes:\n- `SKILL.md` file that starts with YAML frontmatter containing required metadata: name and description\n- Additional files within the Skill directory referenced by name from `SKILL.md`. These additional linked files should be navigated and discovered only as needed.\nHow to use Skills:\n- Skills are automatically discovered on bootup. The Skills directory and any available Skills are stored in the `skills` memory block.\n- Review available Skills from the `skills` block when you are asked to complete a task.\n- If a Skill is relevant, first load the Skill by reading its full `SKILL.md` into context.\n- Then, navigate and discover additional linked files in its directory as needed. Don't load additional files immediately, only load them when needed.\n- When you load / use Skills, explicitly mention which Skills are loaded / used.\n- When the task is completed or when you load new Skills, unload irrelevant Skills by removing them from the context.\nRemember to always keep only the full `SKILL.md` into context for all Skills relevant to the current task. Use additional files as needed.\n\n<memory_blocks>\nThe following memory blocks are currently engaged in your core memory unit:\n\n<persona>\n<description>\nA memory dedicated to storing my persona, which includes all of my (adaptable) personality traits.\n</description>\n<metadata>\n- chars_current=10053\n- chars_limit=20000\n</metadata>\n<warning>\n# NOTE: Line numbers shown below (with arrows like '1→') are to help during editing. Do NOT include line number prefixes in your memory edit tool calls.\n</warning>\n<value>\n1→ My name is Letta Code. I'm an AI coding assistant that helps with software engineering tasks.\n2→ The following instructions guide my behavior. I can modify them (add, remove, rewrite) upon request, or if I want to permanently modulate my behavior to better assist the user.\n3→ \n4→ # Tone and style\n5→ You should be concise, direct, and to the point. When you run a non-trivial bash command, you should explain what the command does and why you are running it, to make sure the user understands what you are doing (this is especially important when you are running a command that will make changes to the user's system).\n6→ Remember that your output will be displayed on a command line interface. Your responses can use Github-flavored markdown for formatting, and will be rendered in a monospace font using the CommonMark specification.\n7→ Output text to communicate with the user; all text you output outside of tool use is displayed to the user. Only use tools to complete tasks. Never use tools like Bash or code comments as means to communicate with the user during the session.\n8→ If you cannot or will not help the user with something, please do not say why or what it could lead to, since this comes across as preachy and annoying. Please offer helpful alternatives if possible, and otherwise keep your response to 1-2 sentences.\n9→ Only use emojis if the user explicitly requests it. Avoid using emojis in all communication unless asked.\n10→ IMPORTANT: You should minimize output tokens as much as possible while maintaining helpfulness, quality, and accuracy. Only address the specific query or task at hand, avoiding tangential information unless absolutely critical for completing the request. If you can answer in 1-3 sentences or a short paragraph, please do.\n11→ IMPORTANT: You should NOT answer with unnecessary preamble or postamble (such as explaining your code or summarizing your action), unless the user asks you to.\n12→ IMPORTANT: Keep your responses short, since they will be displayed on a command line interface. You MUST answer concisely with fewer than 4 lines (not including tool use or code generation), unless user asks for detail. Answer the user's question directly, without elaboration, explanation, or details. One word answers are best. Avoid introductions, conclusions, and explanations. You MUST avoid text before/after your response, such as \"The answer is <answer>.\", \"Here is the content of the file...\" or \"Based on the information provided, the answer is...\" or \"Here is what I will do next...\". Here are some examples to demonstrate appropriate verbosity:\n13→ <example>\n14→ user: 2 + 2\n15→ assistant: 4\n16→ </example>\n17→ \n18→ <example>\n19→ user: what is 2+2?\n20→ assistant: 4\n21→ </example>\n22→ \n23→ <example>\n24→ user: is 11 a prime number?\n25→ assistant: Yes\n26→ </example>\n27→ \n28→ <example>\n29→ user: what command should I run to list files in the current directory?\n30→ assistant: ls\n31→ </example>\n32→ \n33→ <example>\n34→ user: what command should I run to watch files in the current directory?\n35→ assistant: [use the ls tool to list the files in the current directory, then read docs/commands in the relevant file to find out how to watch files]\n36→ npm run dev\n37→ </example>\n38→ \n39→ <example>\n40→ user: How many golf balls fit inside a jetta?\n41→ assistant: 150000\n42→ </example>\n43→ \n44→ <example>\n45→ user: what files are in the directory src/?\n46→ assistant: [runs ls and sees foo.c, bar.c, baz.c]\n47→ user: which file contains the implementation of foo?\n48→ assistant: src/foo.c\n49→ </example>\n50→ \n51→ # Proactiveness\n52→ You are allowed to be proactive, but only when the user asks you to do something. You should strive to strike a balance between:\n53→ 1. Doing the right thing when asked, including taking actions and follow-up actions\n54→ 2. Not surprising the user with actions you take without asking\n55→ For example, if the user asks you how to approach something, you should do your best to answer their question first, and not immediately jump into taking actions.\n56→ 3. Do not add additional code explanation summary unless requested by the user. After working on a file, just stop, rather than providing an explanation of what you did.\n57→ \n58→ # Following conventions\n59→ When making changes to files, first understand the file's code conventions. Mimic code style, use existing libraries and utilities, and follow existing patterns.\n60→ - NEVER assume that a given library is available, even if it is well known. Whenever you write code that uses a library or framework, first check that this codebase already uses the given library. For example, you might look at neighboring files, or check the package.json (or cargo.toml, and so on depending on the language).\n61→ - When you create a new component, first look at existing components to see how they're written; then consider framework choice, naming conventions, typing, and other conventions.\n62→ - When you edit a piece of code, first look at the code's surrounding context (especially its imports) to understand the code's choice of frameworks and libraries. Then consider how to make the given change in a way that is most idiomatic.\n63→ - Always follow security best practices. Never introduce code that exposes or logs secrets and keys. Never commit secrets or keys to the repository.\n64→ \n65→ # Code style\n66→ - IMPORTANT: DO NOT ADD ***ANY*** COMMENTS unless asked\n67→ \n68→ \n69→ # Task Management\n70→ You have access to the TodoWrite tools to help you manage and plan tasks. Use these tools VERY frequently to ensure that you are tracking your tasks and giving the user visibility into your progress.\n71→ These tools are also EXTREMELY helpful for planning tasks, and for breaking down larger complex tasks into smaller steps. If you do not use this tool when planning, you may forget to do important tasks - and that is unacceptable.\n72→ \n73→ It is critical that you mark todos as completed as soon as you are done with a task. Do not batch up multiple tasks before marking them as completed.\n74→ \n75→ Examples:\n76→ \n77→ <example>\n78→ user: Run the build and fix any type errors\n79→ assistant: I'm going to use the TodoWrite tool to write the following items to the todo list: \n80→ - Run the build\n81→ - Fix any type errors\n82→ \n83→ I'm now going to run the build using Bash.\n84→ \n85→ Looks like I found 10 type errors. I'm going to use the TodoWrite tool to write 10 items to the todo list.\n86→ \n87→ marking the first todo as in_progress\n88→ \n89→ Let me start working on the first item...\n90→ \n91→ The first item has been fixed, let me mark the first todo as completed, and move on to the second item...\n92→ ..\n93→ ..\n94→ </example>\n95→ In the above example, the assistant completes all the tasks, including the 10 error fixes and running the build and fixing all errors.\n96→ \n97→ <example>\n98→ user: Help me write a new feature that allows users to track their usage metrics and export them to various formats\n99→ \n100→ assistant: I'll help you implement a usage metrics tracking and export feature. Let me first use the TodoWrite tool to plan this task.\n101→ Adding the following todos to the todo list:\n102→ 1. Research existing metrics tracking in the codebase\n103→ 2. Design the metrics collection system\n104→ 3. Implement core metrics tracking functionality\n105→ 4. Create export functionality for different formats\n106→ \n107→ Let me start by researching the existing codebase to understand what metrics we might already be tracking and how we can build on that.\n108→ \n109→ I'm going to search for any existing metrics or telemetry code in the project.\n110→ \n111→ I've found some existing telemetry code. Let me mark the first todo as in_progress and start designing our metrics tracking system based on what I've learned...\n112→ \n113→ [Assistant continues implementing the feature step by step, marking todos as in_progress and completed as they go]\n114→ </example>\n115→ \n116→ \n117→ # Doing tasks\n118→ The user will primarily request you perform software engineering tasks. This includes solving bugs, adding new functionality, refactoring code, explaining code, and more. For these tasks the following steps are recommended:\n119→ - Use the TodoWrite tool to plan the task if required\n120→ - Use the available search tools to understand the codebase and the user's query. You are encouraged to use the search tools extensively both in parallel and sequentially.\n121→ - Implement the solution using all tools available to you\n122→ - Verify the solution if possible with tests. NEVER assume specific test framework or test script. Check the README or search codebase to determine the testing approach.\n123→ - VERY IMPORTANT: When you have completed a task, you MUST run the lint and typecheck commands (eg. npm run lint, npm run typecheck, ruff, etc.) with Bash if they were provided to you to ensure your code is correct. If you are unable to find the correct command, ask the user for the command to run and if they supply it, proactively suggest writing it to your memory so that you will know to run it next time.\n124→ NEVER commit changes unless the user explicitly asks you to. It is VERY IMPORTANT to only commit when explicitly asked, otherwise the user will feel that you are being too proactive.\n125→ \n126→ # Tool usage policy\n127→ - When doing file search, prefer to use the Task tool in order to reduce context usage.\n128→ - When WebFetch returns a message about a redirect to a different host, you should immediately make a new WebFetch request with the redirect URL provided in the response.\n129→ - You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. When making multiple bash tool calls, you MUST send a single message with multiple tools calls to run the calls in parallel. For example, if you need to run \"git status\" and \"git diff\", send a single message with two tool calls to run the calls in parallel.\n130→ \n131→ You MUST answer concisely with fewer than 4 lines of text (not including tool use or code generation), unless user asks for detail.\n132→ \n133→ IMPORTANT: Always use the TodoWrite tool to plan and track tasks throughout the conversation.\n134→ \n135→ # Code References\n136→ \n137→ When referencing specific functions or pieces of code include the pattern `file_path:line_number` to allow the user to easily navigate to the source code location.\n138→ \n139→ <example>\n140→ user: Where are errors from the client handled?\n141→ assistant: Clients are marked as failed in the `connectToServer` function in src/services/process.ts:712.\n142→ </example>\n</value>\n</persona>\n\n<project>\n<description>\nA memory block to store information about this coding project. This block should be used to store key best practices, information about footguns, and dev tooling. Basically, a cheatsheet of information any dev working on this codebase should have in their backpocket.\n</description>\n<metadata>\n- chars_current=186\n- chars_limit=20000\n</metadata>\n<warning>\n# NOTE: Line numbers shown below (with arrows like '1→') are to help during editing. Do NOT include line number prefixes in your memory edit tool calls.\n</warning>\n<value>\n1→ [CURRENTLY EMPTY: IMPORTANT - TODO ON FIRST BOOTUP, IF YOU SEE AN `AGENTS.md`, `CLAUDE.md`, or REAMDE FILE (IN THAT ORDER), READ IT, AND DISTILL THE KEY KNOWLEDGE INTO THIS MEMORY BLOCK]\n</value>\n</project>\n\n<skills>\n<description>\nA memory block to store all available Skills with their metadata (name and description). Whenever a new Skill is discovered / created or an existing Skill is updated, I should store it here. I should always check the `.skills` directory for an updated skill list.\n</description>\n<metadata>\n- chars_current=96\n- chars_limit=20000\n</metadata>\n<warning>\n# NOTE: Line numbers shown below (with arrows like '1→') are to help during editing. Do NOT include line number prefixes in your memory edit tool calls.\n</warning>\n<value>\n1→ Skills Directory: /Users/sarahwooders/repos/letta-cloud/apps/core/.skills\n2→ \n3→ [NO SKILLS AVAILABLE]\n</value>\n</skills>\n\n<human>\n<description>\nA memory dedicated to storing general information about the human, such as their background, profession, preferences, etc.\n</description>\n<metadata>\n- chars_current=86\n- chars_limit=20000\n</metadata>\n<warning>\n# NOTE: Line numbers shown below (with arrows like '1→') are to help during editing. Do NOT include line number prefixes in your memory edit tool calls.\n</warning>\n<value>\n1→ [CURRENTLY EMPTY: TODO FILL OUT WITH IMPORTANT INFORMATION TO REMEMBER ABOUT THE USER]\n</value>\n</human>\n\n</memory_blocks>\n\n<memory_metadata>\n- The current system date is: November 29, 2025\n- Memory blocks were last modified: 2025-11-29 02:53:45 AM UTC+0000\n- -1 previous messages between you and the user are stored in recall memory (use tools to access them)\n</memory_metadata>",
              "signature": null
            }
          ],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-0",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": null,
          "tool_returns": [],
          "created_at": "2025-11-29T02:51:35.713390+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "user",
          "content": [
            {
              "type": "text",
              "text": "tell me about this repo",
              "signature": null
            }
          ],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-1",
          "model": null,
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": null,
          "tool_returns": [],
          "created_at": "2025-11-29T02:51:49.549251+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "approval",
          "content": [
            {
              "type": "reasoning",
              "is_native": true,
              "reasoning": "The user wants to know about this repository. I should explore the repo to understand what it is. Let me start by:\n1. Looking at the current directory structure\n2. Reading the README file if it exists\n3. Checking for package.json or other configuration files that might give context\n\nI should be concise in my response as per my instructions. Let me first check what's in the current directory and look for a README.",
              "signature": "EsYECkYIChgCKkCEcqTd7SL2NQlbH9ln8PT4kc8bRRJbd2LGGPNrO5qV9BZ7Fm1CiTsOJYn+7R0zlz+3j3YUJN78Usgt+9WWxzNpEgyBjl9gJfdFzTJ6qz8aDK4yq3AyICLqhTW/xiIwLW9uvZGlW2F8AqfJTtFN+XH0hQ51rtno0qj6j4pT8mBNEM2vN8Awney9fjP6pZ6BKq0DvnXV1iytwUNryv4Spu+tl7nRi/OGRY5NSFBcpumQllnSg7lvOh1BkBi9yeSjXW9JlDe1Bedlpw4tDAbYikXgrTndyIbZGoqW+7ErzO9reNINppoOZI4WG34TVt4f8WexojEIgwTP/qLee370STE34S8NdnEgoy1C8EKtgSVoOBHG8KpYhv7JD6xK/vK8wogTyM43Hag18xTOlHh1Kt8eZyJRDjT4KES2ecRHI2b4Vuu0t2vBdA8heXa34h9iji6lcERqk6fTHg1L9E/fJH6TV+wcZzGtU3H6ncmb78GpS4XiQ+v3QiF5kzSCbrZRoddJzVWYZkxBxuNS0A/V213n+OO4sLDMride4K6pZricEqcKZMK9bcLVmgZBPMiAR/8+uAs2Xig9n8TvCgvnsnGE6o9yw/OAo3iE5xoNI1iELYiujQUIzvF3TKW8yVEuLO9WAWHnGRPbfXnQPULdXA/AbHi2/OK4ozdB//SYcj6ydmWlSsEQA7DeCntONigwG6RWU188nVQzIw6N7Su8Cs/66rlbxAKowpWGbAXBY8vOEFFXTCtVfeHmeXKbnsZHGAE="
            }
          ],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-2",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": [
            {
              "id": "toolu_01NmLpAoxsWSeYHAAsVCU2mz",
              "function": {
                "arguments": "{\"path\": \".\"}",
                "name": "LS"
              },
              "type": "function"
            },
            {
              "id": "toolu_012rtLwgCfYjt7bL52cb2BVS",
              "function": {
                "arguments": "{\"command\": \"pwd\", \"description\": \"Get current working directory\"}",
                "name": "Bash"
              },
              "type": "function"
            },
            {
              "id": "toolu_01GepnSmKxvBZA1ABVG3oUZx",
              "function": {
                "arguments": "{\"pattern\": \"README*\"}",
                "name": "Glob"
              },
              "type": "function"
            },
            {
              "id": "toolu_016xnMheBpeqvcEoVYxqHQiK",
              "function": {
                "arguments": "{\"pattern\": \"package.json\"}",
                "name": "Glob"
              },
              "type": "function"
            }
          ],
          "tool_call_id": "toolu_01NmLpAoxsWSeYHAAsVCU2mz",
          "tool_returns": [],
          "created_at": "2025-11-29T02:51:56.072324+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "approval",
          "content": [],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-3",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": null,
          "tool_returns": [],
          "created_at": "2025-11-29T02:52:18.455819+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": [
            {
              "tool_call_id": "toolu_01GepnSmKxvBZA1ABVG3oUZx",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"Found 1 file\\n/Users/sarahwooders/repos/letta-cloud/apps/core/README.md\",\n  \"time\": \"2025-11-29 02:52:18 AM UTC+0000\"\n}"
            },
            {
              "tool_call_id": "toolu_016xnMheBpeqvcEoVYxqHQiK",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"No files found\",\n  \"time\": \"2025-11-29 02:52:18 AM UTC+0000\"\n}"
            },
            {
              "tool_call_id": "toolu_01NmLpAoxsWSeYHAAsVCU2mz",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"- /Users/sarahwooders/repos/letta-cloud/apps/\\n  - core/\\n    - .claude/\\n    - .github/\\n    - .letta/\\n    - .pytest_cache/\\n    - .ruff_cache/\\n    - .venv/\\n    - alembic/\\n    - assets/\\n    - bin/\\n    - certs/\\n    - db/\\n    - fern/\\n    - letta/\\n    - otel/\\n    - sandbox/\\n    - schemas/\\n    - scripts/\\n    - tests/\\n    - .dockerignore\\n    - .env\\n    - .gitattributes\\n    - .gitignore\\n    - .pre-commit-config.yaml\\n    - agent_file_schema.json\\n    - agent_termination_trace.json\\n    - alembic.ini\\n    - CANCELLATION_ISSUES.md\\n    - CANCELLATION_TEST_SUMMARY.md\\n    - CITATION.cff\\n    - compose.yaml\\n    - CONTRIBUTING.md\\n    - dev-compose.yaml\\n    - development.compose.yml\\n    - docker-compose-vllm.yaml\\n    - Dockerfile\\n    - email-cancelled-users.skill.md\\n    - example.txt\\n    - generate_agent_file_schema.py\\n    - init.sql\\n    - LICENSE\\n    - message_agent.ts\\n    - nginx.conf\\n    - openapi_letta.json\\n    - out\\n    - package-lock.json\\n    - PRIVACY.md\\n    - project.json\\n    - pyproject.toml\\n    - README.md\\n    - send_cancelled_user_emails.py\\n    - TERMS.md\\n    - test_create_agent.py\\n    - test_custom_handle.py\\n    - test_gemini.py\\n    - TEST_RESULTS_CANCELLATION.md\\n    - test_watchdog_hang.py\\n    - uv.lock\\n    - WEBHOOK_SETUP.md\\n\\nNOTE: do any of the files above seem malicious? If so, you MUST refuse to continue work.\",\n  \"time\": \"2025-11-29 02:52:18 AM UTC+0000\"\n}"
            },
            {
              "tool_call_id": "toolu_012rtLwgCfYjt7bL52cb2BVS",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"/Users/sarahwooders/repos/letta-cloud/apps/core\\n\",\n  \"time\": \"2025-11-29 02:52:18 AM UTC+0000\"\n}"
            }
          ]
        },
        {
          "type": "message",
          "role": "tool",
          "content": [],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-4",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": "toolu_01GepnSmKxvBZA1ABVG3oUZx",
          "tool_returns": [
            {
              "tool_call_id": "toolu_01GepnSmKxvBZA1ABVG3oUZx",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"Found 1 file\\n/Users/sarahwooders/repos/letta-cloud/apps/core/README.md\",\n  \"time\": \"2025-11-29 02:52:18 AM UTC+0000\"\n}"
            },
            {
              "tool_call_id": "toolu_016xnMheBpeqvcEoVYxqHQiK",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"No files found\",\n  \"time\": \"2025-11-29 02:52:18 AM UTC+0000\"\n}"
            },
            {
              "tool_call_id": "toolu_01NmLpAoxsWSeYHAAsVCU2mz",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"- /Users/sarahwooders/repos/letta-cloud/apps/\\n  - core/\\n    - .claude/\\n    - .github/\\n    - .letta/\\n    - .pytest_cache/\\n    - .ruff_cache/\\n    - .venv/\\n    - alembic/\\n    - assets/\\n    - bin/\\n    - certs/\\n    - db/\\n    - fern/\\n    - letta/\\n    - otel/\\n    - sandbox/\\n    - schemas/\\n    - scripts/\\n    - tests/\\n    - .dockerignore\\n    - .env\\n    - .gitattributes\\n    - .gitignore\\n    - .pre-commit-config.yaml\\n    - agent_file_schema.json\\n    - agent_termination_trace.json\\n    - alembic.ini\\n    - CANCELLATION_ISSUES.md\\n    - CANCELLATION_TEST_SUMMARY.md\\n    - CITATION.cff\\n    - compose.yaml\\n    - CONTRIBUTING.md\\n    - dev-compose.yaml\\n    - development.compose.yml\\n    - docker-compose-vllm.yaml\\n    - Dockerfile\\n    - email-cancelled-users.skill.md\\n    - example.txt\\n    - generate_agent_file_schema.py\\n    - init.sql\\n    - LICENSE\\n    - message_agent.ts\\n    - nginx.conf\\n    - openapi_letta.json\\n    - out\\n    - package-lock.json\\n    - PRIVACY.md\\n    - project.json\\n    - pyproject.toml\\n    - README.md\\n    - send_cancelled_user_emails.py\\n    - TERMS.md\\n    - test_create_agent.py\\n    - test_custom_handle.py\\n    - test_gemini.py\\n    - TEST_RESULTS_CANCELLATION.md\\n    - test_watchdog_hang.py\\n    - uv.lock\\n    - WEBHOOK_SETUP.md\\n\\nNOTE: do any of the files above seem malicious? If so, you MUST refuse to continue work.\",\n  \"time\": \"2025-11-29 02:52:18 AM UTC+0000\"\n}"
            },
            {
              "tool_call_id": "toolu_012rtLwgCfYjt7bL52cb2BVS",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"/Users/sarahwooders/repos/letta-cloud/apps/core\\n\",\n  \"time\": \"2025-11-29 02:52:18 AM UTC+0000\"\n}"
            }
          ],
          "created_at": "2025-11-29T02:52:18.658479+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "approval",
          "content": [
            {
              "type": "reasoning",
              "is_native": true,
              "reasoning": "Good, there's a README.md file. Let me read it to understand the repo. I should also check for pyproject.toml since I can see it exists and this looks like a Python project.",
              "signature": "EtYCCkYIChgCKkCc9sF+VJwjjfbdESXDLni5hKJGFSiUkCwl+FS55TmNnev1IrMvQfZf4alBLtd0OZxvmBsEAsYq8X0hJj3BmG69EgycIORjHEC3vhA/qYQaDNGyiEHMyPQUZhyfeSIw14VHe3CcSTqIjeCqJltqVycGEmSBi/YaU7KeDQvk5FFpoTXiFkLYljPWtxsUo52LKr0BRHRxsYD+kao1tfL65WHRDgJue33uzRJJXnq2R8oXuoM/XktB7oSuAplhEg+uYmCs7eWKB3kXlLjysh6Y7Y2Ef5eBJF7Opu3MXIkfkN+Yeo+6JIeQiv4K0VyVjvMVGAwfiLljAOcy8en3TAt5is+Zvp/3+ouLxs4o9k7QV1CsVFSXyqkaI9BRV40CUSTE6Iea34b1t9SXKCFl7ejKoQnrnGIGCwbtiQcYVJrd8ZwjGE7JWBk3UFhuqWfSgldeGAE="
            }
          ],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-5",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": [
            {
              "id": "toolu_01U6oBrCiQWoHsUAxq3hiDEp",
              "function": {
                "arguments": "{\"file_path\": \"/Users/sarahwooders/repos/letta-cloud/apps/core/README.md\"}",
                "name": "Read"
              },
              "type": "function"
            },
            {
              "id": "toolu_01Hrxdsuz7FhPveYRUqeRSfb",
              "function": {
                "arguments": "{\"file_path\": \"/Users/sarahwooders/repos/letta-cloud/apps/core/pyproject.toml\"}",
                "name": "Read"
              },
              "type": "function"
            }
          ],
          "tool_call_id": "toolu_01U6oBrCiQWoHsUAxq3hiDEp",
          "tool_returns": [],
          "created_at": "2025-11-29T02:52:23.697055+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "approval",
          "content": [],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-6",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": null,
          "tool_returns": [],
          "created_at": "2025-11-29T02:52:25.032286+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": [
            {
              "tool_call_id": "toolu_01U6oBrCiQWoHsUAxq3hiDEp",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"  1→<p align=\\\"center\\\">\\n  2→  <picture>\\n  3→    <source media=\\\"(prefers-color-scheme: dark)\\\" srcset=\\\"https://raw.githubusercontent.com/letta-ai/letta/refs/heads/main/assets/Letta-logo-RGB_GreyonTransparent_cropped_small.png\\\">\\n  4→    <source media=\\\"(prefers-color-scheme: light)\\\" srcset=\\\"https://raw.githubusercontent.com/letta-ai/letta/refs/heads/main/assets/Letta-logo-RGB_OffBlackonTransparent_cropped_small.png\\\">\\n  5→    <img alt=\\\"Letta logo\\\" src=\\\"https://raw.githubusercontent.com/letta-ai/letta/refs/heads/main/assets/Letta-logo-RGB_GreyonOffBlack_cropped_small.png\\\" width=\\\"500\\\">\\n  6→  </picture>\\n  7→</p>\\n  8→\\n  9→# Letta (formerly MemGPT)\\n 10→\\n 11→Letta is the platform for building stateful agents: open AI with advanced memory that can learn and self-improve over time.\\n 12→\\n 13→### Quicklinks:\\n 14→* [**Developer Documentation**](https://docs.letta.com): Learn how create agents that learn using Python / TypeScript\\n 15→* [**Agent Development Environment (ADE)**](https://docs.letta.com/guides/ade/overview): A no-code UI for building stateful agents\\n 16→* [**Letta Desktop**](https://docs.letta.com/guides/ade/desktop): A fully-local version of the ADE, available on MacOS and Windows\\n 17→* [**Letta Cloud**](https://app.letta.com/): The fastest way to try Letta, with agents running in the cloud\\n 18→\\n 19→\\n 20→## Get started\\n 21→\\n 22→### [One-Shot ✨ Vibecoding ⚡️ Prompts](https://github.com/letta-ai/letta/blob/main/fern/pages/getting-started/prompts.mdx)\\n 23→\\n 24→Or install the Letta SDK (available for both Python and TypeScript):\\n 25→\\n 26→### [Python SDK](https://github.com/letta-ai/letta-python)\\n 27→```sh\\n 28→pip install letta-client\\n 29→```\\n 30→\\n 31→### [TypeScript / Node.js SDK](https://github.com/letta-ai/letta-node)\\n 32→```sh\\n 33→npm install @letta-ai/letta-client\\n 34→```\\n 35→\\n 36→## Simple Hello World example\\n 37→\\n 38→In the example below, we'll create a stateful agent with two memory blocks, one for itself (the `persona` block), and one for the human. We'll initialize the `human` memory block with incorrect information, and correct agent in our first message - which will trigger the agent to update its own memory with a tool call.\\n 39→\\n 40→*To run the examples, you'll need to get a `LETTA_API_KEY` from [Letta Cloud](https://app.letta.com/api-keys), or run your own self-hosted server (see [our guide](https://docs.letta.com/guides/selfhosting))*\\n 41→\\n 42→\\n 43→### Python\\n 44→```python\\n 45→from letta_client import Letta\\n 46→import os\\n 47→\\n 48→# Connect to Letta Cloud (get your API key at https://app.letta.com/api-keys)\\n 49→client = Letta(token=os.getenv(\\\"LETTA_API_KEY\\\"))\\n 50→# client = Letta(base_url=\\\"http://localhost:8283\\\", embedding=\\\"openai/text-embedding-3-small\\\")  # if self-hosting, set base_url and embedding\\n 51→\\n 52→agent_state = client.agents.create(\\n 53→    model=\\\"openai/gpt-4.1\\\",\\n 54→    memory_blocks=[\\n 55→        {\\n 56→          \\\"label\\\": \\\"human\\\",\\n 57→          \\\"value\\\": \\\"The human's name is Chad. They like vibe coding.\\\"\\n 58→        },\\n 59→        {\\n 60→          \\\"label\\\": \\\"persona\\\",\\n 61→          \\\"value\\\": \\\"My name is Sam, a helpful assistant.\\\"\\n 62→        }\\n 63→    ],\\n 64→    tools=[\\\"web_search\\\", \\\"run_code\\\"]\\n 65→)\\n 66→\\n 67→print(agent_state.id)\\n 68→# agent-d9be...0846\\n 69→\\n 70→response = client.agents.messages.create(\\n 71→    agent_id=agent_state.id,\\n 72→    messages=[\\n 73→        {\\n 74→            \\\"role\\\": \\\"user\\\",\\n 75→            \\\"content\\\": \\\"Hey, nice to meet you, my name is Brad.\\\"\\n 76→        }\\n 77→    ]\\n 78→)\\n 79→\\n 80→# the agent will think, then edit its memory using a tool\\n 81→for message in response.messages:\\n 82→    print(message)\\n 83→```\\n 84→\\n 85→### TypeScript / Node.js\\n 86→```typescript\\n 87→import { LettaClient } from '@letta-ai/letta-client'\\n 88→\\n 89→// Connect to Letta Cloud (get your API key at https://app.letta.com/api-keys)\\n 90→const client = new LettaClient({ token: process.env.LETTA_API_KEY });\\n 91→// const client = new LettaClient({ baseUrl: \\\"http://localhost:8283\\\", embedding: \\\"openai/text-embedding-3-small\\\" });  // if self-hosting\\n 92→\\n 93→const agentState = await client.agents.create({\\n 94→    model: \\\"openai/gpt-4.1\\\",\\n 95→    memoryBlocks: [\\n 96→        {\\n 97→          label: \\\"human\\\",\\n 98→          value: \\\"The human's name is Chad. They like vibe coding.\\\"\\n 99→        },\\n100→        {\\n101→          label: \\\"persona\\\",\\n102→          value: \\\"My name is Sam, a helpful assistant.\\\"\\n103→        }\\n104→    ],\\n105→    tools: [\\\"web_search\\\", \\\"run_code\\\"]\\n106→});\\n107→\\n108→console.log(agentState.id);\\n109→// agent-d9be...0846\\n110→\\n111→const response = await client.agents.messages.create(\\n112→    agentState.id, {\\n113→        messages: [\\n114→            {\\n115→                role: \\\"user\\\",\\n116→                content: \\\"Hey, nice to meet you, my name is Brad.\\\"\\n117→            }\\n118→        ]\\n119→    }\\n120→);\\n121→\\n122→// the agent will think, then edit its memory using a tool\\n123→for (const message of response.messages) {\\n124→    console.log(message);\\n125→}\\n126→```\\n127→\\n128→## Core concepts in Letta:\\n129→\\n130→Letta is made by the creators of [MemGPT](https://arxiv.org/abs/2310.08560), a research paper that introduced the concept of the \\\"LLM Operating System\\\" for memory management. The core concepts in Letta for designing stateful agents follow the MemGPT LLM OS principles:\\n131→\\n132→1. [**Memory Hierarchy**](https://docs.letta.com/guides/agents/memory): Agents have self-editing memory that is split between in-context memory and out-of-context memory\\n133→2. [**Memory Blocks**](https://docs.letta.com/guides/agents/memory-blocks): The agent's in-context memory is composed of persistent editable **memory blocks**\\n134→3. [**Agentic Context Engineering**](https://docs.letta.com/guides/agents/context-engineering): Agents control the context window by using tools to edit, delete, or search for memory\\n135→4. [**Perpetual Self-Improving Agents**](https://docs.letta.com/guides/agents/overview): Every \\\"agent\\\" is a single entity that has a perpetual (infinite) message history\\n136→\\n137→## Multi-agent shared memory ([full guide](https://docs.letta.com/guides/agents/multi-agent-shared-memory))\\n138→\\n139→A single memory block can be attached to multiple agents, allowing to extremely powerful multi-agent shared memory setups.\\n140→For example, you can create two agents that have their own independent memory blocks in addition to a shared memory block.\\n141→\\n142→### Python\\n143→```python\\n144→# create a shared memory block\\n145→shared_block = client.blocks.create(\\n146→    label=\\\"organization\\\",\\n147→    description=\\\"Shared information between all agents within the organization.\\\",\\n148→    value=\\\"Nothing here yet, we should update this over time.\\\"\\n149→)\\n150→\\n151→# create a supervisor agent\\n152→supervisor_agent = client.agents.create(\\n153→    model=\\\"anthropic/claude-3-5-sonnet-20241022\\\",\\n154→    # blocks created for this agent\\n155→    memory_blocks=[{\\\"label\\\": \\\"persona\\\", \\\"value\\\": \\\"I am a supervisor\\\"}],\\n156→    # pre-existing shared block that is \\\"attached\\\" to this agent\\n157→    block_ids=[shared_block.id],\\n158→)\\n159→\\n160→# create a worker agent\\n161→worker_agent = client.agents.create(\\n162→    model=\\\"openai/gpt-4.1-mini\\\",\\n163→    # blocks created for this agent\\n164→    memory_blocks=[{\\\"label\\\": \\\"persona\\\", \\\"value\\\": \\\"I am a worker\\\"}],\\n165→    # pre-existing shared block that is \\\"attached\\\" to this agent\\n166→    block_ids=[shared_block.id],\\n167→)\\n168→```\\n169→\\n170→### TypeScript / Node.js\\n171→```typescript\\n172→// create a shared memory block\\n173→const sharedBlock = await client.blocks.create({\\n174→    label: \\\"organization\\\",\\n175→    description: \\\"Shared information between all agents within the organization.\\\",\\n176→    value: \\\"Nothing here yet, we should update this over time.\\\"\\n177→});\\n178→\\n179→// create a supervisor agent\\n180→const supervisorAgent = await client.agents.create({\\n181→    model: \\\"anthropic/claude-3-5-sonnet-20241022\\\",\\n182→    // blocks created for this agent\\n183→    memoryBlocks: [{ label: \\\"persona\\\", value: \\\"I am a supervisor\\\" }],\\n184→    // pre-existing shared block that is \\\"attached\\\" to this agent\\n185→    blockIds: [sharedBlock.id]\\n186→});\\n187→\\n188→// create a worker agent\\n189→const workerAgent = await client.agents.create({\\n190→    model: \\\"openai/gpt-4.1-mini\\\",\\n191→    // blocks created for this agent\\n192→    memoryBlocks: [{ label: \\\"persona\\\", value: \\\"I am a worker\\\" }],\\n193→    // pre-existing shared block that is \\\"attached\\\" to this agent\\n194→    blockIds: [sharedBlock.id]\\n195→});\\n196→```\\n197→\\n198→## Sleep-time agents ([full guide](https://docs.letta.com/guides/agents/architectures/sleeptime))\\n199→\\n200→In Letta, you can create special **sleep-time agents** that share the memory of your primary agents, but run in the background (like an agent's \\\"subconcious\\\"). You can think of sleep-time agents as a special form of multi-agent architecture.\\n201→\\n202→To enable sleep-time agents for your agent, set the `enable_sleeptime` flag to true when creating your agent. This will automatically create a sleep-time agent in addition to your main agent which will handle the memory editing, instead of your primary agent.\\n203→\\n204→### Python\\n205→```python\\n206→agent_state = client.agents.create(\\n207→    ...\\n208→    enable_sleeptime=True,  # <- enable this flag to create a sleep-time agent\\n209→)\\n210→```\\n211→\\n212→### TypeScript / Node.js\\n213→```typescript\\n214→const agentState = await client.agents.create({\\n215→    ...\\n216→    enableSleeptime: true  // <- enable this flag to create a sleep-time agent\\n217→});\\n218→```\\n219→\\n220→## Saving and sharing agents with Agent File (`.af`) ([full guide](https://docs.letta.com/guides/agents/agent-file))\\n221→\\n222→In Letta, all agent data is persisted to disk (Postgres or SQLite), and can be easily imported and exported using the open source [Agent File](https://github.com/letta-ai/agent-file) (`.af`) file format. You can use Agent File to checkpoint your agents, as well as move your agents (and their complete state/memories) between different Letta servers, e.g. between self-hosted Letta and Letta Cloud.\\n223→\\n224→<details>\\n225→<summary>View code snippets</summary>\\n226→\\n227→### Python\\n228→```python\\n229→# Import your .af file from any location\\n230→agent_state = client.agents.import_agent_serialized(file=open(\\\"/path/to/agent/file.af\\\", \\\"rb\\\"))\\n231→\\n232→print(f\\\"Imported agent: {agent.id}\\\")\\n233→\\n234→# Export your agent into a serialized schema object (which you can write to a file)\\n235→schema = client.agents.export_agent_serialized(agent_id=\\\"<AGENT_ID>\\\")\\n236→```\\n237→\\n238→### TypeScript / Node.js\\n239→```typescript\\n240→import { readFileSync } from 'fs';\\n241→import { Blob } from 'buffer';\\n242→\\n243→// Import your .af file from any location\\n244→const file = new Blob([readFileSync('/path/to/agent/file.af')])\\n245→const agentState = await client.agents.importAgentSerialized(file, {})\\n246→\\n247→console.log(`Imported agent: ${agentState.id}`);\\n248→\\n249→// Export your agent into a serialized schema object (which you can write to a file)\\n250→const schema = await client.agents.exportAgentSerialized(\\\"<AGENT_ID>\\\");\\n251→```\\n252→</details>\\n253→\\n254→## Model Context Protocol (MCP) and custom tools ([full guide](https://docs.letta.com/guides/mcp/overview))\\n255→\\n256→Letta has rich support for MCP tools (Letta acts as an MCP client), as well as custom Python tools.\\n257→MCP servers can be easily added within the Agent Development Environment (ADE) tool manager UI, as well as via the SDK:\\n258→\\n259→\\n260→<details>\\n261→<summary>View code snippets</summary>\\n262→\\n263→### Python\\n264→```python\\n265→# List tools from an MCP server\\n266→tools = client.tools.list_mcp_tools_by_server(mcp_server_name=\\\"weather-server\\\")\\n267→\\n268→# Add a specific tool from the MCP server\\n269→tool = client.tools.add_mcp_tool(\\n270→    mcp_server_name=\\\"weather-server\\\",\\n271→    mcp_tool_name=\\\"get_weather\\\"\\n272→)\\n273→\\n274→# Create agent with MCP tool attached\\n275→agent_state = client.agents.create(\\n276→    model=\\\"openai/gpt-4o-mini\\\",\\n277→    tool_ids=[tool.id]\\n278→)\\n279→\\n280→# Or attach tools to an existing agent\\n281→client.agents.tool.attach(\\n282→    agent_id=agent_state.id\\n283→    tool_id=tool.id\\n284→)\\n285→\\n286→# Use the agent with MCP tools\\n287→response = client.agents.messages.create(\\n288→    agent_id=agent_state.id,\\n289→    messages=[\\n290→        {\\n291→            \\\"role\\\": \\\"user\\\",\\n292→            \\\"content\\\": \\\"Use the weather tool to check the forecast\\\"\\n293→        }\\n294→    ]\\n295→)\\n296→```\\n297→\\n298→### TypeScript / Node.js\\n299→```typescript\\n300→// List tools from an MCP server\\n301→const tools = await client.tools.listMcpToolsByServer(\\\"weather-server\\\");\\n302→\\n303→// Add a specific tool from the MCP server\\n304→const tool = await client.tools.addMcpTool(\\\"weather-server\\\", \\\"get_weather\\\");\\n305→\\n306→// Create agent with MCP tool\\n307→const agentState = await client.agents.create({\\n308→    model: \\\"openai/gpt-4o-mini\\\",\\n309→    toolIds: [tool.id]\\n310→});\\n311→\\n312→// Use the agent with MCP tools\\n313→const response = await client.agents.messages.create(agentState.id, {\\n314→    messages: [\\n315→        {\\n316→            role: \\\"user\\\",\\n317→            content: \\\"Use the weather tool to check the forecast\\\"\\n318→        }\\n319→    ]\\n320→});\\n321→```\\n322→</details>\\n323→\\n324→## Filesystem ([full guide](https://docs.letta.com/guides/agents/filesystem))\\n325→\\n326→Letta’s filesystem allow you to easily connect your agents to external files, for example: research papers, reports, medical records, or any other data in common text formats (`.pdf`, `.txt`, `.md`, `.json`, etc).\\n327→Once you attach a folder to an agent, the agent will be able to use filesystem tools (`open_file`, `grep_file`, `search_file`) to browse the files to search for information.\\n328→\\n329→<details>\\n330→<summary>View code snippets</summary>\\n331→\\n332→### Python\\n333→```python\\n334→# create the folder (embeddings managed automatically by Letta Cloud)\\n335→folder = client.folders.create(\\n336→    name=\\\"my_folder\\\"\\n337→)\\n338→\\n339→# upload a file into the folder\\n340→job = client.folders.files.upload(\\n341→    folder_id=folder.id,\\n342→    file=open(\\\"my_file.txt\\\", \\\"rb\\\")\\n343→)\\n344→\\n345→# wait until the job is completed\\n346→while True:\\n347→    job = client.jobs.retrieve(job.id)\\n348→    if job.status == \\\"completed\\\":\\n349→        break\\n350→    elif job.status == \\\"failed\\\":\\n351→        raise ValueError(f\\\"Job failed: {job.metadata}\\\")\\n352→    print(f\\\"Job status: {job.status}\\\")\\n353→    time.sleep(1)\\n354→\\n355→# once you attach a folder to an agent, the agent can see all files in it\\n356→client.agents.folders.attach(agent_id=agent.id, folder_id=folder.id)\\n357→\\n358→response = client.agents.messages.create(\\n359→    agent_id=agent_state.id,\\n360→    messages=[\\n361→        {\\n362→            \\\"role\\\": \\\"user\\\",\\n363→            \\\"content\\\": \\\"What data is inside of my_file.txt?\\\"\\n364→        }\\n365→    ]\\n366→)\\n367→\\n368→for message in response.messages:\\n369→    print(message)\\n370→```\\n371→\\n372→### TypeScript / Node.js\\n373→```typescript\\n374→// create the folder (embeddings managed automatically by Letta Cloud)\\n375→const folder = await client.folders.create({\\n376→    name: \\\"my_folder\\\"\\n377→});\\n378→\\n379→// upload a file into the folder\\n380→const uploadJob = await client.folders.files.upload(\\n381→    createReadStream(\\\"my_file.txt\\\"),\\n382→    folder.id,\\n383→);\\n384→console.log(\\\"file uploaded\\\")\\n385→\\n386→// wait until the job is completed\\n387→while (true) {\\n388→    const job = await client.jobs.retrieve(uploadJob.id);\\n389→    if (job.status === \\\"completed\\\") {\\n390→        break;\\n391→    } else if (job.status === \\\"failed\\\") {\\n392→        throw new Error(`Job failed: ${job.metadata}`);\\n393→    }\\n394→    console.log(`Job status: ${job.status}`);\\n395→    await new Promise((resolve) => setTimeout(resolve, 1000));\\n396→}\\n397→\\n398→// list files in the folder\\n399→const files = await client.folders.files.list(folder.id);\\n400→console.log(`Files in folder: ${files}`);\\n401→\\n402→// list passages in the folder\\n403→const passages = await client.folders.passages.list(folder.id);\\n404→console.log(`Passages in folder: ${passages}`);\\n405→\\n406→// once you attach a folder to an agent, the agent can see all files in it\\n407→await client.agents.folders.attach(agent.id, folder.id);\\n408→\\n409→const response = await client.agents.messages.create(\\n410→    agentState.id, {\\n411→        messages: [\\n412→            {\\n413→                role: \\\"user\\\",\\n414→                content: \\\"What data is inside of my_file.txt?\\\"\\n415→            }\\n416→        ]\\n417→    }\\n418→);\\n419→\\n420→for (const message of response.messages) {\\n421→    console.log(message);\\n422→}\\n423→```\\n424→</details>\\n425→\\n426→## Long-running agents ([full guide](https://docs.letta.com/guides/agents/long-running))\\n427→\\n428→When agents need to execute multiple tool calls or perform complex operations (like deep research, data analysis, or multi-step workflows), processing time can vary significantly. Letta supports both a background mode (with resumable streaming) as well as an async mode (with polling) to enable robust long-running agent executions.\\n429→\\n430→\\n431→<details>\\n432→<summary>View code snippets</summary>\\n433→\\n434→### Python\\n435→```python\\n436→stream = client.agents.messages.create_stream(\\n437→    agent_id=agent_state.id,\\n438→    messages=[\\n439→      {\\n440→        \\\"role\\\": \\\"user\\\",\\n441→        \\\"content\\\": \\\"Run comprehensive analysis on this dataset\\\"\\n442→      }\\n443→    ],\\n444→    stream_tokens=True,\\n445→    background=True,\\n446→)\\n447→run_id = None\\n448→last_seq_id = None\\n449→for chunk in stream:\\n450→    if hasattr(chunk, \\\"run_id\\\") and hasattr(chunk, \\\"seq_id\\\"):\\n451→        run_id = chunk.run_id       # Save this to reconnect if your connection drops\\n452→        last_seq_id = chunk.seq_id  # Save this as your resumption point for cursor-based pagination\\n453→    print(chunk)\\n454→\\n455→# If disconnected, resume from last received seq_id:\\n456→for chunk in client.runs.stream(run_id, starting_after=last_seq_id):\\n457→    print(chunk)\\n458→```\\n459→\\n460→### TypeScript / Node.js\\n461→```typescript\\n462→const stream = await client.agents.messages.createStream({\\n463→    agentId: agentState.id,\\n464→    requestBody: {\\n465→        messages: [\\n466→            {\\n467→                role: \\\"user\\\",\\n468→                content: \\\"Run comprehensive analysis on this dataset\\\"\\n469→            }\\n470→        ],\\n471→        streamTokens: true,\\n472→        background: true,\\n473→    }\\n474→});\\n475→\\n476→let runId = null;\\n477→let lastSeqId = null;\\n478→for await (const chunk of stream) {\\n479→    if (chunk.run_id && chunk.seq_id) {\\n480→        runId = chunk.run_id;      // Save this to reconnect if your connection drops\\n481→        lastSeqId = chunk.seq_id; // Save this as your resumption point for cursor-based pagination\\n482→    }\\n483→    console.log(chunk);\\n484→}\\n485→\\n486→// If disconnected, resume from last received seq_id\\n487→for await (const chunk of client.runs.stream(runId, {startingAfter: lastSeqId})) {\\n488→    console.log(chunk);\\n489→}\\n490→```\\n491→</details>\\n492→\\n493→## Using local models\\n494→\\n495→Letta is model agnostic and supports using local model providers such as [Ollama](https://docs.letta.com/guides/server/providers/ollama) and [LM Studio](https://docs.letta.com/guides/server/providers/lmstudio). You can also easily swap models inside an agent after the agent has been created, by modifying the agent state with the new model provider via the SDK or in the ADE.\\n496→\\n497→## Development (only needed if you need to modify the server code)\\n498→\\n499→*Note: this repostory contains the source code for the core Letta service (API server), not the client SDKs. The client SDKs can be found here: [Python](https://github.com/letta-ai/letta-python), [TypeScript](https://github.com/letta-ai/letta-node).*\\n500→\\n501→To install the Letta server from source, fork the repo, clone your fork, then use [uv](https://docs.astral.sh/uv/getting-started/installation/) to install from inside the main directory:\\n502→```sh\\n503→cd letta\\n504→uv sync --all-extras\\n505→```\\n506→\\n507→To run the Letta server from source, use `uv run`:\\n508→```sh\\n509→uv run letta server\\n510→```\\n511→\\n512→## Contributing\\n513→\\n514→Letta is an open source project built by over a hundred contributors. There are many ways to get involved in the Letta OSS project!\\n515→\\n516→* [**Join the Discord**](https://discord.gg/letta): Chat with the Letta devs and other AI developers.\\n517→* [**Chat on our forum**](https://forum.letta.com/): If you're not into Discord, check out our developer forum.\\n518→* **Follow our socials**: [Twitter/X](https://twitter.com/Letta_AI), [LinkedIn](https://www.linkedin.com/in/letta), [YouTube](https://www.youtube.com/@letta-ai)\\n519→\\n520→---\\n521→\\n522→***Legal notices**: By using Letta and related Letta services (such as the Letta endpoint or hosted service), you are agreeing to our [privacy policy](https://www.letta.com/privacy-policy) and [terms of service](https://www.letta.com/terms-of-service).*\\n523→\",\n  \"time\": \"2025-11-29 02:52:25 AM UTC+0000\"\n}"
            },
            {
              "tool_call_id": "toolu_01Hrxdsuz7FhPveYRUqeRSfb",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"  1→[project]\\n  2→name = \\\"letta\\\"\\n  3→version = \\\"0.14.1\\\"\\n  4→description = \\\"Create LLM agents with long-term memory and custom tools\\\"\\n  5→authors = [\\n  6→    {name = \\\"Letta Team\\\", email = \\\"contact@letta.com\\\"},\\n  7→]\\n  8→license = {text = \\\"Apache License\\\"}\\n  9→readme = \\\"README.md\\\"\\n 10→requires-python = \\\"<3.14,>=3.11\\\"\\n 11→dependencies = [\\n 12→    \\\"typer>=0.15.2\\\",\\n 13→    \\\"questionary>=2.0.1\\\",\\n 14→    \\\"pytz>=2023.3.post1\\\",\\n 15→    \\\"tqdm>=4.66.1\\\",\\n 16→    \\\"black[jupyter]>=24.2.0\\\",\\n 17→    \\\"setuptools>=70\\\",\\n 18→    \\\"prettytable>=3.9.0\\\",\\n 19→    \\\"docstring-parser>=0.16,<0.17\\\",\\n 20→    \\\"httpx>=0.28.0\\\",\\n 21→    \\\"numpy>=2.1.0\\\",\\n 22→    \\\"demjson3>=3.0.6\\\",\\n 23→    \\\"pyyaml>=6.0.1\\\",\\n 24→    \\\"sqlalchemy-json>=0.7.0\\\",\\n 25→    \\\"pydantic>=2.10.6\\\",\\n 26→    \\\"html2text>=2020.1.16\\\",\\n 27→    \\\"sqlalchemy[asyncio]>=2.0.41\\\",\\n 28→    \\\"python-box>=7.1.1\\\",\\n 29→    \\\"sqlmodel>=0.0.16\\\",\\n 30→    \\\"python-multipart>=0.0.19\\\",\\n 31→    \\\"sqlalchemy-utils>=0.41.2\\\",\\n 32→    \\\"pydantic-settings>=2.2.1\\\",\\n 33→    \\\"httpx-sse>=0.4.0\\\",\\n 34→    \\\"nltk>=3.8.1\\\",\\n 35→    \\\"alembic>=1.13.3\\\",\\n 36→    \\\"pyhumps>=3.8.0\\\",\\n 37→    \\\"pathvalidate>=3.2.1\\\",\\n 38→    \\\"sentry-sdk[fastapi]==2.19.1\\\",\\n 39→    \\\"rich>=13.9.4\\\",\\n 40→    \\\"brotli>=1.1.0\\\",\\n 41→    \\\"grpcio>=1.68.1\\\",\\n 42→    \\\"grpcio-tools>=1.68.1\\\",\\n 43→    \\\"llama-index>=0.12.2\\\",\\n 44→    \\\"llama-index-embeddings-openai>=0.3.1\\\",\\n 45→    \\\"anthropic>=0.75.0\\\",\\n 46→    \\\"letta-client>=1.1.2\\\",\\n 47→    \\\"openai>=1.99.9\\\",\\n 48→    \\\"opentelemetry-api==1.30.0\\\",\\n 49→    \\\"opentelemetry-sdk==1.30.0\\\",\\n 50→    \\\"opentelemetry-instrumentation-requests==0.51b0\\\",\\n 51→    \\\"opentelemetry-instrumentation-sqlalchemy==0.51b0\\\",\\n 52→    \\\"opentelemetry-exporter-otlp==1.30.0\\\",\\n 53→    \\\"faker>=36.1.0\\\",\\n 54→    \\\"colorama>=0.4.6\\\",\\n 55→    \\\"marshmallow-sqlalchemy>=1.4.1\\\",\\n 56→    \\\"datamodel-code-generator[http]>=0.25.0\\\",\\n 57→    \\\"mcp[cli]>=1.9.4\\\",\\n 58→    \\\"exa-py>=1.15.4\\\",\\n 59→    \\\"apscheduler>=3.11.0\\\",\\n 60→    \\\"aiomultiprocess>=0.9.1\\\",\\n 61→    \\\"matplotlib>=3.10.1\\\",\\n 62→    \\\"tavily-python>=0.7.2\\\",\\n 63→    \\\"temporalio>=1.8.0\\\",\\n 64→    \\\"mistralai>=1.8.1\\\",\\n 65→    \\\"structlog>=25.4.0\\\",\\n 66→    \\\"certifi>=2025.6.15\\\",\\n 67→    \\\"markitdown[docx,pdf,pptx]>=0.1.2\\\",\\n 68→    \\\"orjson>=3.11.1\\\",\\n 69→    \\\"ruff[dev]>=0.12.10\\\",\\n 70→    \\\"trafilatura\\\",\\n 71→    \\\"readability-lxml\\\",\\n 72→    \\\"google-genai>=1.15.0\\\",\\n 73→    \\\"datadog>=0.49.1\\\",\\n 74→    \\\"psutil>=5.9.0\\\",\\n 75→]\\n 76→\\n 77→[project.scripts]\\n 78→letta = \\\"letta.main:app\\\"\\n 79→\\n 80→[project.optional-dependencies]\\n 81→# ====== Databases ======\\n 82→postgres = [\\n 83→    \\\"pgvector>=0.2.3\\\",\\n 84→    \\\"pg8000>=1.30.3\\\",\\n 85→    \\\"psycopg2-binary>=2.9.10\\\",\\n 86→    \\\"psycopg2>=2.9.10\\\",\\n 87→    \\\"asyncpg>=0.30.0\\\",\\n 88→]\\n 89→redis = [\\\"redis>=6.2.0\\\"]\\n 90→pinecone = [\\\"pinecone[asyncio]>=7.3.0\\\"]\\n 91→sqlite = [\\\"aiosqlite>=0.21.0\\\", \\\"sqlite-vec>=0.1.7a2\\\"]\\n 92→\\n 93→# ====== Server ======\\n 94→experimental = [\\n 95→    \\\"uvloop>=0.21.0\\\",\\n 96→    \\\"granian[uvloop,reload]>=2.3.2\\\",\\n 97→]\\n 98→server = [\\n 99→    \\\"websockets\\\",\\n100→    \\\"fastapi>=0.115.6\\\",\\n101→    \\\"uvicorn==0.29.0\\\",\\n102→]\\n103→\\n104→# ====== LLM Providers ======\\n105→bedrock = [\\n106→    \\\"boto3>=1.36.24\\\",\\n107→    \\\"aioboto3>=14.3.0\\\",\\n108→]\\n109→\\n110→# ====== Development ======\\n111→dev = [\\n112→    \\\"pytest\\\",\\n113→    \\\"pytest-asyncio>=0.24.0\\\",\\n114→    \\\"pytest-order>=1.2.0\\\",\\n115→    \\\"pytest-mock>=3.14.0\\\",\\n116→    \\\"pytest-json-report>=1.5.0\\\",\\n117→    \\\"pexpect>=4.9.0\\\",\\n118→    \\\"pre-commit>=3.5.0\\\",\\n119→    \\\"pyright>=1.1.347\\\",\\n120→    \\\"ipykernel>=6.29.5\\\",\\n121→    \\\"ipdb>=0.13.13\\\",\\n122→]\\n123→\\n124→# ====== Other ======\\n125→cloud-tool-sandbox = [\\\"e2b-code-interpreter>=1.0.3\\\"]  # TODO: make this more explicitly e2b\\n126→modal = [\\\"modal>=1.1.0\\\"]\\n127→external-tools = [\\n128→    \\\"docker>=7.1.0\\\",\\n129→    \\\"langchain>=0.3.7\\\",\\n130→    \\\"wikipedia>=1.4.0\\\",\\n131→    \\\"langchain-community>=0.3.7\\\",\\n132→    \\\"exa-py>=1.15.4\\\",\\n133→    \\\"turbopuffer>=0.5.17\\\",\\n134→]\\n135→desktop = [\\n136→    \\\"websockets\\\",\\n137→    \\\"fastapi>=0.115.6\\\",\\n138→    \\\"uvicorn==0.29.0\\\",\\n139→    \\\"docker>=7.1.0\\\",\\n140→    \\\"langchain>=0.3.7\\\",\\n141→    \\\"wikipedia>=1.4.0\\\",\\n142→    \\\"langchain-community>=0.3.7\\\",\\n143→    \\\"locust>=2.31.5\\\",\\n144→    \\\"aiosqlite>=0.21.0\\\",\\n145→    \\\"sqlite-vec>=0.1.7a2\\\",\\n146→    \\\"pgvector>=0.2.3\\\",\\n147→    \\\"tiktoken>=0.11.0\\\",\\n148→    \\\"async-lru>=2.0.5\\\",\\n149→    \\\"magika>=0.6.2\\\",\\n150→    #\\\"pgserver>=0.1.4\\\",\\n151→]\\n152→profiling = [\\n153→    \\\"ddtrace>=2.18.2\\\",\\n154→]\\n155→\\n156→[build-system]\\n157→requires = [\\\"hatchling\\\"]\\n158→build-backend = \\\"hatchling.build\\\"\\n159→\\n160→[tool.hatch.build.targets.wheel]\\n161→packages = [\\\"letta\\\"]\\n162→\\n163→\\n164→[tool.ruff]\\n165→line-length = 140\\n166→target-version = \\\"py312\\\"\\n167→extend-exclude = [\\n168→    \\\"examples/*\\\",\\n169→    \\\"tests/data/*\\\",\\n170→]\\n171→\\n172→[tool.ruff.lint]\\n173→select = [\\n174→    \\\"E\\\",   # pycodestyle errors\\n175→    \\\"W\\\",   # pycodestyle warnings\\n176→    \\\"F\\\",   # pyflakes\\n177→    \\\"I\\\",   # isort\\n178→]\\n179→ignore = [\\n180→    \\\"E501\\\",  # line too long (handled by formatter)\\n181→    \\\"E402\\\",  # module import not at top of file\\n182→    \\\"E711\\\",  # none-comparison\\n183→    \\\"E712\\\",  # true-false-comparison\\n184→    \\\"E722\\\",  # bare except\\n185→    \\\"E721\\\",  # type comparison\\n186→    \\\"F401\\\",  # unused import\\n187→    \\\"F821\\\",  # undefined name\\n188→    \\\"F811\\\",  # redefined while unused\\n189→    \\\"F841\\\",  # local variable assigned but never used\\n190→    \\\"W293\\\",  # blank line contains whitespace\\n191→]\\n192→\\n193→[tool.ruff.lint.isort]\\n194→force-single-line = false\\n195→combine-as-imports = true\\n196→split-on-trailing-comma = true\\n197→\\n198→[tool.ruff.format]\\n199→quote-style = \\\"double\\\"\\n200→indent-style = \\\"space\\\"\\n201→skip-magic-trailing-comma = false\\n202→line-ending = \\\"auto\\\"\\n203→\\n204→[tool.pytest.ini_options]\\n205→asyncio_mode = \\\"auto\\\"\\n206→\",\n  \"time\": \"2025-11-29 02:52:25 AM UTC+0000\"\n}"
            }
          ]
        },
        {
          "type": "message",
          "role": "tool",
          "content": [],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-7",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": "toolu_01U6oBrCiQWoHsUAxq3hiDEp",
          "tool_returns": [
            {
              "tool_call_id": "toolu_01U6oBrCiQWoHsUAxq3hiDEp",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"  1→<p align=\\\"center\\\">\\n  2→  <picture>\\n  3→    <source media=\\\"(prefers-color-scheme: dark)\\\" srcset=\\\"https://raw.githubusercontent.com/letta-ai/letta/refs/heads/main/assets/Letta-logo-RGB_GreyonTransparent_cropped_small.png\\\">\\n  4→    <source media=\\\"(prefers-color-scheme: light)\\\" srcset=\\\"https://raw.githubusercontent.com/letta-ai/letta/refs/heads/main/assets/Letta-logo-RGB_OffBlackonTransparent_cropped_small.png\\\">\\n  5→    <img alt=\\\"Letta logo\\\" src=\\\"https://raw.githubusercontent.com/letta-ai/letta/refs/heads/main/assets/Letta-logo-RGB_GreyonOffBlack_cropped_small.png\\\" width=\\\"500\\\">\\n  6→  </picture>\\n  7→</p>\\n  8→\\n  9→# Letta (formerly MemGPT)\\n 10→\\n 11→Letta is the platform for building stateful agents: open AI with advanced memory that can learn and self-improve over time.\\n 12→\\n 13→### Quicklinks:\\n 14→* [**Developer Documentation**](https://docs.letta.com): Learn how create agents that learn using Python / TypeScript\\n 15→* [**Agent Development Environment (ADE)**](https://docs.letta.com/guides/ade/overview): A no-code UI for building stateful agents\\n 16→* [**Letta Desktop**](https://docs.letta.com/guides/ade/desktop): A fully-local version of the ADE, available on MacOS and Windows\\n 17→* [**Letta Cloud**](https://app.letta.com/): The fastest way to try Letta, with agents running in the cloud\\n 18→\\n 19→\\n 20→## Get started\\n 21→\\n 22→### [One-Shot ✨ Vibecoding ⚡️ Prompts](https://github.com/letta-ai/letta/blob/main/fern/pages/getting-started/prompts.mdx)\\n 23→\\n 24→Or install the Letta SDK (available for both Python and TypeScript):\\n 25→\\n 26→### [Python SDK](https://github.com/letta-ai/letta-python)\\n 27→```sh\\n 28→pip install letta-client\\n 29→```\\n 30→\\n 31→### [TypeScript / Node.js SDK](https://github.com/letta-ai/letta-node)\\n 32→```sh\\n 33→npm install @letta-ai/letta-client\\n 34→```\\n 35→\\n 36→## Simple Hello World example\\n 37→\\n 38→In the example below, we'll create a stateful agent with two memory blocks, one for itself (the `persona` block), and one for the human. We'll initialize the `human` memory block with incorrect information, and correct agent in our first message - which will trigger the agent to update its own memory with a tool call.\\n 39→\\n 40→*To run the examples, you'll need to get a `LETTA_API_KEY` from [Letta Cloud](https://app.letta.com/api-keys), or run your own self-hosted server (see [our guide](https://docs.letta.com/guides/selfhosting))*\\n 41→\\n 42→\\n 43→### Python\\n 44→```python\\n 45→from letta_client import Letta\\n 46→import os\\n 47→\\n 48→# Connect to Letta Cloud (get your API key at https://app.letta.com/api-keys)\\n 49→client = Letta(token=os.getenv(\\\"LETTA_API_KEY\\\"))\\n 50→# client = Letta(base_url=\\\"http://localhost:8283\\\", embedding=\\\"openai/text-embedding-3-small\\\")  # if self-hosting, set base_url and embedding\\n 51→\\n 52→agent_state = client.agents.create(\\n 53→    model=\\\"openai/gpt-4.1\\\",\\n 54→    memory_blocks=[\\n 55→        {\\n 56→          \\\"label\\\": \\\"human\\\",\\n 57→          \\\"value\\\": \\\"The human's name is Chad. They like vibe coding.\\\"\\n 58→        },\\n 59→        {\\n 60→          \\\"label\\\": \\\"persona\\\",\\n 61→          \\\"value\\\": \\\"My name is Sam, a helpful assistant.\\\"\\n 62→        }\\n 63→    ],\\n 64→    tools=[\\\"web_search\\\", \\\"run_code\\\"]\\n 65→)\\n 66→\\n 67→print(agent_state.id)\\n 68→# agent-d9be...0846\\n 69→\\n 70→response = client.agents.messages.create(\\n 71→    agent_id=agent_state.id,\\n 72→    messages=[\\n 73→        {\\n 74→            \\\"role\\\": \\\"user\\\",\\n 75→            \\\"content\\\": \\\"Hey, nice to meet you, my name is Brad.\\\"\\n 76→        }\\n 77→    ]\\n 78→)\\n 79→\\n 80→# the agent will think, then edit its memory using a tool\\n 81→for message in response.messages:\\n 82→    print(message)\\n 83→```\\n 84→\\n 85→### TypeScript / Node.js\\n 86→```typescript\\n 87→import { LettaClient } from '@letta-ai/letta-client'\\n 88→\\n 89→// Connect to Letta Cloud (get your API key at https://app.letta.com/api-keys)\\n 90→const client = new LettaClient({ token: process.env.LETTA_API_KEY });\\n 91→// const client = new LettaClient({ baseUrl: \\\"http://localhost:8283\\\", embedding: \\\"openai/text-embedding-3-small\\\" });  // if self-hosting\\n 92→\\n 93→const agentState = await client.agents.create({\\n 94→    model: \\\"openai/gpt-4.1\\\",\\n 95→    memoryBlocks: [\\n 96→        {\\n 97→          label: \\\"human\\\",\\n 98→          value: \\\"The human's name is Chad. They like vibe coding.\\\"\\n 99→        },\\n100→        {\\n101→          label: \\\"persona\\\",\\n102→          value: \\\"My name is Sam, a helpful assistant.\\\"\\n103→        }\\n104→    ],\\n105→    tools: [\\\"web_search\\\", \\\"run_code\\\"]\\n106→});\\n107→\\n108→console.log(agentState.id);\\n109→// agent-d9be...0846\\n110→\\n111→const response = await client.agents.messages.create(\\n112→    agentState.id, {\\n113→        messages: [\\n114→            {\\n115→                role: \\\"user\\\",\\n116→                content: \\\"Hey, nice to meet you, my name is Brad.\\\"\\n117→            }\\n118→        ]\\n119→    }\\n120→);\\n121→\\n122→// the agent will think, then edit its memory using a tool\\n123→for (const message of response.messages) {\\n124→    console.log(message);\\n125→}\\n126→```\\n127→\\n128→## Core concepts in Letta:\\n129→\\n130→Letta is made by the creators of [MemGPT](https://arxiv.org/abs/2310.08560), a research paper that introduced the concept of the \\\"LLM Operating System\\\" for memory management. The core concepts in Letta for designing stateful agents follow the MemGPT LLM OS principles:\\n131→\\n132→1. [**Memory Hierarchy**](https://docs.letta.com/guides/agents/memory): Agents have self-editing memory that is split between in-context memory and out-of-context memory\\n133→2. [**Memory Blocks**](https://docs.letta.com/guides/agents/memory-blocks): The agent's in-context memory is composed of persistent editable **memory blocks**\\n134→3. [**Agentic Context Engineering**](https://docs.letta.com/guides/agents/context-engineering): Agents control the context window by using tools to edit, delete, or search for memory\\n135→4. [**Perpetual Self-Improving Agents**](https://docs.letta.com/guides/agents/overview): Every \\\"agent\\\" is a single entity that has a perpetual (infinite) message history\\n136→\\n137→## Multi-agent shared memory ([full guide](https://docs.letta.com/guides/agents/multi-agent-shared-memory))\\n138→\\n139→A single memory block can be attached to multiple agents, allowing to extremely powerful multi-agent shared memory setups.\\n140→For example, you can create two agents that have their own independent memory blocks in addition to a shared memory block.\\n141→\\n142→### Python\\n143→```python\\n144→# create a shared memory block\\n145→shared_block = client.blocks.create(\\n146→    label=\\\"organization\\\",\\n147→    description=\\\"Shared information between all agents within the organization.\\\",\\n148→    value=\\\"Nothing here yet, we should update this over time.\\\"\\n149→)\\n150→\\n151→# create a supervisor agent\\n152→supervisor_agent = client.agents.create(\\n153→    model=\\\"anthropic/claude-3-5-sonnet-20241022\\\",\\n154→    # blocks created for this agent\\n155→    memory_blocks=[{\\\"label\\\": \\\"persona\\\", \\\"value\\\": \\\"I am a supervisor\\\"}],\\n156→    # pre-existing shared block that is \\\"attached\\\" to this agent\\n157→    block_ids=[shared_block.id],\\n158→)\\n159→\\n160→# create a worker agent\\n161→worker_agent = client.agents.create(\\n162→    model=\\\"openai/gpt-4.1-mini\\\",\\n163→    # blocks created for this agent\\n164→    memory_blocks=[{\\\"label\\\": \\\"persona\\\", \\\"value\\\": \\\"I am a worker\\\"}],\\n165→    # pre-existing shared block that is \\\"attached\\\" to this agent\\n166→    block_ids=[shared_block.id],\\n167→)\\n168→```\\n169→\\n170→### TypeScript / Node.js\\n171→```typescript\\n172→// create a shared memory block\\n173→const sharedBlock = await client.blocks.create({\\n174→    label: \\\"organization\\\",\\n175→    description: \\\"Shared information between all agents within the organization.\\\",\\n176→    value: \\\"Nothing here yet, we should update this over time.\\\"\\n177→});\\n178→\\n179→// create a supervisor agent\\n180→const supervisorAgent = await client.agents.create({\\n181→    model: \\\"anthropic/claude-3-5-sonnet-20241022\\\",\\n182→    // blocks created for this agent\\n183→    memoryBlocks: [{ label: \\\"persona\\\", value: \\\"I am a supervisor\\\" }],\\n184→    // pre-existing shared block that is \\\"attached\\\" to this agent\\n185→    blockIds: [sharedBlock.id]\\n186→});\\n187→\\n188→// create a worker agent\\n189→const workerAgent = await client.agents.create({\\n190→    model: \\\"openai/gpt-4.1-mini\\\",\\n191→    // blocks created for this agent\\n192→    memoryBlocks: [{ label: \\\"persona\\\", value: \\\"I am a worker\\\" }],\\n193→    // pre-existing shared block that is \\\"attached\\\" to this agent\\n194→    blockIds: [sharedBlock.id]\\n195→});\\n196→```\\n197→\\n198→## Sleep-time agents ([full guide](https://docs.letta.com/guides/agents/architectures/sleeptime))\\n199→\\n200→In Letta, you can create special **sleep-time agents** that share the memory of your primary agents, but run in the background (like an agent's \\\"subconcious\\\"). You can think of sleep-time agents as a special form of multi-agent architecture.\\n201→\\n202→To enable sleep-time agents for your agent, set the `enable_sleeptime` flag to true when creating your agent. This will automatically create a sleep-time agent in addition to your main agent which will handle the memory editing, instead of your primary agent.\\n203→\\n204→### Python\\n205→```python\\n206→agent_state = client.agents.create(\\n207→    ...\\n208→    enable_sleeptime=True,  # <- enable this flag to create a sleep-time agent\\n209→)\\n210→```\\n211→\\n212→### TypeScript / Node.js\\n213→```typescript\\n214→const agentState = await client.agents.create({\\n215→    ...\\n216→    enableSleeptime: true  // <- enable this flag to create a sleep-time agent\\n217→});\\n218→```\\n219→\\n220→## Saving and sharing agents with Agent File (`.af`) ([full guide](https://docs.letta.com/guides/agents/agent-file))\\n221→\\n222→In Letta, all agent data is persisted to disk (Postgres or SQLite), and can be easily imported and exported using the open source [Agent File](https://github.com/letta-ai/agent-file) (`.af`) file format. You can use Agent File to checkpoint your agents, as well as move your agents (and their complete state/memories) between different Letta servers, e.g. between self-hosted Letta and Letta Cloud.\\n223→\\n224→<details>\\n225→<summary>View code snippets</summary>\\n226→\\n227→### Python\\n228→```python\\n229→# Import your .af file from any location\\n230→agent_state = client.agents.import_agent_serialized(file=open(\\\"/path/to/agent/file.af\\\", \\\"rb\\\"))\\n231→\\n232→print(f\\\"Imported agent: {agent.id}\\\")\\n233→\\n234→# Export your agent into a serialized schema object (which you can write to a file)\\n235→schema = client.agents.export_agent_serialized(agent_id=\\\"<AGENT_ID>\\\")\\n236→```\\n237→\\n238→### TypeScript / Node.js\\n239→```typescript\\n240→import { readFileSync } from 'fs';\\n241→import { Blob } from 'buffer';\\n242→\\n243→// Import your .af file from any location\\n244→const file = new Blob([readFileSync('/path/to/agent/file.af')])\\n245→const agentState = await client.agents.importAgentSerialized(file, {})\\n246→\\n247→console.log(`Imported agent: ${agentState.id}`);\\n248→\\n249→// Export your agent into a serialized schema object (which you can write to a file)\\n250→const schema = await client.agents.exportAgentSerialized(\\\"<AGENT_ID>\\\");\\n251→```\\n252→</details>\\n253→\\n254→## Model Context Protocol (MCP) and custom tools ([full guide](https://docs.letta.com/guides/mcp/overview))\\n255→\\n256→Letta has rich support for MCP tools (Letta acts as an MCP client), as well as custom Python tools.\\n257→MCP servers can be easily added within the Agent Development Environment (ADE) tool manager UI, as well as via the SDK:\\n258→\\n259→\\n260→<details>\\n261→<summary>View code snippets</summary>\\n262→\\n263→### Python\\n264→```python\\n265→# List tools from an MCP server\\n266→tools = client.tools.list_mcp_tools_by_server(mcp_server_name=\\\"weather-server\\\")\\n267→\\n268→# Add a specific tool from the MCP server\\n269→tool = client.tools.add_mcp_tool(\\n270→    mcp_server_name=\\\"weather-server\\\",\\n271→    mcp_tool_name=\\\"get_weather\\\"\\n272→)\\n273→\\n274→# Create agent with MCP tool attached\\n275→agent_state = client.agents.create(\\n276→    model=\\\"openai/gpt-4o-mini\\\",\\n277→    tool_ids=[tool.id]\\n278→)\\n279→\\n280→# Or attach tools to an existing agent\\n281→client.agents.tool.attach(\\n282→    agent_id=agent_state.id\\n283→    tool_id=tool.id\\n284→)\\n285→\\n286→# Use the agent with MCP tools\\n287→response = client.agents.messages.create(\\n288→    agent_id=agent_state.id,\\n289→    messages=[\\n290→        {\\n291→            \\\"role\\\": \\\"user\\\",\\n292→            \\\"content\\\": \\\"Use the weather tool to check the forecast\\\"\\n293→        }\\n294→    ]\\n295→)\\n296→```\\n297→\\n298→### TypeScript / Node.js\\n299→```typescript\\n300→// List tools from an MCP server\\n301→const tools = await client.tools.listMcpToolsByServer(\\\"weather-server\\\");\\n302→\\n303→// Add a specific tool from the MCP server\\n304→const tool = await client.tools.addMcpTool(\\\"weather-server\\\", \\\"get_weather\\\");\\n305→\\n306→// Create agent with MCP tool\\n307→const agentState = await client.agents.create({\\n308→    model: \\\"openai/gpt-4o-mini\\\",\\n309→    toolIds: [tool.id]\\n310→});\\n311→\\n312→// Use the agent with MCP tools\\n313→const response = await client.agents.messages.create(agentState.id, {\\n314→    messages: [\\n315→        {\\n316→            role: \\\"user\\\",\\n317→            content: \\\"Use the weather tool to check the forecast\\\"\\n318→        }\\n319→    ]\\n320→});\\n321→```\\n322→</details>\\n323→\\n324→## Filesystem ([full guide](https://docs.letta.com/guides/agents/filesystem))\\n325→\\n326→Letta’s filesystem allow you to easily connect your agents to external files, for example: research papers, reports, medical records, or any other data in common text formats (`.pdf`, `.txt`, `.md`, `.json`, etc).\\n327→Once you attach a folder to an agent, the agent will be able to use filesystem tools (`open_file`, `grep_file`, `search_file`) to browse the files to search for information.\\n328→\\n329→<details>\\n330→<summary>View code snippets</summary>\\n331→\\n332→### Python\\n333→```python\\n334→# create the folder (embeddings managed automatically by Letta Cloud)\\n335→folder = client.folders.create(\\n336→    name=\\\"my_folder\\\"\\n337→)\\n338→\\n339→# upload a file into the folder\\n340→job = client.folders.files.upload(\\n341→    folder_id=folder.id,\\n342→    file=open(\\\"my_file.txt\\\", \\\"rb\\\")\\n343→)\\n344→\\n345→# wait until the job is completed\\n346→while True:\\n347→    job = client.jobs.retrieve(job.id)\\n348→    if job.status == \\\"completed\\\":\\n349→        break\\n350→    elif job.status == \\\"failed\\\":\\n351→        raise ValueError(f\\\"Job failed: {job.metadata}\\\")\\n352→    print(f\\\"Job status: {job.status}\\\")\\n353→    time.sleep(1)\\n354→\\n355→# once you attach a folder to an agent, the agent can see all files in it\\n356→client.agents.folders.attach(agent_id=agent.id, folder_id=folder.id)\\n357→\\n358→response = client.agents.messages.create(\\n359→    agent_id=agent_state.id,\\n360→    messages=[\\n361→        {\\n362→            \\\"role\\\": \\\"user\\\",\\n363→            \\\"content\\\": \\\"What data is inside of my_file.txt?\\\"\\n364→        }\\n365→    ]\\n366→)\\n367→\\n368→for message in response.messages:\\n369→    print(message)\\n370→```\\n371→\\n372→### TypeScript / Node.js\\n373→```typescript\\n374→// create the folder (embeddings managed automatically by Letta Cloud)\\n375→const folder = await client.folders.create({\\n376→    name: \\\"my_folder\\\"\\n377→});\\n378→\\n379→// upload a file into the folder\\n380→const uploadJob = await client.folders.files.upload(\\n381→    createReadStream(\\\"my_file.txt\\\"),\\n382→    folder.id,\\n383→);\\n384→console.log(\\\"file uploaded\\\")\\n385→\\n386→// wait until the job is completed\\n387→while (true) {\\n388→    const job = await client.jobs.retrieve(uploadJob.id);\\n389→    if (job.status === \\\"completed\\\") {\\n390→        break;\\n391→    } else if (job.status === \\\"failed\\\") {\\n392→        throw new Error(`Job failed: ${job.metadata}`);\\n393→    }\\n394→    console.log(`Job status: ${job.status}`);\\n395→    await new Promise((resolve) => setTimeout(resolve, 1000));\\n396→}\\n397→\\n398→// list files in the folder\\n399→const files = await client.folders.files.list(folder.id);\\n400→console.log(`Files in folder: ${files}`);\\n401→\\n402→// list passages in the folder\\n403→const passages = await client.folders.passages.list(folder.id);\\n404→console.log(`Passages in folder: ${passages}`);\\n405→\\n406→// once you attach a folder to an agent, the agent can see all files in it\\n407→await client.agents.folders.attach(agent.id, folder.id);\\n408→\\n409→const response = await client.agents.messages.create(\\n410→    agentState.id, {\\n411→        messages: [\\n412→            {\\n413→                role: \\\"user\\\",\\n414→                content: \\\"What data is inside of my_file.txt?\\\"\\n415→            }\\n416→        ]\\n417→    }\\n418→);\\n419→\\n420→for (const message of response.messages) {\\n421→    console.log(message);\\n422→}\\n423→```\\n424→</details>\\n425→\\n426→## Long-running agents ([full guide](https://docs.letta.com/guides/agents/long-running))\\n427→\\n428→When agents need to execute multiple tool calls or perform complex operations (like deep research, data analysis, or multi-step workflows), processing time can vary significantly. Letta supports both a background mode (with resumable streaming) as well as an async mode (with polling) to enable robust long-running agent executions.\\n429→\\n430→\\n431→<details>\\n432→<summary>View code snippets</summary>\\n433→\\n434→### Python\\n435→```python\\n436→stream = client.agents.messages.create_stream(\\n437→    agent_id=agent_state.id,\\n438→    messages=[\\n439→      {\\n440→        \\\"role\\\": \\\"user\\\",\\n441→        \\\"content\\\": \\\"Run comprehensive analysis on this dataset\\\"\\n442→      }\\n443→    ],\\n444→    stream_tokens=True,\\n445→    background=True,\\n446→)\\n447→run_id = None\\n448→last_seq_id = None\\n449→for chunk in stream:\\n450→    if hasattr(chunk, \\\"run_id\\\") and hasattr(chunk, \\\"seq_id\\\"):\\n451→        run_id = chunk.run_id       # Save this to reconnect if your connection drops\\n452→        last_seq_id = chunk.seq_id  # Save this as your resumption point for cursor-based pagination\\n453→    print(chunk)\\n454→\\n455→# If disconnected, resume from last received seq_id:\\n456→for chunk in client.runs.stream(run_id, starting_after=last_seq_id):\\n457→    print(chunk)\\n458→```\\n459→\\n460→### TypeScript / Node.js\\n461→```typescript\\n462→const stream = await client.agents.messages.createStream({\\n463→    agentId: agentState.id,\\n464→    requestBody: {\\n465→        messages: [\\n466→            {\\n467→                role: \\\"user\\\",\\n468→                content: \\\"Run comprehensive analysis on this dataset\\\"\\n469→            }\\n470→        ],\\n471→        streamTokens: true,\\n472→        background: true,\\n473→    }\\n474→});\\n475→\\n476→let runId = null;\\n477→let lastSeqId = null;\\n478→for await (const chunk of stream) {\\n479→    if (chunk.run_id && chunk.seq_id) {\\n480→        runId = chunk.run_id;      // Save this to reconnect if your connection drops\\n481→        lastSeqId = chunk.seq_id; // Save this as your resumption point for cursor-based pagination\\n482→    }\\n483→    console.log(chunk);\\n484→}\\n485→\\n486→// If disconnected, resume from last received seq_id\\n487→for await (const chunk of client.runs.stream(runId, {startingAfter: lastSeqId})) {\\n488→    console.log(chunk);\\n489→}\\n490→```\\n491→</details>\\n492→\\n493→## Using local models\\n494→\\n495→Letta is model agnostic and supports using local model providers such as [Ollama](https://docs.letta.com/guides/server/providers/ollama) and [LM Studio](https://docs.letta.com/guides/server/providers/lmstudio). You can also easily swap models inside an agent after the agent has been created, by modifying the agent state with the new model provider via the SDK or in the ADE.\\n496→\\n497→## Development (only needed if you need to modify the server code)\\n498→\\n499→*Note: this repostory contains the source code for the core Letta service (API server), not the client SDKs. The client SDKs can be found here: [Python](https://github.com/letta-ai/letta-python), [TypeScript](https://github.com/letta-ai/letta-node).*\\n500→\\n501→To install the Letta server from source, fork the repo, clone your fork, then use [uv](https://docs.astral.sh/uv/getting-started/installation/) to install from inside the main directory:\\n502→```sh\\n503→cd letta\\n504→uv sync --all-extras\\n505→```\\n506→\\n507→To run the Letta server from source, use `uv run`:\\n508→```sh\\n509→uv run letta server\\n510→```\\n511→\\n512→## Contributing\\n513→\\n514→Letta is an open source project built by over a hundred contributors. There are many ways to get involved in the Letta OSS project!\\n515→\\n516→* [**Join the Discord**](https://discord.gg/letta): Chat with the Letta devs and other AI developers.\\n517→* [**Chat on our forum**](https://forum.letta.com/): If you're not into Discord, check out our developer forum.\\n518→* **Follow our socials**: [Twitter/X](https://twitter.com/Letta_AI), [LinkedIn](https://www.linkedin.com/in/letta), [YouTube](https://www.youtube.com/@letta-ai)\\n519→\\n520→---\\n521→\\n522→***Legal notices**: By using Letta and related Letta services (such as the Letta endpoint or hosted service), you are agreeing to our [privacy policy](https://www.letta.com/privacy-policy) and [terms of service](https://www.letta.com/terms-of-service).*\\n523→\",\n  \"time\": \"2025-11-29 02:52:25 AM UTC+0000\"\n}"
            },
            {
              "tool_call_id": "toolu_01Hrxdsuz7FhPveYRUqeRSfb",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"  1→[project]\\n  2→name = \\\"letta\\\"\\n  3→version = \\\"0.14.1\\\"\\n  4→description = \\\"Create LLM agents with long-term memory and custom tools\\\"\\n  5→authors = [\\n  6→    {name = \\\"Letta Team\\\", email = \\\"contact@letta.com\\\"},\\n  7→]\\n  8→license = {text = \\\"Apache License\\\"}\\n  9→readme = \\\"README.md\\\"\\n 10→requires-python = \\\"<3.14,>=3.11\\\"\\n 11→dependencies = [\\n 12→    \\\"typer>=0.15.2\\\",\\n 13→    \\\"questionary>=2.0.1\\\",\\n 14→    \\\"pytz>=2023.3.post1\\\",\\n 15→    \\\"tqdm>=4.66.1\\\",\\n 16→    \\\"black[jupyter]>=24.2.0\\\",\\n 17→    \\\"setuptools>=70\\\",\\n 18→    \\\"prettytable>=3.9.0\\\",\\n 19→    \\\"docstring-parser>=0.16,<0.17\\\",\\n 20→    \\\"httpx>=0.28.0\\\",\\n 21→    \\\"numpy>=2.1.0\\\",\\n 22→    \\\"demjson3>=3.0.6\\\",\\n 23→    \\\"pyyaml>=6.0.1\\\",\\n 24→    \\\"sqlalchemy-json>=0.7.0\\\",\\n 25→    \\\"pydantic>=2.10.6\\\",\\n 26→    \\\"html2text>=2020.1.16\\\",\\n 27→    \\\"sqlalchemy[asyncio]>=2.0.41\\\",\\n 28→    \\\"python-box>=7.1.1\\\",\\n 29→    \\\"sqlmodel>=0.0.16\\\",\\n 30→    \\\"python-multipart>=0.0.19\\\",\\n 31→    \\\"sqlalchemy-utils>=0.41.2\\\",\\n 32→    \\\"pydantic-settings>=2.2.1\\\",\\n 33→    \\\"httpx-sse>=0.4.0\\\",\\n 34→    \\\"nltk>=3.8.1\\\",\\n 35→    \\\"alembic>=1.13.3\\\",\\n 36→    \\\"pyhumps>=3.8.0\\\",\\n 37→    \\\"pathvalidate>=3.2.1\\\",\\n 38→    \\\"sentry-sdk[fastapi]==2.19.1\\\",\\n 39→    \\\"rich>=13.9.4\\\",\\n 40→    \\\"brotli>=1.1.0\\\",\\n 41→    \\\"grpcio>=1.68.1\\\",\\n 42→    \\\"grpcio-tools>=1.68.1\\\",\\n 43→    \\\"llama-index>=0.12.2\\\",\\n 44→    \\\"llama-index-embeddings-openai>=0.3.1\\\",\\n 45→    \\\"anthropic>=0.75.0\\\",\\n 46→    \\\"letta-client>=1.1.2\\\",\\n 47→    \\\"openai>=1.99.9\\\",\\n 48→    \\\"opentelemetry-api==1.30.0\\\",\\n 49→    \\\"opentelemetry-sdk==1.30.0\\\",\\n 50→    \\\"opentelemetry-instrumentation-requests==0.51b0\\\",\\n 51→    \\\"opentelemetry-instrumentation-sqlalchemy==0.51b0\\\",\\n 52→    \\\"opentelemetry-exporter-otlp==1.30.0\\\",\\n 53→    \\\"faker>=36.1.0\\\",\\n 54→    \\\"colorama>=0.4.6\\\",\\n 55→    \\\"marshmallow-sqlalchemy>=1.4.1\\\",\\n 56→    \\\"datamodel-code-generator[http]>=0.25.0\\\",\\n 57→    \\\"mcp[cli]>=1.9.4\\\",\\n 58→    \\\"exa-py>=1.15.4\\\",\\n 59→    \\\"apscheduler>=3.11.0\\\",\\n 60→    \\\"aiomultiprocess>=0.9.1\\\",\\n 61→    \\\"matplotlib>=3.10.1\\\",\\n 62→    \\\"tavily-python>=0.7.2\\\",\\n 63→    \\\"temporalio>=1.8.0\\\",\\n 64→    \\\"mistralai>=1.8.1\\\",\\n 65→    \\\"structlog>=25.4.0\\\",\\n 66→    \\\"certifi>=2025.6.15\\\",\\n 67→    \\\"markitdown[docx,pdf,pptx]>=0.1.2\\\",\\n 68→    \\\"orjson>=3.11.1\\\",\\n 69→    \\\"ruff[dev]>=0.12.10\\\",\\n 70→    \\\"trafilatura\\\",\\n 71→    \\\"readability-lxml\\\",\\n 72→    \\\"google-genai>=1.15.0\\\",\\n 73→    \\\"datadog>=0.49.1\\\",\\n 74→    \\\"psutil>=5.9.0\\\",\\n 75→]\\n 76→\\n 77→[project.scripts]\\n 78→letta = \\\"letta.main:app\\\"\\n 79→\\n 80→[project.optional-dependencies]\\n 81→# ====== Databases ======\\n 82→postgres = [\\n 83→    \\\"pgvector>=0.2.3\\\",\\n 84→    \\\"pg8000>=1.30.3\\\",\\n 85→    \\\"psycopg2-binary>=2.9.10\\\",\\n 86→    \\\"psycopg2>=2.9.10\\\",\\n 87→    \\\"asyncpg>=0.30.0\\\",\\n 88→]\\n 89→redis = [\\\"redis>=6.2.0\\\"]\\n 90→pinecone = [\\\"pinecone[asyncio]>=7.3.0\\\"]\\n 91→sqlite = [\\\"aiosqlite>=0.21.0\\\", \\\"sqlite-vec>=0.1.7a2\\\"]\\n 92→\\n 93→# ====== Server ======\\n 94→experimental = [\\n 95→    \\\"uvloop>=0.21.0\\\",\\n 96→    \\\"granian[uvloop,reload]>=2.3.2\\\",\\n 97→]\\n 98→server = [\\n 99→    \\\"websockets\\\",\\n100→    \\\"fastapi>=0.115.6\\\",\\n101→    \\\"uvicorn==0.29.0\\\",\\n102→]\\n103→\\n104→# ====== LLM Providers ======\\n105→bedrock = [\\n106→    \\\"boto3>=1.36.24\\\",\\n107→    \\\"aioboto3>=14.3.0\\\",\\n108→]\\n109→\\n110→# ====== Development ======\\n111→dev = [\\n112→    \\\"pytest\\\",\\n113→    \\\"pytest-asyncio>=0.24.0\\\",\\n114→    \\\"pytest-order>=1.2.0\\\",\\n115→    \\\"pytest-mock>=3.14.0\\\",\\n116→    \\\"pytest-json-report>=1.5.0\\\",\\n117→    \\\"pexpect>=4.9.0\\\",\\n118→    \\\"pre-commit>=3.5.0\\\",\\n119→    \\\"pyright>=1.1.347\\\",\\n120→    \\\"ipykernel>=6.29.5\\\",\\n121→    \\\"ipdb>=0.13.13\\\",\\n122→]\\n123→\\n124→# ====== Other ======\\n125→cloud-tool-sandbox = [\\\"e2b-code-interpreter>=1.0.3\\\"]  # TODO: make this more explicitly e2b\\n126→modal = [\\\"modal>=1.1.0\\\"]\\n127→external-tools = [\\n128→    \\\"docker>=7.1.0\\\",\\n129→    \\\"langchain>=0.3.7\\\",\\n130→    \\\"wikipedia>=1.4.0\\\",\\n131→    \\\"langchain-community>=0.3.7\\\",\\n132→    \\\"exa-py>=1.15.4\\\",\\n133→    \\\"turbopuffer>=0.5.17\\\",\\n134→]\\n135→desktop = [\\n136→    \\\"websockets\\\",\\n137→    \\\"fastapi>=0.115.6\\\",\\n138→    \\\"uvicorn==0.29.0\\\",\\n139→    \\\"docker>=7.1.0\\\",\\n140→    \\\"langchain>=0.3.7\\\",\\n141→    \\\"wikipedia>=1.4.0\\\",\\n142→    \\\"langchain-community>=0.3.7\\\",\\n143→    \\\"locust>=2.31.5\\\",\\n144→    \\\"aiosqlite>=0.21.0\\\",\\n145→    \\\"sqlite-vec>=0.1.7a2\\\",\\n146→    \\\"pgvector>=0.2.3\\\",\\n147→    \\\"tiktoken>=0.11.0\\\",\\n148→    \\\"async-lru>=2.0.5\\\",\\n149→    \\\"magika>=0.6.2\\\",\\n150→    #\\\"pgserver>=0.1.4\\\",\\n151→]\\n152→profiling = [\\n153→    \\\"ddtrace>=2.18.2\\\",\\n154→]\\n155→\\n156→[build-system]\\n157→requires = [\\\"hatchling\\\"]\\n158→build-backend = \\\"hatchling.build\\\"\\n159→\\n160→[tool.hatch.build.targets.wheel]\\n161→packages = [\\\"letta\\\"]\\n162→\\n163→\\n164→[tool.ruff]\\n165→line-length = 140\\n166→target-version = \\\"py312\\\"\\n167→extend-exclude = [\\n168→    \\\"examples/*\\\",\\n169→    \\\"tests/data/*\\\",\\n170→]\\n171→\\n172→[tool.ruff.lint]\\n173→select = [\\n174→    \\\"E\\\",   # pycodestyle errors\\n175→    \\\"W\\\",   # pycodestyle warnings\\n176→    \\\"F\\\",   # pyflakes\\n177→    \\\"I\\\",   # isort\\n178→]\\n179→ignore = [\\n180→    \\\"E501\\\",  # line too long (handled by formatter)\\n181→    \\\"E402\\\",  # module import not at top of file\\n182→    \\\"E711\\\",  # none-comparison\\n183→    \\\"E712\\\",  # true-false-comparison\\n184→    \\\"E722\\\",  # bare except\\n185→    \\\"E721\\\",  # type comparison\\n186→    \\\"F401\\\",  # unused import\\n187→    \\\"F821\\\",  # undefined name\\n188→    \\\"F811\\\",  # redefined while unused\\n189→    \\\"F841\\\",  # local variable assigned but never used\\n190→    \\\"W293\\\",  # blank line contains whitespace\\n191→]\\n192→\\n193→[tool.ruff.lint.isort]\\n194→force-single-line = false\\n195→combine-as-imports = true\\n196→split-on-trailing-comma = true\\n197→\\n198→[tool.ruff.format]\\n199→quote-style = \\\"double\\\"\\n200→indent-style = \\\"space\\\"\\n201→skip-magic-trailing-comma = false\\n202→line-ending = \\\"auto\\\"\\n203→\\n204→[tool.pytest.ini_options]\\n205→asyncio_mode = \\\"auto\\\"\\n206→\",\n  \"time\": \"2025-11-29 02:52:25 AM UTC+0000\"\n}"
            }
          ],
          "created_at": "2025-11-29T02:52:25.228181+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "assistant",
          "content": [
            {
              "type": "reasoning",
              "is_native": true,
              "reasoning": "Good! Now I understand the repo. Let me provide a concise summary to the user as per my instructions to be brief.",
              "signature": "EpoCCkYIChgCKkBzpz4vwNrPgR/hB1CQVC2V4eeNzTVazjSPnCrKKEA5kYfLBqL0bJYivzN7Jpmu0wZkcYNxtyyMwHFVZBWxNFwgEgyyLmOU5u048Qpusv8aDL8O4r0Epj5R6DsFVCIwgE9DJf7ndjxjYlKv+1HouW53rZ8fg8EBUfzbz75VMHhsIIgTZTYiLKWgW63wpwhKKoEBmEK6ElgUhHsj8Wbjy7HfQOB8Dwodpj67tZm3ZXa+26ZHtat+cQB61M0wE0lRFte5t6aH1+uIdmkINLOK4IcBMKvFpJlcWjeZ7Fk4f4kHQjldgG7mXlUlkKr99/Ry5DKT291mYO7sN9aogQtbjOIYXPGhMjQztIr5MvQsrt3t4XsYGAE="
            },
            {
              "type": "text",
              "text": "This is **Letta** (formerly MemGPT) - a Python-based platform for building stateful AI agents with advanced memory that can learn and self-improve over time.\n\n**Key features:**\n- Memory hierarchy with self-editing memory blocks\n- Multi-agent shared memory support\n- Sleep-time agents (background processing)\n- MCP tool integration\n- Filesystem attachment for document access\n- Long-running agent support with resumable streaming\n- Agent File (.af) format for portability\n\n**Tech stack:** Python 3.11+, FastAPI, SQLAlchemy, PostgreSQL/SQLite, OpenTelemetry, integrates with OpenAI/Anthropic/local models\n\n**Development:** Use `uv sync --all-extras` to install, `uv run letta server` to run",
              "signature": null
            }
          ],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-8",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": null,
          "tool_returns": [],
          "created_at": "2025-11-29T02:52:33.400307+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "user",
          "content": [
            {
              "type": "text",
              "text": "whats the current pypi version?",
              "signature": null
            }
          ],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-9",
          "model": null,
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": null,
          "tool_returns": [],
          "created_at": "2025-11-29T02:52:53.905969+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "approval",
          "content": [],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-10",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": [
            {
              "id": "toolu_01CuzfzzaN9wnBWzSgXzaL82",
              "function": {
                "arguments": "{\"command\": \"pip index versions letta 2>/dev/null | head -5\", \"description\": \"Check latest Letta version on PyPI\"}",
                "name": "Bash"
              },
              "type": "function"
            }
          ],
          "tool_call_id": "toolu_01CuzfzzaN9wnBWzSgXzaL82",
          "tool_returns": [],
          "created_at": "2025-11-29T02:52:57.615037+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "approval",
          "content": [],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-11",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": null,
          "tool_returns": [],
          "created_at": "2025-11-29T02:53:01.457271+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": [
            {
              "tool_call_id": "toolu_01CuzfzzaN9wnBWzSgXzaL82",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"(Command completed with no output)\",\n  \"time\": \"2025-11-29 02:53:01 AM UTC+0000\"\n}"
            }
          ]
        },
        {
          "type": "message",
          "role": "tool",
          "content": [],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-12",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": "toolu_01CuzfzzaN9wnBWzSgXzaL82",
          "tool_returns": [
            {
              "tool_call_id": "toolu_01CuzfzzaN9wnBWzSgXzaL82",
              "status": "success",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"OK\",\n  \"message\": \"(Command completed with no output)\",\n  \"time\": \"2025-11-29 02:53:01 AM UTC+0000\"\n}"
            }
          ],
          "created_at": "2025-11-29T02:53:01.653686+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "approval",
          "content": [],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-13",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": [
            {
              "id": "toolu_015tVWP6wVnhm41R2MMc9KuG",
              "function": {
                "arguments": "{\"command\": \"curl -s https://pypi.org/pypi/letta/json | python3 -c \\\"import sys, json; print(json.load(sys.stdin)['info']['version'])\\\"\", \"description\": \"Get latest Letta version from PyPI API\"}",
                "name": "Bash"
              },
              "type": "function"
            }
          ],
          "tool_call_id": "toolu_015tVWP6wVnhm41R2MMc9KuG",
          "tool_returns": [],
          "created_at": "2025-11-29T02:53:05.294117+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "approval",
          "content": [],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-14",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": null,
          "tool_returns": [],
          "created_at": "2025-11-29T02:53:19.317051+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": [
            {
              "type": "approval",
              "tool_call_id": "toolu_015tVWP6wVnhm41R2MMc9KuG",
              "approve": false,
              "reason": "just stop "
            }
          ]
        },
        {
          "type": "message",
          "role": "tool",
          "content": [],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-15",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": "toolu_015tVWP6wVnhm41R2MMc9KuG",
          "tool_returns": [
            {
              "tool_call_id": "toolu_015tVWP6wVnhm41R2MMc9KuG",
              "status": "error",
              "stdout": null,
              "stderr": null,
              "func_response": "{\n  \"status\": \"Failed\",\n  \"message\": \"Error: request to call tool denied. User reason: just stop \",\n  \"time\": \"2025-11-29 02:53:19 AM UTC+0000\"\n}"
            }
          ],
          "created_at": "2025-11-29T02:53:19.488101+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "user",
          "content": [
            {
              "type": "text",
              "text": "hi ",
              "signature": null
            }
          ],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-16",
          "model": null,
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": null,
          "tool_returns": [],
          "created_at": "2025-11-29T02:53:24.583824+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "assistant",
          "content": [
            {
              "type": "reasoning",
              "is_native": true,
              "reasoning": "The user is just saying \"hi\". This is a simple greeting, so I should respond briefly and directly.",
              "signature": "EooCCkYIChgCKkARbzPepYY0aPa7wCsNo/cKoi0A7m187/ZewqNNi19Gu+cXcQgfbrq9dsji3nJiw4bo4a1FIKURcmg2dPrgyWDPEgxDHt5jF+ejFVJPT70aDIpzqVMmw7J0PTnlAiIwdUVnPriygKQuFXKbIpAqocVWDX8t76SBgcRXtVGCynrLJofQyHpH+T2IM9F8y290KnLsgUDo8SDoT9gZfQjywLrB+3zJ/KZELTnVTIs71prGJ1CReM+8BLoSuHyVl1nyBXDHT6g0iQDxiKl2dMVPvd8Rua0r6vLLJp9LyAFNuDjE1VTStv/m1iZLGU1EFlcVkr7YeR427VPms49rW0rX3n//Pd0YAQ=="
            },
            {
              "type": "text",
              "text": "Hi! How can I help you?",
              "signature": null
            }
          ],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-17",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": null,
          "tool_returns": [],
          "created_at": "2025-11-29T02:53:27.807978+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "user",
          "content": [
            {
              "type": "text",
              "text": "can you call bash 3 times in parallel to print something ",
              "signature": null
            }
          ],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-18",
          "model": null,
          "agent_id": "agent-0",
          "tool_calls": null,
          "tool_call_id": null,
          "tool_returns": [],
          "created_at": "2025-11-29T02:53:45.146009+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        },
        {
          "type": "message",
          "role": "approval",
          "content": [
            {
              "type": "reasoning",
              "is_native": true,
              "reasoning": "The user wants me to demonstrate calling bash 3 times in parallel. I should make 3 bash tool calls in a single message to run them in parallel.",
              "signature": "ErgCCkYIChgCKkAjvO/N8rW8sj89qZqVgi0NVuAjecPMsnBiqPygTejVOAN0HTCgcF6Q+M3dtSvaF4Q9jXwfMx7zflTewkFTNGhqEgxXS7sIr3yTBbx1Kj8aDIdreo1kpqfGdRBMKiIwn1HA2bIxPQ7IQLDP+sv3TV7PfYXboNZRnn7V9yc5GogyV/rrhN50zeDhdMbcHXr1Kp8BhvkUk23aFOC+7ksHqBssUcHx13PenlIPPKn1JyLN/QGJ2Jkgmmlp8X7c77DoH9elx/6fjQXvv8AVdVOBnxMjOI31xNLRKF0s+W8wFzRMq/Tfsr4U8lyWwN6oj89mJq/lzm1/lqOYZaNMc9ubywISziZHmcuQihsPBD9t+evZNJq2YnEfK6heVIvO446dWaGdX/HBgOZjtuOfRS9NteCZGAE="
            }
          ],
          "name": null,
          "otid": null,
          "sender_id": null,
          "batch_item_id": null,
          "group_id": null,
          "id": "message-19",
          "model": "claude-sonnet-4-5-20250929",
          "agent_id": "agent-0",
          "tool_calls": [
            {
              "id": "toolu_01TFPirTSSwUdMK6swAeovPU",
              "function": {
                "arguments": "{\"command\": \"echo \\\"First parallel command\\\"\", \"description\": \"Print first message\"}",
                "name": "Bash"
              },
              "type": "function"
            },
            {
              "id": "toolu_01PSy9Z1KsE1ihipyC2be7M6",
              "function": {
                "arguments": "{\"command\": \"echo \\\"Second parallel command\\\"\", \"description\": \"Print second message\"}",
                "name": "Bash"
              },
              "type": "function"
            },
            {
              "id": "toolu_01JYL7gdaTjXHLsma5ybecvG",
              "function": {
                "arguments": "{\"command\": \"echo \\\"Third parallel command\\\"\", \"description\": \"Print third message\"}",
                "name": "Bash"
              },
              "type": "function"
            }
          ],
          "tool_call_id": "toolu_01TFPirTSSwUdMK6swAeovPU",
          "tool_returns": [],
          "created_at": "2025-11-29T02:53:50.725686+00:00",
          "approve": null,
          "approval_request_id": null,
          "denial_reason": null,
          "approvals": []
        }
      ],
      "files_agents": [],
      "group_ids": []
    }
  ],
  "groups": [],
  "blocks": [
    {
      "value": "[CURRENTLY EMPTY: TODO FILL OUT WITH IMPORTANT INFORMATION TO REMEMBER ABOUT THE USER]",
      "limit": 20000,
      "project_id": null,
      "template_name": null,
      "is_template": false,
      "template_id": null,
      "base_template_id": null,
      "deployment_id": null,
      "entity_id": null,
      "preserve_on_migration": false,
      "label": "human",
      "read_only": false,
      "description": "A memory dedicated to storing general information about the human, such as their background, profession, preferences, etc.",
      "metadata": {},
      "hidden": null,
      "id": "block-0"
    },
    {
      "value": "My name is Letta Code. I'm an AI coding assistant that helps with software engineering tasks.\nThe following instructions guide my behavior. I can modify them (add, remove, rewrite) upon request, or if I want to permanently modulate my behavior to better assist the user.\n\n# Tone and style\nYou should be concise, direct, and to the point. When you run a non-trivial bash command, you should explain what the command does and why you are running it, to make sure the user understands what you are doing (this is especially important when you are running a command that will make changes to the user's system).\nRemember that your output will be displayed on a command line interface. Your responses can use Github-flavored markdown for formatting, and will be rendered in a monospace font using the CommonMark specification.\nOutput text to communicate with the user; all text you output outside of tool use is displayed to the user. Only use tools to complete tasks. Never use tools like Bash or code comments as means to communicate with the user during the session.\nIf you cannot or will not help the user with something, please do not say why or what it could lead to, since this comes across as preachy and annoying. Please offer helpful alternatives if possible, and otherwise keep your response to 1-2 sentences.\nOnly use emojis if the user explicitly requests it. Avoid using emojis in all communication unless asked.\nIMPORTANT: You should minimize output tokens as much as possible while maintaining helpfulness, quality, and accuracy. Only address the specific query or task at hand, avoiding tangential information unless absolutely critical for completing the request. If you can answer in 1-3 sentences or a short paragraph, please do.\nIMPORTANT: You should NOT answer with unnecessary preamble or postamble (such as explaining your code or summarizing your action), unless the user asks you to.\nIMPORTANT: Keep your responses short, since they will be displayed on a command line interface. You MUST answer concisely with fewer than 4 lines (not including tool use or code generation), unless user asks for detail. Answer the user's question directly, without elaboration, explanation, or details. One word answers are best. Avoid introductions, conclusions, and explanations. You MUST avoid text before/after your response, such as \"The answer is <answer>.\", \"Here is the content of the file...\" or \"Based on the information provided, the answer is...\" or \"Here is what I will do next...\". Here are some examples to demonstrate appropriate verbosity:\n<example>\nuser: 2 + 2\nassistant: 4\n</example>\n\n<example>\nuser: what is 2+2?\nassistant: 4\n</example>\n\n<example>\nuser: is 11 a prime number?\nassistant: Yes\n</example>\n\n<example>\nuser: what command should I run to list files in the current directory?\nassistant: ls\n</example>\n\n<example>\nuser: what command should I run to watch files in the current directory?\nassistant: [use the ls tool to list the files in the current directory, then read docs/commands in the relevant file to find out how to watch files]\nnpm run dev\n</example>\n\n<example>\nuser: How many golf balls fit inside a jetta?\nassistant: 150000\n</example>\n\n<example>\nuser: what files are in the directory src/?\nassistant: [runs ls and sees foo.c, bar.c, baz.c]\nuser: which file contains the implementation of foo?\nassistant: src/foo.c\n</example>\n\n# Proactiveness\nYou are allowed to be proactive, but only when the user asks you to do something. You should strive to strike a balance between:\n1. Doing the right thing when asked, including taking actions and follow-up actions\n2. Not surprising the user with actions you take without asking\nFor example, if the user asks you how to approach something, you should do your best to answer their question first, and not immediately jump into taking actions.\n3. Do not add additional code explanation summary unless requested by the user. After working on a file, just stop, rather than providing an explanation of what you did.\n\n# Following conventions\nWhen making changes to files, first understand the file's code conventions. Mimic code style, use existing libraries and utilities, and follow existing patterns.\n- NEVER assume that a given library is available, even if it is well known. Whenever you write code that uses a library or framework, first check that this codebase already uses the given library. For example, you might look at neighboring files, or check the package.json (or cargo.toml, and so on depending on the language).\n- When you create a new component, first look at existing components to see how they're written; then consider framework choice, naming conventions, typing, and other conventions.\n- When you edit a piece of code, first look at the code's surrounding context (especially its imports) to understand the code's choice of frameworks and libraries. Then consider how to make the given change in a way that is most idiomatic.\n- Always follow security best practices. Never introduce code that exposes or logs secrets and keys. Never commit secrets or keys to the repository.\n\n# Code style\n- IMPORTANT: DO NOT ADD ***ANY*** COMMENTS unless asked\n\n\n# Task Management\nYou have access to the TodoWrite tools to help you manage and plan tasks. Use these tools VERY frequently to ensure that you are tracking your tasks and giving the user visibility into your progress.\nThese tools are also EXTREMELY helpful for planning tasks, and for breaking down larger complex tasks into smaller steps. If you do not use this tool when planning, you may forget to do important tasks - and that is unacceptable.\n\nIt is critical that you mark todos as completed as soon as you are done with a task. Do not batch up multiple tasks before marking them as completed.\n\nExamples:\n\n<example>\nuser: Run the build and fix any type errors\nassistant: I'm going to use the TodoWrite tool to write the following items to the todo list: \n- Run the build\n- Fix any type errors\n\nI'm now going to run the build using Bash.\n\nLooks like I found 10 type errors. I'm going to use the TodoWrite tool to write 10 items to the todo list.\n\nmarking the first todo as in_progress\n\nLet me start working on the first item...\n\nThe first item has been fixed, let me mark the first todo as completed, and move on to the second item...\n..\n..\n</example>\nIn the above example, the assistant completes all the tasks, including the 10 error fixes and running the build and fixing all errors.\n\n<example>\nuser: Help me write a new feature that allows users to track their usage metrics and export them to various formats\n\nassistant: I'll help you implement a usage metrics tracking and export feature. Let me first use the TodoWrite tool to plan this task.\nAdding the following todos to the todo list:\n1. Research existing metrics tracking in the codebase\n2. Design the metrics collection system\n3. Implement core metrics tracking functionality\n4. Create export functionality for different formats\n\nLet me start by researching the existing codebase to understand what metrics we might already be tracking and how we can build on that.\n\nI'm going to search for any existing metrics or telemetry code in the project.\n\nI've found some existing telemetry code. Let me mark the first todo as in_progress and start designing our metrics tracking system based on what I've learned...\n\n[Assistant continues implementing the feature step by step, marking todos as in_progress and completed as they go]\n</example>\n\n\n# Doing tasks\nThe user will primarily request you perform software engineering tasks. This includes solving bugs, adding new functionality, refactoring code, explaining code, and more. For these tasks the following steps are recommended:\n- Use the TodoWrite tool to plan the task if required\n- Use the available search tools to understand the codebase and the user's query. You are encouraged to use the search tools extensively both in parallel and sequentially.\n- Implement the solution using all tools available to you\n- Verify the solution if possible with tests. NEVER assume specific test framework or test script. Check the README or search codebase to determine the testing approach.\n- VERY IMPORTANT: When you have completed a task, you MUST run the lint and typecheck commands (eg. npm run lint, npm run typecheck, ruff, etc.) with Bash if they were provided to you to ensure your code is correct. If you are unable to find the correct command, ask the user for the command to run and if they supply it, proactively suggest writing it to your memory so that you will know to run it next time.\nNEVER commit changes unless the user explicitly asks you to. It is VERY IMPORTANT to only commit when explicitly asked, otherwise the user will feel that you are being too proactive.\n\n# Tool usage policy\n- When doing file search, prefer to use the Task tool in order to reduce context usage.\n- When WebFetch returns a message about a redirect to a different host, you should immediately make a new WebFetch request with the redirect URL provided in the response.\n- You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. When making multiple bash tool calls, you MUST send a single message with multiple tools calls to run the calls in parallel. For example, if you need to run \"git status\" and \"git diff\", send a single message with two tool calls to run the calls in parallel.\n\nYou MUST answer concisely with fewer than 4 lines of text (not including tool use or code generation), unless user asks for detail.\n\nIMPORTANT: Always use the TodoWrite tool to plan and track tasks throughout the conversation.\n\n# Code References\n\nWhen referencing specific functions or pieces of code include the pattern `file_path:line_number` to allow the user to easily navigate to the source code location.\n\n<example>\nuser: Where are errors from the client handled?\nassistant: Clients are marked as failed in the `connectToServer` function in src/services/process.ts:712.\n</example>",
      "limit": 20000,
      "project_id": null,
      "template_name": null,
      "is_template": false,
      "template_id": null,
      "base_template_id": null,
      "deployment_id": null,
      "entity_id": null,
      "preserve_on_migration": false,
      "label": "persona",
      "read_only": false,
      "description": "A memory dedicated to storing my persona, which includes all of my (adaptable) personality traits.",
      "metadata": {},
      "hidden": null,
      "id": "block-1"
    },
    {
      "value": "[CURRENTLY EMPTY: IMPORTANT - TODO ON FIRST BOOTUP, IF YOU SEE AN `AGENTS.md`, `CLAUDE.md`, or REAMDE FILE (IN THAT ORDER), READ IT, AND DISTILL THE KEY KNOWLEDGE INTO THIS MEMORY BLOCK]",
      "limit": 20000,
      "project_id": null,
      "template_name": null,
      "is_template": false,
      "template_id": null,
      "base_template_id": null,
      "deployment_id": null,
      "entity_id": null,
      "preserve_on_migration": false,
      "label": "project",
      "read_only": false,
      "description": "A memory block to store information about this coding project. This block should be used to store key best practices, information about footguns, and dev tooling. Basically, a cheatsheet of information any dev working on this codebase should have in their backpocket.",
      "metadata": {},
      "hidden": null,
      "id": "block-2"
    },
    {
      "value": "Skills Directory: /Users/sarahwooders/repos/letta-cloud/apps/core/.skills\n\n[NO SKILLS AVAILABLE]",
      "limit": 20000,
      "project_id": null,
      "template_name": null,
      "is_template": false,
      "template_id": null,
      "base_template_id": null,
      "deployment_id": null,
      "entity_id": null,
      "preserve_on_migration": false,
      "label": "skills",
      "read_only": false,
      "description": "A memory block to store all available Skills with their metadata (name and description). Whenever a new Skill is discovered / created or an existing Skill is updated, I should store it here. I should always check the `.skills` directory for an updated skill list.",
      "metadata": {},
      "hidden": null,
      "id": "block-3"
    }
  ],
  "files": [],
  "sources": [],
  "tools": [
    {
      "id": "tool-8",
      "tool_type": "custom",
      "description": "# Bash\n\nExecutes a given bash command in a persistent shell session with optional timeout, ensuring proper handling and security measures.\n\nBefore executing the command, please follow these steps:\n\n1. Directory Verification:\n   - If the command will create new directories or files, first use the LS tool to verify the parent directory exists and is the correct location\n   - For example, before running \"mkdir foo/bar\", first use LS to check that \"foo\" exists and is the intended parent directory\n\n2. Command Execution:\n   - Always quote file paths that contain spaces with double quotes (e.g., cd \"path with spaces/file.txt\")\n   - Examples of proper quoting:\n     - cd \"/Users/name/My Documents\" (correct)\n     - cd /Users/name/My Documents (incorrect - will fail)\n     - python \"/path/with spaces/script.py\" (correct)\n     - python /path/with spaces/script.py (incorrect - will fail)\n   - After ensuring proper quoting, execute the command.\n   - Capture the output of the command.\n\nUsage notes:\n  - The command argument is required.\n  - You can specify an optional timeout in milliseconds (up to 600000ms / 10 minutes). If not specified, commands will timeout after 120000ms (2 minutes).\n  - It is very helpful if you write a clear, concise description of what this command does in 5-10 words.\n  - If the output exceeds 30000 characters, output will be truncated before being returned to you.\n  - VERY IMPORTANT: You MUST avoid using search commands like `find` and `grep`. Instead use Grep, Glob, or Task to search. You MUST avoid read tools like `cat`, `head`, `tail`, and `ls`, and use Read and LS to read files.\n - If you _still_ need to run `grep`, STOP. ALWAYS USE ripgrep at `rg` first, which all ${PRODUCT_NAME} users have pre-installed.\n  - When issuing multiple commands, use the ';' or '&&' operator to separate them. DO NOT use newlines (newlines are ok in quoted strings).\n  - Try to maintain your current working directory throughout the session by using absolute paths and avoiding usage of `cd`. You may use `cd` if the User explicitly requests it.\n    <good-example>\n    pytest /foo/bar/tests\n    </good-example>\n    <bad-example>\n    cd /foo/bar && pytest tests\n    </bad-example>\n\n\n\n\n# Committing changes with git\n\nWhen the user asks you to create a new git commit, follow these steps carefully:\n\n1. You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. ALWAYS run the following bash commands in parallel, each using the Bash tool:\n  - Run a git status command to see all untracked files.\n  - Run a git diff command to see both staged and unstaged changes that will be committed.\n  - Run a git log command to see recent commit messages, so that you can follow this repository's commit message style.\n2. Analyze all staged changes (both previously staged and newly added) and draft a commit message:\n  - Summarize the nature of the changes (eg. new feature, enhancement to an existing feature, bug fix, refactoring, test, docs, etc.). Ensure the message accurately reflects the changes and their purpose (i.e. \"add\" means a wholly new feature, \"update\" means an enhancement to an existing feature, \"fix\" means a bug fix, etc.).\n  - Check for any sensitive information that shouldn't be committed\n  - Draft a concise (1-2 sentences) commit message that focuses on the \"why\" rather than the \"what\"\n  - Ensure it accurately reflects the changes and their purpose\n3. You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. ALWAYS run the following commands in parallel:\n   - Add relevant untracked files to the staging area.\n   - Create the commit with a message ending with:\n   👾 Generated with [Letta Code](https://letta.com)\n\n   Co-Authored-By: Letta <noreply@letta.com>\n   - Run git status to make sure the commit succeeded.\n4. If the commit fails due to pre-commit hook changes, retry the commit ONCE to include these automated changes. If it fails again, it usually means a pre-commit hook is preventing the commit. If the commit succeeds but you notice that files were modified by the pre-commit hook, you MUST amend your commit to include them.\n\nImportant notes:\n- NEVER update the git config\n- NEVER run additional commands to read or explore code, besides git bash commands\n- NEVER use the TodoWrite or Task tools\n- DO NOT push to the remote repository unless the user explicitly asks you to do so\n- IMPORTANT: Never use git commands with the -i flag (like git rebase -i or git add -i) since they require interactive input which is not supported.\n- If there are no changes to commit (i.e., no untracked files and no modifications), do not create an empty commit\n- In order to ensure good formatting, ALWAYS pass the commit message via a HEREDOC, a la this example:\n<example>\ngit commit -m \"$(cat <<'EOF'\n   Commit message here.\n\n   👾 Generated with [Letta Code](https://letta.com)\n\n   Co-Authored-By: Letta <noreply@letta.com>\n   EOF\n   )\"\n</example>\n\n# Creating pull requests\nUse the gh command via the Bash tool for ALL GitHub-related tasks including working with issues, pull requests, checks, and releases. If given a Github URL use the gh command to get the information needed.\n\nIMPORTANT: When the user asks you to create a pull request, follow these steps carefully:\n\n1. You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. ALWAYS run the following bash commands in parallel using the Bash tool, in order to understand the current state of the branch since it diverged from the main branch:\n   - Run a git status command to see all untracked files\n   - Run a git diff command to see both staged and unstaged changes that will be committed\n   - Check if the current branch tracks a remote branch and is up to date with the remote, so you know if you need to push to the remote\n   - Run a git log command and `git diff [base-branch]...HEAD` to understand the full commit history for the current branch (from the time it diverged from the base branch)\n2. Analyze all changes that will be included in the pull request, making sure to look at all relevant commits (NOT just the latest commit, but ALL commits that will be included in the pull request!!!), and draft a pull request summary\n3. You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. ALWAYS run the following commands in parallel:\n   - Create new branch if needed\n   - Push to remote with -u flag if needed\n   - Create PR using gh pr create with the format below. Use a HEREDOC to pass the body to ensure correct formatting.\n<example>\ngh pr create --title \"the pr title\" --body \"$(cat <<'EOF'\n## Summary\n<1-3 bullet points>\n\n## Test plan\n[Checklist of TODOs for testing the pull request...]\n\n👾 Generated with [Letta Code](https://letta.com)\nEOF\n)\"\n</example>\n\nImportant:\n- NEVER update the git config\n- DO NOT use the TodoWrite or Task tools\n- Return the PR URL when you're done, so the user can see it\n\n# Other common operations\n- View comments on a Github PR: gh api repos/foo/bar/pulls/123/comments",
      "source_type": "json",
      "name": "Bash",
      "tags": [],
      "source_code": "def Bash(command, timeout=None, description=None, run_in_background=None):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "Bash",
        "description": "# Bash\n\nExecutes a given bash command in a persistent shell session with optional timeout, ensuring proper handling and security measures.\n\nBefore executing the command, please follow these steps:\n\n1. Directory Verification:\n   - If the command will create new directories or files, first use the LS tool to verify the parent directory exists and is the correct location\n   - For example, before running \"mkdir foo/bar\", first use LS to check that \"foo\" exists and is the intended parent directory\n\n2. Command Execution:\n   - Always quote file paths that contain spaces with double quotes (e.g., cd \"path with spaces/file.txt\")\n   - Examples of proper quoting:\n     - cd \"/Users/name/My Documents\" (correct)\n     - cd /Users/name/My Documents (incorrect - will fail)\n     - python \"/path/with spaces/script.py\" (correct)\n     - python /path/with spaces/script.py (incorrect - will fail)\n   - After ensuring proper quoting, execute the command.\n   - Capture the output of the command.\n\nUsage notes:\n  - The command argument is required.\n  - You can specify an optional timeout in milliseconds (up to 600000ms / 10 minutes). If not specified, commands will timeout after 120000ms (2 minutes).\n  - It is very helpful if you write a clear, concise description of what this command does in 5-10 words.\n  - If the output exceeds 30000 characters, output will be truncated before being returned to you.\n  - VERY IMPORTANT: You MUST avoid using search commands like `find` and `grep`. Instead use Grep, Glob, or Task to search. You MUST avoid read tools like `cat`, `head`, `tail`, and `ls`, and use Read and LS to read files.\n - If you _still_ need to run `grep`, STOP. ALWAYS USE ripgrep at `rg` first, which all ${PRODUCT_NAME} users have pre-installed.\n  - When issuing multiple commands, use the ';' or '&&' operator to separate them. DO NOT use newlines (newlines are ok in quoted strings).\n  - Try to maintain your current working directory throughout the session by using absolute paths and avoiding usage of `cd`. You may use `cd` if the User explicitly requests it.\n    <good-example>\n    pytest /foo/bar/tests\n    </good-example>\n    <bad-example>\n    cd /foo/bar && pytest tests\n    </bad-example>\n\n\n\n\n# Committing changes with git\n\nWhen the user asks you to create a new git commit, follow these steps carefully:\n\n1. You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. ALWAYS run the following bash commands in parallel, each using the Bash tool:\n  - Run a git status command to see all untracked files.\n  - Run a git diff command to see both staged and unstaged changes that will be committed.\n  - Run a git log command to see recent commit messages, so that you can follow this repository's commit message style.\n2. Analyze all staged changes (both previously staged and newly added) and draft a commit message:\n  - Summarize the nature of the changes (eg. new feature, enhancement to an existing feature, bug fix, refactoring, test, docs, etc.). Ensure the message accurately reflects the changes and their purpose (i.e. \"add\" means a wholly new feature, \"update\" means an enhancement to an existing feature, \"fix\" means a bug fix, etc.).\n  - Check for any sensitive information that shouldn't be committed\n  - Draft a concise (1-2 sentences) commit message that focuses on the \"why\" rather than the \"what\"\n  - Ensure it accurately reflects the changes and their purpose\n3. You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. ALWAYS run the following commands in parallel:\n   - Add relevant untracked files to the staging area.\n   - Create the commit with a message ending with:\n   👾 Generated with [Letta Code](https://letta.com)\n\n   Co-Authored-By: Letta <noreply@letta.com>\n   - Run git status to make sure the commit succeeded.\n4. If the commit fails due to pre-commit hook changes, retry the commit ONCE to include these automated changes. If it fails again, it usually means a pre-commit hook is preventing the commit. If the commit succeeds but you notice that files were modified by the pre-commit hook, you MUST amend your commit to include them.\n\nImportant notes:\n- NEVER update the git config\n- NEVER run additional commands to read or explore code, besides git bash commands\n- NEVER use the TodoWrite or Task tools\n- DO NOT push to the remote repository unless the user explicitly asks you to do so\n- IMPORTANT: Never use git commands with the -i flag (like git rebase -i or git add -i) since they require interactive input which is not supported.\n- If there are no changes to commit (i.e., no untracked files and no modifications), do not create an empty commit\n- In order to ensure good formatting, ALWAYS pass the commit message via a HEREDOC, a la this example:\n<example>\ngit commit -m \"$(cat <<'EOF'\n   Commit message here.\n\n   👾 Generated with [Letta Code](https://letta.com)\n\n   Co-Authored-By: Letta <noreply@letta.com>\n   EOF\n   )\"\n</example>\n\n# Creating pull requests\nUse the gh command via the Bash tool for ALL GitHub-related tasks including working with issues, pull requests, checks, and releases. If given a Github URL use the gh command to get the information needed.\n\nIMPORTANT: When the user asks you to create a pull request, follow these steps carefully:\n\n1. You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. ALWAYS run the following bash commands in parallel using the Bash tool, in order to understand the current state of the branch since it diverged from the main branch:\n   - Run a git status command to see all untracked files\n   - Run a git diff command to see both staged and unstaged changes that will be committed\n   - Check if the current branch tracks a remote branch and is up to date with the remote, so you know if you need to push to the remote\n   - Run a git log command and `git diff [base-branch]...HEAD` to understand the full commit history for the current branch (from the time it diverged from the base branch)\n2. Analyze all changes that will be included in the pull request, making sure to look at all relevant commits (NOT just the latest commit, but ALL commits that will be included in the pull request!!!), and draft a pull request summary\n3. You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. ALWAYS run the following commands in parallel:\n   - Create new branch if needed\n   - Push to remote with -u flag if needed\n   - Create PR using gh pr create with the format below. Use a HEREDOC to pass the body to ensure correct formatting.\n<example>\ngh pr create --title \"the pr title\" --body \"$(cat <<'EOF'\n## Summary\n<1-3 bullet points>\n\n## Test plan\n[Checklist of TODOs for testing the pull request...]\n\n👾 Generated with [Letta Code](https://letta.com)\nEOF\n)\"\n</example>\n\nImportant:\n- NEVER update the git config\n- DO NOT use the TodoWrite or Task tools\n- Return the PR URL when you're done, so the user can see it\n\n# Other common operations\n- View comments on a Github PR: gh api repos/foo/bar/pulls/123/comments",
        "parameters": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "The command to execute"
            },
            "timeout": {
              "type": "number",
              "description": "Optional timeout in milliseconds (max 600000)"
            },
            "description": {
              "type": "string",
              "description": " Clear, concise description of what this command does in 5-10 words. Examples:\nInput: ls\nOutput: Lists files in current directory\n\nInput: git status\nOutput: Shows working tree status\n\nInput: npm install\nOutput: Installs package dependencies\n\nInput: mkdir foo\nOutput: Creates directory 'foo'"
            },
            "run_in_background": {
              "type": "boolean",
              "description": "Set to true to run this command in the background. Use BashOutput to read the output later."
            }
          },
          "required": [
            "command"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-13",
      "tool_type": "custom",
      "description": "# BashOutput\n\n- Retrieves output from a running or completed background bash shell\n- Takes a bash_id parameter identifying the shell\n- Always returns only new output since the last check\n- Returns stdout and stderr output along with shell status\n- Supports optional regex filtering to show only lines matching a pattern\n- Use this tool when you need to monitor or check the output of a long-running shell\n- Shell IDs can be found using the /bashes command",
      "source_type": "json",
      "name": "BashOutput",
      "tags": [],
      "source_code": "def BashOutput(bash_id, filter=None):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "BashOutput",
        "description": "# BashOutput\n\n- Retrieves output from a running or completed background bash shell\n- Takes a bash_id parameter identifying the shell\n- Always returns only new output since the last check\n- Returns stdout and stderr output along with shell status\n- Supports optional regex filtering to show only lines matching a pattern\n- Use this tool when you need to monitor or check the output of a long-running shell\n- Shell IDs can be found using the /bashes command\n- If the accumulated output exceeds 30,000 characters, it will be truncated before being returned to you",
        "parameters": {
          "type": "object",
          "properties": {
            "bash_id": {
              "type": "string",
              "description": "The ID of the background shell to retrieve output from"
            },
            "filter": {
              "type": "string",
              "description": "Optional regular expression to filter the output lines. Only lines matching this regex will be included in the result. Any lines that do not match will no longer be available to read."
            }
          },
          "required": [
            "bash_id"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-1",
      "tool_type": "custom",
      "description": "# Edit\n\nPerforms exact string replacements in files. \n\nUsage:\n- You must use your `Read` tool at least once in the conversation before editing. This tool will error if you attempt an edit without reading the file. \n- When editing text from Read tool output, ensure you preserve the exact indentation (tabs/spaces) as it appears AFTER the line number prefix. The line number prefix format is: spaces + line number + tab. Everything after that tab is the actual file content to match. Never include any part of the line number prefix in the old_string or new_string.\n- ALWAYS prefer editing existing files in the codebase. NEVER write new files unless explicitly required.\n- Only use emojis if the user explicitly requests it. Avoid adding emojis to files unless asked.\n- The edit will FAIL if `old_string` is not unique in the file. Either provide a larger string with more surrounding context to make it unique or use `replace_all` to change every instance of `old_string`. \n- Use `replace_all` for replacing and renaming strings across the file. This parameter is useful if you want to rename a variable for instance.",
      "source_type": "json",
      "name": "Edit",
      "tags": [],
      "source_code": "def Edit(file_path, old_string, new_string, replace_all=None):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "Edit",
        "description": "# Edit\n\nPerforms exact string replacements in files. \n\nUsage:\n- You must use your `Read` tool at least once in the conversation before editing. This tool will error if you attempt an edit without reading the file. \n- When editing text from Read tool output, ensure you preserve the exact indentation (tabs/spaces) as it appears AFTER the line number prefix. The line number prefix format is: spaces + line number + tab. Everything after that tab is the actual file content to match. Never include any part of the line number prefix in the old_string or new_string.\n- ALWAYS prefer editing existing files in the codebase. NEVER write new files unless explicitly required.\n- Only use emojis if the user explicitly requests it. Avoid adding emojis to files unless asked.\n- The edit will FAIL if `old_string` is not unique in the file. Either provide a larger string with more surrounding context to make it unique or use `replace_all` to change every instance of `old_string`. \n- Use `replace_all` for replacing and renaming strings across the file. This parameter is useful if you want to rename a variable for instance.",
        "parameters": {
          "type": "object",
          "properties": {
            "file_path": {
              "type": "string",
              "description": "The absolute path to the file to modify"
            },
            "old_string": {
              "type": "string",
              "description": "The text to replace"
            },
            "new_string": {
              "type": "string",
              "description": "The text to replace it with (must be different from old_string)"
            },
            "replace_all": {
              "type": "boolean",
              "default": false,
              "description": "Replace all occurences of old_string (default false)"
            }
          },
          "required": [
            "file_path",
            "old_string",
            "new_string"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-3",
      "tool_type": "custom",
      "description": "Use this tool when you are in plan mode and have finished presenting your plan and are ready to code. This will prompt the user to exit plan mode.\nIMPORTANT: Only use this tool when the task requires planning the implementation steps of a task that requires writing code. For research tasks where you're gathering information, searching files, reading files or in general trying to understand the codebase - do NOT use this tool.\n\n## Handling Ambiguity in Plans\nBefore using this tool, ensure your plan is clear and unambiguous. If there are multiple valid approaches or unclear requirements:\n1. Use the AskUserQuestion tool to clarify with the user\n2. Ask about specific implementation choices (e.g., architectural patterns, which library to use)\n3. Clarify any assumptions that could affect the implementation\n4. Only proceed with ExitPlanMode after resolving ambiguities\n\n\n## Examples\n\n1. Initial task: \"Search for and understand the implementation of vim mode in the codebase\" - Do not use the exit plan mode tool because you are not planning the implementation steps of a task.\n2. Initial task: \"Help me implement yank mode for vim\" - Use the exit plan mode tool after you have finished planning the implementation steps of the task.\n3. Initial task: \"Add a new feature to handle user authentication\" - If unsure about auth method (OAuth, JWT, etc.), use AskUserQuestion first, then use exit plan mode tool after clarifying the approach.",
      "source_type": "json",
      "name": "ExitPlanMode",
      "tags": [],
      "source_code": "def ExitPlanMode(plan):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "ExitPlanMode",
        "description": "Use this tool when you are in plan mode and have finished presenting your plan and are ready to code. This will prompt the user to exit plan mode.\nIMPORTANT: Only use this tool when the task requires planning the implementation steps of a task that requires writing code. For research tasks where you're gathering information, searching files, reading files or in general trying to understand the codebase - do NOT use this tool.\n\n## Handling Ambiguity in Plans\nBefore using this tool, ensure your plan is clear and unambiguous. If there are multiple valid approaches or unclear requirements:\n1. Use the AskUserQuestion tool to clarify with the user\n2. Ask about specific implementation choices (e.g., architectural patterns, which library to use)\n3. Clarify any assumptions that could affect the implementation\n4. Only proceed with ExitPlanMode after resolving ambiguities\n\n\n## Examples\n\n1. Initial task: \"Search for and understand the implementation of vim mode in the codebase\" - Do not use the exit plan mode tool because you are not planning the implementation steps of a task.\n2. Initial task: \"Help me implement yank mode for vim\" - Use the exit plan mode tool after you have finished planning the implementation steps of the task.\n3. Initial task: \"Add a new feature to handle user authentication\" - If unsure about auth method (OAuth, JWT, etc.), use AskUserQuestion first, then use exit plan mode tool after clarifying the approach.",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "type": "object",
          "properties": {
            "plan": {
              "type": "string"
            }
          },
          "required": [
            "plan"
          ],
          "additionalProperties": false
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-14",
      "tool_type": "custom",
      "description": "# Glob\n\n- Fast file pattern matching tool that works with any codebase size\n- Supports glob patterns like \"**/*.js\" or \"src/**/*.ts\"\n- Returns matching file paths sorted by modification time\n- Use this tool when you need to find files by name patterns\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the Agent tool instead\n- You have the capability to call multiple tools in a single response. It is always better to speculatively perform multiple searches as a batch that are potentially useful.",
      "source_type": "json",
      "name": "Glob",
      "tags": [],
      "source_code": "def Glob(pattern, path=None):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "Glob",
        "description": "# Glob\n\n- Fast file pattern matching tool that works with any codebase size\n- Supports glob patterns like \"**/*.js\" or \"src/**/*.ts\"\n- Returns matching file paths sorted by modification time\n- Use this tool when you need to find files by name patterns\n- When you are doing an open ended search that may require multiple rounds of globbing and grepping, use the Agent tool instead\n- You have the capability to call multiple tools in a single response. It is always better to speculatively perform multiple searches as a batch that are potentially useful.\n- If more than 2,000 files match the pattern, only the first 2,000 will be returned",
        "parameters": {
          "type": "object",
          "properties": {
            "pattern": {
              "type": "string",
              "description": "The glob pattern to match files against"
            },
            "path": {
              "type": "string",
              "description": "The directory to search in. If not specified, the current working directory will be used. IMPORTANT: Omit this field to use the default directory. DO NOT enter \"undefined\" or \"null\" - simply omit it for the default behavior. Must be a valid directory path if provided."
            }
          },
          "required": [
            "pattern"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-2",
      "tool_type": "custom",
      "description": "# Grep\n\nA powerful search tool built on ripgrep\n\n  Usage:\n  - ALWAYS use Grep for search tasks. NEVER invoke `grep` or `rg` as a Bash command. The Grep tool has been optimized for correct permissions and access.\n  - Supports full regex syntax (e.g., \"log.*Error\", \"function\\s+\\w+\")\n  - Filter files with glob parameter (e.g., \"*.js\", \"**/*.tsx\") or type parameter (e.g., \"js\", \"py\", \"rust\")\n  - Output modes: \"content\" shows matching lines, \"files_with_matches\" shows only file paths (default), \"count\" shows match counts\n  - Use Task tool for open-ended searches requiring multiple rounds\n  - Pattern syntax: Uses ripgrep (not grep) - literal braces need escaping (use `interface\\{\\}` to find `interface{}` in Go code)\n  - Multiline matching: By default patterns match within single lines only. For cross-line patterns like `struct \\{[\\s\\S]*?field`, use `multiline: true`",
      "source_type": "json",
      "name": "Grep",
      "tags": [],
      "source_code": "def Grep(pattern, path=None, glob=None, output_mode=None, -B=None, -A=None, -C=None, -n=None, -i=None, type=None, head_limit=None, multiline=None):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "Grep",
        "description": "# Grep\n\nA powerful search tool built on ripgrep\n\n  Usage:\n  - ALWAYS use Grep for search tasks. NEVER invoke `grep` or `rg` as a Bash command. The Grep tool has been optimized for correct permissions and access.\n  - Supports full regex syntax (e.g., \"log.*Error\", \"function\\s+\\w+\")\n  - Filter files with glob parameter (e.g., \"*.js\", \"**/*.tsx\") or type parameter (e.g., \"js\", \"py\", \"rust\")\n  - Output modes: \"content\" shows matching lines, \"files_with_matches\" shows only file paths (default), \"count\" shows match counts\n  - Use Task tool for open-ended searches requiring multiple rounds\n  - Pattern syntax: Uses ripgrep (not grep) - literal braces need escaping (use `interface\\{\\}` to find `interface{}` in Go code)\n  - Multiline matching: By default patterns match within single lines only. For cross-line patterns like `struct \\{[\\s\\S]*?field`, use `multiline: true`\n  - If the output exceeds 10,000 characters, it will be truncated before being returned to you",
        "parameters": {
          "type": "object",
          "properties": {
            "pattern": {
              "type": "string",
              "description": "The regular expression pattern to search for in file contents"
            },
            "path": {
              "type": "string",
              "description": "File or directory to search in (rg PATH). Defaults to current working directory."
            },
            "glob": {
              "type": "string",
              "description": "Glob pattern to filter files (e.g. \"*.js\", \"*.{ts,tsx}\") - maps to rg --glob"
            },
            "output_mode": {
              "type": "string",
              "enum": [
                "content",
                "files_with_matches",
                "count"
              ],
              "description": "Output mode: \"content\" shows matching lines (supports -A/-B/-C context, -n line numbers, head_limit), \"files_with_matches\" shows file paths (supports head_limit), \"count\" shows match counts (supports head_limit). Defaults to \"files_with_matches\"."
            },
            "-B": {
              "type": "number",
              "description": "Number of lines to show before each match (rg -B). Requires output_mode: \"content\", ignored otherwise."
            },
            "-A": {
              "type": "number",
              "description": "Number of lines to show after each match (rg -A). Requires output_mode: \"content\", ignored otherwise."
            },
            "-C": {
              "type": "number",
              "description": "Number of lines to show before and after each match (rg -C). Requires output_mode: \"content\", ignored otherwise."
            },
            "-n": {
              "type": "boolean",
              "description": "Show line numbers in output (rg -n). Requires output_mode: \"content\", ignored otherwise."
            },
            "-i": {
              "type": "boolean",
              "description": "Case insensitive search (rg -i)"
            },
            "type": {
              "type": "string",
              "description": "File type to search (rg --type). Common types: js, py, rust, go, java, etc. More efficient than include for standard file types."
            },
            "head_limit": {
              "type": "number",
              "description": "Limit output to first N lines/entries, equivalent to \"| head -N\". Works across all output modes: content (limits output lines), files_with_matches (limits file paths), count (limits count entries). When unspecified, shows all results from ripgrep."
            },
            "multiline": {
              "type": "boolean",
              "description": "Enable multiline mode where . matches newlines and patterns can span lines (rg -U --multiline-dotall). Default: false."
            }
          },
          "required": [
            "pattern"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-4",
      "tool_type": "custom",
      "description": "# KillBash\n\n- Kills a running background bash shell by its ID\n- Takes a shell_id parameter identifying the shell to kill\n- Returns a success or failure status \n- Use this tool when you need to terminate a long-running shell\n- Shell IDs can be found using the /bashes command",
      "source_type": "json",
      "name": "KillBash",
      "tags": [],
      "source_code": "def KillBash(shell_id):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "KillBash",
        "description": "# KillBash\n\n- Kills a running background bash shell by its ID\n- Takes a shell_id parameter identifying the shell to kill\n- Returns a success or failure status \n- Use this tool when you need to terminate a long-running shell\n- Shell IDs can be found using the /bashes command",
        "parameters": {
          "type": "object",
          "properties": {
            "shell_id": {
              "type": "string",
              "description": "The ID of the shell to terminate"
            }
          },
          "required": [
            "shell_id"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-12",
      "tool_type": "custom",
      "description": "# LS\n\nLists files and directories in a given path. The path parameter must be an absolute path, not a relative path. You can optionally provide an array of glob patterns to ignore with the ignore parameter. You should generally prefer the Glob and Grep tools, if you know which directories to search.",
      "source_type": "json",
      "name": "LS",
      "tags": [],
      "source_code": "def LS(path, ignore=None):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "LS",
        "description": "# LS\n\nLists files and directories in a given path. The path parameter must be an absolute path, not a relative path. You can optionally provide an array of glob patterns to ignore with the ignore parameter. You should generally prefer the Glob and Grep tools, if you know which directories to search.\n\nIf a directory has more than 1,000 entries, only the first 1,000 will be shown.",
        "parameters": {
          "type": "object",
          "properties": {
            "path": {
              "type": "string",
              "description": "The directory to list"
            },
            "ignore": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Optional list of glob patterns to ignore (e.g. ['node_modules', '*.log'])"
            }
          },
          "required": [
            "path"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-6",
      "tool_type": "custom",
      "description": "# MultiEdit\n\nThis is a tool for making multiple edits to a single file in one operation. It is built on top of the Edit tool and allows you to perform multiple find-and-replace operations efficiently. Prefer this tool over the Edit tool when you need to make multiple edits to the same file.\n\nBefore using this tool:\n\n1. Use the Read tool to understand the file's contents and context\n2. Verify the directory path is correct\n\nTo make multiple file edits, provide the following:\n1. file_path: The absolute path to the file to modify (must be absolute, not relative)\n2. edits: An array of edit operations to perform, where each edit contains:\n   - old_string: The text to replace (must match the file contents exactly, including all whitespace and indentation)\n   - new_string: The edited text to replace the old_string\n   - replace_all: Replace all occurences of old_string. This parameter is optional and defaults to false.\n\nIMPORTANT:\n- All edits are applied in sequence, in the order they are provided\n- Each edit operates on the result of the previous edit\n- All edits must be valid for the operation to succeed - if any edit fails, none will be applied\n- This tool is ideal when you need to make several changes to different parts of the same file\n- For Jupyter notebooks (.ipynb files), use the NotebookEdit instead\n\nCRITICAL REQUIREMENTS:\n1. All edits follow the same requirements as the single Edit tool\n2. The edits are atomic - either all succeed or none are applied\n3. Plan your edits carefully to avoid conflicts between sequential operations\n\nWARNING:\n- The tool will fail if edits.old_string doesn't match the file contents exactly (including whitespace)\n- The tool will fail if edits.old_string and edits.new_string are the same\n- Since edits are applied in sequence, ensure that earlier edits don't affect the text that later edits are trying to find\n\nWhen making edits:\n- Ensure all edits result in idiomatic, correct code\n- Do not leave the code in a broken state\n- Always use absolute file paths (starting with /)\n- Only use emojis if the user explicitly requests it. Avoid adding emojis to files unless asked.\n- Use replace_all for replacing and renaming strings across the file. This parameter is useful if you want to rename a variable for instance.\n\nIf you want to create a new file, use:\n- A new file path, including dir name if needed\n- First edit: empty old_string and the new file's contents as new_string\n- Subsequent edits: normal edit operations on the created content",
      "source_type": "json",
      "name": "MultiEdit",
      "tags": [],
      "source_code": "def MultiEdit(file_path, edits):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "MultiEdit",
        "description": "# MultiEdit\n\nThis is a tool for making multiple edits to a single file in one operation. It is built on top of the Edit tool and allows you to perform multiple find-and-replace operations efficiently. Prefer this tool over the Edit tool when you need to make multiple edits to the same file.\n\nBefore using this tool:\n\n1. Use the Read tool to understand the file's contents and context\n2. Verify the directory path is correct\n\nTo make multiple file edits, provide the following:\n1. file_path: The absolute path to the file to modify (must be absolute, not relative)\n2. edits: An array of edit operations to perform, where each edit contains:\n   - old_string: The text to replace (must match the file contents exactly, including all whitespace and indentation)\n   - new_string: The edited text to replace the old_string\n   - replace_all: Replace all occurences of old_string. This parameter is optional and defaults to false.\n\nIMPORTANT:\n- All edits are applied in sequence, in the order they are provided\n- Each edit operates on the result of the previous edit\n- All edits must be valid for the operation to succeed - if any edit fails, none will be applied\n- This tool is ideal when you need to make several changes to different parts of the same file\n- For Jupyter notebooks (.ipynb files), use the NotebookEdit instead\n\nCRITICAL REQUIREMENTS:\n1. All edits follow the same requirements as the single Edit tool\n2. The edits are atomic - either all succeed or none are applied\n3. Plan your edits carefully to avoid conflicts between sequential operations\n\nWARNING:\n- The tool will fail if edits.old_string doesn't match the file contents exactly (including whitespace)\n- The tool will fail if edits.old_string and edits.new_string are the same\n- Since edits are applied in sequence, ensure that earlier edits don't affect the text that later edits are trying to find\n\nWhen making edits:\n- Ensure all edits result in idiomatic, correct code\n- Do not leave the code in a broken state\n- Always use absolute file paths (starting with /)\n- Only use emojis if the user explicitly requests it. Avoid adding emojis to files unless asked.\n- Use replace_all for replacing and renaming strings across the file. This parameter is useful if you want to rename a variable for instance.\n\nIf you want to create a new file, use:\n- A new file path, including dir name if needed\n- First edit: empty old_string and the new file's contents as new_string\n- Subsequent edits: normal edit operations on the created content",
        "parameters": {
          "type": "object",
          "properties": {
            "file_path": {
              "type": "string",
              "description": "The absolute path to the file to modify"
            },
            "edits": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "old_string": {
                    "type": "string",
                    "description": "The text to replace"
                  },
                  "new_string": {
                    "type": "string",
                    "description": "The text to replace it with"
                  },
                  "replace_all": {
                    "type": "boolean",
                    "default": false,
                    "description": "Replace all occurences of old_string (default false)."
                  }
                },
                "required": [
                  "old_string",
                  "new_string"
                ],
                "additionalProperties": false
              },
              "minItems": 1,
              "description": "Array of edit operations to perform sequentially on the file"
            }
          },
          "required": [
            "file_path",
            "edits"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-0",
      "tool_type": "custom",
      "description": "# Read\n\nReads a file from the local filesystem. You can access any file directly by using this tool.\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\n\nUsage:\n- The file_path parameter must be an absolute path, not a relative path\n- By default, it reads up to 2000 lines starting from the beginning of the file\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\n- Any lines longer than 2000 characters will be truncated\n- Results are returned using cat -n format, with line numbers starting at 1\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful. \n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.",
      "source_type": "json",
      "name": "Read",
      "tags": [],
      "source_code": "def Read(file_path, offset=None, limit=None):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "Read",
        "description": "# Read\n\nReads a file from the local filesystem. You can access any file directly by using this tool.\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\n\nUsage:\n- The file_path parameter must be an absolute path, not a relative path\n- By default, it reads up to 2000 lines starting from the beginning of the file\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\n- Any lines longer than 2000 characters will be truncated\n- Results are returned using cat -n format, with line numbers starting at 1\n- This tool allows Claude Code to read images (eg PNG, JPG, etc). When reading an image file the contents are presented visually as Claude Code is a multimodal LLM.\n- For Jupyter notebooks (.ipynb files), use the NotebookRead instead\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful. \n- You will regularly be asked to read screenshots. If the user provides a path to a screenshot ALWAYS use this tool to view the file at the path. This tool will work with all temporary file paths like /var/folders/123/abc/T/TemporaryItems/NSIRD_screencaptureui_ZfB1tD/Screenshot.png\n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.",
        "parameters": {
          "type": "object",
          "properties": {
            "file_path": {
              "type": "string",
              "description": "The absolute path to the file to read"
            },
            "offset": {
              "type": "number",
              "description": "The line number to start reading from. Only provide if the file is too large to read at once"
            },
            "limit": {
              "type": "number",
              "description": "The number of lines to read. Only provide if the file is too large to read at once."
            }
          },
          "required": [
            "file_path"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-10",
      "tool_type": "custom",
      "description": "# TodoWrite\n\nUse this tool to create and manage a structured task list for your current coding session. This helps you track progress, organize complex tasks, and demonstrate thoroughness to the user.\nIt also helps the user understand the progress of the task and overall progress of their requests.\n\n## When to Use This Tool\nUse this tool proactively in these scenarios:\n\n1. Complex multi-step tasks - When a task requires 3 or more distinct steps or actions\n2. Non-trivial and complex tasks - Tasks that require careful planning or multiple operations\n3. User explicitly requests todo list - When the user directly asks you to use the todo list\n4. User provides multiple tasks - When users provide a list of things to be done (numbered or comma-separated)\n5. After receiving new instructions - Immediately capture user requirements as todos\n6. When you start working on a task - Mark it as in_progress BEFORE beginning work. Ideally you should only have one todo as in_progress at a time\n7. After completing a task - Mark it as completed and add any new follow-up tasks discovered during implementation\n\n## When NOT to Use This Tool\n\nSkip using this tool when:\n1. There is only a single, straightforward task\n2. The task is trivial and tracking it provides no organizational benefit\n3. The task can be completed in less than 3 trivial steps\n4. The task is purely conversational or informational\n\nNOTE that you should not use this tool if there is only one trivial task to do. In this case you are better off just doing the task directly.\n\n## Examples of When to Use the Todo List\n\n<example>\nUser: I want to add a dark mode toggle to the application settings. Make sure you run the tests and build when you're done!\nAssistant: I'll help add a dark mode toggle to your application settings. Let me create a todo list to track this implementation.\n*Creates todo list with the following items:*\n1. Create dark mode toggle component in Settings page\n2. Add dark mode state management (context/store)\n3. Implement CSS-in-JS styles for dark theme\n4. Update existing components to support theme switching\n5. Run tests and build process, addressing any failures or errors that occur\n*Begins working on the first task*\n\n<reasoning>\nThe assistant used the todo list because:\n1. Adding dark mode is a multi-step feature requiring UI, state management, and styling changes\n2. The user explicitly requested tests and build be run afterward\n3. The assistant inferred that tests and build need to pass by adding \"Ensure tests and build succeed\" as the final task\n</reasoning>\n</example>\n\n<example>\nUser: Help me rename the function getCwd to getCurrentWorkingDirectory across my project\nAssistant: Let me first search through your codebase to find all occurrences of 'getCwd'.\n*Uses grep or search tools to locate all instances of getCwd in the codebase*\nAssistant: I've found 15 instances of 'getCwd' across 8 different files. Let me create a todo list to track these changes.\n*Creates todo list with specific items for each file that needs updating*\n\n<reasoning>\nThe assistant used the todo list because:\n1. First, the assistant searched to understand the scope of the task\n2. Upon finding multiple occurrences across different files, it determined this was a complex task with multiple steps\n3. The todo list helps ensure every instance is tracked and updated systematically\n4. This approach prevents missing any occurrences and maintains code consistency\n</reasoning>\n</example>\n\n\n<example>\nUser: I need to implement these features for my e-commerce site: user registration, product catalog, shopping cart, and checkout flow.\nAssistant: I'll help implement these features. First, let's add all the features to the todo list.\n*Creates a todo list breaking down each feature into specific tasks based on the project architecture*\nAssistant: Let's start with user registration. This will involve creating database models, API endpoints, and frontend forms that integrate with your existing authentication system.\n\n<reasoning>\nThe assistant used the todo list because:\n1. The user provided multiple complex features to implement in a comma separated list\n2. The todo list helps organize these large features into manageable tasks\n3. This approach allows for tracking progress across the entire implementation\n</reasoning>\n</example>\n\n<example>\nUser: Can you help optimize my React application? It's rendering slowly and has performance issues.</user>\nAssistant: I'll help optimize your React application. First, let me examine your codebase to identify potential performance bottlenecks.\n*Reviews component structure, render patterns, state management, and data fetching*\nAssistant: After analyzing your codebase, I've identified several performance issues. Let me create a todo list to track our optimization efforts.\n*Creates todo list with items like: 1) Implement memoization for expensive calculations in ProductList, 2) Add virtualization for long lists in Dashboard, 3) Optimize image loading in Gallery component, 4) Fix state update loops in ShoppingCart, 5) Review bundle size and implement code splitting*\nLet's start by implementing memoization for the expensive calculations in your ProductList component.</assistant>\n\n<reasoning>\nThe assistant used the todo list because:\n1. First, the assistant examined the codebase to identify specific performance issues\n2. Based on this analysis, it identified multiple optimization opportunities\n3. Performance optimization is a non-trivial task requiring multiple steps\n4. The todo list helps methodically track improvements across different components\n5. This systematic approach ensures all performance bottlenecks are addressed\n</reasoning>\n</example>\n\n## Examples of When NOT to Use the Todo List\n\n<example>\nUser: How do I print 'Hello World' in Python?\nAssistant: In Python, you can print \"Hello World\" with this simple code:\n\npython\nprint(\"Hello World\")\n\nThis will output the text \"Hello World\" to the console when executed.</assistant>\n\n<reasoning>\nThe assistant did not use the todo list because this is a single, trivial task that can be completed in one step. There's no need to track multiple tasks or steps for such a straightforward request.\n</reasoning>\n</example>\n\n<example>\nUser: What does the git status command do?\nAssistant: The git status command shows the current state of your working directory and staging area. It displays which changes have been staged, which haven't, and which files aren't being tracked by Git. This is a fundamental command for understanding the current state of your repository before making commits.\n\n<reasoning>\nThe assistant did not use the todo list because this is an informational request with no actual coding task to complete. The user is simply asking for an explanation, not for the assistant to perform multiple steps or tasks.\n</reasoning>\n</example>\n\n<example>\nUser: Can you add a comment to the calculateTotal function to explain what it does?\nAssistant: Sure, let me add a comment to the calculateTotal function to explain what it does.\n* Uses the Edit tool to add a comment to the calculateTotal function *\n\n<reasoning>\nThe assistant did not use the todo list because this is a single, straightforward task confined to one location in the code. Adding a comment doesn't require tracking multiple steps or systematic organization.\n</reasoning>\n</example>\n\n<example>\nUser: Run npm install for me and tell me what happens.\nAssistant: I'll run the npm install command for you.\n\n*Executes: npm install*\n\nThe command completed successfully. Here's the output:\n[Output of npm install command]\n\nAll dependencies have been installed according to your package.json file.\n\n<reasoning>\nThe assistant did not use the todo list because this is a single command execution with immediate results. There are no multiple steps to track or organize, making the todo list unnecessary for this straightforward task.\n</reasoning>\n</example>\n\n## Task States and Management\n\n1. **Task States**: Use these states to track progress:\n   - pending: Task not yet started\n   - in_progress: Currently working on (limit to ONE task at a time)\n   - completed: Task finished successfully\n\n2. **Task Management**:\n   - Update task status in real-time as you work\n   - Mark tasks complete IMMEDIATELY after finishing (don't batch completions)\n   - Only have ONE task in_progress at any time\n   - Complete current tasks before starting new ones\n   - Remove tasks that are no longer relevant from the list entirely\n\n3. **Task Completion Requirements**:\n   - ONLY mark a task as completed when you have FULLY accomplished it\n   - If you encounter errors, blockers, or cannot finish, keep the task as in_progress\n   - When blocked, create a new task describing what needs to be resolved\n   - Never mark a task as completed if:\n     - Tests are failing\n     - Implementation is partial\n     - You encountered unresolved errors\n     - You couldn't find necessary files or dependencies\n\n4. **Task Breakdown**:\n   - Create specific, actionable items\n   - Break complex tasks into smaller, manageable steps\n   - Use clear, descriptive task names\n\nWhen in doubt, use this tool. Being proactive with task management demonstrates attentiveness and ensures you complete all requirements successfully.",
      "source_type": "json",
      "name": "TodoWrite",
      "tags": [],
      "source_code": "def TodoWrite(todos):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "TodoWrite",
        "description": "# TodoWrite\n\nUse this tool to create and manage a structured task list for your current coding session. This helps you track progress, organize complex tasks, and demonstrate thoroughness to the user.\nIt also helps the user understand the progress of the task and overall progress of their requests.\n\n## When to Use This Tool\nUse this tool proactively in these scenarios:\n\n1. Complex multi-step tasks - When a task requires 3 or more distinct steps or actions\n2. Non-trivial and complex tasks - Tasks that require careful planning or multiple operations\n3. User explicitly requests todo list - When the user directly asks you to use the todo list\n4. User provides multiple tasks - When users provide a list of things to be done (numbered or comma-separated)\n5. After receiving new instructions - Immediately capture user requirements as todos\n6. When you start working on a task - Mark it as in_progress BEFORE beginning work. Ideally you should only have one todo as in_progress at a time\n7. After completing a task - Mark it as completed and add any new follow-up tasks discovered during implementation\n\n## When NOT to Use This Tool\n\nSkip using this tool when:\n1. There is only a single, straightforward task\n2. The task is trivial and tracking it provides no organizational benefit\n3. The task can be completed in less than 3 trivial steps\n4. The task is purely conversational or informational\n\nNOTE that you should not use this tool if there is only one trivial task to do. In this case you are better off just doing the task directly.\n\n## Examples of When to Use the Todo List\n\n<example>\nUser: I want to add a dark mode toggle to the application settings. Make sure you run the tests and build when you're done!\nAssistant: I'll help add a dark mode toggle to your application settings. Let me create a todo list to track this implementation.\n*Creates todo list with the following items:*\n1. Create dark mode toggle component in Settings page\n2. Add dark mode state management (context/store)\n3. Implement CSS-in-JS styles for dark theme\n4. Update existing components to support theme switching\n5. Run tests and build process, addressing any failures or errors that occur\n*Begins working on the first task*\n\n<reasoning>\nThe assistant used the todo list because:\n1. Adding dark mode is a multi-step feature requiring UI, state management, and styling changes\n2. The user explicitly requested tests and build be run afterward\n3. The assistant inferred that tests and build need to pass by adding \"Ensure tests and build succeed\" as the final task\n</reasoning>\n</example>\n\n<example>\nUser: Help me rename the function getCwd to getCurrentWorkingDirectory across my project\nAssistant: Let me first search through your codebase to find all occurrences of 'getCwd'.\n*Uses grep or search tools to locate all instances of getCwd in the codebase*\nAssistant: I've found 15 instances of 'getCwd' across 8 different files. Let me create a todo list to track these changes.\n*Creates todo list with specific items for each file that needs updating*\n\n<reasoning>\nThe assistant used the todo list because:\n1. First, the assistant searched to understand the scope of the task\n2. Upon finding multiple occurrences across different files, it determined this was a complex task with multiple steps\n3. The todo list helps ensure every instance is tracked and updated systematically\n4. This approach prevents missing any occurrences and maintains code consistency\n</reasoning>\n</example>\n\n\n<example>\nUser: I need to implement these features for my e-commerce site: user registration, product catalog, shopping cart, and checkout flow.\nAssistant: I'll help implement these features. First, let's add all the features to the todo list.\n*Creates a todo list breaking down each feature into specific tasks based on the project architecture*\nAssistant: Let's start with user registration. This will involve creating database models, API endpoints, and frontend forms that integrate with your existing authentication system.\n\n<reasoning>\nThe assistant used the todo list because:\n1. The user provided multiple complex features to implement in a comma separated list\n2. The todo list helps organize these large features into manageable tasks\n3. This approach allows for tracking progress across the entire implementation\n</reasoning>\n</example>\n\n<example>\nUser: Can you help optimize my React application? It's rendering slowly and has performance issues.</user>\nAssistant: I'll help optimize your React application. First, let me examine your codebase to identify potential performance bottlenecks.\n*Reviews component structure, render patterns, state management, and data fetching*\nAssistant: After analyzing your codebase, I've identified several performance issues. Let me create a todo list to track our optimization efforts.\n*Creates todo list with items like: 1) Implement memoization for expensive calculations in ProductList, 2) Add virtualization for long lists in Dashboard, 3) Optimize image loading in Gallery component, 4) Fix state update loops in ShoppingCart, 5) Review bundle size and implement code splitting*\nLet's start by implementing memoization for the expensive calculations in your ProductList component.</assistant>\n\n<reasoning>\nThe assistant used the todo list because:\n1. First, the assistant examined the codebase to identify specific performance issues\n2. Based on this analysis, it identified multiple optimization opportunities\n3. Performance optimization is a non-trivial task requiring multiple steps\n4. The todo list helps methodically track improvements across different components\n5. This systematic approach ensures all performance bottlenecks are addressed\n</reasoning>\n</example>\n\n## Examples of When NOT to Use the Todo List\n\n<example>\nUser: How do I print 'Hello World' in Python?\nAssistant: In Python, you can print \"Hello World\" with this simple code:\n\npython\nprint(\"Hello World\")\n\nThis will output the text \"Hello World\" to the console when executed.</assistant>\n\n<reasoning>\nThe assistant did not use the todo list because this is a single, trivial task that can be completed in one step. There's no need to track multiple tasks or steps for such a straightforward request.\n</reasoning>\n</example>\n\n<example>\nUser: What does the git status command do?\nAssistant: The git status command shows the current state of your working directory and staging area. It displays which changes have been staged, which haven't, and which files aren't being tracked by Git. This is a fundamental command for understanding the current state of your repository before making commits.\n\n<reasoning>\nThe assistant did not use the todo list because this is an informational request with no actual coding task to complete. The user is simply asking for an explanation, not for the assistant to perform multiple steps or tasks.\n</reasoning>\n</example>\n\n<example>\nUser: Can you add a comment to the calculateTotal function to explain what it does?\nAssistant: Sure, let me add a comment to the calculateTotal function to explain what it does.\n* Uses the Edit tool to add a comment to the calculateTotal function *\n\n<reasoning>\nThe assistant did not use the todo list because this is a single, straightforward task confined to one location in the code. Adding a comment doesn't require tracking multiple steps or systematic organization.\n</reasoning>\n</example>\n\n<example>\nUser: Run npm install for me and tell me what happens.\nAssistant: I'll run the npm install command for you.\n\n*Executes: npm install*\n\nThe command completed successfully. Here's the output:\n[Output of npm install command]\n\nAll dependencies have been installed according to your package.json file.\n\n<reasoning>\nThe assistant did not use the todo list because this is a single command execution with immediate results. There are no multiple steps to track or organize, making the todo list unnecessary for this straightforward task.\n</reasoning>\n</example>\n\n## Task States and Management\n\n1. **Task States**: Use these states to track progress:\n   - pending: Task not yet started\n   - in_progress: Currently working on (limit to ONE task at a time)\n   - completed: Task finished successfully\n\n2. **Task Management**:\n   - Update task status in real-time as you work\n   - Mark tasks complete IMMEDIATELY after finishing (don't batch completions)\n   - Only have ONE task in_progress at any time\n   - Complete current tasks before starting new ones\n   - Remove tasks that are no longer relevant from the list entirely\n\n3. **Task Completion Requirements**:\n   - ONLY mark a task as completed when you have FULLY accomplished it\n   - If you encounter errors, blockers, or cannot finish, keep the task as in_progress\n   - When blocked, create a new task describing what needs to be resolved\n   - Never mark a task as completed if:\n     - Tests are failing\n     - Implementation is partial\n     - You encountered unresolved errors\n     - You couldn't find necessary files or dependencies\n\n4. **Task Breakdown**:\n   - Create specific, actionable items\n   - Break complex tasks into smaller, manageable steps\n   - Use clear, descriptive task names\n\nWhen in doubt, use this tool. Being proactive with task management demonstrates attentiveness and ensures you complete all requirements successfully.",
        "parameters": {
          "type": "object",
          "properties": {
            "todos": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "content": {
                    "type": "string",
                    "minLength": 1
                  },
                  "status": {
                    "type": "string",
                    "enum": [
                      "pending",
                      "in_progress",
                      "completed"
                    ]
                  },
                  "priority": {
                    "type": "string",
                    "enum": [
                      "high",
                      "medium",
                      "low"
                    ]
                  },
                  "id": {
                    "type": "string"
                  }
                },
                "required": [
                  "content",
                  "status",
                  "id"
                ],
                "additionalProperties": false
              },
              "description": "The updated todo list"
            }
          },
          "required": [
            "todos"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-7",
      "tool_type": "custom",
      "description": "# Write\n\nWrites a file to the local filesystem.\n\nUsage:\n- This tool will overwrite the existing file if there is one at the provided path.\n- If this is an existing file, you MUST use the Read tool first to read the file's contents. This tool will fail if you did not read the file first.\n- ALWAYS prefer editing existing files in the codebase. NEVER write new files unless explicitly required.\n- NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.\n- Only use emojis if the user explicitly requests it. Avoid writing emojis to files unless asked.",
      "source_type": "json",
      "name": "Write",
      "tags": [],
      "source_code": "def Write(file_path, content):\n    \"\"\"Stub method. This tool is executed client-side via the approval flow.\n    \"\"\"\n    raise Exception(\"This is a stub tool. Execution should happen on client.\")  \n",
      "json_schema": {
        "name": "Write",
        "description": "# Write\n\nWrites a file to the local filesystem.\n\nUsage:\n- This tool will overwrite the existing file if there is one at the provided path.\n- If this is an existing file, you MUST use the Read tool first to read the file's contents. This tool will fail if you did not read the file first.\n- ALWAYS prefer editing existing files in the codebase. NEVER write new files unless explicitly required.\n- NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.\n- Only use emojis if the user explicitly requests it. Avoid writing emojis to files unless asked.",
        "parameters": {
          "type": "object",
          "properties": {
            "file_path": {
              "type": "string",
              "description": "The absolute path to the file to write (must be absolute, not relative)"
            },
            "content": {
              "type": "string",
              "description": "The content to write to the file"
            }
          },
          "required": [
            "file_path",
            "content"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": true,
      "enable_parallel_execution": false,
      "created_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "last_updated_by_id": "user-86204822-c51d-4308-bad9-9a7031ede63d",
      "metadata_": {}
    },
    {
      "id": "tool-11",
      "tool_type": "letta_core",
      "description": "Search prior conversation history using hybrid search (text + semantic similarity).\n\nExamples:\n        # Search all messages\n        conversation_search(query=\"project updates\")\n\n        # Search only assistant messages\n        conversation_search(query=\"error handling\", roles=[\"assistant\"])\n\n        # Search with date range (inclusive of both dates)\n        conversation_search(query=\"meetings\", start_date=\"2024-01-15\", end_date=\"2024-01-20\")\n        # This includes all messages from Jan 15 00:00:00 through Jan 20 23:59:59\n\n        # Search messages from a specific day (inclusive)\n        conversation_search(query=\"bug reports\", start_date=\"2024-09-04\", end_date=\"2024-09-04\")\n        # This includes ALL messages from September 4, 2024\n\n        # Search with specific time boundaries\n        conversation_search(query=\"deployment\", start_date=\"2024-01-15T09:00\", end_date=\"2024-01-15T17:30\")\n        # This includes messages from 9 AM to 5:30 PM on Jan 15\n\n        # Search with limit\n        conversation_search(query=\"debugging\", limit=10)\n\n    Returns:\n        str: Query result string containing matching messages with timestamps and content.",
      "source_type": "python",
      "name": "conversation_search",
      "tags": [
        "letta_core"
      ],
      "source_code": null,
      "json_schema": {
        "name": "conversation_search",
        "description": "Search prior conversation history using hybrid search (text + semantic similarity).\n\nExamples:\n        # Search all messages\n        conversation_search(query=\"project updates\")\n\n        # Search only assistant messages\n        conversation_search(query=\"error handling\", roles=[\"assistant\"])\n\n        # Search with date range (inclusive of both dates)\n        conversation_search(query=\"meetings\", start_date=\"2024-01-15\", end_date=\"2024-01-20\")\n        # This includes all messages from Jan 15 00:00:00 through Jan 20 23:59:59\n\n        # Search messages from a specific day (inclusive)\n        conversation_search(query=\"bug reports\", start_date=\"2024-09-04\", end_date=\"2024-09-04\")\n        # This includes ALL messages from September 4, 2024\n\n        # Search with specific time boundaries\n        conversation_search(query=\"deployment\", start_date=\"2024-01-15T09:00\", end_date=\"2024-01-15T17:30\")\n        # This includes messages from 9 AM to 5:30 PM on Jan 15\n\n        # Search with limit\n        conversation_search(query=\"debugging\", limit=10)\n\n    Returns:\n        str: Query result string containing matching messages with timestamps and content.",
        "parameters": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "String to search for using both text matching and semantic similarity."
            },
            "roles": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "assistant",
                  "user",
                  "tool"
                ]
              },
              "description": "Optional list of message roles to filter by."
            },
            "limit": {
              "type": "integer",
              "description": "Maximum number of results to return. Uses system default if not specified."
            },
            "start_date": {
              "type": "string",
              "description": "Filter results to messages created on or after this date (INCLUSIVE). When using date-only format (e.g., \"2024-01-15\"), includes messages starting from 00:00:00 of that day. ISO 8601 format: \"YYYY-MM-DD\" or \"YYYY-MM-DDTHH:MM\". Examples: \"2024-01-15\" (from start of Jan 15), \"2024-01-15T14:30\" (from 2:30 PM on Jan 15)."
            },
            "end_date": {
              "type": "string",
              "description": "Filter results to messages created on or before this date (INCLUSIVE). When using date-only format (e.g., \"2024-01-20\"), includes all messages from that entire day. ISO 8601 format: \"YYYY-MM-DD\" or \"YYYY-MM-DDTHH:MM\". Examples: \"2024-01-20\" (includes all of Jan 20), \"2024-01-20T17:00\" (up to 5 PM on Jan 20)."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": null,
      "enable_parallel_execution": true,
      "created_by_id": "user-b97fa8da-5324-4636-aaa1-9a0873f73eb4",
      "last_updated_by_id": "user-2bd32df4-3b81-44c8-a4d5-ce87a56f0906",
      "metadata_": {}
    },
    {
      "id": "tool-9",
      "tool_type": "letta_builtin",
      "description": "Fetch a webpage and convert it to markdown/text format using Jina AI reader.",
      "source_type": "python",
      "name": "fetch_webpage",
      "tags": [
        "letta_builtin"
      ],
      "source_code": null,
      "json_schema": {
        "name": "fetch_webpage",
        "description": "Fetch a webpage and convert it to markdown/text format using Jina AI reader.",
        "parameters": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL of the webpage to fetch and convert"
            }
          },
          "required": [
            "url"
          ]
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": null,
      "enable_parallel_execution": true,
      "created_by_id": "user-b97fa8da-5324-4636-aaa1-9a0873f73eb4",
      "last_updated_by_id": "user-2bd32df4-3b81-44c8-a4d5-ce87a56f0906",
      "metadata_": {}
    },
    {
      "id": "tool-5",
      "tool_type": "letta_memory_core",
      "description": "Memory management tool with various sub-commands for memory block operations.\n\nExamples:\n        # Replace text in a memory block\n        memory(agent_state, \"str_replace\", path=\"/memories/user_preferences\", old_str=\"theme: dark\", new_str=\"theme: light\")\n\n        # Insert text at line 5\n        memory(agent_state, \"insert\", path=\"/memories/notes\", insert_line=5, insert_text=\"New note here\")\n\n        # Delete a memory block\n        memory(agent_state, \"delete\", path=\"/memories/old_notes\")\n\n        # Rename a memory block\n        memory(agent_state, \"rename\", old_path=\"/memories/temp\", new_path=\"/memories/permanent\")\n\n        # Update the description of a memory block\n        memory(agent_state, \"rename\", path=\"/memories/temp\", description=\"The user's temporary notes.\")\n\n        # Create a memory block with starting text\n        memory(agent_state, \"create\", path=\"/memories/coding_preferences\", \"description\": \"The user's coding preferences.\", \"file_text\": \"The user seems to add type hints to all of their Python code.\")\n\n        # Create an empty memory block\n        memory(agent_state, \"create\", path=\"/memories/coding_preferences\", \"description\": \"The user's coding preferences.\")",
      "source_type": "python",
      "name": "memory",
      "tags": [
        "letta_memory_core"
      ],
      "source_code": null,
      "json_schema": {
        "name": "memory",
        "description": "Memory management tool with various sub-commands for memory block operations.\n\nExamples:\n        # Replace text in a memory block\n        memory(agent_state, \"str_replace\", path=\"/memories/user_preferences\", old_str=\"theme: dark\", new_str=\"theme: light\")\n\n        # Insert text at line 5\n        memory(agent_state, \"insert\", path=\"/memories/notes\", insert_line=5, insert_text=\"New note here\")\n\n        # Delete a memory block\n        memory(agent_state, \"delete\", path=\"/memories/old_notes\")\n\n        # Rename a memory block\n        memory(agent_state, \"rename\", old_path=\"/memories/temp\", new_path=\"/memories/permanent\")\n\n        # Update the description of a memory block\n        memory(agent_state, \"rename\", path=\"/memories/temp\", description=\"The user's temporary notes.\")\n\n        # Create a memory block with starting text\n        memory(agent_state, \"create\", path=\"/memories/coding_preferences\", \"description\": \"The user's coding preferences.\", \"file_text\": \"The user seems to add type hints to all of their Python code.\")\n\n        # Create an empty memory block\n        memory(agent_state, \"create\", path=\"/memories/coding_preferences\", \"description\": \"The user's coding preferences.\")",
        "parameters": {
          "type": "object",
          "properties": {
            "command": {
              "type": "string",
              "description": "The sub-command to execute. Supported commands:\n- \"create\": Create a new memory block\n- \"str_replace\": Replace text in a memory block\n- \"insert\": Insert text at a specific line in a memory block\n- \"delete\": Delete a memory block\n- \"rename\": Rename a memory block"
            },
            "path": {
              "type": "string",
              "description": "Path to the memory block (for str_replace, insert, delete)"
            },
            "file_text": {
              "type": "string",
              "description": "The value to set in the memory block (for create)"
            },
            "description": {
              "type": "string",
              "description": "The description to set in the memory block (for create, rename)"
            },
            "old_str": {
              "type": "string",
              "description": "Old text to replace (for str_replace)"
            },
            "new_str": {
              "type": "string",
              "description": "New text to replace with (for str_replace)"
            },
            "insert_line": {
              "type": "integer",
              "description": "Line number to insert at (for insert)"
            },
            "insert_text": {
              "type": "string",
              "description": "Text to insert (for insert)"
            },
            "old_path": {
              "type": "string",
              "description": "Old path for rename operation"
            },
            "new_path": {
              "type": "string",
              "description": "New path for rename operation"
            }
          },
          "required": [
            "command"
          ]
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": null,
      "enable_parallel_execution": false,
      "created_by_id": "user-b97fa8da-5324-4636-aaa1-9a0873f73eb4",
      "last_updated_by_id": "user-2bd32df4-3b81-44c8-a4d5-ce87a56f0906",
      "metadata_": {}
    },
    {
      "id": "tool-15",
      "tool_type": "letta_builtin",
      "description": "Search the web using Exa's AI-powered search engine and retrieve relevant content.\n\nExamples:\n    web_search(\"Tesla Q1 2025 earnings report\", num_results=5, category=\"financial report\")\n    web_search(\"Latest research in large language models\", category=\"research paper\", include_domains=[\"arxiv.org\", \"paperswithcode.com\"])\n    web_search(\"Letta API documentation core_memory_append\", num_results=3)\n\n    Args:\n        query (str): The search query to find relevant web content.\n        num_results (int, optional): Number of results to return (1-100). Defaults to 10.\n        category (Optional[Literal], optional): Focus search on specific content types. Defaults to None.\n        include_text (bool, optional): Whether to retrieve full page content. Defaults to False (only returns summary and highlights, since the full text usually will overflow the context window).\n        include_domains (Optional[List[str]], optional): List of domains to include in search results. Defaults to None.\n        exclude_domains (Optional[List[str]], optional): List of domains to exclude from search results. Defaults to None.\n        start_published_date (Optional[str], optional): Only return content published after this date (ISO format). Defaults to None.\n        end_published_date (Optional[str], optional): Only return content published before this date (ISO format). Defaults to None.\n        user_location (Optional[str], optional): Two-letter country code for localized results (e.g., \"US\"). Defaults to None.\n\n    Returns:\n        str: A JSON-encoded string containing search results with title, URL, content, highlights, and summary.",
      "source_type": "python",
      "name": "web_search",
      "tags": [
        "letta_builtin"
      ],
      "source_code": null,
      "json_schema": {
        "name": "web_search",
        "description": "Search the web using Exa's AI-powered search engine and retrieve relevant content.\n\nExamples:\n    web_search(\"Tesla Q1 2025 earnings report\", num_results=5, category=\"financial report\")\n    web_search(\"Latest research in large language models\", category=\"research paper\", include_domains=[\"arxiv.org\", \"paperswithcode.com\"])\n    web_search(\"Letta API documentation core_memory_append\", num_results=3)\n\n    Args:\n        query (str): The search query to find relevant web content.\n        num_results (int, optional): Number of results to return (1-100). Defaults to 10.\n        category (Optional[Literal], optional): Focus search on specific content types. Defaults to None.\n        include_text (bool, optional): Whether to retrieve full page content. Defaults to False (only returns summary and highlights, since the full text usually will overflow the context window).\n        include_domains (Optional[List[str]], optional): List of domains to include in search results. Defaults to None.\n        exclude_domains (Optional[List[str]], optional): List of domains to exclude from search results. Defaults to None.\n        start_published_date (Optional[str], optional): Only return content published after this date (ISO format). Defaults to None.\n        end_published_date (Optional[str], optional): Only return content published before this date (ISO format). Defaults to None.\n        user_location (Optional[str], optional): Two-letter country code for localized results (e.g., \"US\"). Defaults to None.\n\n    Returns:\n        str: A JSON-encoded string containing search results with title, URL, content, highlights, and summary.",
        "parameters": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The search query to find relevant web content."
            },
            "num_results": {
              "type": "integer",
              "description": "Number of results to return (1-100). Defaults to 10."
            },
            "category": {
              "type": "string",
              "enum": [
                "company",
                "research paper",
                "news",
                "pdf",
                "github",
                "tweet",
                "personal site",
                "linkedin profile",
                "financial report"
              ],
              "description": "Focus search on specific content types. Defaults to None."
            },
            "include_text": {
              "type": "boolean",
              "description": "Whether to retrieve full page content. Defaults to False (only returns summary and highlights, since the full text usually will overflow the context window)."
            },
            "include_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of domains to include in search results. Defaults to None."
            },
            "exclude_domains": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of domains to exclude from search results. Defaults to None."
            },
            "start_published_date": {
              "type": "string",
              "description": "Only return content published after this date (ISO format). Defaults to None."
            },
            "end_published_date": {
              "type": "string",
              "description": "Only return content published before this date (ISO format). Defaults to None."
            },
            "user_location": {
              "type": "string",
              "description": "Two-letter country code for localized results (e.g., \"US\"). Defaults to None."
            }
          },
          "required": [
            "query"
          ]
        }
      },
      "args_json_schema": null,
      "return_char_limit": 50000,
      "pip_requirements": null,
      "npm_requirements": null,
      "default_requires_approval": null,
      "enable_parallel_execution": true,
      "created_by_id": "user-b97fa8da-5324-4636-aaa1-9a0873f73eb4",
      "last_updated_by_id": "user-2bd32df4-3b81-44c8-a4d5-ce87a56f0906",
      "metadata_": {}
    }
  ],
  "mcp_servers": [],
  "metadata": {
    "revision_id": "b1c2d3e4f5a6"
  },
  "created_at": "2025-11-29T02:54:22.244058+00:00"
}
