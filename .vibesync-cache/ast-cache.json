{
  "projectId": "LCORE",
  "version": 1,
  "updatedAt": 1769611398553,
  "files": {
    "alembic/env.py": {
      "path": "alembic/env.py",
      "contentHash": "5ffb3148ae94eb7469cae0be91394dc8",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "run_migrations_offline",
          "signature": "def run_migrations_offline() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": "Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.",
          "decorators": [],
          "start_line": 46,
          "end_line": 67,
          "is_async": false
        },
        {
          "name": "run_migrations_online",
          "signature": "def run_migrations_online() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": "Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.",
          "decorators": [],
          "start_line": 70,
          "end_line": 87,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796358
    },
    "alembic/versions/0335b1eb9c40_add_batch_item_id_to_messages.py": {
      "path": "alembic/versions/0335b1eb9c40_add_batch_item_id_to_messages.py",
      "contentHash": "97c8078f9adf607d2c2a69171c65a054",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796358
    },
    "alembic/versions/038e68cdf0df_add_cascades_to_blocks_agents_fks_set_.py": {
      "path": "alembic/versions/038e68cdf0df_add_cascades_to_blocks_agents_fks_set_.py",
      "contentHash": "249cb88e8d8cb155805227ee195cf0e9",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 38,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 41,
          "end_line": 55,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796358
    },
    "alembic/versions/05c3bc564286_add_metrics_to_agent_loop_runs.py": {
      "path": "alembic/versions/05c3bc564286_add_metrics_to_agent_loop_runs.py",
      "contentHash": "9ae41b826fafca48a7b6a9d279faf195",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 29,
          "end_line": 33,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796358
    },
    "alembic/versions/066857381578_add_approvals_field_to_messages.py": {
      "path": "alembic/versions/066857381578_add_approvals_field_to_messages.py",
      "contentHash": "340e53d167e30f474cd4fecfffb5f72b",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 41,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796358
    },
    "alembic/versions/068588268b02_add_vector_db_provider_to_archives_table.py": {
      "path": "alembic/versions/068588268b02_add_vector_db_provider_to_archives_table.py",
      "contentHash": "67ae8e4cdac650e42ce4ab2f99248833",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 49,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 52,
          "end_line": 60,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796358
    },
    "alembic/versions/06fbbf65d4f1_support_for_project_id_for_blocks_and_.py": {
      "path": "alembic/versions/06fbbf65d4f1_support_for_project_id_for_blocks_and_.py",
      "contentHash": "02a3b5f66ba3eb30e823b4533331256d",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 64,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 67,
          "end_line": 71,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796358
    },
    "alembic/versions/08b2f8225812_adding_toolsagents_orm.py": {
      "path": "alembic/versions/08b2f8225812_adding_toolsagents_orm.py",
      "contentHash": "bfc05126ea9e5ea15cbcfa705ac9c014",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 48,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 51,
          "end_line": 58,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796358
    },
    "alembic/versions/0b496eae90de_add_file_agent_table.py": {
      "path": "alembic/versions/0b496eae90de_add_file_agent_table.py",
      "contentHash": "f30c08f116e79e9c41346cd80314dc54",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 52,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 55,
          "end_line": 63,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796358
    },
    "alembic/versions/0ceb975e0063_add_llm_batch_jobs_tables.py": {
      "path": "alembic/versions/0ceb975e0063_add_llm_batch_jobs_tables.py",
      "contentHash": "edb9085fc414f6b42958ffd84eace1ce",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 79,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 82,
          "end_line": 95,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796358
    },
    "alembic/versions/15b577c62f3f_add_hidden_property_to_agents.py": {
      "path": "alembic/versions/15b577c62f3f_add_hidden_property_to_agents.py",
      "contentHash": "165898ce7dd36d42e3cabb0df46ab203",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 27,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 30,
          "end_line": 31,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796358
    },
    "alembic/versions/167491cfb7a8_add_identities_for_blocks.py": {
      "path": "alembic/versions/167491cfb7a8_add_identities_for_blocks.py",
      "contentHash": "784818fd6eedfed104a5de186395ec3b",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 37,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 47,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/175dd10fb916_add_prompt_tokens_details_to_steps.py": {
      "path": "alembic/versions/175dd10fb916_add_prompt_tokens_details_to_steps.py",
      "contentHash": "8176e63981265494b4c5afca1ff7891b",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 28,
          "end_line": 29,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/18e300709530_add_instructions_field_to_sources.py": {
      "path": "alembic/versions/18e300709530_add_instructions_field_to_sources.py",
      "contentHash": "f025859b50eaa1a6ee9ecb263ce2b1aa",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/18ff61fbc034_add_agent_id_index_to_mapping_tables.py": {
      "path": "alembic/versions/18ff61fbc034_add_agent_id_index_to_mapping_tables.py",
      "contentHash": "82afc3ba8fe2b6134bc844fe662020c2",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 29,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 32,
          "end_line": 39,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/1af251a42c06_fix_files_agents_constraints.py": {
      "path": "alembic/versions/1af251a42c06_fix_files_agents_constraints.py",
      "contentHash": "4d8fda1aae5db9ab2be3801059426934",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 54,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/1c6b6a38b713_add_pip_requirements_to_tools.py": {
      "path": "alembic/versions/1c6b6a38b713_add_pip_requirements_to_tools.py",
      "contentHash": "f9c0f80c4721e9b8c89b4b53efc04586",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/1c8880d671ee_make_an_blocks_agents_mapping_table.py": {
      "path": "alembic/versions/1c8880d671ee_make_an_blocks_agents_mapping_table.py",
      "contentHash": "1eb0158c9abd0e5cfb75917a3290989d",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 50,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 53,
          "end_line": 61,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/1dc0fee72dea_add_block_related_indexes.py": {
      "path": "alembic/versions/1dc0fee72dea_add_block_related_indexes.py",
      "contentHash": "daf90cf714af76c9240bf7692fd2ff98",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 33,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 36,
          "end_line": 43,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/1e553a664210_add_metadata_to_tools.py": {
      "path": "alembic/versions/1e553a664210_add_metadata_to_tools.py",
      "contentHash": "6680c61dbff672021bab3d61ce95e68c",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/220856bbf43b_add_read_only_column.py": {
      "path": "alembic/versions/220856bbf43b_add_read_only_column.py",
      "contentHash": "9faff67708efb9d867825410ab3cef09",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 36,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 39,
          "end_line": 44,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/22a6e413d89c_remove_module_field_on_tool.py": {
      "path": "alembic/versions/22a6e413d89c_remove_module_field_on_tool.py",
      "contentHash": "0dfce166f3237ca1bdf013d936af056e",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/25fc99e97839_fix_alembic_check_warnings.py": {
      "path": "alembic/versions/25fc99e97839_fix_alembic_check_warnings.py",
      "contentHash": "d2046ce1d648a507bebf65c08db0e7fd",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 52,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/27de0f58e076_add_conversations_tables_and_run_.py": {
      "path": "alembic/versions/27de0f58e076_add_conversations_tables_and_run_.py",
      "contentHash": "87f52ce99fa620e9f38f86618f8301af",
      "mtime": 1768610518502.1995,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 78,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 81,
          "end_line": 97,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/28b8765bdd0a_add_support_for_structured_outputs_in_.py": {
      "path": "alembic/versions/28b8765bdd0a_add_support_for_structured_outputs_in_.py",
      "contentHash": "4fa9fe4e3c98de3dea0dff6d1fe962d6",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796359
    },
    "alembic/versions/2c059cad97cc_create_sqlite_baseline_schema.py": {
      "path": "alembic/versions/2c059cad97cc_create_sqlite_baseline_schema.py",
      "contentHash": "228628ccfa8922f078662f5bad86c67d",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 789,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 792,
          "end_line": 798,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/2cceb07c2384_add_content_parts_to_message.py": {
      "path": "alembic/versions/2cceb07c2384_add_content_parts_to_message.py",
      "contentHash": "a01a9ac3e23acbdc9d049fdff24a21d1",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 41,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/2dbb2cf49e07_add_models_table.py": {
      "path": "alembic/versions/2dbb2cf49e07_add_models_table.py",
      "contentHash": "e4586a715aec9b2582225f4e7fdbc329",
      "mtime": 1767315071920.5396,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 55,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 58,
          "end_line": 66,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/2e162879008b_add_webhook_fields_to_agents.py": {
      "path": "alembic/versions/2e162879008b_add_webhook_fields_to_agents.py",
      "contentHash": "5c6e8bebfd589f78088f30bfde7a6266",
      "mtime": 1767316202632.2612,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 28,
          "end_line": 32,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/2e5e90d3cdf8_add_project_id_to_tools.py": {
      "path": "alembic/versions/2e5e90d3cdf8_add_project_id_to_tools.py",
      "contentHash": "8084b0b29fc8a01702c2ad0c10ae3c77",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 23,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 26,
          "end_line": 27,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/2f4ede6ae33b_add_otid_and_tool_return_to_message.py": {
      "path": "alembic/versions/2f4ede6ae33b_add_otid_and_tool_return_to_message.py",
      "contentHash": "75c98c88a0a5376d4637e1bb0a247bb0",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 32,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 35,
          "end_line": 43,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/341068089f14_add_preserve_on_migration_to_block.py": {
      "path": "alembic/versions/341068089f14_add_preserve_on_migration_to_block.py",
      "contentHash": "17ed301ae023e0cea9c43aaf265c2504",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/348214cbc081_add_org_agent_id_indices.py": {
      "path": "alembic/versions/348214cbc081_add_org_agent_id_indices.py",
      "contentHash": "0ec9eaed03e27544448221c73efd66c0",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 29,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 32,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/373dabcba6cf_add_byok_fields_and_unique_constraint.py": {
      "path": "alembic/versions/373dabcba6cf_add_byok_fields_and_unique_constraint.py",
      "contentHash": "66e5f0c796439af301836720c65d875f",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 32,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 35,
          "end_line": 44,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/39577145c45d_add_project_constraint_on_tools.py": {
      "path": "alembic/versions/39577145c45d_add_project_constraint_on_tools.py",
      "contentHash": "ef9497e1790d375197815359c144823d",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 27,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 30,
          "end_line": 33,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/3a8f2c1d4e56_add_webhook_deliveries_table.py": {
      "path": "alembic/versions/3a8f2c1d4e56_add_webhook_deliveries_table.py",
      "contentHash": "0c6e5993cfefc694f271e24cabf53c03",
      "mtime": 1767318762562.8486,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 49,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 52,
          "end_line": 58,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/3bc3c031fbe4_create_new_runs_table_and_remove_legacy_.py": {
      "path": "alembic/versions/3bc3c031fbe4_create_new_runs_table_and_remove_legacy_.py",
      "contentHash": "ac6413a43965b9dc2ada008358e989bc",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 29,
          "end_line": 33,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/3c683a662c82_migrate_jobs_to_the_orm.py": {
      "path": "alembic/versions/3c683a662c82_migrate_jobs_to_the_orm.py",
      "contentHash": "9bd402dca0b2f3a13b069f42b262f49c",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 38,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 41,
          "end_line": 55,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/3d2e9fb40a3c_add_indexes_for_feedback.py": {
      "path": "alembic/versions/3d2e9fb40a3c_add_indexes_for_feedback.py",
      "contentHash": "fc9c331dfa1ecfa310f5e47794dbac33",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 54,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 57,
          "end_line": 68,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/400501b04bf0_add_per_agent_environment_variables.py": {
      "path": "alembic/versions/400501b04bf0_add_per_agent_environment_variables.py",
      "contentHash": "fc4f9b3fb1b65b3617758e85d52caabf",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 50,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 53,
          "end_line": 60,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/416b9d2db10b_repurpose_jobusagestatistics_for_new_.py": {
      "path": "alembic/versions/416b9d2db10b_repurpose_jobusagestatistics_for_new_.py",
      "contentHash": "bd1dac8f6d5b2ac4fca39b0078355793",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 78,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 81,
          "end_line": 125,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/4537f0996495_add_start_end_for_agent_file.py": {
      "path": "alembic/versions/4537f0996495_add_start_end_for_agent_file.py",
      "contentHash": "98a5373d4e7442900cd151d400c768e8",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 29,
          "end_line": 33,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796360
    },
    "alembic/versions/46699adc71a7_add_unique_constraint_to_source_names_.py": {
      "path": "alembic/versions/46699adc71a7_add_unique_constraint_to_source_names_.py",
      "contentHash": "495bd3a0a968775750d72713ac99ed69",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 66,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 69,
          "end_line": 77,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796361
    },
    "alembic/versions/47d2277e530d_add_total_chunks_and_chunks_embedded_to_.py": {
      "path": "alembic/versions/47d2277e530d_add_total_chunks_and_chunks_embedded_to_.py",
      "contentHash": "8e3b87ce0bf60936d4cf6ae4caa4210a",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 42,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796361
    },
    "alembic/versions/495f3f474131_write_source_id_directly_to_files_agents.py": {
      "path": "alembic/versions/495f3f474131_write_source_id_directly_to_files_agents.py",
      "contentHash": "f9c8629caf67a0c1d86b0ba39a6897f9",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 50,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 53,
          "end_line": 61,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796361
    },
    "alembic/versions/4b9c3d2e5f67_add_created_by_fields_to_webhook_deliveries.py": {
      "path": "alembic/versions/4b9c3d2e5f67_add_created_by_fields_to_webhook_deliveries.py",
      "contentHash": "bc982a9dca0a5cd06f16fba2c42251d6",
      "mtime": 1767393779136.4119,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 24,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 27,
          "end_line": 29,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796361
    },
    "alembic/versions/4c6c9ef0387d_support_modal_sandbox_type.py": {
      "path": "alembic/versions/4c6c9ef0387d_support_modal_sandbox_type.py",
      "contentHash": "d4b4630f1c04827f477901f174df534c",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 29,
          "end_line": 55,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796361
    },
    "alembic/versions/4e88e702f85e_drop_api_tokens_table_in_oss.py": {
      "path": "alembic/versions/4e88e702f85e_drop_api_tokens_table_in_oss.py",
      "contentHash": "d6755161cf119ff912c0c9e680d17b8e",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 32,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 35,
          "end_line": 51,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796361
    },
    "alembic/versions/51999513bcf1_steps_feedback_field.py": {
      "path": "alembic/versions/51999513bcf1_steps_feedback_field.py",
      "contentHash": "91bddeb89e12e332ba66e8b9e6822324",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796361
    },
    "alembic/versions/549eff097c71_update_identities_unique_constraint_and_.py": {
      "path": "alembic/versions/549eff097c71_update_identities_unique_constraint_and_.py",
      "contentHash": "83fb5b98c34fa70a4cc603ef20d1a6e8",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 66,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 69,
          "end_line": 98,
          "is_async": false
        }
      ],
      "parsedAt": 1769607796361
    },
    "alembic/versions/54c76f7cabca_add_tags_to_passages_and_create_passage_.py": {
      "path": "alembic/versions/54c76f7cabca_add_tags_to_passages_and_create_passage_.py",
      "contentHash": "69f80bf0fc9e11e52a19ff1d60f13597",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 61,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 64,
          "end_line": 73,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844491
    },
    "alembic/versions/54dec07619c4_divide_passage_table_into_.py": {
      "path": "alembic/versions/54dec07619c4_divide_passage_table_into_.py",
      "contentHash": "f07b13f7ca64f7072f54bdabf8a1e811",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 83,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 86,
          "end_line": 121,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844491
    },
    "alembic/versions/54f2311edb62_add_args_schema_to_tools.py": {
      "path": "alembic/versions/54f2311edb62_add_args_schema_to_tools.py",
      "contentHash": "9942c130ba6d2affe3c3bc7573799d9f",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844491
    },
    "alembic/versions/56254216524f_add_custom_headers_to_mcp_server.py": {
      "path": "alembic/versions/56254216524f_add_custom_headers_to_mcp_server.py",
      "contentHash": "e2731c18d62cb711855a7a77a7d41a3f",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/567e9fe06270_create_new_runs_table_and_remove_legacy_.py": {
      "path": "alembic/versions/567e9fe06270_create_new_runs_table_and_remove_legacy_.py",
      "contentHash": "e97d44d35f53fa62103e1fb899a6cc94",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 80,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 83,
          "end_line": 128,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/57bcea83af3f_add_various_indexes.py": {
      "path": "alembic/versions/57bcea83af3f_add_various_indexes.py",
      "contentHash": "2758a5f946a3cbc7c80251f186e08868",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 43,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/5973fd8b8c60_add_agents_runs_table.py": {
      "path": "alembic/versions/5973fd8b8c60_add_agents_runs_table.py",
      "contentHash": "5dca39f22a05c98a3d614b6c5e0fc09b",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 42,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 45,
          "end_line": 51,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/5987401b40ae_refactor_agent_memory.py": {
      "path": "alembic/versions/5987401b40ae_refactor_agent_memory.py",
      "contentHash": "a60069f0031baf55db01ef2f09b246ec",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 32,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 35,
          "end_line": 43,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/5b804970e6a0_add_hidden_property_to_groups_and_blocks.py": {
      "path": "alembic/versions/5b804970e6a0_add_hidden_property_to_groups_and_blocks.py",
      "contentHash": "590ecd9a9b0fab30ed3e3317ee7df406",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 27,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 30,
          "end_line": 35,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/5d27a719b24d_add_organization_id_to_jobs_model.py": {
      "path": "alembic/versions/5d27a719b24d_add_organization_id_to_jobs_model.py",
      "contentHash": "a4eadcab019a0056f951c8d4b549a797",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 27,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 30,
          "end_line": 35,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/5fb8bba2c373_add_step_metrics.py": {
      "path": "alembic/versions/5fb8bba2c373_add_step_metrics.py",
      "contentHash": "5595b363474d4cad741531ff19f64b0f",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 49,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 52,
          "end_line": 55,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/60ed28ee7138_add_project_id_to_step_model.py": {
      "path": "alembic/versions/60ed28ee7138_add_project_id_to_step_model.py",
      "contentHash": "a4def9286d1272c3d3c2e4cd177eecc2",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 40,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 43,
          "end_line": 50,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/614c4e53b66e_add_unique_constraint_to_file_id_and_.py": {
      "path": "alembic/versions/614c4e53b66e_add_unique_constraint_to_file_id_and_.py",
      "contentHash": "18e055364c1e471d1160ae1489c5e11a",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 28,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 31,
          "end_line": 38,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/61ee53ec45a5_add_index_on_source_passages_for_files.py": {
      "path": "alembic/versions/61ee53ec45a5_add_index_on_source_passages_for_files.py",
      "contentHash": "36285f481e439b6150aabf6400c697ef",
      "mtime": 1767315071924.5398,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 28,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 31,
          "end_line": 38,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/6756d04c3ddb_add_tools_used_field_to_run_metrics_.py": {
      "path": "alembic/versions/6756d04c3ddb_add_tools_used_field_to_run_metrics_.py",
      "contentHash": "d1f3f399c20e729657bfb6733ce1f8c8",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 28,
          "end_line": 31,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/6c53224a7a58_add_provider_category_to_steps.py": {
      "path": "alembic/versions/6c53224a7a58_add_provider_category_to_steps.py",
      "contentHash": "e4b4e80c30d55c59f2881e0f9761252f",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844492
    },
    "alembic/versions/6fbe9cace832_adding_indexes_to_models.py": {
      "path": "alembic/versions/6fbe9cace832_adding_indexes_to_models.py",
      "contentHash": "7dbe510ce9dd29c65610df89c6b75079",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 52,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844493
    },
    "alembic/versions/6fe79c0525f2_enable_sleeptime_agent_fields.py": {
      "path": "alembic/versions/6fe79c0525f2_enable_sleeptime_agent_fields.py",
      "contentHash": "7550e630116d1fb15111f9620ee5aaf9",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 42,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844493
    },
    "alembic/versions/74e860718e0d_add_archival_memory_sharing.py": {
      "path": "alembic/versions/74e860718e0d_add_archival_memory_sharing.py",
      "contentHash": "7dba19883ff1518a856026f7f645813e",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 31,
          "end_line": 389,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 392,
          "end_line": 508,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844493
    },
    "alembic/versions/74f2ede29317_add_background_group_support.py": {
      "path": "alembic/versions/74f2ede29317_add_background_group_support.py",
      "contentHash": "e215c03a65dccef4d03e49212044ba26",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 40,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 43,
          "end_line": 53,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844493
    },
    "alembic/versions/750dd87faa12_add_build_request_latency_to_step_.py": {
      "path": "alembic/versions/750dd87faa12_add_build_request_latency_to_step_.py",
      "contentHash": "74b821729ac84dad327da6e6d917fd74",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 29,
          "end_line": 33,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844493
    },
    "alembic/versions/7778731d15e2_added_jobusagestatistics_table.py": {
      "path": "alembic/versions/7778731d15e2_added_jobusagestatistics_table.py",
      "contentHash": "ea14b1faa98eb83c3d989cb252ba468e",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 49,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 52,
          "end_line": 62,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844493
    },
    "alembic/versions/77de976590ae_add_groups_for_multi_agent.py": {
      "path": "alembic/versions/77de976590ae_add_groups_for_multi_agent.py",
      "contentHash": "8d2fa2d30215b32b512c008793d07969",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 59,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 62,
          "end_line": 71,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844493
    },
    "alembic/versions/7980d239ea08_add_stateless_option_for_agentstate.py": {
      "path": "alembic/versions/7980d239ea08_add_stateless_option_for_agentstate.py",
      "contentHash": "3523201a7d1ff8b966fb925cc4ab446b",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 45,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844493
    },
    "alembic/versions/7b189006c97d_rename_batch_id_to_llm_batch_id_on_llm_.py": {
      "path": "alembic/versions/7b189006c97d_rename_batch_id_to_llm_batch_id_on_llm_.py",
      "contentHash": "03d4613943254bf8ac398988d6e1592b",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 50,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844493
    },
    "alembic/versions/7f652fdd3dba_change_jobmessage_unique_constraint_to_.py": {
      "path": "alembic/versions/7f652fdd3dba_change_jobmessage_unique_constraint_to_.py",
      "contentHash": "91e86aa6bdb79f6f612024d6765577ec",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 42,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844493
    },
    "alembic/versions/7f7933666957_add_stop_reason_to_jobs_table.py": {
      "path": "alembic/versions/7f7933666957_add_stop_reason_to_jobs_table.py",
      "contentHash": "4a7077bd8b223832fb80a2e72b13d40c",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 24,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 27,
          "end_line": 28,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844493
    },
    "alembic/versions/8149a781ac1b_backfill_encrypted_columns_for_.py": {
      "path": "alembic/versions/8149a781ac1b_backfill_encrypted_columns_for_.py",
      "contentHash": "66bc56fd90360d97379c21d5b8c09ed9",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 26,
          "end_line": 345,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 348,
          "end_line": 349,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/878607e41ca4_add_provider_category.py": {
      "path": "alembic/versions/878607e41ca4_add_provider_category.py",
      "contentHash": "8769f19494e3e9ba7ae765f04edce7ba",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/887a4367b560_convert_stop_reason_from_enum_to_string.py": {
      "path": "alembic/versions/887a4367b560_convert_stop_reason_from_enum_to_string.py",
      "contentHash": "573cb558e84a64874377ddedb63e47ab",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 33,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 36,
          "end_line": 39,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/88f9432739a9_add_jobtype_to_job_table.py": {
      "path": "alembic/versions/88f9432739a9_add_jobtype_to_job_table.py",
      "contentHash": "443ce1ae49a1f9d314c6ec8212e9ee5f",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 44,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/89b595051e48_replace_composite_runs_index.py": {
      "path": "alembic/versions/89b595051e48_replace_composite_runs_index.py",
      "contentHash": "9e010d7a4fa328d62fa221c3587590ef",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 29,
          "end_line": 33,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/89fd4648866b_add_last_stop_reason_to_agent_state.py": {
      "path": "alembic/versions/89fd4648866b_add_last_stop_reason_to_agent_state.py",
      "contentHash": "f07f4b4190a448791540b34fe735b9af",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 28,
          "end_line": 31,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/8d70372ad130_adding_jobmessages_table.py": {
      "path": "alembic/versions/8d70372ad130_adding_jobmessages_table.py",
      "contentHash": "b43be490e03f2bde599db40afe7f6a6b",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 46,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 49,
          "end_line": 56,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/90bb156e71df_rename_sleeptime_agent_frequency.py": {
      "path": "alembic/versions/90bb156e71df_rename_sleeptime_agent_frequency.py",
      "contentHash": "f00327a29b3db40f46024688d0e03189",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 28,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 31,
          "end_line": 38,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/90fd814d0cda_add_callback_error_field_to_jobs.py": {
      "path": "alembic/versions/90fd814d0cda_add_callback_error_field_to_jobs.py",
      "contentHash": "9dbb840151fad29c0c66726e5ff01c1c",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/915b68780108_add_providers_data_to_orm.py": {
      "path": "alembic/versions/915b68780108_add_providers_data_to_orm.py",
      "contentHash": "d8e53c794237ce0bec14afe5088f0938",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 46,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 49,
          "end_line": 56,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/9556081ce65b_add_bedrock_creds_to_byok.py": {
      "path": "alembic/versions/9556081ce65b_add_bedrock_creds_to_byok.py",
      "contentHash": "45d77bdfb984db6bbf66a92cf1d0749f",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 42,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/95badb46fdf9_migrate_messages_to_the_orm.py": {
      "path": "alembic/versions/95badb46fdf9_migrate_messages_to_the_orm.py",
      "contentHash": "cb33e47b6b555830768d8d086910d7ae",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 52,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 55,
          "end_line": 72,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/9758adf8fdd3_add_run_completion_and_duration_to_.py": {
      "path": "alembic/versions/9758adf8fdd3_add_run_completion_and_duration_to_.py",
      "contentHash": "25888731927f641032f2cf5b0a1012e0",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 42,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844494
    },
    "alembic/versions/9792f94e961d_add_file_processing_status_to_.py": {
      "path": "alembic/versions/9792f94e961d_add_file_processing_status_to_.py",
      "contentHash": "e2ded81ec24f05ad77ec273f36108d07",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 44,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 47,
          "end_line": 59,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844495
    },
    "alembic/versions/9a505cc7eca9_create_a_baseline_migrations.py": {
      "path": "alembic/versions/9a505cc7eca9_create_a_baseline_migrations.py",
      "contentHash": "e6ad54165ce3eba964366efa390518fb",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 178,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 181,
          "end_line": 205,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844495
    },
    "alembic/versions/9ecbdbaa409f_add_table_to_store_mcp_servers.py": {
      "path": "alembic/versions/9ecbdbaa409f_add_table_to_store_mcp_servers.py",
      "contentHash": "692929f3462b41687125a0ec141306d7",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 50,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 53,
          "end_line": 60,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844495
    },
    "alembic/versions/a113caac453e_add_identities_table.py": {
      "path": "alembic/versions/a113caac453e_add_identities_table.py",
      "contentHash": "56025b487f3a9637cb6a07e793c706fe",
      "mtime": 1767315071928.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 62,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 65,
          "end_line": 75,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844495
    },
    "alembic/versions/a1b2c3d4e5f6_add_index_to_step_metrics_run_id.py": {
      "path": "alembic/versions/a1b2c3d4e5f6_add_index_to_step_metrics_run_id.py",
      "contentHash": "9b872b34047c1abb4ab843056840be42",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 38,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844495
    },
    "alembic/versions/a3047a624130_add_identifier_key_to_agents.py": {
      "path": "alembic/versions/a3047a624130_add_identifier_key_to_agents.py",
      "contentHash": "7edbcb51148e8b0b717dedde6adf3619",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 28,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 31,
          "end_line": 36,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844495
    },
    "alembic/versions/a3c7d62e08ca_add_callback_data_to_jobs_table.py": {
      "path": "alembic/versions/a3c7d62e08ca_add_callback_data_to_jobs_table.py",
      "contentHash": "5caba64925b26620a382b735d502cad1",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 32,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 35,
          "end_line": 44,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844495
    },
    "alembic/versions/a66510f83fc2_add_ordered_agent_ids_to_groups.py": {
      "path": "alembic/versions/a66510f83fc2_add_ordered_agent_ids_to_groups.py",
      "contentHash": "99e431d59687fbad98fa798fd0f6e024",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844495
    },
    "alembic/versions/a91994b9752f_add_column_to_tools_table_to_contain_.py": {
      "path": "alembic/versions/a91994b9752f_add_column_to_tools_table_to_contain_.py",
      "contentHash": "8eeb88533cbba67291dbfaad5dbd2df8",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 38,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 41,
          "end_line": 48,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844495
    },
    "alembic/versions/af842aa6f743_add_tool_indexes_for_organization_id.py": {
      "path": "alembic/versions/af842aa6f743_add_tool_indexes_for_organization_id.py",
      "contentHash": "7eb12713b6acef079e7882ce0ca1b0ac",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 29,
          "end_line": 33,
          "is_async": false
        }
      ],
      "parsedAt": 1769607844495
    },
    "alembic/versions/b183663c6769_add_trace_id_to_steps_table.py": {
      "path": "alembic/versions/b183663c6769_add_trace_id_to_steps_table.py",
      "contentHash": "d006b5794fc7212cb05c1dc65711c1cc",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917933
    },
    "alembic/versions/b1c2d3e4f5a6_drop_unused_and_redundant_indexes.py": {
      "path": "alembic/versions/b1c2d3e4f5a6_drop_unused_and_redundant_indexes.py",
      "contentHash": "3a521b79153eaa4238026498d942594c",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 52,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 55,
          "end_line": 73,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917933
    },
    "alembic/versions/b6061da886ee_add_encrypted_columns.py": {
      "path": "alembic/versions/b6061da886ee_add_encrypted_columns.py",
      "contentHash": "86fb1c5aec671237ca6167167e01d266",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 29,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 32,
          "end_line": 39,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917933
    },
    "alembic/versions/b6d7ca024aa9_add_agents_tags_table.py": {
      "path": "alembic/versions/b6d7ca024aa9_add_agents_tags_table.py",
      "contentHash": "2b7e425397cffba4eeb95757d3edb7b2",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 51,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 54,
          "end_line": 61,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917933
    },
    "alembic/versions/b888f21b151f_add_vector_db_provider_to_source.py": {
      "path": "alembic/versions/b888f21b151f_add_vector_db_provider_to_source.py",
      "contentHash": "0cb18eaa9d9c1ad59f4ca968fa36bd92",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 65,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 68,
          "end_line": 70,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917933
    },
    "alembic/versions/bdddd421ec41_add_privileged_tools_to_organization.py": {
      "path": "alembic/versions/bdddd421ec41_add_privileged_tools_to_organization.py",
      "contentHash": "6c1263373f2c7782dd595416bd1e2e49",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 40,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 43,
          "end_line": 48,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/bff040379479_add_block_history_tables.py": {
      "path": "alembic/versions/bff040379479_add_block_history_tables.py",
      "contentHash": "5910ad3fa1a1611e5ebf8f7103a495f0",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 59,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 62,
          "end_line": 74,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/c0ef3ff26306_add_token_to_mcp_server.py": {
      "path": "alembic/versions/c0ef3ff26306_add_token_to_mcp_server.py",
      "contentHash": "9cd4c1b4d9f4ce84c479a9684a914358",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/c3b1da3d1157_add_sender_id_to_message.py": {
      "path": "alembic/versions/c3b1da3d1157_add_sender_id_to_message.py",
      "contentHash": "6c21afdf7d5197ce8ee0981c8cb9acbc",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/c41c87205254_add_default_requires_approval_field_on_.py": {
      "path": "alembic/versions/c41c87205254_add_default_requires_approval_field_on_.py",
      "contentHash": "81cf5fe06b38adf1ed0c4f4fd9eccf8a",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 28,
          "end_line": 31,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/c4eb5a907b38_add_file_controls_to_agent_state.py": {
      "path": "alembic/versions/c4eb5a907b38_add_file_controls_to_agent_state.py",
      "contentHash": "c16355f20640f8aaa8c4f90784e0fffd",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 29,
          "end_line": 33,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/c56081a05371_add_buffer_length_min_max_for_voice_.py": {
      "path": "alembic/versions/c56081a05371_add_buffer_length_min_max_for_voice_.py",
      "contentHash": "1c1b526f6a72835fafebee09906b7177",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 42,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/c5d964280dff_add_passages_orm_drop_legacy_passages_.py": {
      "path": "alembic/versions/c5d964280dff_add_passages_orm_drop_legacy_passages_.py",
      "contentHash": "595a734e36149f4813c939fb5bf644bb",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 60,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 63,
          "end_line": 83,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/c6c43222e2de_add_mcp_tools_table.py": {
      "path": "alembic/versions/c6c43222e2de_add_mcp_tools_table.py",
      "contentHash": "f149b880c3617292dedf9ec2248e23e1",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 41,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 44,
          "end_line": 47,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/c734cfc0d595_add_runs_metrics_table.py": {
      "path": "alembic/versions/c734cfc0d595_add_runs_metrics_table.py",
      "contentHash": "1ed4a3f3726b8085365ac542fee473df",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 49,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 52,
          "end_line": 55,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/c7ac45f69849_add_timezone_to_agents_table.py": {
      "path": "alembic/versions/c7ac45f69849_add_timezone_to_agents_table.py",
      "contentHash": "6ac769131e43c038bf31e843a237ca4d",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/c85a3d07c028_move_files_to_orm.py": {
      "path": "alembic/versions/c85a3d07c028_move_files_to_orm.py",
      "contentHash": "846279ebe0c6a0f66f010a888626732c",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 48,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 51,
          "end_line": 65,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/c96263433aef_add_file_name_to_source_passages.py": {
      "path": "alembic/versions/c96263433aef_add_file_name_to_source_passages.py",
      "contentHash": "71cb00b7d6bb6ad14ec796f4206caa46",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 41,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 44,
          "end_line": 49,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/cc8dc340836d_add_support_for_request_and_response_.py": {
      "path": "alembic/versions/cc8dc340836d_add_support_for_request_and_response_.py",
      "contentHash": "500f37f805b1d88e601fdd5e65d1accf",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 48,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 51,
          "end_line": 59,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/cce9a6174366_add_stop_reasons_to_steps_and_message_.py": {
      "path": "alembic/versions/cce9a6174366_add_stop_reasons_to_steps_and_message_.py",
      "contentHash": "f2466660f4be0902ff068ab11741c1a1",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 32,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 35,
          "end_line": 42,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/cda66b6cb0d6_move_sources_to_orm.py": {
      "path": "alembic/versions/cda66b6cb0d6_move_sources_to_orm.py",
      "contentHash": "351bf83e0a316a893e2252852fba124f",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 55,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 58,
          "end_line": 73,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917934
    },
    "alembic/versions/cdb3db091113_remove_unique_name_restriction_on_agents.py": {
      "path": "alembic/versions/cdb3db091113_remove_unique_name_restriction_on_agents.py",
      "contentHash": "413832e263f2b5c3ab569ca5c75f00a9",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 28,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 31,
          "end_line": 38,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/cdd4a1c11aee_add_file_name_to_fileagent_association_.py": {
      "path": "alembic/versions/cdd4a1c11aee_add_file_name_to_fileagent_association_.py",
      "contentHash": "56b23594de5ece10a585af5e2e9088af",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 59,
          "is_async": false
        },
        {
          "name": "wngrade()",
          "signature": "def wngrade() - -> ne:\n",
          "parameters": " -",
          "return_type": "ne:\n",
          "docstring": null,
          "decorators": [],
          "start_line": 62,
          "end_line": 72,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/d007f4ca66bf_npm_requirements_in_tools.py": {
      "path": "alembic/versions/d007f4ca66bf_npm_requirements_in_tools.py",
      "contentHash": "ee1850a2a9cf951faa9307a2e0a7fefe",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 28,
          "end_line": 31,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/d05669b60ebe_migrate_agents_to_orm.py": {
      "path": "alembic/versions/d05669b60ebe_migrate_agents_to_orm.py",
      "contentHash": "37fb851904d3d5e69be8382057faba5b",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 100,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 103,
          "end_line": 184,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/d06594144ef3_add_and_migrate_encrypted_columns_for_.py": {
      "path": "alembic/versions/d06594144ef3_add_and_migrate_encrypted_columns_for_.py",
      "contentHash": "c02684052c171fcf4b216accb0c8520d",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 31,
          "end_line": 306,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 309,
          "end_line": 315,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/d0880aae6cee_add_compaction_settings_to_agents_table.py": {
      "path": "alembic/versions/d0880aae6cee_add_compaction_settings_to_agents_table.py",
      "contentHash": "fe041304c86ce048cf1f914d255a28e3",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 24,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 27,
          "end_line": 28,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/d14ae606614c_move_organizations_users_tools_to_orm.py": {
      "path": "alembic/versions/d14ae606614c_move_organizations_users_tools_to_orm.py",
      "contentHash": "660fc87acf5c126820f4b779e6a86ce0",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 64,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 67,
          "end_line": 100,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/d211df879a5f_add_agent_id_to_steps.py": {
      "path": "alembic/versions/d211df879a5f_add_agent_id_to_steps.py",
      "contentHash": "3c0073b766a268d9c2ec59413cf8bea1",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/d5103ee17ed5_add_template_fields_to_blocks_agents_.py": {
      "path": "alembic/versions/d5103ee17ed5_add_template_fields_to_blocks_agents_.py",
      "contentHash": "46039ef9aff94c400d124b5d9874aecf",
      "mtime": 1767315071932.54,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 33,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 36,
          "end_line": 47,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/d6632deac81d_add_composite_index_to_messages_table.py": {
      "path": "alembic/versions/d6632deac81d_add_composite_index_to_messages_table.py",
      "contentHash": "5d8d273969fd498cdc0c0beaefb0f181",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 28,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 31,
          "end_line": 38,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/d798609d65ff_add_index_on_messages_step_id.py": {
      "path": "alembic/versions/d798609d65ff_add_index_on_messages_step_id.py",
      "contentHash": "555e2ec24b7cea48978a38c76ea0d99e",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 28,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 31,
          "end_line": 36,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/dd049fbec729_add_index_on_agent_id_for_agent_env_var.py": {
      "path": "alembic/versions/dd049fbec729_add_index_on_agent_id_for_agent_env_var.py",
      "contentHash": "36334b1014a4bee9c8f4e90f0eb67df4",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 28,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 31,
          "end_line": 38,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/ddb69be34a72_add_vector_db_namespace_fields_to_.py": {
      "path": "alembic/versions/ddb69be34a72_add_vector_db_namespace_fields_to_.py",
      "contentHash": "6f8bcb76cd7ec44c4978b282d69929c2",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 29,
          "end_line": 33,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/ddecfe4902bc_add_prompts.py": {
      "path": "alembic/versions/ddecfe4902bc_add_prompts.py",
      "contentHash": "afa88c825ef337c4a1c2533a3d4b8b9d",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 36,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 39,
          "end_line": 42,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/dfafcf8210ca_add_model_endpoint_to_steps_table.py": {
      "path": "alembic/versions/dfafcf8210ca_add_model_endpoint_to_steps_table.py",
      "contentHash": "c5af6a57d0c4d9013ce409c7b6cfb1bf",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917935
    },
    "alembic/versions/e1a625072dbf_tweak_created_at_field_for_messages.py": {
      "path": "alembic/versions/e1a625072dbf_tweak_created_at_field_for_messages.py",
      "contentHash": "ae785f749fa481724d1ef79048a5e8f3",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/e20573fe9b86_add_tool_types.py": {
      "path": "alembic/versions/e20573fe9b86_add_tool_types.py",
      "contentHash": "5defc26e5f3d57debd93999f16c7ea6a",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 26,
          "end_line": 68,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 71,
          "end_line": 79,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/e67961ed7c32_add_enable_parallel_execution_to_tools_table.py": {
      "path": "alembic/versions/e67961ed7c32_add_enable_parallel_execution_to_tools_table.py",
      "contentHash": "2dd11aba12137c18e40ffbb6c9bcb60d",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 28,
          "end_line": 31,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/e78b4e82db30_add_cascading_deletes_for_sources_to_.py": {
      "path": "alembic/versions/e78b4e82db30_add_cascading_deletes_for_sources_to_.py",
      "contentHash": "79d9e89c6bd3ddf26119f4b0ed2f050a",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 44,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/e991d2e3b428_add_monotonically_increasing_ids_to_.py": {
      "path": "alembic/versions/e991d2e3b428_add_monotonically_increasing_ids_to_.py",
      "contentHash": "e258f668210b9337c9105b7389c0aaff",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "print_flush",
          "signature": "def print_flush(message)",
          "parameters": "(message)",
          "return_type": null,
          "docstring": "Helper function to print and flush stdout immediately.",
          "decorators": [],
          "start_line": 35,
          "end_line": 38,
          "is_async": false
        },
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 41,
          "end_line": 122,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 125,
          "end_line": 153,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/ee2b43eea55e_add_request_id_to_steps_table.py": {
      "path": "alembic/versions/ee2b43eea55e_add_request_id_to_steps_table.py",
      "contentHash": "fdc0fd17b6362a203c9dd3d02fe9c165",
      "mtime": 1768610518502.1995,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 28,
          "end_line": 31,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/eff256d296cb_mcp_encrypted_data_migration.py": {
      "path": "alembic/versions/eff256d296cb_mcp_encrypted_data_migration.py",
      "contentHash": "ff57bceb2369c9223cf8b1d5823a7c80",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 29,
          "end_line": 296,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 299,
          "end_line": 300,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/f2f78d62005c_add_letta_batch_job_id_to_llm_batch_job.py": {
      "path": "alembic/versions/f2f78d62005c_add_letta_batch_job_id_to_llm_batch_job.py",
      "contentHash": "fa72c34fdf8480ce24b7ffb9a07d8e3e",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 42,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/f3bf00ef6118_add_approval_fields_to_message_model.py": {
      "path": "alembic/versions/f3bf00ef6118_add_approval_fields_to_message_model.py",
      "contentHash": "dbcb455ea733a4d0cd10a14964cecb75",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 27,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 30,
          "end_line": 35,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/f55542f37641_add_index_for_agent_tags_reversed_order.py": {
      "path": "alembic/versions/f55542f37641_add_index_for_agent_tags_reversed_order.py",
      "contentHash": "caec8e13167a9abea53855c21fe763e7",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 20,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 37,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/f595e0e8013e_adding_request_config_to_job_table.py": {
      "path": "alembic/versions/f595e0e8013e_adding_request_config_to_job_table.py",
      "contentHash": "0b67c972a54a8ecb1f0b1028aaf26924",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/f5d26b0526e8_add_mcp_oauth.py": {
      "path": "alembic/versions/f5d26b0526e8_add_mcp_oauth.py",
      "contentHash": "651f2eec3bd4a4de2e4be4b83747b5c0",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 61,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 64,
          "end_line": 67,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/f6cd5a1e519d_add_embedding_config_field_to_archives_.py": {
      "path": "alembic/versions/f6cd5a1e519d_add_embedding_config_field_to_archives_.py",
      "contentHash": "6556c3ec79fdc24a455cc36fd7d7ac67",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 26,
          "end_line": 79,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 82,
          "end_line": 83,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/f7507eab4bb9_migrate_blocks_to_orm_model.py": {
      "path": "alembic/versions/f7507eab4bb9_migrate_blocks_to_orm_model.py",
      "contentHash": "f407a1b38a534a738ef2f67f6e04a2b3",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 62,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 65,
          "end_line": 83,
          "is_async": false
        }
      ],
      "parsedAt": 1769607917936
    },
    "alembic/versions/f7f757414d20_add_error_tracking_to_steps_table.py": {
      "path": "alembic/versions/f7f757414d20_add_error_tracking_to_steps_table.py",
      "contentHash": "36df1b26b425fbaf60d96fa9985a931c",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 43,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961912
    },
    "alembic/versions/f81ceea2c08d_create_sandbox_config_and_sandbox_env_.py": {
      "path": "alembic/versions/f81ceea2c08d_create_sandbox_config_and_sandbox_env_.py",
      "contentHash": "ae82d52a6e4a4ea2e47be8196327d1d6",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 71,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 74,
          "end_line": 82,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961912
    },
    "alembic/versions/f895232c144a_backfill_composio_tools.py": {
      "path": "alembic/versions/f895232c144a_backfill_composio_tools.py",
      "contentHash": "da3518f0179fdd6eb358a5de41ad9801",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 39,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 42,
          "end_line": 60,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961912
    },
    "alembic/versions/f922ca16e42c_add_project_and_template_id_to_agent.py": {
      "path": "alembic/versions/f922ca16e42c_add_project_and_template_id_to_agent.py",
      "contentHash": "4d754fa8e837aa06ef264c081b842f69",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 32,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 35,
          "end_line": 44,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961912
    },
    "alembic/versions/f9ad1c25fd2b_add_query_optimizing_runs_listing.py": {
      "path": "alembic/versions/f9ad1c25fd2b_add_query_optimizing_runs_listing.py",
      "contentHash": "c7801d76cd3b8bf793a5454e8f30478a",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 28,
          "end_line": 31,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961912
    },
    "alembic/versions/fdcdafdb11cf_identity_properties_jsonb_to_json.py": {
      "path": "alembic/versions/fdcdafdb11cf_identity_properties_jsonb_to_json.py",
      "contentHash": "aca86e3f6edb20038b61b70b880ee85c",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 45,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 48,
          "end_line": 69,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961912
    },
    "alembic/versions/ffb17eb241fc_add_api_version_to_byok_providers.py": {
      "path": "alembic/versions/ffb17eb241fc_add_api_version_to_byok_providers.py",
      "contentHash": "c7cee363bd0723ff2b76f3428f1f837c",
      "mtime": 1767315071936.5403,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 28,
          "end_line": 31,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961912
    },
    "alembic/versions/merge_heads_27de_4b9c.py": {
      "path": "alembic/versions/merge_heads_27de_4b9c.py",
      "contentHash": "022286d254bab6189c57cbb11806ccae",
      "mtime": 1769412641092.6182,
      "functions": [
        {
          "name": "upgrade",
          "signature": "def upgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 18,
          "end_line": 19,
          "is_async": false
        },
        {
          "name": "downgrade",
          "signature": "def downgrade() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 22,
          "end_line": 23,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961912
    },
    "enable_graphiti_archival.py": {
      "path": "enable_graphiti_archival.py",
      "contentHash": "c032e2539e4539d41e4d65b27a3aa174",
      "mtime": 1751863300128.777,
      "functions": [
        {
          "name": "patch_tool_executor",
          "signature": "def patch_tool_executor()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Patch the CoreToolExecutor to use GraphitiToolExecutor",
          "decorators": [],
          "start_line": 20,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "patch_dependency_injection",
          "signature": "def patch_dependency_injection()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Patch the dependency injection to use GraphitiToolExecutor",
          "decorators": [],
          "start_line": 46,
          "end_line": 63,
          "is_async": false
        },
        {
          "name": "create_startup_hook",
          "signature": "def create_startup_hook()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Create a startup hook that enables Graphiti when Letta starts",
          "decorators": [],
          "start_line": 66,
          "end_line": 100,
          "is_async": false
        },
        {
          "name": "test_graphiti_connection",
          "signature": "def test_graphiti_connection()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that Graphiti is accessible",
          "decorators": [],
          "start_line": 103,
          "end_line": 127,
          "is_async": false
        },
        {
          "name": ":\n  ",
          "signature": "def :\n    ",
          "parameters": "  ",
          "return_type": null,
          "docstring": "n function to enable Graphiti integration\"\"\"\n    l",
          "decorators": [],
          "start_line": 161,
          "end_line": 198,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961912
    },
    "graphiti_archival_insert.py": {
      "path": "graphiti_archival_insert.py",
      "contentHash": "fc3a5d38e47d9520612312f71698e670",
      "mtime": 1751864756477.068,
      "functions": [
        {
          "name": "archival_memory_insert",
          "signature": "def archival_memory_insert(self, agent_state: AgentState, actor: User, content: str) -> Optional[str]",
          "parameters": "(self, agent_state: AgentState, actor: User, content: str)",
          "return_type": "Optional[str]",
          "docstring": "Add to archival memory. Make sure to phrase the memory contents such that it can be easily queried later.\n\n        Args:\n            content (str): Content to write to the memory. All unicode (including emojis) are supported.\n\n        Returns:\n            Optional[str]: None is always returned as this function does not produce a response.",
          "decorators": [],
          "start_line": 4,
          "end_line": 60,
          "is_async": true
        }
      ],
      "parsedAt": 1769607961912
    },
    "graphiti_modifications.py": {
      "path": "graphiti_modifications.py",
      "contentHash": "d20fe9dac561139a3b741d931932e09c",
      "mtime": 1751864535995.572,
      "functions": [
        {
          "name": "modify_file",
          "signature": "def modify_file(input_file, output_file)",
          "parameters": "(input_file, output_file)",
          "return_type": null,
          "docstring": "Modify the core_tool_executor.py file to use Graphiti",
          "decorators": [],
          "start_line": 168,
          "end_line": 193,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961912
    },
    "letta/agent.py": {
      "path": "letta/agent.py",
      "contentHash": "d844f7ceac9123f8fb9d99c689a9284a",
      "mtime": 1767315071992.5425,
      "functions": [
        {
          "name": "save_agent",
          "signature": "def save_agent(agent: Agent)",
          "parameters": "(agent: Agent)",
          "return_type": null,
          "docstring": "Save agent to metadata store",
          "decorators": [],
          "start_line": 1706,
          "end_line": 1731,
          "is_async": false
        },
        {
          "name": "strip_name_field_from_user_message",
          "signature": "def strip_name_field_from_user_message(user_message_text: str) -> Tuple[str, Optional[str]]",
          "parameters": "(user_message_text: str)",
          "return_type": "Tuple[str, Optional[str]]",
          "docstring": "If 'name' exists in the JSON string, remove it and return the cleaned text + name value",
          "decorators": [],
          "start_line": 1734,
          "end_line": 1747,
          "is_async": false
        },
        {
          "name": "validate_json",
          "signature": "def validate_json(user_message_text: str) -> str",
          "parameters": "(user_message_text: str)",
          "return_type": "str",
          "docstring": "Make sure that the user input message is valid JSON",
          "decorators": [],
          "start_line": 1750,
          "end_line": 1758,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961913
    },
    "letta/agents/helpers.py": {
      "path": "letta/agents/helpers.py",
      "contentHash": "b63619675ca40e66836b55dca43bda93",
      "mtime": 1768610518510.1997,
      "functions": [
        {
          "name": "validate_approval_tool_call_ids",
          "signature": "def validate_approval_tool_call_ids(approval_request_message: Message, approval_response_message: ApprovalCreate)",
          "parameters": "(approval_request_message: Message, approval_response_message: ApprovalCreate)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@trace_method"
          ],
          "start_line": 101,
          "end_line": 125,
          "is_async": false
        },
        {
          "name": "serialize_message_history",
          "signature": "def serialize_message_history(messages: List[str], context: str) -> str",
          "parameters": "(messages: List[str], context: str)",
          "return_type": "str",
          "docstring": "\"\"\"\n    Produce an XML document like:\n\n    <memory>\n      <messages>\n        <message></message>\n        <message></message>\n        \n      </messages>\n      <context></context>\n    </memory>\n    \"\"\"\n    roo",
          "decorators": [],
          "start_line": 259,
          "end_line": 283,
          "is_async": false
        },
        {
          "name": "ize_message_history(xml_str",
          "signature": "def ize_message_history(xml_str: str) -> Tupl -> st[str], str]:\n    \"\"",
          "parameters": ": str) -> Tupl",
          "return_type": "st[str], str]:\n    \"\"",
          "docstring": "Parse the XML back into (messages, context). Raises ValueError if tags are missing.\n    \"\"\"\n    try",
          "decorators": [],
          "start_line": 286,
          "end_line": 309,
          "is_async": false
        },
        {
          "name": "ad_tool_call_str(tool_ca",
          "signature": "def ad_tool_call_str(tool_call_args_str: str) -> dict ->   \"\"",
          "parameters": "ll_args_str: str) -> dict",
          "return_type": "  \"\"",
          "docstring": "nt JSON  dict with fallback to eval on assertion failure.\"\"\"\n    # Tem",
          "decorators": [],
          "start_line": 317,
          "end_line": 332,
          "is_async": false
        },
        {
          "name": "cepts_value(prop_sche",
          "signature": "def cepts_value(prop_schema: Dict[str, Any], value: Any) -> bool:\n -> \"\"\"C",
          "parameters": "ma: Dict[str, Any], value: Any) -> bool:\n",
          "return_type": "\"\"\"C",
          "docstring": "f a value is acceptable for a property schema.\n\n    Handles: type, enum, const, anyOf, oneOf (by shallow traversal).\n    \"\"\"\n    if pr",
          "decorators": [],
          "start_line": 368,
          "end_line": 401,
          "is_async": false
        },
        {
          "name": "validate_prefilled_args(tool: \"To",
          "signature": "def validate_prefilled_args(tool: \"Tool\", llm_args: Dict[str, Any], prefilled_args: Dict[str, Any]) -> Dict[s -> Any]:\n    \"\"\"M",
          "parameters": "ol\", llm_args: Dict[str, Any], prefilled_args: Dict[str, Any]) -> Dict[s",
          "return_type": "Any]:\n    \"\"\"M",
          "docstring": "LM-provided args with prefilled args from tool rules.\n\n    - Overlapping keys are replaced by prefilled values (prefilled wins).\n    - Validates that prefilled keys exist on the tool schema and that values satisfy\n      basic JSON Schema constraints (type/enum/const/anyOf/oneOf).\n    - Returns merged args, or raises ValueError on invalid prefilled inputs.\n    \"\"\"\n    from",
          "decorators": [],
          "start_line": 404,
          "end_line": 432,
          "is_async": false
        },
        {
          "name": "beat(tool_args",
          "signature": "def beat(tool_args: dict) -> bool:\n -> hb =",
          "parameters": ": dict) -> bool:\n",
          "return_type": "hb =",
          "docstring": null,
          "decorators": [],
          "start_line": 435,
          "end_line": 437,
          "is_async": false
        },
        {
          "name": "e_violation_result(tool_name",
          "signature": "def e_violation_result(tool_name: str, valid: list[str], solver: ToolRulesSolver) -> ToolEx -> ionResult:\n    hint",
          "parameters": ": str, valid: list[str], solver: ToolRulesSolver) -> ToolEx",
          "return_type": "ionResult:\n    hint",
          "docstring": null,
          "decorators": [],
          "start_line": 440,
          "end_line": 444,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961913
    },
    "letta/agents/letta_agent_batch.py": {
      "path": "letta/agents/letta_agent_batch.py",
      "contentHash": "067bb8e0f610a49e2cd5a605d727da59",
      "mtime": 1767315071992.5425,
      "functions": [
        {
          "name": "execute_tool_wrapper",
          "signature": "def execute_tool_wrapper(params: ToolExecutionParams) -> tuple[str, ToolExecutionResult]",
          "parameters": "(params: ToolExecutionParams)",
          "return_type": "tuple[str, ToolExecutionResult]",
          "docstring": "\"\"\"\n    Executes the tool in an outofprocess worker and returns:\n        (agent_id, (tool_result:str, success_flag:bool))\n    \"\"\"",
          "decorators": [],
          "start_line": 70,
          "end_line": 96,
          "is_async": true
        }
      ],
      "parsedAt": 1769607961913
    },
    "letta/cli/cli.py": {
      "path": "letta/cli/cli.py",
      "contentHash": "5c501ca774893eed41022849e646e1a0",
      "mtime": 1767315071996.5425,
      "functions": [
        {
          "name": "server",
          "signature": "def server(\n    type: Annotated[ServerChoice, typer.Option(help=\"Server to run\")] = \"rest\",\n    port: Annotated[Optional[int], typer.Option(help=\"Port to run the server on\")] = None,\n    host: Annotated[Optional[str], typer.Option(help=\"Host to run the server on (default to localhost)\")] = None,\n    debug: Annotated[bool, typer.Option(help=\"Turn debugging output on\")] = False,\n    reload: Annotated[bool, typer.Option(help=\"Enable hot-reload\")] = False,\n    ade: Annotated[bool, typer.Option(help=\"Allows remote access\")] = False,  # NOTE: deprecated\n    secure: Annotated[bool, typer.Option(help=\"Adds simple security access\")] = False,\n    localhttps: Annotated[bool, typer.Option(help=\"Setup local https\")] = False,\n)",
          "parameters": "(\n    type: Annotated[ServerChoice, typer.Option(help=\"Server to run\")] = \"rest\",\n    port: Annotated[Optional[int], typer.Option(help=\"Port to run the server on\")] = None,\n    host: Annotated[Optional[str], typer.Option(help=\"Host to run the server on (default to localhost)\")] = None,\n    debug: Annotated[bool, typer.Option(help=\"Turn debugging output on\")] = False,\n    reload: Annotated[bool, typer.Option(help=\"Enable hot-reload\")] = False,\n    ade: Annotated[bool, typer.Option(help=\"Allows remote access\")] = False,  # NOTE: deprecated\n    secure: Annotated[bool, typer.Option(help=\"Adds simple security access\")] = False,\n    localhttps: Annotated[bool, typer.Option(help=\"Setup local https\")] = False,\n)",
          "return_type": null,
          "docstring": "Launch a Letta server process",
          "decorators": [],
          "start_line": 18,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "version",
          "signature": "def version() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 46,
          "end_line": 49,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961913
    },
    "letta/client/utils.py": {
      "path": "letta/client/utils.py",
      "contentHash": "410802ffa754db21e989a8384ca43e8b",
      "mtime": 1767315071996.5425,
      "functions": [
        {
          "name": "pprint",
          "signature": "def pprint(messages)",
          "parameters": "(messages)",
          "return_type": null,
          "docstring": "Utility function for pretty-printing the output of client.send_message in notebooks",
          "decorators": [],
          "start_line": 11,
          "end_line": 66,
          "is_async": false
        },
        {
          "name": "ction_name_regex(function_",
          "signature": "def ction_name_regex(function_string: str) -> Option -> tr]:\n    # Re",
          "parameters": "string: str) -> Option",
          "return_type": "tr]:\n    # Re",
          "docstring": null,
          "decorators": [],
          "start_line": 69,
          "end_line": 78,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961914
    },
    "letta/config/graphiti_config.py": {
      "path": "letta/config/graphiti_config.py",
      "contentHash": "8b0e033956a0c2e233d27f8c5b90fd9a",
      "mtime": 1751863265091.9043,
      "functions": [
        {
          "name": "is_graphiti_enabled",
          "signature": "def is_graphiti_enabled() -> bool",
          "parameters": "()",
          "return_type": "bool",
          "docstring": "Check if Graphiti integration is enabled",
          "decorators": [],
          "start_line": 81,
          "end_line": 83,
          "is_async": false
        },
        {
          "name": "get_graphiti_url",
          "signature": "def get_graphiti_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Get configured Graphiti URL",
          "decorators": [],
          "start_line": 86,
          "end_line": 88,
          "is_async": false
        },
        {
          "name": "enable_graphiti",
          "signature": "def enable_graphiti(url: Optional[str] = None)",
          "parameters": "(url: Optional[str] = None)",
          "return_type": null,
          "docstring": "Enable Graphiti integration programmatically",
          "decorators": [],
          "start_line": 91,
          "end_line": 101,
          "is_async": false
        },
        {
          "name": "disable_graphiti",
          "signature": "def disable_graphiti()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Disable Graphiti integration",
          "decorators": [],
          "start_line": 104,
          "end_line": 108,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961914
    },
    "letta/config.py": {
      "path": "letta/config.py",
      "contentHash": "85e0feb2152ade12050e0bd4842ddc49",
      "mtime": 1767315071996.5425,
      "functions": [
        {
          "name": "get_field",
          "signature": "def get_field(config, section, field)",
          "parameters": "(config, section, field)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 29,
          "is_async": false
        },
        {
          "name": "set_field",
          "signature": "def set_field(config, section, field, value)",
          "parameters": "(config, section, field, value)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 32,
          "end_line": 37,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961914
    },
    "letta/constants.py": {
      "path": "letta/constants.py",
      "contentHash": "539af011818d48ec0ddb09ef0040958b",
      "mtime": 1768610518510.1997,
      "functions": [
        {
          "name": "TION_RETURN_VALUE_TRUNCATED(ret",
          "signature": "def TION_RETURN_VALUE_TRUNCATED(return_str, return_char: int, return_char_limit: int):\n  ",
          "parameters": "urn_str, return_char: int, return_char_limit: int):\n  ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 198,
          "end_line": 201,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961914
    },
    "letta/data_sources/connectors.py": {
      "path": "letta/data_sources/connectors.py",
      "contentHash": "57b7eea49cbd6d1c86e2a66c852eaf95",
      "mtime": 1767315071996.5425,
      "functions": [
        {
          "name": "load_data",
          "signature": "def load_data(connector: DataConnector, source: Source, passage_manager: PassageManager, file_manager: FileManager, actor: \"User\")",
          "parameters": "(connector: DataConnector, source: Source, passage_manager: PassageManager, file_manager: FileManager, actor: \"User\")",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 142,
          "is_async": true
        }
      ],
      "parsedAt": 1769607961914
    },
    "letta/data_sources/connectors_helper.py": {
      "path": "letta/data_sources/connectors_helper.py",
      "contentHash": "2a7c7b3ee63166c8eb24686c59995eb4",
      "mtime": 1767315071996.5425,
      "functions": [
        {
          "name": "extract_file_metadata",
          "signature": "def extract_file_metadata(file_path) -> dict",
          "parameters": "(file_path)",
          "return_type": "dict",
          "docstring": "Extracts metadata from a single file.",
          "decorators": [],
          "start_line": 8,
          "end_line": 21,
          "is_async": false
        },
        {
          "name": "extract_metadata_from_files",
          "signature": "def extract_metadata_from_files(file_list)",
          "parameters": "(file_list)",
          "return_type": null,
          "docstring": "Extracts metadata for a list of files.",
          "decorators": [],
          "start_line": 24,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "get_filenames_in_dir",
          "signature": "def get_filenames_in_dir(\n    input_dir: str, recursive: bool = True, required_exts: Optional[List[str]] = None, exclude: Optional[List[str]] = None\n)",
          "parameters": "(\n    input_dir: str, recursive: bool = True, required_exts: Optional[List[str]] = None, exclude: Optional[List[str]] = None\n)",
          "return_type": null,
          "docstring": "Recursively reads files from the directory, applying required_exts and exclude filters.\n    Ensures that required_exts and exclude do not overlap.\n\n    Args:\n        input_dir (str): The directory to scan for files.\n        recursive (bool): Whether to scan directories recursively.\n        required_exts (list): List of file extensions to include (e.g., ['pdf', 'txt']).\n                             If None or empty, matches any file extension.\n        exclude (list): List of file patterns to exclude (e.g., ['*png', '*jpg']).\n\n    Returns:\n        list: A list of matching file paths.",
          "decorators": [],
          "start_line": 34,
          "end_line": 78,
          "is_async": false
        },
        {
          "name": "assert_all_files_exist_locally",
          "signature": "def assert_all_files_exist_locally(file_paths: List[str]) -> bool",
          "parameters": "(file_paths: List[str])",
          "return_type": "bool",
          "docstring": "Checks if all file paths in the provided list exist locally.\n    Raises a FileNotFoundError with a list of missing files if any do not exist.\n\n    Args:\n        file_paths (List[str]): List of file paths to check.\n\n    Returns:\n        bool: True if all files exist, raises FileNotFoundError if any file is missing.",
          "decorators": [],
          "start_line": 81,
          "end_line": 97,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961914
    },
    "letta/data_sources/redis_client.py": {
      "path": "letta/data_sources/redis_client.py",
      "contentHash": "8bb15b11608972694faebc062be77202",
      "mtime": 1768610518514.1997,
      "functions": [
        {
          "name": "get_redis_client",
          "signature": "def get_redis_client() -> AsyncRedisClient",
          "parameters": "()",
          "return_type": "AsyncRedisClient",
          "docstring": null,
          "decorators": [],
          "start_line": 508,
          "end_line": 526,
          "is_async": true
        }
      ],
      "parsedAt": 1769607961914
    },
    "letta/database_utils.py": {
      "path": "letta/database_utils.py",
      "contentHash": "6e4befca2fca3dd46c324bfc963bacc3",
      "mtime": 1767315071996.5425,
      "functions": [
        {
          "name": "parse_database_uri",
          "signature": "def parse_database_uri(uri: str) -> dict[str, Optional[str]]",
          "parameters": "(uri: str)",
          "return_type": "dict[str, Optional[str]]",
          "docstring": "Parse a database URI into its components.\n\n    Args:\n        uri: Database URI (e.g., postgresql://user:pass@host:port/db)\n\n    Returns:\n        Dictionary with parsed components: scheme, driver, user, password, host, port, database",
          "decorators": [],
          "start_line": 13,
          "end_line": 40,
          "is_async": false
        },
        {
          "name": "build_database_uri",
          "signature": "def build_database_uri(\n    scheme: str = \"postgresql\",\n    driver: Optional[str] = None,\n    user: Optional[str] = None,\n    password: Optional[str] = None,\n    host: Optional[str] = None,\n    port: Optional[str] = None,\n    database: Optional[str] = None,\n    query: Optional[str] = None,\n    fragment: Optional[str] = None,\n) -> str",
          "parameters": "(\n    scheme: str = \"postgresql\",\n    driver: Optional[str] = None,\n    user: Optional[str] = None,\n    password: Optional[str] = None,\n    host: Optional[str] = None,\n    port: Optional[str] = None,\n    database: Optional[str] = None,\n    query: Optional[str] = None,\n    fragment: Optional[str] = None,\n)",
          "return_type": "str",
          "docstring": "Build a database URI from components.\n\n    Args:\n        scheme: Base scheme (e.g., \"postgresql\")\n        driver: Driver name (e.g., \"asyncpg\", \"pg8000\")\n        user: Username\n        password: Password\n        host: Hostname\n        port: Port number\n        database: Database name\n        query: Query string\n        fragment: Fragment\n\n    Returns:\n        Complete database URI",
          "decorators": [],
          "start_line": 43,
          "end_line": 94,
          "is_async": false
        },
        {
          "name": "convert_to_async_uri",
          "signature": "def convert_to_async_uri(uri: str) -> str",
          "parameters": "(uri: str)",
          "return_type": "str",
          "docstring": "Convert a database URI to use the asyncpg driver for async operations.\n\n    Args:\n        uri: Original database URI\n\n    Returns:\n        URI with asyncpg driver and ssl parameter adjustments",
          "decorators": [],
          "start_line": 97,
          "end_line": 118,
          "is_async": false
        },
        {
          "name": "convert_to_sync_uri",
          "signature": "def convert_to_sync_uri(uri: str) -> str",
          "parameters": "(uri: str)",
          "return_type": "str",
          "docstring": "Convert a database URI to use the pg8000 driver for sync operations (alembic).\n\n    Args:\n        uri: Original database URI\n\n    Returns:\n        URI with pg8000 driver and sslmode parameter adjustments",
          "decorators": [],
          "start_line": 121,
          "end_line": 142,
          "is_async": false
        },
        {
          "name": "get_database_uri_for_context",
          "signature": "def get_database_uri_for_context(uri: str, context: str = \"async\") -> str",
          "parameters": "(uri: str, context: str = \"async\")",
          "return_type": "str",
          "docstring": "Get the appropriate database URI for a specific context.\n\n    Args:\n        uri: Original database URI\n        context: Context type (\"async\" for asyncpg, \"sync\" for pg8000, \"alembic\" for pg8000)\n\n    Returns:\n        URI formatted for the specified context",
          "decorators": [],
          "start_line": 145,
          "end_line": 161,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961914
    },
    "letta/exceptions/logging.py": {
      "path": "letta/exceptions/logging.py",
      "contentHash": "dfce10c7b3f6ffe68dd7ded21a0df25c",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "log_and_raise",
          "signature": "def log_and_raise(\n    exception: Exception,\n    message: str,\n    context: Optional[Dict[str, Any]] = None,\n    level: str = \"error\",\n) -> None",
          "parameters": "(\n    exception: Exception,\n    message: str,\n    context: Optional[Dict[str, Any]] = None,\n    level: str = \"error\",\n)",
          "return_type": "None",
          "docstring": "Log an exception with structured context and then raise it.\n\n    This is useful when you want to ensure an exception is logged with\n    full context before raising it.\n\n    Args:\n        exception: The exception to log and raise\n        message: Human-readable message to log\n        context: Additional context to include in logs (dict)\n        level: Log level (default: \"error\")\n\n    Example:\n        try:\n            result = some_operation()\n        except ValueError as e:\n            log_and_raise(\n                e,\n                \"Failed to process operation\",\n                context={\n                    \"user_id\": user.id,\n                    \"operation\": \"some_operation\",\n                    \"input\": input_data,\n                }\n            )",
          "decorators": [],
          "start_line": 13,
          "end_line": 61,
          "is_async": false
        },
        {
          "name": "log_exception",
          "signature": "def log_exception(\n    exception: Exception,\n    message: str,\n    context: Optional[Dict[str, Any]] = None,\n    level: str = \"error\",\n) -> None",
          "parameters": "(\n    exception: Exception,\n    message: str,\n    context: Optional[Dict[str, Any]] = None,\n    level: str = \"error\",\n)",
          "return_type": "None",
          "docstring": "Log an exception with structured context without raising it.\n\n    Use this when you want to log an exception but handle it gracefully.\n\n    Args:\n        exception: The exception to log\n        message: Human-readable message to log\n        context: Additional context to include in logs (dict)\n        level: Log level (default: \"error\")\n\n    Example:\n        try:\n            result = some_operation()\n        except ValueError as e:\n            log_exception(\n                e,\n                \"Operation failed, using fallback\",\n                context={\"user_id\": user.id}\n            )\n            result = fallback_operation()",
          "decorators": [],
          "start_line": 64,
          "end_line": 106,
          "is_async": false
        },
        {
          "name": "add_exception_context",
          "signature": "def add_exception_context(exception: Exception, **context) -> Exception",
          "parameters": "(exception: Exception, **context)",
          "return_type": "Exception",
          "docstring": "Add context to an exception that will be picked up by the global exception handler.\n\n    This attaches a __letta_context__ attribute to the exception with structured data.\n    The global exception handler will automatically include this context in logs.\n\n    Args:\n        exception: The exception to add context to\n        **context: Key-value pairs to add as context\n\n    Returns:\n        The same exception with context attached\n\n    Example:\n        try:\n            result = operation()\n        except ValueError as e:\n            raise add_exception_context(\n                e,\n                user_id=user.id,\n                operation=\"do_thing\",\n                input_data=data,\n            )",
          "decorators": [],
          "start_line": 109,
          "end_line": 137,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961914
    },
    "letta/functions/ast_parsers.py": {
      "path": "letta/functions/ast_parsers.py",
      "contentHash": "b0545a4cfb6c34e0eef9f85288c64491",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "resolve_type",
          "signature": "def resolve_type(annotation: str)",
          "parameters": "(annotation: str)",
          "return_type": null,
          "docstring": "Resolve a type annotation string into a Python type.\n    Previously, primitive support for int, float, str, dict, list, set, tuple, bool.\n\n    Args:\n        annotation (str): The annotation string (e.g., 'int', 'list[int]', 'dict[str, int]').\n\n    Returns:\n        type: The corresponding Python type.\n\n    Raises:\n        ValueError: If the annotation is unsupported or invalid.",
          "decorators": [],
          "start_line": 11,
          "end_line": 34,
          "is_async": false
        },
        {
          "name": "get_function_annotations_from_source",
          "signature": "def get_function_annotations_from_source(source_code: str, function_name: str) -> Dict[str, str]",
          "parameters": "(source_code: str, function_name: str)",
          "return_type": "Dict[str, str]",
          "docstring": "Parse the source code to extract annotations for a given function name.\n\n    Args:\n        source_code (str): The Python source code containing the function.\n        function_name (str): The name of the function to extract annotations for.\n\n    Returns:\n        Dict[str, str]: A dictionary of argument names to their annotation strings.\n\n    Raises:\n        ValueError: If the function is not found in the source code.",
          "decorators": [],
          "start_line": 38,
          "end_line": 61,
          "is_async": false
        },
        {
          "name": "coerce_dict_args_by_annotations",
          "signature": "def coerce_dict_args_by_annotations(function_args: JsonDict, annotations: Dict[str, str]) -> dict",
          "parameters": "(function_args: JsonDict, annotations: Dict[str, str])",
          "return_type": "dict",
          "docstring": null,
          "decorators": [],
          "start_line": 65,
          "end_line": 96,
          "is_async": false
        },
        {
          "name": "get_function_name_and_docstring",
          "signature": "def get_function_name_and_docstring(source_code: str, name: Optional[str] = None) -> Tuple[str, str]",
          "parameters": "(source_code: str, name: Optional[str] = None)",
          "return_type": "Tuple[str, str]",
          "docstring": "Gets the name and docstring for a given function source code by parsing the AST.\n\n    Args:\n        source_code: The source code to parse\n        name: Optional override for the function name\n\n    Returns:\n        Tuple of (function_name, docstring)",
          "decorators": [],
          "start_line": 99,
          "end_line": 141,
          "is_async": false
        }
      ],
      "parsedAt": 1769607961914
    },
    "letta/functions/composio_helpers.py": {
      "path": "letta/functions/composio_helpers.py",
      "contentHash": "1c1a0802cbe3e1b4bb958935ca58d853",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "generate_composio_action_from_func_name",
          "signature": "def generate_composio_action_from_func_name(func_name: str) -> str",
          "parameters": "(func_name: str)",
          "return_type": "str",
          "docstring": "Generates the composio action from the composio function name.\n\n    Args:\n        func_name: The composio function name\n\n    Returns:\n        composio action name",
          "decorators": [],
          "start_line": 33,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "generate_composio_tool_wrapper",
          "signature": "def generate_composio_tool_wrapper(action_name: str) -> tuple[str, str]",
          "parameters": "(action_name: str)",
          "return_type": "tuple[str, str]",
          "docstring": null,
          "decorators": [],
          "start_line": 46,
          "end_line": 58,
          "is_async": false
        },
        {
          "name": "execute_composio_action_async",
          "signature": "def execute_composio_action_async(\n    action_name: str, args: dict, api_key: Optional[str] = None, entity_id: Optional[str] = None\n) -> tuple[str, str]",
          "parameters": "(\n    action_name: str, args: dict, api_key: Optional[str] = None, entity_id: Optional[str] = None\n)",
          "return_type": "tuple[str, str]",
          "docstring": null,
          "decorators": [],
          "start_line": 61,
          "end_line": 85,
          "is_async": true
        },
        {
          "name": "execute_composio_action",
          "signature": "def execute_composio_action(action_name: str, args: dict, api_key: Optional[str] = None, entity_id: Optional[str] = None) -> Any",
          "parameters": "(action_name: str, args: dict, api_key: Optional[str] = None, entity_id: Optional[str] = None)",
          "return_type": "Any",
          "docstring": null,
          "decorators": [],
          "start_line": 88,
          "end_line": 89,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991577
    },
    "letta/functions/function_sets/base.py": {
      "path": "letta/functions/function_sets/base.py",
      "contentHash": "c277f5bcebb348799278ba86ff4873f0",
      "mtime": 1768610518514.1997,
      "functions": [
        {
          "name": "memory",
          "signature": "def memory(\n    agent_state: \"AgentState\",\n    command: str,\n    path: Optional[str] = None,\n    file_text: Optional[str] = None,\n    description: Optional[str] = None,\n    old_str: Optional[str] = None,\n    new_str: Optional[str] = None,\n    insert_line: Optional[int] = None,\n    insert_text: Optional[str] = None,\n    old_path: Optional[str] = None,\n    new_path: Optional[str] = None,\n) -> Optional[str]",
          "parameters": "(\n    agent_state: \"AgentState\",\n    command: str,\n    path: Optional[str] = None,\n    file_text: Optional[str] = None,\n    description: Optional[str] = None,\n    old_str: Optional[str] = None,\n    new_str: Optional[str] = None,\n    insert_line: Optional[int] = None,\n    insert_text: Optional[str] = None,\n    old_path: Optional[str] = None,\n    new_path: Optional[str] = None,\n)",
          "return_type": "Optional[str]",
          "docstring": "Memory management tool with various sub-commands for memory block operations.\n\n    Args:\n        command (str): The sub-command to execute. Supported commands:\n            - \"create\": Create a new memory block\n            - \"str_replace\": Replace text in a memory block\n            - \"insert\": Insert text at a specific line in a memory block\n            - \"delete\": Delete a memory block\n            - \"rename\": Rename a memory block\n        path (Optional[str]): Path to the memory block (for str_replace, insert, delete)\n        file_text (Optional[str]): The value to set in the memory block (for create)\n        description (Optional[str]): The description to set in the memory block (for create, rename)\n        old_str (Optional[str]): Old text to replace (for str_replace)\n        new_str (Optional[str]): New text to replace with (for str_replace)\n        insert_line (Optional[int]): Line number to insert at (for insert)\n        insert_text (Optional[str]): Text to insert (for insert)\n        old_path (Optional[str]): Old path for rename operation\n        new_path (Optional[str]): New path for rename operation\n\n    Returns:\n        Optional[str]: Success message or error description\n\n    Examples:\n        # Replace text in a memory block\n        memory(agent_state, \"str_replace\", path=\"/memories/user_preferences\", old_str=\"theme: dark\", new_str=\"theme: light\")\n\n        # Insert text at line 5\n        memory(agent_state, \"insert\", path=\"/memories/notes\", insert_line=5, insert_text=\"New note here\")\n\n        # Delete a memory block\n        memory(agent_state, \"delete\", path=\"/memories/old_notes\")\n\n        # Rename a memory block\n        memory(agent_state, \"rename\", old_path=\"/memories/temp\", new_path=\"/memories/permanent\")\n\n        # Update the description of a memory block\n        memory(agent_state, \"rename\", path=\"/memories/temp\", description=\"The user's temporary notes.\")\n\n        # Create a memory block with starting text\n        memory(agent_state, \"create\", path=\"/memories/coding_preferences\", \"description\": \"The user's coding preferences.\", \"file_text\": \"The user seems to add type hints to all of their Python code.\")\n\n        # Create an empty memory block\n        memory(agent_state, \"create\", path=\"/memories/coding_preferences\", \"description\": \"The user's coding preferences.\")",
          "decorators": [],
          "start_line": 9,
          "end_line": 67,
          "is_async": false
        },
        {
          "name": "send_message",
          "signature": "def send_message(self: \"Agent\", message: str) -> Optional[str]",
          "parameters": "(self: \"Agent\", message: str)",
          "return_type": "Optional[str]",
          "docstring": "Sends a message to the human user.\n\n    Args:\n        message (str): Message contents. All unicode (including emojis) are supported.\n\n    Returns:\n        Optional[str]: None is always returned as this function does not produce a response.",
          "decorators": [],
          "start_line": 70,
          "end_line": 83,
          "is_async": false
        },
        {
          "name": "conversation_search",
          "signature": "def conversation_search(\n    self: \"Agent\",\n    query: str,\n    roles: Optional[List[Literal[\"assistant\", \"user\", \"tool\"]]] = None,\n    limit: Optional[int] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n) -> Optional[str]",
          "parameters": "(\n    self: \"Agent\",\n    query: str,\n    roles: Optional[List[Literal[\"assistant\", \"user\", \"tool\"]]] = None,\n    limit: Optional[int] = None,\n    start_date: Optional[str] = None,\n    end_date: Optional[str] = None,\n)",
          "return_type": "Optional[str]",
          "docstring": "Search prior conversation history using hybrid search (text + semantic similarity).\n\n    Args:\n        query (str): String to search for using both text matching and semantic similarity.\n        roles (Optional[List[Literal[\"assistant\", \"user\", \"tool\"]]]): Optional list of message roles to filter by.\n        limit (Optional[int]): Maximum number of results to return. Uses system default if not specified.\n        start_date (Optional[str]): Filter results to messages created on or after this date (INCLUSIVE). When using date-only format (e.g., \"2024-01-15\"), includes messages starting from 00:00:00 of that day. ISO 8601 format: \"YYYY-MM-DD\" or \"YYYY-MM-DDTHH:MM\". Examples: \"2024-01-15\" (from start of Jan 15), \"2024-01-15T14:30\" (from 2:30 PM on Jan 15).\n        end_date (Optional[str]): Filter results to messages created on or before this date (INCLUSIVE). When using date-only format (e.g., \"2024-01-20\"), includes all messages from that entire day. ISO 8601 format: \"YYYY-MM-DD\" or \"YYYY-MM-DDTHH:MM\". Examples: \"2024-01-20\" (includes all of Jan 20), \"2024-01-20T17:00\" (up to 5 PM on Jan 20).\n\n    Examples:\n        # Search all messages\n        conversation_search(query=\"project updates\")\n\n        # Search only assistant messages\n        conversation_search(query=\"error handling\", roles=[\"assistant\"])\n\n        # Search with date range (inclusive of both dates)\n        conversation_search(query=\"meetings\", start_date=\"2024-01-15\", end_date=\"2024-01-20\")\n        # This includes all messages from Jan 15 00:00:00 through Jan 20 23:59:59\n\n        # Search messages from a specific day (inclusive)\n        conversation_search(query=\"bug reports\", start_date=\"2024-09-04\", end_date=\"2024-09-04\")\n        # This includes ALL messages from September 4, 2024\n\n        # Search with specific time boundaries\n        conversation_search(query=\"deployment\", start_date=\"2024-01-15T09:00\", end_date=\"2024-01-15T17:30\")\n        # This includes messages from 9 AM to 5:30 PM on Jan 15\n\n        # Search with limit\n        conversation_search(query=\"debugging\", limit=10)\n\n    Returns:\n        str: Query result string containing matching messages with timestamps and content.",
          "decorators": [],
          "start_line": 86,
          "end_line": 156,
          "is_async": false
        },
        {
          "name": "archival_memory_insert",
          "signature": "def archival_memory_insert(self: \"Agent\", content: str, tags: Optional[list[str]] = None) -> Optional[str]",
          "parameters": "(self: \"Agent\", content: str, tags: Optional[list[str]] = None)",
          "return_type": "Optional[str]",
          "docstring": "Add information to long-term archival memory for later retrieval.\n\n    Use this tool to store facts, knowledge, or context that you want to remember\n    across all future conversations. Archival memory is permanent and searchable by\n    semantic similarity.\n\n    Best practices:\n    - Store self-contained facts or summaries, not conversational fragments\n    - Add descriptive tags to make information easier to find later\n    - Use for: meeting notes, project updates, conversation summaries, events, reports\n    - Information stored here persists indefinitely and can be searched semantically\n\n    Args:\n        content: The information to store. Should be clear and self-contained.\n        tags: Optional list of category tags (e.g., [\"meetings\", \"project-updates\"])\n\n    Returns:\n        Confirmation message with the ID of the inserted memory.\n\n    Examples:\n        archival_memory_insert(\n            content=\"Meeting on 2024-03-15: Discussed Q2 roadmap priorities. Decided to focus on performance optimization and API v2 release. John will lead the optimization effort.\",\n            tags=[\"meetings\", \"roadmap\", \"q2-2024\"]\n        )",
          "decorators": [],
          "start_line": 159,
          "end_line": 186,
          "is_async": true
        },
        {
          "name": "archival_memory_search",
          "signature": "def archival_memory_search(\n    self: \"Agent\",\n    query: str,\n    tags: Optional[list[str]] = None,\n    tag_match_mode: Literal[\"any\", \"all\"] = \"any\",\n    top_k: Optional[int] = None,\n    start_datetime: Optional[str] = None,\n    end_datetime: Optional[str] = None,\n) -> Optional[str]",
          "parameters": "(\n    self: \"Agent\",\n    query: str,\n    tags: Optional[list[str]] = None,\n    tag_match_mode: Literal[\"any\", \"all\"] = \"any\",\n    top_k: Optional[int] = None,\n    start_datetime: Optional[str] = None,\n    end_datetime: Optional[str] = None,\n)",
          "return_type": "Optional[str]",
          "docstring": "Search archival memory using semantic similarity to find relevant information.\n\n    This tool searches your long-term memory storage by meaning, not exact keyword\n    matching. Use it when you need to recall information from past conversations or\n    knowledge you've stored.\n\n    Search strategy:\n    - Query by concept/meaning, not exact phrases\n    - Use tags to narrow results when you know the category\n    - Start broad, then narrow with tags if needed\n    - Results are ranked by semantic relevance\n\n    Args:\n        query: What you're looking for, described naturally (e.g., \"meetings about API redesign\")\n        tags: Filter to memories with these tags. Use tag_match_mode to control matching.\n        tag_match_mode: \"any\" = match memories with ANY of the tags, \"all\" = match only memories with ALL tags\n        start_datetime: Only return memories created after this time (ISO 8601: \"2024-01-15\" or \"2024-01-15T14:30\")\n        end_datetime: Only return memories created before this time (ISO 8601 format)\n        top_k: Maximum number of results to return (default: 10)\n\n    Returns:\n        A list of relevant memories with IDs, timestamps, and content, ranked by similarity.\n\n    Examples:\n        # Search for project discussions\n        archival_memory_search(\n            query=\"database migration decisions and timeline\",\n            tags=[\"projects\"]\n        )\n\n        # Search meeting notes from Q1\n        archival_memory_search(\n            query=\"roadmap planning discussions\",\n            start_datetime=\"2024-01-01\",\n            end_datetime=\"2024-03-31\",\n            tags=[\"meetings\", \"roadmap\"],\n            tag_match_mode=\"all\"\n        )",
          "decorators": [],
          "start_line": 189,
          "end_line": 238,
          "is_async": true
        },
        {
          "name": "core_memory_append",
          "signature": "def core_memory_append(agent_state: \"AgentState\", label: str, content: str) -> Optional[str]",
          "parameters": "(agent_state: \"AgentState\", label: str, content: str)",
          "return_type": "Optional[str]",
          "docstring": "Append to the contents of core memory.\n\n    Args:\n        label (str): Section of the memory to be edited.\n        content (str): Content to write to the memory. All unicode (including emojis) are supported.\n\n    Returns:\n        Optional[str]: None is always returned as this function does not produce a response.",
          "decorators": [],
          "start_line": 241,
          "end_line": 255,
          "is_async": false
        },
        {
          "name": "core_memory_replace",
          "signature": "def core_memory_replace(agent_state: \"AgentState\", label: str, old_content: str, new_content: str) -> Optional[str]",
          "parameters": "(agent_state: \"AgentState\", label: str, old_content: str, new_content: str)",
          "return_type": "Optional[str]",
          "docstring": "Replace the contents of core memory. To delete memories, use an empty string for new_content.\n\n    Args:\n        label (str): Section of the memory to be edited.\n        old_content (str): String to replace. Must be an exact match.\n        new_content (str): Content to write to the memory. All unicode (including emojis) are supported.\n\n    Returns:\n        Optional[str]: None is always returned as this function does not produce a response.",
          "decorators": [],
          "start_line": 258,
          "end_line": 275,
          "is_async": false
        },
        {
          "name": "rethink_memory",
          "signature": "def rethink_memory(agent_state: \"AgentState\", new_memory: str, target_block_label: str) -> None",
          "parameters": "(agent_state: \"AgentState\", new_memory: str, target_block_label: str)",
          "return_type": "None",
          "docstring": "Rewrite memory block for the main agent, new_memory should contain all current information from the block that is not outdated or inconsistent, integrating any new information, resulting in a new memory block that is organized, readable, and comprehensive.\n\n    Args:\n        new_memory (str): The new memory with information integrated from the memory block. If there is no new information, then this should be the same as the content in the source block.\n        target_block_label (str): The name of the block to write to.\n\n    Returns:\n        None: None is always returned as this function does not produce a response.",
          "decorators": [],
          "start_line": 278,
          "end_line": 297,
          "is_async": false
        },
        {
          "name": "memory_replace",
          "signature": "def memory_replace(agent_state: \"AgentState\", label: str, old_str: str, new_str: str) -> str",
          "parameters": "(agent_state: \"AgentState\", label: str, old_str: str, new_str: str)",
          "return_type": "str",
          "docstring": "\"\"\"\n    The memory_replace command allows you to replace a specific string in a memory block with a new string. This is used for making precise edits.\n    Do NOT attempt to replace long strings, e.g. do not attempt to replace the entire contents of a memory block with a new string.\n\n    Args:\n        label (str): Section of the memory to be edited, identified by its label.\n        old_str (str): The text to replace (must match exactly, including whitespace and indentation).\n        new_str (str): The new text to insert in place of the old text. Do not include line number prefixes.\n\n    Examples:\n        # Update a block containing information about the user\n        memory_replace(label=\"human\", old_str=\"Their name is Alice\", new_str=\"Their name is Bob\")\n\n        # Update a block containing a todo list\n        memory_replace(label=\"todos\", old_str=\"- [ ] Step 5: Search the web\", new_str=\"- [x] Step 5: Search the web\")\n\n        # Pass an empty string to\n        memory_replace(label=\"human\", old_str=\"Their name is Alice\", new_str=\"\")\n\n        # Bad example - do NOT add (view-only) line numbers to the args\n        memory_replace(label=\"human\", old_str=\"1: Their name is Alice\", new_str=\"1: Their name is Bob\")\n\n        # Bad example - do NOT include the line number warning either\n        memory_replace(label=\"human\", old_str=\"# NOTE: Line numbers shown below (with arrows like '1') are to help during editing. Do NOT include line number prefixes in your memory edit tool calls.\\\\n1 Their name is Alice\", new_str=\"1 Their name is Bob\")\n\n        # Good example - no line numbers or line number warning (they are view-only), just the text\n        memory_replace(label=\"human\", old_str=\"Their name is Alice\", new_str=\"Their name is Bob\")\n\n    Returns:\n        str: The success message\n    \"\"\"\n    i",
          "decorators": [],
          "start_line": 306,
          "end_line": 390,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991577
    },
    "letta/functions/function_sets/builtin.py": {
      "path": "letta/functions/function_sets/builtin.py",
      "contentHash": "3198121ae63f3a26de03696a33b1bd1b",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "run_code",
          "signature": "def run_code(code: str, language: Literal[\"python\", \"js\", \"ts\", \"r\", \"java\"]) -> str",
          "parameters": "(code: str, language: Literal[\"python\", \"js\", \"ts\", \"r\", \"java\"])",
          "return_type": "str",
          "docstring": "Run code in a sandbox. Supports Python, Javascript, Typescript, R, and Java.\n\n    Args:\n        code (str): The code to run.\n        language (Literal[\"python\", \"js\", \"ts\", \"r\", \"java\"]): The language of the code.\n    Returns:\n        str: The output of the code, the stdout, the stderr, and error traces (if any).",
          "decorators": [],
          "start_line": 4,
          "end_line": 15,
          "is_async": false
        },
        {
          "name": "run_code_with_tools",
          "signature": "def run_code_with_tools(code: str) -> str",
          "parameters": "(code: str)",
          "return_type": "str",
          "docstring": "Run code with access to the tools of the agent. Only support python. You can directly invoke the tools of the agent in the code.\n    Args:\n        code (str): The python code to run.\n    Returns:\n        str: The output of the code, the stdout, the stderr, and error traces (if any).",
          "decorators": [],
          "start_line": 18,
          "end_line": 27,
          "is_async": false
        },
        {
          "name": "web_search",
          "signature": "def web_search(\n    query: str,\n    num_results: int = 10,\n    category: Optional[\n        Literal[\"company\", \"research paper\", \"news\", \"pdf\", \"github\", \"tweet\", \"personal site\", \"linkedin profile\", \"financial report\"]\n    ] = None,\n    include_text: bool = False,\n    include_domains: Optional[List[str]] = None,\n    exclude_domains: Optional[List[str]] = None,\n    start_published_date: Optional[str] = None,\n    end_published_date: Optional[str] = None,\n    user_location: Optional[str] = None,\n) -> str",
          "parameters": "(\n    query: str,\n    num_results: int = 10,\n    category: Optional[\n        Literal[\"company\", \"research paper\", \"news\", \"pdf\", \"github\", \"tweet\", \"personal site\", \"linkedin profile\", \"financial report\"]\n    ] = None,\n    include_text: bool = False,\n    include_domains: Optional[List[str]] = None,\n    exclude_domains: Optional[List[str]] = None,\n    start_published_date: Optional[str] = None,\n    end_published_date: Optional[str] = None,\n    user_location: Optional[str] = None,\n)",
          "return_type": "str",
          "docstring": "Search the web using Exa's AI-powered search engine and retrieve relevant content.\n\n    Examples:\n    web_search(\"Tesla Q1 2025 earnings report\", num_results=5, category=\"financial report\")\n    web_search(\"Latest research in large language models\", category=\"research paper\", include_domains=[\"arxiv.org\", \"paperswithcode.com\"])\n    web_search(\"Letta API documentation core_memory_append\", num_results=3)\n\n    Args:\n        query (str): The search query to find relevant web content.\n        num_results (int, optional): Number of results to return (1-100). Defaults to 10.\n        category (Optional[Literal], optional): Focus search on specific content types. Defaults to None.\n        include_text (bool, optional): Whether to retrieve full page content. Defaults to False (only returns summary and highlights, since the full text usually will overflow the context window).\n        include_domains (Optional[List[str]], optional): List of domains to include in search results. Defaults to None.\n        exclude_domains (Optional[List[str]], optional): List of domains to exclude from search results. Defaults to None.\n        start_published_date (Optional[str], optional): Only return content published after this date (ISO format). Defaults to None.\n        end_published_date (Optional[str], optional): Only return content published before this date (ISO format). Defaults to None.\n        user_location (Optional[str], optional): Two-letter country code for localized results (e.g., \"US\"). Defaults to None.\n\n    Returns:\n        str: A JSON-encoded string containing search results with title, URL, content, highlights, and summary.",
          "decorators": [],
          "start_line": 30,
          "end_line": 65,
          "is_async": true
        },
        {
          "name": "fetch_webpage",
          "signature": "def fetch_webpage(url: str) -> str",
          "parameters": "(url: str)",
          "return_type": "str",
          "docstring": "Fetch a webpage and convert it to markdown/text format using Exa API (if available) or trafilatura/readability.\n\n    Args:\n        url: The URL of the webpage to fetch and convert\n\n    Returns:\n        String containing the webpage content in markdown/text format",
          "decorators": [],
          "start_line": 68,
          "end_line": 78,
          "is_async": true
        }
      ],
      "parsedAt": 1769607991577
    },
    "letta/functions/function_sets/extras.py": {
      "path": "letta/functions/function_sets/extras.py",
      "contentHash": "d30d71f19d2096d636f3ac870e758f76",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "message_chatgpt",
          "signature": "def message_chatgpt(self, message: str)",
          "parameters": "(self, message: str)",
          "return_type": null,
          "docstring": "Send a message to a more basic AI, ChatGPT. A useful resource for asking questions. ChatGPT does not retain memory of previous interactions.\n\n    Args:\n        message (str): Message to send ChatGPT. Phrase your message as a full English sentence.\n\n    Returns:\n        str: Reply message from ChatGPT",
          "decorators": [],
          "start_line": 14,
          "end_line": 42,
          "is_async": false
        },
        {
          "name": "read_from_text_file",
          "signature": "def read_from_text_file(self, filename: str, line_start: int, num_lines: Optional[int] = 1)",
          "parameters": "(self, filename: str, line_start: int, num_lines: Optional[int] = 1)",
          "return_type": null,
          "docstring": "Read lines from a text file.\n\n    Args:\n        filename (str): The name of the file to read.\n        line_start (int): Line to start reading from.\n        num_lines (Optional[int]): How many lines to read (defaults to 1).\n\n    Returns:\n        str: Text read from the file",
          "decorators": [],
          "start_line": 45,
          "end_line": 84,
          "is_async": false
        },
        {
          "name": "append_to_text_file",
          "signature": "def append_to_text_file(self, filename: str, content: str)",
          "parameters": "(self, filename: str, content: str)",
          "return_type": null,
          "docstring": "Append to a text file.\n\n    Args:\n        filename (str): The name of the file to append to.\n        content (str): Content to append to the file.\n\n    Returns:\n        Optional[str]: None is always returned as this function does not produce a response.",
          "decorators": [],
          "start_line": 87,
          "end_line": 102,
          "is_async": false
        },
        {
          "name": "http_request",
          "signature": "def http_request(self, method: str, url: str, payload_json: Optional[str] = None)",
          "parameters": "(self, method: str, url: str, payload_json: Optional[str] = None)",
          "return_type": null,
          "docstring": "Generates an HTTP request and returns the response.\n\n    Args:\n        method (str): The HTTP method (e.g., 'GET', 'POST').\n        url (str): The URL for the request.\n        payload_json (Optional[str]): A JSON string representing the request payload.\n\n    Returns:\n        dict: The response from the HTTP request.",
          "decorators": [],
          "start_line": 105,
          "end_line": 135,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991577
    },
    "letta/functions/function_sets/files.py": {
      "path": "letta/functions/function_sets/files.py",
      "contentHash": "919c74a378effd3c649c67300dccffc4",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "open_files",
          "signature": "def open_files(agent_state: \"AgentState\", file_requests: List[FileOpenRequest], close_all_others: bool = False) -> str",
          "parameters": "(agent_state: \"AgentState\", file_requests: List[FileOpenRequest], close_all_others: bool = False)",
          "return_type": "str",
          "docstring": "Open one or more files and load their contents into files section in core memory. Maximum of 5 files can be opened simultaneously.\n\n    Use this when you want to:\n    - Inspect or reference file contents during reasoning\n    - View specific portions of large files (e.g. functions or definitions)\n    - Replace currently open files with a new set for focused context (via `close_all_others=True`)\n\n    Examples:\n        Open single file belonging to a directory named `project_utils` (entire content):\n            file_requests = [FileOpenRequest(file_name=\"project_utils/config.py\")]\n\n        Open multiple files with different view ranges:\n            file_requests = [\n                FileOpenRequest(file_name=\"project_utils/config.py\", offset=0, length=50),     # Lines 1-50\n                FileOpenRequest(file_name=\"project_utils/main.py\", offset=100, length=100),    # Lines 101-200\n                FileOpenRequest(file_name=\"project_utils/utils.py\")                            # Entire file\n            ]\n\n        Close all other files and open new ones:\n            open_files(agent_state, file_requests, close_all_others=True)\n\n    Args:\n        file_requests (List[FileOpenRequest]): List of file open requests, each specifying file name and optional view range.\n        close_all_others (bool): If True, closes all other currently open files first. Defaults to False.\n\n    Returns:\n        str: A status message",
          "decorators": [],
          "start_line": 10,
          "end_line": 39,
          "is_async": true
        },
        {
          "name": "grep_files",
          "signature": "def grep_files(\n    agent_state: \"AgentState\",\n    pattern: str,\n    include: Optional[str] = None,\n    context_lines: Optional[int] = 1,\n    offset: Optional[int] = None,\n) -> str",
          "parameters": "(\n    agent_state: \"AgentState\",\n    pattern: str,\n    include: Optional[str] = None,\n    context_lines: Optional[int] = 1,\n    offset: Optional[int] = None,\n)",
          "return_type": "str",
          "docstring": "Searches file contents for pattern matches with surrounding context.\n\n    Results are paginated - shows 20 matches per call. The response includes:\n    - A summary of total matches and which files contain them\n    - The current page of matches (20 at a time)\n    - Instructions for viewing more matches using the offset parameter\n\n    Example usage:\n        First call: grep_files(pattern=\"TODO\")\n        Next call: grep_files(pattern=\"TODO\", offset=20)  # Shows matches 21-40\n\n    Returns search results containing:\n    - Summary with total match count and file distribution\n    - List of files with match counts per file\n    - Current page of matches (up to 20)\n    - Navigation hint for next page if more matches exist\n\n    Args:\n        pattern (str): Keyword or regex pattern to search within file contents.\n        include (Optional[str]): Optional keyword or regex pattern to filter filenames to include in the search.\n        context_lines (Optional[int]): Number of lines of context to show before and after each match.\n                                       Equivalent to `-C` in grep_files. Defaults to 1.\n        offset (Optional[int]): Number of matches to skip before showing results. Used for pagination.\n                                For example, offset=20 shows matches starting from the 21st match.\n                                Use offset=0 (or omit) for first page, offset=20 for second page,\n                                offset=40 for third page, etc. The tool will tell you the exact\n                                offset to use for the next page.",
          "decorators": [],
          "start_line": 42,
          "end_line": 78,
          "is_async": true
        },
        {
          "name": "semantic_search_files",
          "signature": "def semantic_search_files(agent_state: \"AgentState\", query: str, limit: int = 5) -> List[\"FileMetadata\"]",
          "parameters": "(agent_state: \"AgentState\", query: str, limit: int = 5)",
          "return_type": "List[\"FileMetadata\"]",
          "docstring": "Searches file contents using semantic meaning rather than exact matches.\n\n    Ideal for:\n    - Finding conceptually related information across files\n    - Discovering relevant content without knowing exact keywords\n    - Locating files with similar topics or themes\n\n    Args:\n        query (str): The search query text to find semantically similar content.\n        limit: Maximum number of results to return (default: 5)\n\n    Returns:\n        List[FileMetadata]: List of matching files.",
          "decorators": [],
          "start_line": 81,
          "end_line": 97,
          "is_async": true
        }
      ],
      "parsedAt": 1769607991577
    },
    "letta/functions/function_sets/multi_agent.py": {
      "path": "letta/functions/function_sets/multi_agent.py",
      "contentHash": "248bb7e61c78b46e70660ba5b2bb7bae",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "send_message_to_agent_and_wait_for_reply",
          "signature": "def send_message_to_agent_and_wait_for_reply(self: \"Agent\", message: str, other_agent_id: str) -> str",
          "parameters": "(self: \"Agent\", message: str, other_agent_id: str)",
          "return_type": "str",
          "docstring": "Sends a message to a specific Letta agent within the same organization and waits for a response. The sender's identity is automatically included, so no explicit introduction is needed in the message. This function is designed for two-way communication where a reply is expected.\n\n    Args:\n        message (str): The content of the message to be sent to the target agent.\n        other_agent_id (str): The unique identifier of the target Letta agent.\n\n    Returns:\n        str: The response from the target agent.",
          "decorators": [],
          "start_line": 18,
          "end_line": 41,
          "is_async": false
        },
        {
          "name": "send_message_to_agents_matching_tags",
          "signature": "def send_message_to_agents_matching_tags(self: \"Agent\", message: str, match_all: List[str], match_some: List[str]) -> List[str]",
          "parameters": "(self: \"Agent\", message: str, match_all: List[str], match_some: List[str])",
          "return_type": "List[str]",
          "docstring": "Sends a message to all agents within the same organization that match the specified tag criteria. Agents must possess *all* of the tags in `match_all` and *at least one* of the tags in `match_some` to receive the message.\n\n    Args:\n        message (str): The content of the message to be sent to each matching agent.\n        match_all (List[str]): A list of tags that an agent must possess to receive the message.\n        match_some (List[str]): A list of tags where an agent must have at least one to qualify.\n\n    Returns:\n        List[str]: A list of responses from the agents that matched the filtering criteria. Each\n        response corresponds to a single agent. Agents that do not respond will not have an entry\n        in the returned list.",
          "decorators": [],
          "start_line": 44,
          "end_line": 109,
          "is_async": false
        },
        {
          "name": "send_message_to_all_agents_in_group",
          "signature": "def send_message_to_all_agents_in_group(self: \"Agent\", message: str) -> List[str]",
          "parameters": "(self: \"Agent\", message: str)",
          "return_type": "List[str]",
          "docstring": "Sends a message to all agents within the same multi-agent group.\n\n    Args:\n        message (str): The content of the message to be sent to each matching agent.\n\n    Returns:\n        List[str]: A list of responses from the agents that matched the filtering criteria. Each\n        response corresponds to a single agent. Agents that do not respond will not have an entry\n        in the returned list.",
          "decorators": [],
          "start_line": 112,
          "end_line": 125,
          "is_async": false
        },
        {
          "name": "send_message_to_agent_async",
          "signature": "def send_message_to_agent_async(self: \"Agent\", message: str, other_agent_id: str) -> str",
          "parameters": "(self: \"Agent\", message: str, other_agent_id: str)",
          "return_type": "str",
          "docstring": "Sends a message to a specific Letta agent within the same organization. The sender's identity is automatically included, so no explicit introduction is required in the message. This function does not expect a response from the target agent, making it suitable for notifications or one-way communication.\n    Args:\n        message (str): The content of the message to be sent to the target agent.\n        other_agent_id (str): The unique identifier of the target Letta agent.\n    Returns:\n        str: A confirmation message indicating the message was successfully sent.",
          "decorators": [],
          "start_line": 128,
          "end_line": 157,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991577
    },
    "letta/functions/function_sets/voice.py": {
      "path": "letta/functions/function_sets/voice.py",
      "contentHash": "074335d44183a41cb204c33d84f31a6e",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "rethink_user_memory",
          "signature": "def rethink_user_memory(agent_state: \"AgentState\", new_memory: str) -> None",
          "parameters": "(agent_state: \"AgentState\", new_memory: str)",
          "return_type": "None",
          "docstring": "Rewrite memory block for the main agent, new_memory should contain all current information from the block that is not outdated or inconsistent, integrating any new information, resulting in a new memory block that is organized, readable, and comprehensive.\n\n    Args:\n        new_memory (str): The new memory with information integrated from the memory block. If there is no new information, then this should be the same as the content in the source block.\n\n    Returns:\n        None: None is always returned as this function does not produce a response.",
          "decorators": [],
          "start_line": 7,
          "end_line": 18,
          "is_async": false
        },
        {
          "name": "finish_rethinking_memory",
          "signature": "def finish_rethinking_memory(agent_state: \"AgentState\") -> None",
          "parameters": "(agent_state: \"AgentState\")",
          "return_type": "None",
          "docstring": "This function is called when the agent is done rethinking the memory.\n\n    Returns:\n        Optional[str]: None is always returned as this function does not produce a response.",
          "decorators": [],
          "start_line": 21,
          "end_line": 28,
          "is_async": false
        },
        {
          "name": "ore_memories(a",
          "signature": "def ore_memories(agent_state: \"AgentState\", chunks: List[MemoryChunk]) - -> ne:\n",
          "parameters": "gent_state: \"AgentState\", chunks: List[MemoryChunk]) -",
          "return_type": "ne:\n",
          "docstring": "\"\n    Persist dialogue that is about to fall out of the agents context window.\n\n    Args:\n        chunks (List[MemoryChunk]):\n            Each chunk pinpoints a contiguous block of **evicted** lines and provides a short, forward-looking synopsis (`context`) that will be embedded for future semantic lookup.\n\n    Returns:\n        None\n    \"\"\"",
          "decorators": [],
          "start_line": 46,
          "end_line": 58,
          "is_async": false
        },
        {
          "name": "ch_memory(\n  ",
          "signature": "def ch_memory(\n    agent_state: \"AgentState\",\n    convo_keyword_queries: Optional[List[str]],\n    start_minutes_ago: Optional[int],\n    end_minutes_ago: Optional[int],\n) ->  -> onal[str]:\n  ",
          "parameters": "  agent_state: \"AgentState\",\n    convo_keyword_queries: Optional[List[str]],\n    start_minutes_ago: Optional[int],\n    end_minutes_ago: Optional[int],\n) -> ",
          "return_type": "onal[str]:\n  ",
          "docstring": "Look in long-term or earlier-conversation memory only when the user asks about something missing from the visible context. The users latest utterance is sent automatically as the main query.\n\n    Args:\n        convo_keyword_queries (Optional[List[str]]): Extra keywords (e.g., order ID, place name). Use *null* if not appropriate for the latest user message.\n        start_minutes_ago (Optional[int]): Newer bound of the time window for results, specified in minutes ago. Use *null* if no lower time bound is needed.\n        end_minutes_ago (Optional[int]): Older bound of the time window, in minutes ago. Use *null* if no upper bound is needed.\n\n    Returns:\n        Optional[str]: A formatted string of matching memory entries, or None if no\n            relevant memories are found.\n    \"\"\"\n    #",
          "decorators": [],
          "start_line": 61,
          "end_line": 80,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991577
    },
    "letta/functions/functions.py": {
      "path": "letta/functions/functions.py",
      "contentHash": "141ee72ef1cc04ae393cf2919e449475",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "derive_openai_json_schema",
          "signature": "def derive_openai_json_schema(source_code: str, name: Optional[str] = None) -> dict",
          "parameters": "(source_code: str, name: Optional[str] = None)",
          "return_type": "dict",
          "docstring": "Derives the OpenAI JSON schema for a given function source code.\n\n    Parses the source code statically to extract function signature and docstring,\n    then generates the schema without executing any code.\n\n    Limitations:\n    - Complex nested Pydantic models with forward references may not be fully supported\n    - Only basic Pydantic Field definitions are parsed (description, ellipsis for required)\n    - Simple types (str, int, bool, float, list, dict) and basic Pydantic models work well",
          "decorators": [],
          "start_line": 287,
          "end_line": 317,
          "is_async": false
        },
        {
          "name": "parse_source_code",
          "signature": "def parse_source_code(func) -> str",
          "parameters": "(func)",
          "return_type": "str",
          "docstring": "Parse the source code of a function and remove indendation",
          "decorators": [],
          "start_line": 320,
          "end_line": 323,
          "is_async": false
        },
        {
          "name": "get_function_from_module",
          "signature": "def get_function_from_module(module_name: str, function_name: str) -> Callable[..., Any]",
          "parameters": "(module_name: str, function_name: str)",
          "return_type": "Callable[..., Any]",
          "docstring": "Dynamically imports a function from a specified module.\n\n    Args:\n        module_name (str): The name of the module to import (e.g., 'base').\n        function_name (str): The name of the function to retrieve.\n\n    Returns:\n        Callable: The imported function.\n\n    Raises:\n        ModuleNotFoundError: If the specified module cannot be found.\n        AttributeError: If the function is not found in the module.",
          "decorators": [],
          "start_line": 327,
          "end_line": 350,
          "is_async": false
        },
        {
          "name": "get_json_schema_from_module",
          "signature": "def get_json_schema_from_module(module_name: str, function_name: str) -> dict",
          "parameters": "(module_name: str, function_name: str)",
          "return_type": "dict",
          "docstring": "Dynamically loads a specific function from a module and generates its JSON schema.\n\n    Args:\n        module_name (str): The name of the module to import (e.g., 'base').\n        function_name (str): The name of the function to retrieve.\n\n    Returns:\n        dict: The JSON schema for the specified function.\n\n    Raises:\n        ModuleNotFoundError: If the specified module cannot be found.\n        AttributeError: If the function is not found in the module.\n        ValueError: If the attribute is not a user-defined function.",
          "decorators": [],
          "start_line": 353,
          "end_line": 387,
          "is_async": false
        },
        {
          "name": "load_function_set",
          "signature": "def load_function_set(module: ModuleType) -> dict",
          "parameters": "(module: ModuleType)",
          "return_type": "dict",
          "docstring": "Load the functions and generate schema for them, given a module object",
          "decorators": [],
          "start_line": 390,
          "end_line": 412,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991578
    },
    "letta/functions/helpers.py": {
      "path": "letta/functions/helpers.py",
      "contentHash": "5d5b19ea16e52fc13b4294ebae7e25d1",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "generate_mcp_tool_wrapper",
          "signature": "def generate_mcp_tool_wrapper(mcp_tool_name: str) -> tuple[str, str]",
          "parameters": "(mcp_tool_name: str)",
          "return_type": "tuple[str, str]",
          "docstring": null,
          "decorators": [],
          "start_line": 26,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "generate_langchain_tool_wrapper",
          "signature": "def generate_langchain_tool_wrapper(\n    tool: \"LangChainBaseTool\", additional_imports_module_attr_map: dict[str, str] = None\n) -> tuple[str, str]",
          "parameters": "(\n    tool: \"LangChainBaseTool\", additional_imports_module_attr_map: dict[str, str] = None\n)",
          "return_type": "tuple[str, str]",
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 65,
          "is_async": false
        },
        {
          "name": "generate_imported_tool_instantiation_call_str",
          "signature": "def generate_imported_tool_instantiation_call_str(obj: Any) -> Optional[str]",
          "parameters": "(obj: Any)",
          "return_type": "Optional[str]",
          "docstring": null,
          "decorators": [],
          "start_line": 134,
          "end_line": 190,
          "is_async": false
        },
        {
          "name": "async_execute_send_message_to_agent",
          "signature": "def async_execute_send_message_to_agent(\n    sender_agent: \"Agent\",\n    messages: List[MessageCreate],\n    other_agent_id: str,\n    log_prefix: str,\n) -> Optional[str]",
          "parameters": "(\n    sender_agent: \"Agent\",\n    messages: List[MessageCreate],\n    other_agent_id: str,\n    log_prefix: str,\n)",
          "return_type": "Optional[str]",
          "docstring": "Async helper to:\n      1) validate the target agent exists & is in the same org,\n      2) send a message via _async_send_message_with_retries.",
          "decorators": [],
          "start_line": 226,
          "end_line": 254,
          "is_async": true
        },
        {
          "name": "execute_send_message_to_agent",
          "signature": "def execute_send_message_to_agent(\n    sender_agent: \"Agent\",\n    messages: List[MessageCreate],\n    other_agent_id: str,\n    log_prefix: str,\n) -> Optional[str]",
          "parameters": "(\n    sender_agent: \"Agent\",\n    messages: List[MessageCreate],\n    other_agent_id: str,\n    log_prefix: str,\n)",
          "return_type": "Optional[str]",
          "docstring": "Synchronous wrapper that calls `async_execute_send_message_to_agent` using asyncio.run.\n    This function must be called from a synchronous context (i.e., no running event loop).",
          "decorators": [],
          "start_line": 257,
          "end_line": 267,
          "is_async": false
        },
        {
          "name": "fire_and_forget_send_to_agent",
          "signature": "def fire_and_forget_send_to_agent(\n    sender_agent: \"Agent\",\n    messages: List[MessageCreate],\n    other_agent_id: str,\n    log_prefix: str,\n    use_retries: bool = False,\n) -> None",
          "parameters": "(\n    sender_agent: \"Agent\",\n    messages: List[MessageCreate],\n    other_agent_id: str,\n    log_prefix: str,\n    use_retries: bool = False,\n)",
          "return_type": "None",
          "docstring": "Fire-and-forget send of messages to a specific agent.\n    Returns immediately in the calling thread, never blocks.\n\n    Args:\n        sender_agent (Agent): The sender agent object.\n        server: The Letta server instance\n        messages (List[MessageCreate]): The messages to send.\n        other_agent_id (str): The ID of the target agent.\n        log_prefix (str): Prefix for logging.\n        use_retries (bool): If True, uses _async_send_message_with_retries;\n                            if False, calls server.send_message_to_agent directly.",
          "decorators": [],
          "start_line": 354,
          "end_line": 435,
          "is_async": false
        },
        {
          "name": "generate_model_from_args_json_schema",
          "signature": "def generate_model_from_args_json_schema(schema: Dict[str, Any]) -> Type[BaseModel]",
          "parameters": "(schema: Dict[str, Any])",
          "return_type": "Type[BaseModel]",
          "docstring": "Creates a Pydantic model from a JSON schema.\n\n    Args:\n        schema: The JSON schema dictionary\n\n    Returns:\n        A Pydantic model class",
          "decorators": [],
          "start_line": 504,
          "end_line": 520,
          "is_async": false
        },
        {
          "name": "extract_send_message_from_steps_messages",
          "signature": "def extract_send_message_from_steps_messages(\n    steps_messages: List[List[Message]],\n    agent_send_message_tool_name: str = DEFAULT_MESSAGE_TOOL,\n    agent_send_message_tool_kwarg: str = DEFAULT_MESSAGE_TOOL_KWARG,\n    logger: Optional[logging.Logger] = None,\n) -> List[str]",
          "parameters": "(\n    steps_messages: List[List[Message]],\n    agent_send_message_tool_name: str = DEFAULT_MESSAGE_TOOL,\n    agent_send_message_tool_kwarg: str = DEFAULT_MESSAGE_TOOL_KWARG,\n    logger: Optional[logging.Logger] = None,\n)",
          "return_type": "List[str]",
          "docstring": null,
          "decorators": [],
          "start_line": 595,
          "end_line": 616,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991578
    },
    "letta/functions/prompts.py": {
      "path": "letta/functions/prompts.py",
      "contentHash": "12c04054c8b2f79a3507e5eaaea7add7",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "get_firecrawl_search_user_prompt",
          "signature": "def get_firecrawl_search_user_prompt(query: str, question: str, numbered_content: str) -> str",
          "parameters": "(query: str, question: str, numbered_content: str)",
          "return_type": "str",
          "docstring": "Generate the user prompt for line-number based search analysis.",
          "decorators": [],
          "start_line": 16,
          "end_line": 26,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991578
    },
    "letta/functions/schema_generator.py": {
      "path": "letta/functions/schema_generator.py",
      "contentHash": "d98b2743353201d5cbf514532fd144ef",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "validate_google_style_docstring",
          "signature": "def validate_google_style_docstring(function)",
          "parameters": "(function)",
          "return_type": null,
          "docstring": "Validate that a function's docstring follows Google Python style format.\n\n    Args:\n        function: The function to validate\n\n    Raises:\n        ValueError: If the docstring is not in Google Python style format",
          "decorators": [],
          "start_line": 15,
          "end_line": 59,
          "is_async": false
        },
        {
          "name": "is_optional",
          "signature": "def is_optional(annotation)",
          "parameters": "(annotation)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 62,
          "end_line": 67,
          "is_async": false
        },
        {
          "name": "optional_length",
          "signature": "def optional_length(annotation)",
          "parameters": "(annotation)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 70,
          "end_line": 75,
          "is_async": false
        },
        {
          "name": "type_to_json_schema_type",
          "signature": "def type_to_json_schema_type(py_type) -> dict",
          "parameters": "(py_type)",
          "return_type": "dict",
          "docstring": "Maps a Python type to a JSON schema type.\n    Specifically handles typing.Optional and common Python types.",
          "decorators": [],
          "start_line": 78,
          "end_line": 194,
          "is_async": false
        },
        {
          "name": "pydantic_model_to_open_ai",
          "signature": "def pydantic_model_to_open_ai(model: Type[BaseModel]) -> dict",
          "parameters": "(model: Type[BaseModel])",
          "return_type": "dict",
          "docstring": "Converts a Pydantic model as a singular arg to a JSON schema object for use in OpenAI function calling.",
          "decorators": [],
          "start_line": 197,
          "end_line": 224,
          "is_async": false
        },
        {
          "name": "pydantic_model_to_json_schema",
          "signature": "def pydantic_model_to_json_schema(model: Type[BaseModel]) -> dict",
          "parameters": "(model: Type[BaseModel])",
          "return_type": "dict",
          "docstring": "Converts a Pydantic model (as an arg that already is annotated) to a JSON schema object for use in OpenAI function calling.\n\n    An example of a Pydantic model as an arg:\n\n    class Step(BaseModel):\n        name: str = Field(\n            ...,\n            description=\"Name of the step.\",\n        )\n        key: str = Field(\n            ...,\n            description=\"Unique identifier for the step.\",\n        )\n        description: str = Field(\n            ...,\n            description=\"An exhaustic description of what this step is trying to achieve and accomplish.\",\n        )\n\n    def create_task_plan(steps: list[Step]):\n        '''\n        Creates a task plan for the current task.\n\n        Args:\n            steps: List of steps to add to the task plan.\n        ...\n\n    Should result in:\n    {\n      \"name\": \"create_task_plan\",\n      \"description\": \"Creates a task plan for the current task.\",\n      \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"steps\": {  # <= this is the name of the arg\n            \"type\": \"object\",\n            \"description\": \"List of steps to add to the task plan.\",\n            \"properties\": {\n              \"name\": {\n                \"type\": \"str\",\n                \"description\": \"Name of the step.\",\n              },\n              \"key\": {\n                \"type\": \"str\",\n                \"description\": \"Unique identifier for the step.\",\n              },\n              \"description\": {\n                \"type\": \"str\",\n                \"description\": \"An exhaustic description of what this step is trying to achieve and accomplish.\",\n              },\n            },\n            \"required\": [\"name\", \"key\", \"description\"],\n          }\n        },\n        \"required\": [\"steps\"],\n      }\n    }\n\n    Specifically, the result of pydantic_model_to_json_schema(steps) (where `steps` is an instance of BaseModel) is:\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\n                \"type\": \"str\",\n                \"description\": \"Name of the step.\"\n            },\n            \"key\": {\n                \"type\": \"str\",\n                \"description\": \"Unique identifier for the step.\"\n            },\n            \"description\": {\n                \"type\": \"str\",\n                \"description\": \"An exhaustic description of what this step is trying to achieve and accomplish.\"\n            },\n        },\n        \"required\": [\"name\", \"key\", \"description\"],\n    }",
          "decorators": [],
          "start_line": 227,
          "end_line": 406,
          "is_async": false
        },
        {
          "name": "generate_schema",
          "signature": "def generate_schema(function, name: Optional[str] = None, description: Optional[str] = None, tool_id: Optional[str] = None) -> dict",
          "parameters": "(function, name: Optional[str] = None, description: Optional[str] = None, tool_id: Optional[str] = None)",
          "return_type": "dict",
          "docstring": null,
          "decorators": [],
          "start_line": 409,
          "end_line": 523,
          "is_async": false
        },
        {
          "name": "extract_examples_section",
          "signature": "def extract_examples_section(docstring: Optional[str]) -> Optional[str]",
          "parameters": "(docstring: Optional[str])",
          "return_type": "Optional[str]",
          "docstring": "Extracts the 'Examples:' section from a Google-style docstring.\n\n    Args:\n        docstring (Optional[str]): The full docstring of a function.\n\n    Returns:\n        Optional[str]: The extracted examples section, or None if not found.",
          "decorators": [],
          "start_line": 526,
          "end_line": 555,
          "is_async": false
        },
        {
          "name": "generate_schema_from_args_schema_v2",
          "signature": "def generate_schema_from_args_schema_v2(\n    args_schema: Type[BaseModel], name: Optional[str] = None, description: Optional[str] = None, append_heartbeat: bool = True\n) -> Dict[str, Any]",
          "parameters": "(\n    args_schema: Type[BaseModel], name: Optional[str] = None, description: Optional[str] = None, append_heartbeat: bool = True\n)",
          "return_type": "Dict[str, Any]",
          "docstring": null,
          "decorators": [],
          "start_line": 558,
          "end_line": 583,
          "is_async": false
        },
        {
          "name": "normalize_mcp_schema",
          "signature": "def normalize_mcp_schema(schema: Dict[str, Any]) -> Dict[str, Any]",
          "parameters": "(schema: Dict[str, Any])",
          "return_type": "Dict[str, Any]",
          "docstring": "Normalize an MCP JSON schema to fix common issues:\n    1. Add explicit 'additionalProperties': false to all object types\n    2. Add explicit 'type' field to properties using $ref\n    3. Process $defs recursively\n\n    Args:\n        schema: The JSON schema to normalize (will be modified in-place)\n\n    Returns:\n        The normalized schema (same object, modified in-place)",
          "decorators": [],
          "start_line": 586,
          "end_line": 691,
          "is_async": false
        },
        {
          "name": "generate_tool_schema_for_mcp",
          "signature": "def generate_tool_schema_for_mcp(\n    mcp_tool: MCPTool,\n    append_heartbeat: bool = True,\n    strict: bool = False,\n) -> Dict[str, Any]",
          "parameters": "(\n    mcp_tool: MCPTool,\n    append_heartbeat: bool = True,\n    strict: bool = False,\n)",
          "return_type": "Dict[str, Any]",
          "docstring": null,
          "decorators": [],
          "start_line": 694,
          "end_line": 902,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991578
    },
    "letta/functions/schema_validator.py": {
      "path": "letta/functions/schema_validator.py",
      "contentHash": "28aa802fa4754f2c307448363df59e2a",
      "mtime": 1767315072000.5427,
      "functions": [
        {
          "name": "validate_complete_json_schema",
          "signature": "def validate_complete_json_schema(schema: Dict[str, Any]) -> Tuple[SchemaHealth, List[str]]",
          "parameters": "(schema: Dict[str, Any])",
          "return_type": "Tuple[SchemaHealth, List[str]]",
          "docstring": "Validate schema for OpenAI tool strict mode compliance.\n\n    This validator checks for:\n    - Valid JSON Schema structure\n    - OpenAI strict mode requirements\n    - Special cases like required properties with empty object schemas\n\n    Args:\n        schema: The JSON schema to validate\n\n    Returns:\n        A tuple of (SchemaHealth, list_of_reasons)",
          "decorators": [],
          "start_line": 20,
          "end_line": 202,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991578
    },
    "letta/functions/typescript_parser.py": {
      "path": "letta/functions/typescript_parser.py",
      "contentHash": "72d57b93d0ed7f29ef70c9ea7262fd79",
      "mtime": 1767315072004.543,
      "functions": [
        {
          "name": "derive_typescript_json_schema",
          "signature": "def derive_typescript_json_schema(source_code: str, name: Optional[str] = None) -> dict",
          "parameters": "(source_code: str, name: Optional[str] = None)",
          "return_type": "dict",
          "docstring": "Derives the OpenAI JSON schema for a given TypeScript function source code.\n\n    This parser extracts the function signature, parameters, and types from TypeScript\n    code and generates a JSON schema compatible with OpenAI's function calling format.\n\n    Args:\n        source_code: TypeScript source code containing an exported function\n        name: Optional function name override\n\n    Returns:\n        JSON schema dict with name, description, and parameters\n\n    Raises:\n        LettaToolCreateError: If parsing fails or no exported function is found",
          "decorators": [],
          "start_line": 9,
          "end_line": 63,
          "is_async": false
        },
        {
          "name": "extract_jsdoc_description",
          "signature": "def extract_jsdoc_description(source_code: str, func_name: str) -> Optional[str]",
          "parameters": "(source_code: str, func_name: str)",
          "return_type": "Optional[str]",
          "docstring": "Extract JSDoc description for a function.",
          "decorators": [],
          "start_line": 66,
          "end_line": 88,
          "is_async": false
        },
        {
          "name": "parse_typescript_parameters",
          "signature": "def parse_typescript_parameters(params_str: str) -> Dict[str, Any]",
          "parameters": "(params_str: str)",
          "return_type": "Dict[str, Any]",
          "docstring": "Parse TypeScript function parameters and generate JSON schema properties.",
          "decorators": [],
          "start_line": 91,
          "end_line": 123,
          "is_async": false
        },
        {
          "name": "split_parameters",
          "signature": "def split_parameters(params_str: str) -> list",
          "parameters": "(params_str: str)",
          "return_type": "list",
          "docstring": "Split parameter string by commas, handling nested types.",
          "decorators": [],
          "start_line": 126,
          "end_line": 147,
          "is_async": false
        },
        {
          "name": "typescript_to_json_schema_type",
          "signature": "def typescript_to_json_schema_type(ts_type: str) -> Dict[str, Any]",
          "parameters": "(ts_type: str)",
          "return_type": "Dict[str, Any]",
          "docstring": "Convert TypeScript type to JSON schema type definition.",
          "decorators": [],
          "start_line": 150,
          "end_line": 196,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991578
    },
    "letta/groups/helpers.py": {
      "path": "letta/groups/helpers.py",
      "contentHash": "9399e40c72a0b4ba453d9bb2cf0ed540",
      "mtime": 1767315072004.543,
      "functions": [
        {
          "name": "load_multi_agent",
          "signature": "def load_multi_agent(\n    group: Group,\n    agent_state: Optional[AgentState],\n    actor: User,\n    interface: Union[AgentInterface, None] = None,\n    mcp_clients: Optional[Dict[str, AsyncBaseMCPClient]] = None,\n) -> LettaAgent",
          "parameters": "(\n    group: Group,\n    agent_state: Optional[AgentState],\n    actor: User,\n    interface: Union[AgentInterface, None] = None,\n    mcp_clients: Optional[Dict[str, AsyncBaseMCPClient]] = None,\n)",
          "return_type": "LettaAgent",
          "docstring": null,
          "decorators": [],
          "start_line": 15,
          "end_line": 86,
          "is_async": false
        },
        {
          "name": "stringify_message",
          "signature": "def stringify_message(message: Message, use_assistant_name: bool = False) -> str | None",
          "parameters": "(message: Message, use_assistant_name: bool = False)",
          "return_type": "str | None",
          "docstring": null,
          "decorators": [],
          "start_line": 89,
          "end_line": 166,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991579
    },
    "letta/helpers/composio_helpers.py": {
      "path": "letta/helpers/composio_helpers.py",
      "contentHash": "d8d4ba6059903750b6a02fe1c6a341da",
      "mtime": 1767315072004.543,
      "functions": [
        {
          "name": "get_composio_api_key",
          "signature": "def get_composio_api_key(actor: User, logger: Optional[Logger] = None) -> Optional[str]",
          "parameters": "(actor: User, logger: Optional[Logger] = None)",
          "return_type": "Optional[str]",
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 22,
          "is_async": false
        },
        {
          "name": "get_composio_api_key_async",
          "signature": "def get_composio_api_key_async(actor: User, logger: Optional[Logger] = None) -> Optional[str]",
          "parameters": "(actor: User, logger: Optional[Logger] = None)",
          "return_type": "Optional[str]",
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 38,
          "is_async": true
        }
      ],
      "parsedAt": 1769607991579
    },
    "letta/helpers/converters.py": {
      "path": "letta/helpers/converters.py",
      "contentHash": "492bd171068b55cd421e7094ecd6db1c",
      "mtime": 1768610518514.1997,
      "functions": [
        {
          "name": "serialize_llm_config",
          "signature": "def serialize_llm_config(config: Union[Optional[LLMConfig], Dict]) -> Optional[Dict]",
          "parameters": "(config: Union[Optional[LLMConfig], Dict])",
          "return_type": "Optional[Dict]",
          "docstring": "Convert an LLMConfig object into a JSON-serializable dictionary.",
          "decorators": [],
          "start_line": 66,
          "end_line": 70,
          "is_async": false
        },
        {
          "name": "deserialize_llm_config",
          "signature": "def deserialize_llm_config(data: Optional[Dict]) -> Optional[LLMConfig]",
          "parameters": "(data: Optional[Dict])",
          "return_type": "Optional[LLMConfig]",
          "docstring": "Convert a dictionary back into an LLMConfig object.",
          "decorators": [],
          "start_line": 73,
          "end_line": 75,
          "is_async": false
        },
        {
          "name": "serialize_embedding_config",
          "signature": "def serialize_embedding_config(config: Union[Optional[EmbeddingConfig], Dict]) -> Optional[Dict]",
          "parameters": "(config: Union[Optional[EmbeddingConfig], Dict])",
          "return_type": "Optional[Dict]",
          "docstring": "Convert an EmbeddingConfig object into a JSON-serializable dictionary.",
          "decorators": [],
          "start_line": 83,
          "end_line": 87,
          "is_async": false
        },
        {
          "name": "deserialize_embedding_config",
          "signature": "def deserialize_embedding_config(data: Optional[Dict]) -> Optional[EmbeddingConfig]",
          "parameters": "(data: Optional[Dict])",
          "return_type": "Optional[EmbeddingConfig]",
          "docstring": "Convert a dictionary back into an EmbeddingConfig object.",
          "decorators": [],
          "start_line": 90,
          "end_line": 92,
          "is_async": false
        },
        {
          "name": "serialize_compaction_settings",
          "signature": "def serialize_compaction_settings(config: Union[Optional[\"CompactionSettings\"], Dict]) -> Optional[Dict]",
          "parameters": "(config: Union[Optional[\"CompactionSettings\"], Dict])",
          "return_type": "Optional[Dict]",
          "docstring": "Convert a CompactionSettings object into a JSON-serializable dictionary.",
          "decorators": [],
          "start_line": 100,
          "end_line": 108,
          "is_async": false
        },
        {
          "name": "deserialize_compaction_settings",
          "signature": "def deserialize_compaction_settings(data: Optional[Dict]) -> Optional[\"CompactionSettings\"]",
          "parameters": "(data: Optional[Dict])",
          "return_type": "Optional[\"CompactionSettings\"]",
          "docstring": "Convert a dictionary back into a CompactionSettings object.",
          "decorators": [],
          "start_line": 111,
          "end_line": 118,
          "is_async": false
        },
        {
          "name": "serialize_tool_rules",
          "signature": "def serialize_tool_rules(tool_rules: Optional[List[ToolRule]]) -> List[Dict[str, Any]]",
          "parameters": "(tool_rules: Optional[List[ToolRule]])",
          "return_type": "List[Dict[str, Any]]",
          "docstring": "Convert a list of ToolRules into a JSON-serializable format.",
          "decorators": [],
          "start_line": 126,
          "end_line": 144,
          "is_async": false
        },
        {
          "name": "deserialize_tool_rules",
          "signature": "def deserialize_tool_rules(data: Optional[List[Dict]]) -> List[ToolRule]",
          "parameters": "(data: Optional[List[Dict]])",
          "return_type": "List[ToolRule]",
          "docstring": "Convert a list of dictionaries back into ToolRule objects.",
          "decorators": [],
          "start_line": 147,
          "end_line": 152,
          "is_async": false
        },
        {
          "name": "deserialize_tool_rule",
          "signature": "def deserialize_tool_rule(\n    data: Dict,\n) -> ToolRule",
          "parameters": "(\n    data: Dict,\n)",
          "return_type": "ToolRule",
          "docstring": "Deserialize a dictionary to the appropriate ToolRule subclass based on 'type'.",
          "decorators": [],
          "start_line": 155,
          "end_line": 182,
          "is_async": false
        },
        {
          "name": "serialize_tool_calls",
          "signature": "def serialize_tool_calls(tool_calls: Optional[List[Union[OpenAIToolCall, dict]]]) -> List[Dict]",
          "parameters": "(tool_calls: Optional[List[Union[OpenAIToolCall, dict]]])",
          "return_type": "List[Dict]",
          "docstring": "Convert a list of OpenAI ToolCall objects into JSON-serializable format.\n\n    Note: Tool call arguments may contain null bytes from various sources.\n    These are sanitized to prevent PostgreSQL errors.",
          "decorators": [],
          "start_line": 190,
          "end_line": 210,
          "is_async": false
        },
        {
          "name": "deserialize_tool_calls",
          "signature": "def deserialize_tool_calls(data: Optional[List[Dict]]) -> List[OpenAIToolCall]",
          "parameters": "(data: Optional[List[Dict]])",
          "return_type": "List[OpenAIToolCall]",
          "docstring": "Convert a JSON list back into OpenAIToolCall objects.",
          "decorators": [],
          "start_line": 213,
          "end_line": 225,
          "is_async": false
        },
        {
          "name": "serialize_tool_returns",
          "signature": "def serialize_tool_returns(tool_returns: Optional[List[Union[ToolReturn, dict]]]) -> List[Dict]",
          "parameters": "(tool_returns: Optional[List[Union[ToolReturn, dict]]])",
          "return_type": "List[Dict]",
          "docstring": "Convert a list of ToolReturn objects into JSON-serializable format.\n\n    Note: Tool returns may contain null bytes from sandbox execution or binary data.\n    These are sanitized to prevent PostgreSQL errors.",
          "decorators": [],
          "start_line": 233,
          "end_line": 253,
          "is_async": false
        },
        {
          "name": "deserialize_tool_returns",
          "signature": "def deserialize_tool_returns(data: Optional[List[Dict]]) -> List[ToolReturn]",
          "parameters": "(data: Optional[List[Dict]])",
          "return_type": "List[ToolReturn]",
          "docstring": "Convert a JSON list back into ToolReturn objects.",
          "decorators": [],
          "start_line": 256,
          "end_line": 266,
          "is_async": false
        },
        {
          "name": "serialize_approvals",
          "signature": "def serialize_approvals(approvals: Optional[List[Union[ApprovalReturn, ToolReturn, dict]]]) -> List[Dict]",
          "parameters": "(approvals: Optional[List[Union[ApprovalReturn, ToolReturn, dict]]])",
          "return_type": "List[Dict]",
          "docstring": "Convert a list of ToolReturn objects into JSON-serializable format.\n\n    Note: Approval data may contain null bytes from various sources.\n    These are sanitized to prevent PostgreSQL errors.",
          "decorators": [],
          "start_line": 274,
          "end_line": 296,
          "is_async": false
        },
        {
          "name": "deserialize_approvals",
          "signature": "def deserialize_approvals(data: Optional[List[Dict]]) -> List[Union[ApprovalReturn, ToolReturn]]",
          "parameters": "(data: Optional[List[Dict]])",
          "return_type": "List[Union[ApprovalReturn, ToolReturn]]",
          "docstring": "Convert a JSON list back into ApprovalReturn and ToolReturn objects.",
          "decorators": [],
          "start_line": 299,
          "end_line": 334,
          "is_async": false
        },
        {
          "name": "serialize_message_content",
          "signature": "def serialize_message_content(message_content: Optional[List[Union[MessageContent, dict]]]) -> List[Dict]",
          "parameters": "(message_content: Optional[List[Union[MessageContent, dict]]])",
          "return_type": "List[Dict]",
          "docstring": "Convert a list of MessageContent objects into JSON-serializable format.\n\n    Note: Message content may contain null bytes from various sources.\n    These are sanitized to prevent PostgreSQL errors.",
          "decorators": [],
          "start_line": 342,
          "end_line": 363,
          "is_async": false
        },
        {
          "name": "deserialize_message_content",
          "signature": "def deserialize_message_content(data: Optional[List[Dict]]) -> List[MessageContent]",
          "parameters": "(data: Optional[List[Dict]])",
          "return_type": "List[MessageContent]",
          "docstring": "Convert a JSON list back into MessageContent objects.",
          "decorators": [],
          "start_line": 366,
          "end_line": 400,
          "is_async": false
        },
        {
          "name": "serialize_vector",
          "signature": "def serialize_vector(vector: Optional[Union[List[float], np.ndarray]]) -> Optional[bytes]",
          "parameters": "(vector: Optional[Union[List[float], np.ndarray]])",
          "return_type": "Optional[bytes]",
          "docstring": "Convert a NumPy array or list into serialized format using sqlite-vec.",
          "decorators": [],
          "start_line": 408,
          "end_line": 417,
          "is_async": false
        },
        {
          "name": "deserialize_vector",
          "signature": "def deserialize_vector(data: Optional[bytes], dialect: Dialect) -> Optional[np.ndarray]",
          "parameters": "(data: Optional[bytes], dialect: Dialect)",
          "return_type": "Optional[np.ndarray]",
          "docstring": "Convert serialized data back into a NumPy array using sqlite-vec format.",
          "decorators": [],
          "start_line": 420,
          "end_line": 432,
          "is_async": false
        },
        {
          "name": "serialize_create_batch_response",
          "signature": "def serialize_create_batch_response(create_batch_response: Union[BetaMessageBatch]) -> Dict[str, Any]",
          "parameters": "(create_batch_response: Union[BetaMessageBatch])",
          "return_type": "Dict[str, Any]",
          "docstring": "Convert a list of ToolRules into a JSON-serializable format.",
          "decorators": [],
          "start_line": 440,
          "end_line": 449,
          "is_async": false
        },
        {
          "name": "deserialize_create_batch_response",
          "signature": "def deserialize_create_batch_response(data: Dict) -> Union[BetaMessageBatch]",
          "parameters": "(data: Dict)",
          "return_type": "Union[BetaMessageBatch]",
          "docstring": null,
          "decorators": [],
          "start_line": 452,
          "end_line": 458,
          "is_async": false
        },
        {
          "name": "serialize_poll_batch_response",
          "signature": "def serialize_poll_batch_response(poll_batch_response: Optional[Union[BetaMessageBatch]]) -> Optional[Dict[str, Any]]",
          "parameters": "(poll_batch_response: Optional[Union[BetaMessageBatch]])",
          "return_type": "Optional[Dict[str, Any]]",
          "docstring": "Convert a list of ToolRules into a JSON-serializable format.",
          "decorators": [],
          "start_line": 463,
          "end_line": 475,
          "is_async": false
        },
        {
          "name": "deserialize_poll_batch_response",
          "signature": "def deserialize_poll_batch_response(data: Optional[Dict]) -> Optional[Union[BetaMessageBatch]]",
          "parameters": "(data: Optional[Dict])",
          "return_type": "Optional[Union[BetaMessageBatch]]",
          "docstring": null,
          "decorators": [],
          "start_line": 478,
          "end_line": 487,
          "is_async": false
        },
        {
          "name": "serialize_batch_request_result",
          "signature": "def serialize_batch_request_result(\n    batch_individual_response: Optional[Union[BetaMessageBatchIndividualResponse]],\n) -> Optional[Dict[str, Any]]",
          "parameters": "(\n    batch_individual_response: Optional[Union[BetaMessageBatchIndividualResponse]],\n)",
          "return_type": "Optional[Dict[str, Any]]",
          "docstring": "Convert a list of ToolRules into a JSON-serializable format.",
          "decorators": [],
          "start_line": 490,
          "end_line": 504,
          "is_async": false
        },
        {
          "name": "deserialize_batch_request_result",
          "signature": "def deserialize_batch_request_result(data: Optional[Dict]) -> Optional[Union[BetaMessageBatchIndividualResponse]]",
          "parameters": "(data: Optional[Dict])",
          "return_type": "Optional[Union[BetaMessageBatchIndividualResponse]]",
          "docstring": null,
          "decorators": [],
          "start_line": 507,
          "end_line": 515,
          "is_async": false
        },
        {
          "name": "serialize_agent_step_state",
          "signature": "def serialize_agent_step_state(agent_step_state: Optional[AgentStepState]) -> Optional[Dict[str, Any]]",
          "parameters": "(agent_step_state: Optional[AgentStepState])",
          "return_type": "Optional[Dict[str, Any]]",
          "docstring": "Convert a list of ToolRules into a JSON-serializable format.",
          "decorators": [],
          "start_line": 518,
          "end_line": 523,
          "is_async": false
        },
        {
          "name": "deserialize_agent_step_state",
          "signature": "def deserialize_agent_step_state(data: Optional[Dict]) -> Optional[AgentStepState]",
          "parameters": "(data: Optional[Dict])",
          "return_type": "Optional[AgentStepState]",
          "docstring": null,
          "decorators": [],
          "start_line": 526,
          "end_line": 548,
          "is_async": false
        },
        {
          "name": "serialize_response_format",
          "signature": "def serialize_response_format(response_format: Optional[ResponseFormatUnion]) -> Optional[Dict[str, Any]]",
          "parameters": "(response_format: Optional[ResponseFormatUnion])",
          "return_type": "Optional[Dict[str, Any]]",
          "docstring": null,
          "decorators": [],
          "start_line": 556,
          "end_line": 559,
          "is_async": false
        },
        {
          "name": "deserialize_response_format",
          "signature": "def deserialize_response_format(data: Optional[Dict]) -> Optional[ResponseFormatUnion]",
          "parameters": "(data: Optional[Dict])",
          "return_type": "Optional[ResponseFormatUnion]",
          "docstring": null,
          "decorators": [],
          "start_line": 562,
          "end_line": 571,
          "is_async": false
        },
        {
          "name": "serialize_mcp_stdio_config",
          "signature": "def serialize_mcp_stdio_config(config: Union[Optional[StdioServerConfig], Dict]) -> Optional[Dict]",
          "parameters": "(config: Union[Optional[StdioServerConfig], Dict])",
          "return_type": "Optional[Dict]",
          "docstring": "Convert an StdioServerConfig object into a JSON-serializable dictionary.\n\n    Persist required fields for successful deserialization back into a\n    StdioServerConfig model (namely `server_name` and `type`). The\n    `to_dict()` helper intentionally omits these since they're not needed\n    by MCP transport, but our ORM deserializer reconstructs the pydantic\n    model and requires them.",
          "decorators": [],
          "start_line": 579,
          "end_line": 595,
          "is_async": false
        },
        {
          "name": "deserialize_mcp_stdio_config",
          "signature": "def deserialize_mcp_stdio_config(data: Optional[Dict]) -> Optional[StdioServerConfig]",
          "parameters": "(data: Optional[Dict])",
          "return_type": "Optional[StdioServerConfig]",
          "docstring": "Convert a dictionary back into an StdioServerConfig object.\n\n    Backwards-compatibility notes:\n    - Older rows may only include `transport`, `command`, `args`, `env`.\n      In that case, provide defaults for `server_name` and `type` to\n      satisfy the pydantic model requirements.\n    - If both `type` and `transport` are present, prefer `type`.",
          "decorators": [],
          "start_line": 598,
          "end_line": 619,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991579
    },
    "letta/helpers/datetime_helpers.py": {
      "path": "letta/helpers/datetime_helpers.py",
      "contentHash": "c7a7d20d20e0e664e136c4b5220ee32f",
      "mtime": 1767315072004.543,
      "functions": [
        {
          "name": "parse_formatted_time",
          "signature": "def parse_formatted_time(formatted_time)",
          "parameters": "(formatted_time)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 11,
          "end_line": 13,
          "is_async": false
        },
        {
          "name": "datetime_to_timestamp",
          "signature": "def datetime_to_timestamp(dt)",
          "parameters": "(dt)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 16,
          "end_line": 18,
          "is_async": false
        },
        {
          "name": "get_local_time_fast",
          "signature": "def get_local_time_fast(timezone)",
          "parameters": "(timezone)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "get_local_time_timezone",
          "signature": "def get_local_time_timezone(timezone=DEFAULT_TIMEZONE)",
          "parameters": "(timezone=DEFAULT_TIMEZONE)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "get_local_time",
          "signature": "def get_local_time(timezone: str | None = DEFAULT_TIMEZONE)",
          "parameters": "(timezone: str | None = DEFAULT_TIMEZONE)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 46,
          "end_line": 56,
          "is_async": false
        },
        {
          "name": "get_utc_time",
          "signature": "def get_utc_time() -> datetime",
          "parameters": "()",
          "return_type": "datetime",
          "docstring": "Get the current UTC time",
          "decorators": [],
          "start_line": 59,
          "end_line": 62,
          "is_async": false
        },
        {
          "name": "get_utc_time_int",
          "signature": "def get_utc_time_int() -> int",
          "parameters": "()",
          "return_type": "int",
          "docstring": null,
          "decorators": [],
          "start_line": 65,
          "end_line": 66,
          "is_async": false
        },
        {
          "name": "get_utc_timestamp_ns",
          "signature": "def get_utc_timestamp_ns() -> int",
          "parameters": "()",
          "return_type": "int",
          "docstring": "Get the current UTC time in nanoseconds",
          "decorators": [],
          "start_line": 69,
          "end_line": 71,
          "is_async": false
        },
        {
          "name": "ns_to_ms",
          "signature": "def ns_to_ms(ns: int) -> int",
          "parameters": "(ns: int)",
          "return_type": "int",
          "docstring": null,
          "decorators": [],
          "start_line": 74,
          "end_line": 75,
          "is_async": false
        },
        {
          "name": "timestamp_to_datetime",
          "signature": "def timestamp_to_datetime(timestamp_seconds: int) -> datetime",
          "parameters": "(timestamp_seconds: int)",
          "return_type": "datetime",
          "docstring": "Convert Unix timestamp in seconds to UTC datetime object",
          "decorators": [],
          "start_line": 78,
          "end_line": 80,
          "is_async": false
        },
        {
          "name": "format_datetime",
          "signature": "def format_datetime(dt, timezone)",
          "parameters": "(dt, timezone)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 83,
          "end_line": 87,
          "is_async": false
        },
        {
          "name": "validate_date_format",
          "signature": "def validate_date_format(date_str)",
          "parameters": "(date_str)",
          "return_type": null,
          "docstring": "Validate the given date string in the format 'YYYY-MM-DD'.",
          "decorators": [],
          "start_line": 90,
          "end_line": 96,
          "is_async": false
        },
        {
          "name": "extract_date_from_timestamp",
          "signature": "def extract_date_from_timestamp(timestamp)",
          "parameters": "(timestamp)",
          "return_type": null,
          "docstring": "Extracts and returns the date from the given timestamp.",
          "decorators": [],
          "start_line": 99,
          "end_line": 103,
          "is_async": false
        },
        {
          "name": "is_utc_datetime",
          "signature": "def is_utc_datetime(dt: datetime) -> bool",
          "parameters": "(dt: datetime)",
          "return_type": "bool",
          "docstring": null,
          "decorators": [],
          "start_line": 106,
          "end_line": 107,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991579
    },
    "letta/helpers/decorators.py": {
      "path": "letta/helpers/decorators.py",
      "contentHash": "e69a98fa343791641daac37aeb95a69d",
      "mtime": 1768610518514.1997,
      "functions": [
        {
          "name": "experimental",
          "signature": "def experimental(feature_name: str, fallback_function: Callable, **kwargs)",
          "parameters": "(feature_name: str, fallback_function: Callable, **kwargs)",
          "return_type": null,
          "docstring": "Decorator that runs a fallback function if experimental feature is not enabled.\n\n    - kwargs from the decorator will be combined with function kwargs and overwritten only for experimental evaluation.\n    - if the decorated function, fallback_function, or experimental checker function is async, the whole call will be async",
          "decorators": [],
          "start_line": 19,
          "end_line": 61,
          "is_async": false
        },
        {
          "name": "deprecated",
          "signature": "def deprecated(message: str)",
          "parameters": "(message: str)",
          "return_type": null,
          "docstring": "Simple decorator that marks a method as deprecated.",
          "decorators": [],
          "start_line": 64,
          "end_line": 76,
          "is_async": false
        },
        {
          "name": "async_redis_cache",
          "signature": "def async_redis_cache(\n    key_func: Callable, prefix: str = REDIS_DEFAULT_CACHE_PREFIX, ttl_s: int = 600, model_class: type[BaseModel] | None = None\n)",
          "parameters": "(\n    key_func: Callable, prefix: str = REDIS_DEFAULT_CACHE_PREFIX, ttl_s: int = 600, model_class: type[BaseModel] | None = None\n)",
          "return_type": null,
          "docstring": "Decorator for caching async function results in Redis. May be a Noop if redis is not available.\n    Will handle pydantic objects and raw values.\n\n    Attempts to write to and retrieve from cache, but does not fail on those cases\n\n    Args:\n        key_func: function to generate cache key (preferably lowercase strings to follow redis convention)\n        prefix: cache key prefix\n        ttl_s: time to live (s)\n        model_class: custom pydantic model class for serialization/deserialization\n\n    TODO (cliandy): move to class with generics for type hints",
          "decorators": [],
          "start_line": 90,
          "end_line": 185,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991579
    },
    "letta/helpers/json_helpers.py": {
      "path": "letta/helpers/json_helpers.py",
      "contentHash": "e9fd844d3ce3db46e76f5429db03fc3e",
      "mtime": 1768610518514.1997,
      "functions": [
        {
          "name": "sanitize_null_bytes",
          "signature": "def sanitize_null_bytes(value: Any) -> Any",
          "parameters": "(value: Any)",
          "return_type": "Any",
          "docstring": "Recursively remove null bytes (0x00) from strings.\n\n    PostgreSQL TEXT columns don't accept null bytes in UTF-8 encoding, which causes\n    asyncpg.exceptions.CharacterNotInRepertoireError when data with null bytes is inserted.\n\n    This function sanitizes:\n    - Strings: removes all null bytes\n    - Dicts: recursively sanitizes all string values\n    - Lists: recursively sanitizes all elements\n    - Other types: returned as-is\n\n    Args:\n        value: The value to sanitize\n\n    Returns:\n        The sanitized value with null bytes removed from all strings",
          "decorators": [],
          "start_line": 7,
          "end_line": 39,
          "is_async": false
        },
        {
          "name": "json_loads",
          "signature": "def json_loads(data)",
          "parameters": "(data)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 42,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "json_dumps",
          "signature": "def json_dumps(data, indent=2) -> str",
          "parameters": "(data, indent=2)",
          "return_type": "str",
          "docstring": "Serialize data to JSON string, sanitizing null bytes to prevent PostgreSQL errors.\n\n    PostgreSQL TEXT columns reject null bytes (0x00) in UTF-8 encoding. This function\n    sanitizes all strings in the data structure before JSON serialization to prevent\n    asyncpg.exceptions.CharacterNotInRepertoireError.\n\n    Args:\n        data: The data to serialize\n        indent: JSON indentation level (default: 2)\n\n    Returns:\n        JSON string with null bytes removed from all string values",
          "decorators": [],
          "start_line": 46,
          "end_line": 76,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991579
    },
    "letta/helpers/message_helper.py": {
      "path": "letta/helpers/message_helper.py",
      "contentHash": "46d5a4160b570ea2fcc5414249ce298b",
      "mtime": 1768610518514.1997,
      "functions": [
        {
          "name": "convert_message_creates_to_messages",
          "signature": "def convert_message_creates_to_messages(\n    message_creates: list[MessageCreate],\n    agent_id: str,\n    timezone: str,\n    run_id: str,\n    wrap_user_message: bool = True,\n    wrap_system_message: bool = True,\n) -> list[Message]",
          "parameters": "(\n    message_creates: list[MessageCreate],\n    agent_id: str,\n    timezone: str,\n    run_id: str,\n    wrap_user_message: bool = True,\n    wrap_system_message: bool = True,\n)",
          "return_type": "list[Message]",
          "docstring": null,
          "decorators": [],
          "start_line": 67,
          "end_line": 87,
          "is_async": true
        },
        {
          "name": "consolidate_streaming_messages",
          "signature": "def consolidate_streaming_messages(messages: List[LettaMessage]) -> List[LettaMessage]",
          "parameters": "(messages: List[LettaMessage])",
          "return_type": "List[LettaMessage]",
          "docstring": "Merge consecutive AssistantMessage streaming chunks into single messages.\n\n    Example: [AssistantMessage(\"Let\"), AssistantMessage(\" me\")] -> [AssistantMessage(\"Let me\")]",
          "decorators": [],
          "start_line": 190,
          "end_line": 238,
          "is_async": false
        },
        {
          "name": "input_messages_to_webhook_format",
          "signature": "def input_messages_to_webhook_format(input_messages: List[MessageCreate]) -> List[dict]",
          "parameters": "(input_messages: List[MessageCreate])",
          "return_type": "List[dict]",
          "docstring": "Convert input MessageCreate objects to webhook-friendly UserMessage dicts.",
          "decorators": [],
          "start_line": 241,
          "end_line": 268,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991579
    },
    "letta/helpers/pinecone_utils.py": {
      "path": "letta/helpers/pinecone_utils.py",
      "contentHash": "8061a5cfc2ff10f1598734a0bc12df13",
      "mtime": 1767315072004.543,
      "functions": [
        {
          "name": "pinecone_retry",
          "signature": "def pinecone_retry(\n    max_attempts: int = PINECONE_MAX_RETRY_ATTEMPTS,\n    base_delay: float = PINECONE_RETRY_BASE_DELAY,\n    max_delay: float = PINECONE_RETRY_MAX_DELAY,\n    backoff_factor: float = PINECONE_RETRY_BACKOFF_FACTOR,\n)",
          "parameters": "(\n    max_attempts: int = PINECONE_MAX_RETRY_ATTEMPTS,\n    base_delay: float = PINECONE_RETRY_BASE_DELAY,\n    max_delay: float = PINECONE_RETRY_MAX_DELAY,\n    backoff_factor: float = PINECONE_RETRY_BACKOFF_FACTOR,\n)",
          "return_type": null,
          "docstring": "Decorator to retry Pinecone operations with exponential backoff.\n\n    Args:\n        max_attempts: Maximum number of retry attempts\n        base_delay: Base delay in seconds for the first retry\n        max_delay: Maximum delay in seconds between retries\n        backoff_factor: Factor to increase delay after each failed attempt",
          "decorators": [],
          "start_line": 43,
          "end_line": 121,
          "is_async": false
        },
        {
          "name": "should_use_pinecone",
          "signature": "def should_use_pinecone(verbose: bool = False)",
          "parameters": "(verbose: bool = False)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 124,
          "end_line": 142,
          "is_async": false
        },
        {
          "name": "upsert_pinecone_indices",
          "signature": "def upsert_pinecone_indices()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pinecone_retry()",
            "@trace_method"
          ],
          "start_line": 147,
          "end_line": 167,
          "is_async": true
        },
        {
          "name": "get_pinecone_indices",
          "signature": "def get_pinecone_indices() -> List[str]",
          "parameters": "()",
          "return_type": "List[str]",
          "docstring": null,
          "decorators": [],
          "start_line": 170,
          "end_line": 171,
          "is_async": false
        },
        {
          "name": "upsert_file_records_to_pinecone_index",
          "signature": "def upsert_file_records_to_pinecone_index(file_id: str, source_id: str, chunks: List[str], actor: User)",
          "parameters": "(file_id: str, source_id: str, chunks: List[str], actor: User)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pinecone_retry()",
            "@trace_method"
          ],
          "start_line": 176,
          "end_line": 193,
          "is_async": true
        },
        {
          "name": "delete_file_records_from_pinecone_index",
          "signature": "def delete_file_records_from_pinecone_index(file_id: str, actor: User)",
          "parameters": "(file_id: str, actor: User)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pinecone_retry()",
            "@trace_method"
          ],
          "start_line": 198,
          "end_line": 217,
          "is_async": true
        },
        {
          "name": "delete_source_records_from_pinecone_index",
          "signature": "def delete_source_records_from_pinecone_index(source_id: str, actor: User)",
          "parameters": "(source_id: str, actor: User)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pinecone_retry()",
            "@trace_method"
          ],
          "start_line": 222,
          "end_line": 236,
          "is_async": true
        },
        {
          "name": "upsert_records_to_pinecone_index",
          "signature": "def upsert_records_to_pinecone_index(records: List[dict], actor: User)",
          "parameters": "(records: List[dict], actor: User)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pinecone_retry()",
            "@trace_method"
          ],
          "start_line": 241,
          "end_line": 268,
          "is_async": true
        },
        {
          "name": "earch_pinecone_index(",
          "signature": "def earch_pinecone_index(query: str, limit: int, filter: Dict[str, Any], actor: User)  -> ict[str, Any]:",
          "parameters": "query: str, limit: int, filter: Dict[str, Any], actor: User) ",
          "return_type": "ict[str, Any]:",
          "docstring": null,
          "decorators": [
            "pinecone_retry()\n",
            "trace_method\n"
          ],
          "start_line": 273,
          "end_line": 304,
          "is_async": true
        },
        {
          "name": "ist_pinecone_index_for_files(",
          "signature": "def ist_pinecone_index_for_files(file_id: str, actor: User, limit: int = None, pagination_token: str = None)  -> ist[str]:",
          "parameters": "file_id: str, actor: User, limit: int = None, pagination_token: str = None) ",
          "return_type": "ist[str]:",
          "docstring": null,
          "decorators": [
            "pinecone_retry()\n",
            "trace_method\n"
          ],
          "start_line": 309,
          "end_line": 341,
          "is_async": true
        }
      ],
      "parsedAt": 1769607991579
    },
    "letta/helpers/reasoning_helper.py": {
      "path": "letta/helpers/reasoning_helper.py",
      "contentHash": "767b55770e509c56ae393e957cd6a388",
      "mtime": 1767315072004.543,
      "functions": [
        {
          "name": "is_reasoning_completely_disabled",
          "signature": "def is_reasoning_completely_disabled(llm_config: LLMConfig) -> bool",
          "parameters": "(llm_config: LLMConfig)",
          "return_type": "bool",
          "docstring": "Check if reasoning is completely disabled by verifying all three conditions:\n    - put_inner_thoughts_in_kwargs is False\n    - enable_reasoner is False\n    - max_reasoning_tokens is 0\n\n    Args:\n        llm_config: The LLM configuration to check\n\n    Returns:\n        True if reasoning is completely disabled, False otherwise",
          "decorators": [],
          "start_line": 9,
          "end_line": 22,
          "is_async": false
        },
        {
          "name": "scrub_inner_thoughts_from_messages",
          "signature": "def scrub_inner_thoughts_from_messages(messages: List[Message], llm_config: LLMConfig) -> List[Message]",
          "parameters": "(messages: List[Message], llm_config: LLMConfig)",
          "return_type": "List[Message]",
          "docstring": "Remove inner thoughts (reasoning text) from assistant messages when reasoning is completely disabled.\n    This makes the LLM think reasoning was never enabled by presenting clean message history.\n\n    Args:\n        messages: List of messages to potentially scrub\n        llm_config: The LLM configuration to check\n\n    Returns:\n        The message list with inner thoughts removed if reasoning is disabled, otherwise unchanged",
          "decorators": [],
          "start_line": 25,
          "end_line": 48,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991580
    },
    "letta/helpers/singleton.py": {
      "path": "letta/helpers/singleton.py",
      "contentHash": "2b1cec6e45d7a8727289df0ef16695e3",
      "mtime": 1767315072008.543,
      "functions": [
        {
          "name": "singleton",
          "signature": "def singleton(cls)",
          "parameters": "(cls)",
          "return_type": null,
          "docstring": "Decorator to make a class a Singleton class.",
          "decorators": [],
          "start_line": 5,
          "end_line": 15,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991580
    },
    "letta/helpers/tool_execution_helper.py": {
      "path": "letta/helpers/tool_execution_helper.py",
      "contentHash": "c2906552054cc88ad53f480875603ef4",
      "mtime": 1767315072008.543,
      "functions": [
        {
          "name": "enable_strict_mode",
          "signature": "def enable_strict_mode(tool_schema: Dict[str, Any]) -> Dict[str, Any]",
          "parameters": "(tool_schema: Dict[str, Any])",
          "return_type": "Dict[str, Any]",
          "docstring": "Enables strict mode for a tool schema by setting 'strict' to True and\n    disallowing additional properties in the parameters.\n\n    If the tool schema is NON_STRICT_ONLY, strict mode will not be applied.\n\n    Args:\n        tool_schema (Dict[str, Any]): The original tool schema.\n\n    Returns:\n        Dict[str, Any]: A new tool schema with strict mode conditionally enabled.",
          "decorators": [],
          "start_line": 11,
          "end_line": 50,
          "is_async": false
        },
        {
          "name": "add_pre_execution_message",
          "signature": "def add_pre_execution_message(tool_schema: Dict[str, Any], description: Optional[str] = None) -> Dict[str, Any]",
          "parameters": "(tool_schema: Dict[str, Any], description: Optional[str] = None)",
          "return_type": "Dict[str, Any]",
          "docstring": "Adds a `pre_execution_message` parameter to a tool schema to prompt a natural, human-like message before executing the tool.\n\n    Args:\n        tool_schema (Dict[str, Any]): The original tool schema.\n        description (Optional[str]): Description of the tool schema. Defaults to None.\n\n    Returns:\n        Dict[str, Any]: A new tool schema with the `pre_execution_message` field added at the beginning.",
          "decorators": [],
          "start_line": 53,
          "end_line": 101,
          "is_async": false
        },
        {
          "name": "remove_request_heartbeat",
          "signature": "def remove_request_heartbeat(tool_schema: Dict[str, Any]) -> Dict[str, Any]",
          "parameters": "(tool_schema: Dict[str, Any])",
          "return_type": "Dict[str, Any]",
          "docstring": "Removes the `request_heartbeat` parameter from a tool schema if it exists.\n\n    Args:\n        tool_schema (Dict[str, Any]): The original tool schema.\n\n    Returns:\n        Dict[str, Any]: A new tool schema without `request_heartbeat`.",
          "decorators": [],
          "start_line": 104,
          "end_line": 131,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991580
    },
    "letta/helpers/tool_helpers.py": {
      "path": "letta/helpers/tool_helpers.py",
      "contentHash": "e32eaad867340c7e8f7dd9ba4d4395d0",
      "mtime": 1767315072008.543,
      "functions": [
        {
          "name": "compute_tool_hash",
          "signature": "def compute_tool_hash(tool: Tool)",
          "parameters": "(tool: Tool)",
          "return_type": null,
          "docstring": "Calculate a hash representing the current version of the tool and configuration.\n    This hash changes when:\n    - Tool source code changes\n    - Tool dependencies change\n    - Sandbox configuration changes\n    - Language/runtime changes",
          "decorators": [],
          "start_line": 26,
          "end_line": 42,
          "is_async": false
        },
        {
          "name": "generate_modal_function_name",
          "signature": "def generate_modal_function_name(tool_name: str, organization_id: str, project_id: str = \"default\") -> str",
          "parameters": "(tool_name: str, organization_id: str, project_id: str = \"default\")",
          "return_type": "str",
          "docstring": "Generate a Modal function name from tool name and project ID.\n    Shortens the project ID to just the prefix and first UUID segment.\n\n    Args:\n        tool_name: Name of the tool\n        organization_id: Full organization ID (not used in function name, but kept for future use)\n        project_id: Project ID (e.g., project-12345678-90ab-cdef-1234-567890abcdef or \"default\")\n\n    Returns:\n        Modal function name (e.g., tool_name_project-12345678 or tool_name_default)",
          "decorators": [],
          "start_line": 45,
          "end_line": 69,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991580
    },
    "letta/helpers/tpuf_client.py": {
      "path": "letta/helpers/tpuf_client.py",
      "contentHash": "bfe82fe209528e623a969617df08ee4f",
      "mtime": 1768610518514.1997,
      "functions": [
        {
          "name": "should_use_tpuf",
          "signature": "def should_use_tpuf() -> bool",
          "parameters": "()",
          "return_type": "bool",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "should_use_tpuf_for_messages",
          "signature": "def should_use_tpuf_for_messages() -> bool",
          "parameters": "()",
          "return_type": "bool",
          "docstring": "Check if Turbopuffer should be used for messages.",
          "decorators": [],
          "start_line": 28,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "should_use_tpuf_for_tools",
          "signature": "def should_use_tpuf_for_tools() -> bool",
          "parameters": "()",
          "return_type": "bool",
          "docstring": "Check if Turbopuffer should be used for tools.",
          "decorators": [],
          "start_line": 33,
          "end_line": 35,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991580
    },
    "letta/helpers/webhook_validation.py": {
      "path": "letta/helpers/webhook_validation.py",
      "contentHash": "9b13b2d94b4853a9476091fc9b9840f6",
      "mtime": 1767315762429.7454,
      "functions": [
        {
          "name": "is_private_ip",
          "signature": "def is_private_ip(ip_str: str) -> bool",
          "parameters": "(ip_str: str)",
          "return_type": "bool",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 38,
          "is_async": false
        },
        {
          "name": "resolve_hostname",
          "signature": "def resolve_hostname(hostname: str) -> List[str]",
          "parameters": "(hostname: str)",
          "return_type": "List[str]",
          "docstring": null,
          "decorators": [],
          "start_line": 41,
          "end_line": 46,
          "is_async": false
        },
        {
          "name": "validate_webhook_url",
          "signature": "def validate_webhook_url(\n    url: str,\n    blocked_hosts: Optional[List[str]] = None,\n    allowed_hosts: Optional[List[str]] = None,\n    require_https: bool = False,\n) -> Tuple[bool, Optional[str]]",
          "parameters": "(\n    url: str,\n    blocked_hosts: Optional[List[str]] = None,\n    allowed_hosts: Optional[List[str]] = None,\n    require_https: bool = False,\n)",
          "return_type": "Tuple[bool, Optional[str]]",
          "docstring": null,
          "decorators": [],
          "start_line": 49,
          "end_line": 106,
          "is_async": false
        },
        {
          "name": "validate_webhook_url_strict",
          "signature": "def validate_webhook_url_strict(url: str) -> Tuple[bool, Optional[str]]",
          "parameters": "(url: str)",
          "return_type": "Tuple[bool, Optional[str]]",
          "docstring": null,
          "decorators": [],
          "start_line": 109,
          "end_line": 110,
          "is_async": false
        }
      ],
      "parsedAt": 1769607991580
    },
    "letta/jobs/helpers.py": {
      "path": "letta/jobs/helpers.py",
      "contentHash": "723f8b8e6e2f6539937bc8036e561308",
      "mtime": 1767315072008.543,
      "functions": [
        {
          "name": "map_anthropic_batch_job_status_to_job_status",
          "signature": "def map_anthropic_batch_job_status_to_job_status(anthropic_status: str) -> JobStatus",
          "parameters": "(anthropic_status: str)",
          "return_type": "JobStatus",
          "docstring": null,
          "decorators": [],
          "start_line": 10,
          "end_line": 16,
          "is_async": false
        },
        {
          "name": "map_anthropic_individual_batch_item_status_to_job_status",
          "signature": "def map_anthropic_individual_batch_item_status_to_job_status(individual_item: BetaMessageBatchIndividualResponse) -> JobStatus",
          "parameters": "(individual_item: BetaMessageBatchIndividualResponse)",
          "return_type": "JobStatus",
          "docstring": null,
          "decorators": [],
          "start_line": 19,
          "end_line": 25,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044028
    },
    "letta/jobs/llm_batch_job_polling.py": {
      "path": "letta/jobs/llm_batch_job_polling.py",
      "contentHash": "839b01355594305c632f4d7c7921fa43",
      "mtime": 1767315072012.5432,
      "functions": [
        {
          "name": "fetch_batch_status",
          "signature": "def fetch_batch_status(server: SyncServer, batch_job: LLMBatchJob) -> BatchPollingResult",
          "parameters": "(server: SyncServer, batch_job: LLMBatchJob)",
          "return_type": "BatchPollingResult",
          "docstring": "Fetch the current status of a single batch job from the provider.\n\n    Args:\n        server: The SyncServer instance\n        batch_job: The batch job to check status for\n\n    Returns:\n        A tuple containing (batch_id, new_status, polling_response)",
          "decorators": [
            "@trace_method"
          ],
          "start_line": 42,
          "end_line": 62,
          "is_async": true
        },
        {
          "name": "tch_batch_items(s",
          "signature": "def tch_batch_items(server: SyncServer, batch_id: str, batch_resp_id: str) - -> st[ItemUpdateInfo]:\n",
          "parameters": "erver: SyncServer, batch_id: str, batch_resp_id: str) -",
          "return_type": "st[ItemUpdateInfo]:\n",
          "docstring": "\"\n    Fetch individual item results for a completed batch.\n\n    Args:\n        server: The SyncServer instance\n        batch_id: The internal batch ID\n        batch_resp_id: The provider's batch response ID\n\n    Returns:\n        A list of item update information tuples\n    \"\"\"",
          "decorators": [
            "race_method\na"
          ],
          "start_line": 66,
          "end_line": 89,
          "is_async": true
        },
        {
          "name": "ll_batch_updates(s",
          "signature": "def ll_batch_updates(server: SyncServer, batch_jobs: List[LLMBatchJob], metrics: BatchPollingMetrics) - -> st[BatchPollingResult]:\n",
          "parameters": "erver: SyncServer, batch_jobs: List[LLMBatchJob], metrics: BatchPollingMetrics) -",
          "return_type": "st[BatchPollingResult]:\n",
          "docstring": "\"\n    Poll for updates to multiple batch jobs concurrently.\n\n    Args:\n        server: The SyncServer instance\n        batch_jobs: List of batch jobs to poll\n        metrics: Metrics collection object\n\n    Returns:\n        List of batch polling results\n    \"\"\"",
          "decorators": [
            "race_method\na"
          ],
          "start_line": 93,
          "end_line": 117,
          "is_async": true
        },
        {
          "name": "ocess_completed_batches(\n",
          "signature": "def ocess_completed_batches(\n    server: SyncServer, batch_results: List[BatchPollingResult], metrics: BatchPollingMetrics\n) - -> st[ItemUpdateInfo]:\n",
          "parameters": "    server: SyncServer, batch_results: List[BatchPollingResult], metrics: BatchPollingMetrics\n) -",
          "return_type": "st[ItemUpdateInfo]:\n",
          "docstring": "\"\n    Process batches that have completed and fetch their item results.\n\n    Args:\n        server: The SyncServer instance\n        batch_results: Results from polling batch statuses\n        metrics: Metrics collection object\n\n    Returns:\n        List of item updates to apply\n    \"\"\"",
          "decorators": [
            "race_method\na"
          ],
          "start_line": 121,
          "end_line": 166,
          "is_async": true
        },
        {
          "name": "ll_running_llm_batches(s",
          "signature": "def ll_running_llm_batches(server: \"SyncServer\") - -> st[LettaBatchResponse]:\n",
          "parameters": "erver: \"SyncServer\") -",
          "return_type": "st[LettaBatchResponse]:\n",
          "docstring": "\"\n    Cron job to poll all running LLM batch jobs and update their polling responses in bulk.\n\n    Steps:\n      1. Fetch currently running batch jobs\n      2. Filter Anthropic only\n      3. Retrieve updated top-level polling info concurrently\n      4. Bulk update LLMBatchJob statuses\n      5. For each completed batch, call .results(...) to get item-level results\n      6. Bulk update all matching LLMBatchItem records by (batch_id, agent_id)\n      7. Log telemetry about success/fail\n    \"\"\"",
          "decorators": [
            "race_method\na"
          ],
          "start_line": 170,
          "end_line": 247,
          "is_async": true
        }
      ],
      "parsedAt": 1769608044029
    },
    "letta/jobs/scheduler.py": {
      "path": "letta/jobs/scheduler.py",
      "contentHash": "b5c6867a329cfac5d2aca59d3176c13d",
      "mtime": 1767315072012.5432,
      "functions": [
        {
          "name": "start_scheduler_with_leader_election",
          "signature": "def start_scheduler_with_leader_election(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Call this function from your FastAPI startup event handler.\n    Attempts immediate lock acquisition, starts background retry if failed.",
          "decorators": [],
          "start_line": 163,
          "end_line": 182,
          "is_async": true
        },
        {
          "name": "shutdown_scheduler_and_release_lock",
          "signature": "def shutdown_scheduler_and_release_lock()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Call this function from your FastAPI shutdown event handler.\n    Stops scheduler/releases lock if leader, cancels retry task otherwise.",
          "decorators": [],
          "start_line": 185,
          "end_line": 228,
          "is_async": true
        }
      ],
      "parsedAt": 1769608044029
    },
    "letta/llm_api/anthropic_client.py": {
      "path": "letta/llm_api/anthropic_client.py",
      "contentHash": "f9c05e2309f6ad4bac237bef8ef23626",
      "mtime": 1768610518514.1997,
      "functions": [
        {
          "name": "convert_tools_to_anthropic_format",
          "signature": "def convert_tools_to_anthropic_format(\n    tools: List[OpenAITool],\n    use_strict: bool = False,\n    add_strict_field: bool = True,\n) -> List[dict]",
          "parameters": "(\n    tools: List[OpenAITool],\n    use_strict: bool = False,\n    add_strict_field: bool = True,\n)",
          "return_type": "List[dict]",
          "docstring": "See: https://docs.anthropic.com/claude/docs/tool-use\n\n    OpenAI style:\n      \"tools\": [{\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"find_movies\",\n            \"description\": \"find ....\",\n            \"parameters\": {\n              \"type\": \"object\",\n              \"properties\": {...},\n              \"required\": List[str],\n            }\n        }\n      }]\n\n    Anthropic style:\n      \"tools\": [{\n        \"name\": \"find_movies\",\n        \"description\": \"find ....\",\n        \"input_schema\": {\n          \"type\": \"object\",\n          \"properties\": {...},\n          \"required\": List[str],\n        },\n      }]\n\n    Args:\n        tools: List of OpenAI-style tools to convert\n        use_strict: If True, add additionalProperties: false to all object schemas\n        add_strict_field: If True (and use_strict=True), add strict: true to allowlisted tools.\n                         Set to False for token counting endpoint which doesn't support this field.",
          "decorators": [],
          "start_line": 1096,
          "end_line": 1179,
          "is_async": false
        },
        {
          "name": "is_heartbeat",
          "signature": "def is_heartbeat(message: dict, is_ping: bool = False) -> bool",
          "parameters": "(message: dict, is_ping: bool = False)",
          "return_type": "bool",
          "docstring": "Check if the message is an automated heartbeat ping",
          "decorators": [],
          "start_line": 1235,
          "end_line": 1265,
          "is_async": false
        },
        {
          "name": "drop_heartbeats",
          "signature": "def drop_heartbeats(messages: List[dict])",
          "parameters": "(messages: List[dict])",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1268,
          "end_line": 1303,
          "is_async": false
        },
        {
          "name": "merge_heartbeats_into_tool_responses",
          "signature": "def merge_heartbeats_into_tool_responses(messages: List[dict])",
          "parameters": "(messages: List[dict])",
          "return_type": null,
          "docstring": "For extended thinking mode, we don't want anything other than tool responses in-between assistant actions\n\n    Otherwise, the thinking will silently get dropped.\n\n    NOTE: assumes merge_tool_results_into_user_messages has already been called",
          "decorators": [],
          "start_line": 1306,
          "end_line": 1366,
          "is_async": false
        },
        {
          "name": "merge_tool_results_into_user_messages",
          "signature": "def merge_tool_results_into_user_messages(messages: List[dict])",
          "parameters": "(messages: List[dict])",
          "return_type": null,
          "docstring": "Anthropic API doesn't allow role 'tool'->'user' sequences\n\n    Example HTTP error:\n    messages: roles must alternate between \"user\" and \"assistant\", but found multiple \"user\" roles in a row\n\n    From: https://docs.anthropic.com/claude/docs/tool-use\n    You may be familiar with other APIs that return tool use as separate from the model's primary output,\n    or which use a special-purpose tool or function message role.\n    In contrast, Anthropic's models and API are built around alternating user and assistant messages,\n    where each message is an array of rich content blocks: text, image, tool_use, and tool_result.",
          "decorators": [],
          "start_line": 1369,
          "end_line": 1418,
          "is_async": false
        },
        {
          "name": "dedupe_tool_results_in_user_messages",
          "signature": "def dedupe_tool_results_in_user_messages(messages: List[dict]) -> List[dict]",
          "parameters": "(messages: List[dict])",
          "return_type": "List[dict]",
          "docstring": "Ensure each tool_use has a single tool_result within a user message.\n\n    If multiple tool_result blocks with the same tool_use_id appear in the same user message\n    (e.g., after merging consecutive user messages), merge their content and keep only one block.",
          "decorators": [],
          "start_line": 1421,
          "end_line": 1473,
          "is_async": false
        },
        {
          "name": "remap_finish_reason",
          "signature": "def remap_finish_reason(stop_reason: str) -> str",
          "parameters": "(stop_reason: str)",
          "return_type": "str",
          "docstring": "Remap Anthropic's 'stop_reason' to OpenAI 'finish_reason'\n\n    OpenAI: 'stop', 'length', 'function_call', 'content_filter', null\n    see: https://platform.openai.com/docs/guides/text-generation/chat-completions-api\n\n    From: https://docs.anthropic.com/claude/reference/migrating-from-text-completions-to-messages#stop-reason\n\n    Messages have a stop_reason of one of the following values:\n        \"end_turn\": The conversational turn ended naturally.\n        \"stop_sequence\": One of your specified custom stop sequences was generated.\n        \"max_tokens\": (unchanged)",
          "decorators": [],
          "start_line": 1476,
          "end_line": 1499,
          "is_async": false
        },
        {
          "name": "strip_xml_tags",
          "signature": "def strip_xml_tags(string: str, tag: Optional[str]) -> str",
          "parameters": "(string: str, tag: Optional[str])",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 1502,
          "end_line": 1508,
          "is_async": false
        },
        {
          "name": "strip_xml_tags_streaming",
          "signature": "def strip_xml_tags_streaming(string: str, tag: Optional[str]) -> str",
          "parameters": "(string: str, tag: Optional[str])",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 1511,
          "end_line": 1530,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044029
    },
    "letta/llm_api/error_utils.py": {
      "path": "letta/llm_api/error_utils.py",
      "contentHash": "ce72ab1981a9f18539e2d15ec16a36d9",
      "mtime": 1767315072012.5432,
      "functions": [
        {
          "name": "is_context_window_overflow_message",
          "signature": "def is_context_window_overflow_message(msg: str) -> bool",
          "parameters": "(msg: str)",
          "return_type": "bool",
          "docstring": "Best-effort detection for context window overflow errors.\n\n    Different providers (and even different API surfaces within the same provider)\n    may phrase context-window errors differently. We centralize the heuristic so\n    all layers (clients, streaming interfaces, agent loops) behave consistently.",
          "decorators": [],
          "start_line": 8,
          "end_line": 22,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044029
    },
    "letta/llm_api/google_ai_client.py": {
      "path": "letta/llm_api/google_ai_client.py",
      "contentHash": "35c68cebf33572f2ac7bc4602898f8bb",
      "mtime": 1767315072012.5432,
      "functions": [
        {
          "name": "get_gemini_endpoint_and_headers",
          "signature": "def get_gemini_endpoint_and_headers(\n    base_url: str, model: Optional[str], api_key: str, key_in_header: bool = True, generate_content: bool = False\n) -> Tuple[str, dict]",
          "parameters": "(\n    base_url: str, model: Optional[str], api_key: str, key_in_header: bool = True, generate_content: bool = False\n)",
          "return_type": "Tuple[str, dict]",
          "docstring": "Dynamically generate the model endpoint and headers.",
          "decorators": [],
          "start_line": 27,
          "end_line": 51,
          "is_async": false
        },
        {
          "name": "google_ai_check_valid_api_key_async",
          "signature": "def google_ai_check_valid_api_key_async(api_key: str)",
          "parameters": "(api_key: str)",
          "return_type": null,
          "docstring": "Async version to check if Google AI API key is valid without blocking the event loop.",
          "decorators": [],
          "start_line": 54,
          "end_line": 71,
          "is_async": true
        },
        {
          "name": "google_ai_get_model_list_async",
          "signature": "def google_ai_get_model_list_async(\n    base_url: str, api_key: str, key_in_header: bool = True, client: Optional[httpx.AsyncClient] = None\n) -> List[dict]",
          "parameters": "(\n    base_url: str, api_key: str, key_in_header: bool = True, client: Optional[httpx.AsyncClient] = None\n)",
          "return_type": "List[dict]",
          "docstring": "Asynchronous version to get model list from Google AI API using httpx.",
          "decorators": [],
          "start_line": 74,
          "end_line": 116,
          "is_async": true
        },
        {
          "name": "google_ai_get_model_details",
          "signature": "def google_ai_get_model_details(base_url: str, api_key: str, model: str, key_in_header: bool = True) -> dict",
          "parameters": "(base_url: str, api_key: str, model: str, key_in_header: bool = True)",
          "return_type": "dict",
          "docstring": "Synchronous version to get model details from Google AI API using httpx.",
          "decorators": [],
          "start_line": 119,
          "end_line": 152,
          "is_async": false
        },
        {
          "name": "google_ai_get_model_details_async",
          "signature": "def google_ai_get_model_details_async(\n    base_url: str, api_key: str, model: str, key_in_header: bool = True, client: Optional[httpx.AsyncClient] = None\n) -> dict",
          "parameters": "(\n    base_url: str, api_key: str, model: str, key_in_header: bool = True, client: Optional[httpx.AsyncClient] = None\n)",
          "return_type": "dict",
          "docstring": "Asynchronous version to get model details from Google AI API using httpx.",
          "decorators": [],
          "start_line": 155,
          "end_line": 200,
          "is_async": true
        },
        {
          "name": "google_ai_get_model_context_window",
          "signature": "def google_ai_get_model_context_window(base_url: str, api_key: str, model: str, key_in_header: bool = True) -> int",
          "parameters": "(base_url: str, api_key: str, model: str, key_in_header: bool = True)",
          "return_type": "int",
          "docstring": null,
          "decorators": [],
          "start_line": 203,
          "end_line": 207,
          "is_async": false
        },
        {
          "name": "google_ai_get_model_context_window_async",
          "signature": "def google_ai_get_model_context_window_async(base_url: str, api_key: str, model: str, key_in_header: bool = True) -> int",
          "parameters": "(base_url: str, api_key: str, model: str, key_in_header: bool = True)",
          "return_type": "int",
          "docstring": null,
          "decorators": [],
          "start_line": 210,
          "end_line": 214,
          "is_async": true
        }
      ],
      "parsedAt": 1769608044029
    },
    "letta/llm_api/helpers.py": {
      "path": "letta/llm_api/helpers.py",
      "contentHash": "e170b42101ff6348ca603c844dfc0e2b",
      "mtime": 1767315072016.5435,
      "functions": [
        {
          "name": "convert_to_structured_output",
          "signature": "def convert_to_structured_output(openai_function: dict, allow_optional: bool = False) -> dict",
          "parameters": "(openai_function: dict, allow_optional: bool = False)",
          "return_type": "dict",
          "docstring": "Convert function call objects to structured output objects.\n\n    See: https://platform.openai.com/docs/guides/structured-outputs/supported-schemas\n\n    Supports:\n    - Simple type arrays: type: [\"string\", \"null\"]\n    - anyOf with primitives (flattened to type array)\n    - anyOf with complex objects (preserved as anyOf)\n    - Nested structures with recursion\n\n    For OpenAI strict mode, optional fields (not in required) must have explicit default values.",
          "decorators": [],
          "start_line": 133,
          "end_line": 174,
          "is_async": false
        },
        {
          "name": "convert_response_format_to_responses_api",
          "signature": "def convert_response_format_to_responses_api(\n    response_format: Optional[\"ResponseFormatUnion\"],\n) -> Optional[dict]",
          "parameters": "(\n    response_format: Optional[\"ResponseFormatUnion\"],\n)",
          "return_type": "Optional[dict]",
          "docstring": "Convert Letta's ResponseFormatUnion to OpenAI Responses API text.format structure.\n\n    The Responses API uses a different structure than Chat Completions:\n    text={\n        \"format\": {\n            \"type\": \"json_schema\",\n            \"name\": \"...\",\n            \"strict\": True,\n            \"schema\": {...}\n        }\n    }\n\n    Args:\n        response_format: Letta ResponseFormatUnion object\n\n    Returns:\n        Dict with format structure for Responses API, or None",
          "decorators": [],
          "start_line": 177,
          "end_line": 229,
          "is_async": false
        },
        {
          "name": "make_post_request",
          "signature": "def make_post_request(url: str, headers: dict[str, str], data: dict[str, Any]) -> dict[str, Any]",
          "parameters": "(url: str, headers: dict[str, str], data: dict[str, Any])",
          "return_type": "dict[str, Any]",
          "docstring": null,
          "decorators": [],
          "start_line": 232,
          "end_line": 291,
          "is_async": false
        },
        {
          "name": "add_inner_thoughts_to_functions",
          "signature": "def add_inner_thoughts_to_functions(\n    functions: List[dict],\n    inner_thoughts_key: str,\n    inner_thoughts_description: str,\n    inner_thoughts_required: bool = True,\n    put_inner_thoughts_first: bool = True,\n) -> List[dict]",
          "parameters": "(\n    functions: List[dict],\n    inner_thoughts_key: str,\n    inner_thoughts_description: str,\n    inner_thoughts_required: bool = True,\n    put_inner_thoughts_first: bool = True,\n)",
          "return_type": "List[dict]",
          "docstring": "Add an inner_thoughts kwarg to every function in the provided list, ensuring it's the first parameter",
          "decorators": [],
          "start_line": 295,
          "end_line": 338,
          "is_async": false
        },
        {
          "name": "unpack_all_inner_thoughts_from_kwargs",
          "signature": "def unpack_all_inner_thoughts_from_kwargs(\n    response: ChatCompletionResponse,\n    inner_thoughts_key: str,\n) -> ChatCompletionResponse",
          "parameters": "(\n    response: ChatCompletionResponse,\n    inner_thoughts_key: str,\n)",
          "return_type": "ChatCompletionResponse",
          "docstring": "Strip the inner thoughts out of the tool call and put it in the message content",
          "decorators": [],
          "start_line": 341,
          "end_line": 356,
          "is_async": false
        },
        {
          "name": "unpack_inner_thoughts_from_kwargs",
          "signature": "def unpack_inner_thoughts_from_kwargs(choice: Choice, inner_thoughts_key: str) -> Choice",
          "parameters": "(choice: Choice, inner_thoughts_key: str)",
          "return_type": "Choice",
          "docstring": null,
          "decorators": [],
          "start_line": 359,
          "end_line": 396,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044029
    },
    "letta/llm_api/llm_api_tools.py": {
      "path": "letta/llm_api/llm_api_tools.py",
      "contentHash": "eaecfdfcfc21f889d012fe715c1d38a0",
      "mtime": 1767315072016.5435,
      "functions": [
        {
          "name": "retry_with_exponential_backoff",
          "signature": "def retry_with_exponential_backoff(\n    func,\n    initial_delay: float = 1,\n    exponential_base: float = 2,\n    jitter: bool = True,\n    max_retries: int = 20,\n    # List of OpenAI error codes: https://github.com/openai/openai-python/blob/17ac6779958b2b74999c634c4ea4c7b74906027a/src/openai/_client.py#L227-L250\n    # 429 = rate limit\n    error_codes: tuple = (429,),\n)",
          "parameters": "(\n    func,\n    initial_delay: float = 1,\n    exponential_base: float = 2,\n    jitter: bool = True,\n    max_retries: int = 20,\n    # List of OpenAI error codes: https://github.com/openai/openai-python/blob/17ac6779958b2b74999c634c4ea4c7b74906027a/src/openai/_client.py#L227-L250\n    # 429 = rate limit\n    error_codes: tuple = (429,),\n)",
          "return_type": null,
          "docstring": "Retry a function with exponential backoff.",
          "decorators": [],
          "start_line": 38,
          "end_line": 118,
          "is_async": false
        },
        {
          "name": "create",
          "signature": "def create(\n    # agent_state: AgentState,\n    llm_config: LLMConfig,\n    messages: List[Message],\n    user_id: Optional[str] = None,  # option UUID to associate request with\n    functions: Optional[list] = None,\n    functions_python: Optional[dict] = None,\n    function_call: Optional[str] = None,  # see: https://platform.openai.com/docs/api-reference/chat/create#chat-create-tool_choice\n    # hint\n    first_message: bool = False,\n    force_tool_call: Optional[str] = None,  # Force a specific tool to be called\n    # use tool naming?\n    # if false, will use deprecated 'functions' style\n    use_tool_naming: bool = True,\n    # streaming?\n    stream: bool = False,\n    stream_interface: Optional[Union[AgentRefreshStreamingInterface, AgentChunkStreamingInterface]] = None,\n    model_settings: Optional[dict] = None,  # TODO: eventually pass from server\n    put_inner_thoughts_first: bool = True,\n    name: Optional[str] = None,\n    telemetry_manager: Optional[TelemetryManager] = None,\n    step_id: Optional[str] = None,\n    actor: Optional[User] = None,\n) -> ChatCompletionResponse",
          "parameters": "(\n    # agent_state: AgentState,\n    llm_config: LLMConfig,\n    messages: List[Message],\n    user_id: Optional[str] = None,  # option UUID to associate request with\n    functions: Optional[list] = None,\n    functions_python: Optional[dict] = None,\n    function_call: Optional[str] = None,  # see: https://platform.openai.com/docs/api-reference/chat/create#chat-create-tool_choice\n    # hint\n    first_message: bool = False,\n    force_tool_call: Optional[str] = None,  # Force a specific tool to be called\n    # use tool naming?\n    # if false, will use deprecated 'functions' style\n    use_tool_naming: bool = True,\n    # streaming?\n    stream: bool = False,\n    stream_interface: Optional[Union[AgentRefreshStreamingInterface, AgentChunkStreamingInterface]] = None,\n    model_settings: Optional[dict] = None,  # TODO: eventually pass from server\n    put_inner_thoughts_first: bool = True,\n    name: Optional[str] = None,\n    telemetry_manager: Optional[TelemetryManager] = None,\n    step_id: Optional[str] = None,\n    actor: Optional[User] = None,\n)",
          "return_type": "ChatCompletionResponse",
          "docstring": "Return response to chat completion with backoff",
          "decorators": [
            "@trace_method",
            "@retry_with_exponential_backoff"
          ],
          "start_line": 123,
          "end_line": 282,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044030
    },
    "letta/llm_api/mistral.py": {
      "path": "letta/llm_api/mistral.py",
      "contentHash": "9cd5eecec10f777685ff86290dc311b1",
      "mtime": 1767315072016.5435,
      "functions": [
        {
          "name": "mistral_get_model_list_async",
          "signature": "def mistral_get_model_list_async(url: str, api_key: str) -> dict",
          "parameters": "(url: str, api_key: str)",
          "return_type": "dict",
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 22,
          "is_async": true
        }
      ],
      "parsedAt": 1769608044030
    },
    "letta/llm_api/openai.py": {
      "path": "letta/llm_api/openai.py",
      "contentHash": "508fa798fd3fd20ad3ccd51c21665558",
      "mtime": 1767315072016.5435,
      "functions": [
        {
          "name": "openai_check_valid_api_key",
          "signature": "def openai_check_valid_api_key(base_url: str, api_key: Union[str, None]) -> None",
          "parameters": "(base_url: str, api_key: Union[str, None])",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 50,
          "end_line": 62,
          "is_async": false
        },
        {
          "name": "openai_get_model_list",
          "signature": "def openai_get_model_list(url: str, api_key: Optional[str] = None, fix_url: bool = False, extra_params: Optional[dict] = None) -> dict",
          "parameters": "(url: str, api_key: Optional[str] = None, fix_url: bool = False, extra_params: Optional[dict] = None)",
          "return_type": "dict",
          "docstring": "https://platform.openai.com/docs/api-reference/models/list",
          "decorators": [],
          "start_line": 65,
          "end_line": 128,
          "is_async": false
        },
        {
          "name": "openai_get_model_list_async",
          "signature": "def openai_get_model_list_async(\n    url: str,\n    api_key: Optional[str] = None,\n    fix_url: bool = False,\n    extra_params: Optional[dict] = None,\n    client: Optional[\"httpx.AsyncClient\"] = None,\n) -> dict",
          "parameters": "(\n    url: str,\n    api_key: Optional[str] = None,\n    fix_url: bool = False,\n    extra_params: Optional[dict] = None,\n    client: Optional[\"httpx.AsyncClient\"] = None,\n)",
          "return_type": "dict",
          "docstring": "https://platform.openai.com/docs/api-reference/models/list",
          "decorators": [],
          "start_line": 131,
          "end_line": 187,
          "is_async": true
        },
        {
          "name": "build_openai_chat_completions_request",
          "signature": "def build_openai_chat_completions_request(\n    llm_config: LLMConfig,\n    messages: List[PydanticMessage],\n    user_id: Optional[str],\n    functions: Optional[list],\n    function_call: Optional[str],\n    use_tool_naming: bool,\n    put_inner_thoughts_first: bool = True,\n    use_structured_output: bool = True,\n) -> ChatCompletionRequest",
          "parameters": "(\n    llm_config: LLMConfig,\n    messages: List[PydanticMessage],\n    user_id: Optional[str],\n    functions: Optional[list],\n    function_call: Optional[str],\n    use_tool_naming: bool,\n    put_inner_thoughts_first: bool = True,\n    use_structured_output: bool = True,\n)",
          "return_type": "ChatCompletionRequest",
          "docstring": null,
          "decorators": [],
          "start_line": 190,
          "end_line": 289,
          "is_async": false
        },
        {
          "name": "openai_chat_completions_process_stream",
          "signature": "def openai_chat_completions_process_stream(\n    url: str,\n    api_key: str,\n    chat_completion_request: ChatCompletionRequest,\n    stream_interface: Optional[Union[AgentChunkStreamingInterface, AgentRefreshStreamingInterface]] = None,\n    create_message_id: bool = True,\n    create_message_datetime: bool = True,\n    override_tool_call_id: bool = True,\n    # if we expect reasoning content in the response,\n    # then we should emit reasoning_content as \"inner_thoughts\"\n    # however, we don't necessarily want to put these\n    # expect_reasoning_content: bool = False,\n    expect_reasoning_content: bool = True,\n    name: Optional[str] = None,\n) -> ChatCompletionResponse",
          "parameters": "(\n    url: str,\n    api_key: str,\n    chat_completion_request: ChatCompletionRequest,\n    stream_interface: Optional[Union[AgentChunkStreamingInterface, AgentRefreshStreamingInterface]] = None,\n    create_message_id: bool = True,\n    create_message_datetime: bool = True,\n    override_tool_call_id: bool = True,\n    # if we expect reasoning content in the response,\n    # then we should emit reasoning_content as \"inner_thoughts\"\n    # however, we don't necessarily want to put these\n    # expect_reasoning_content: bool = False,\n    expect_reasoning_content: bool = True,\n    name: Optional[str] = None,\n)",
          "return_type": "ChatCompletionResponse",
          "docstring": "Process a streaming completion response, and return a ChatCompletionResponse at the end.\n\n    To \"stream\" the response in Letta, we want to call a streaming-compatible interface function\n    on the chunks received from the OpenAI-compatible server POST SSE response.",
          "decorators": [],
          "start_line": 292,
          "end_line": 547,
          "is_async": false
        },
        {
          "name": "openai_chat_completions_request_stream",
          "signature": "def openai_chat_completions_request_stream(\n    url: str,\n    api_key: str,\n    chat_completion_request: ChatCompletionRequest,\n    fix_url: bool = False,\n) -> Generator[ChatCompletionChunkResponse, None, None]",
          "parameters": "(\n    url: str,\n    api_key: str,\n    chat_completion_request: ChatCompletionRequest,\n    fix_url: bool = False,\n)",
          "return_type": "Generator[ChatCompletionChunkResponse, None, None]",
          "docstring": null,
          "decorators": [],
          "start_line": 550,
          "end_line": 582,
          "is_async": false
        },
        {
          "name": "openai_chat_completions_request",
          "signature": "def openai_chat_completions_request(\n    url: str,\n    api_key: str,\n    chat_completion_request: ChatCompletionRequest,\n) -> ChatCompletionResponse",
          "parameters": "(\n    url: str,\n    api_key: str,\n    chat_completion_request: ChatCompletionRequest,\n)",
          "return_type": "ChatCompletionResponse",
          "docstring": "Send a ChatCompletion request to an OpenAI-compatible server\n\n    If request.stream == True, will yield ChatCompletionChunkResponses\n    If request.stream == False, will return a ChatCompletionResponse\n\n    https://platform.openai.com/docs/guides/text-generation?lang=curl",
          "decorators": [],
          "start_line": 585,
          "end_line": 611,
          "is_async": false
        },
        {
          "name": "openai_embeddings_request",
          "signature": "def openai_embeddings_request(url: str, api_key: str, data: dict) -> EmbeddingResponse",
          "parameters": "(url: str, api_key: str, data: dict)",
          "return_type": "EmbeddingResponse",
          "docstring": "https://platform.openai.com/docs/api-reference/embeddings/create",
          "decorators": [],
          "start_line": 614,
          "end_line": 620,
          "is_async": false
        },
        {
          "name": "prepare_openai_payload",
          "signature": "def prepare_openai_payload(chat_completion_request: ChatCompletionRequest)",
          "parameters": "(chat_completion_request: ChatCompletionRequest)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 623,
          "end_line": 650,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044030
    },
    "letta/llm_api/openai_client.py": {
      "path": "letta/llm_api/openai_client.py",
      "contentHash": "8f2d7195d1c5d87fece15e2be3f44685",
      "mtime": 1768610518518.1997,
      "functions": [
        {
          "name": "is_openai_reasoning_model",
          "signature": "def is_openai_reasoning_model(model: str) -> bool",
          "parameters": "(model: str)",
          "return_type": "bool",
          "docstring": "Utility function to check if the model is a 'reasoner'",
          "decorators": [],
          "start_line": 69,
          "end_line": 74,
          "is_async": false
        },
        {
          "name": "does_not_support_minimal_reasoning",
          "signature": "def does_not_support_minimal_reasoning(model: str) -> bool",
          "parameters": "(model: str)",
          "return_type": "bool",
          "docstring": "Check if the model does not support minimal reasoning effort.\n\n    Currently, models that contain codex don't support minimal reasoning.",
          "decorators": [],
          "start_line": 77,
          "end_line": 82,
          "is_async": false
        },
        {
          "name": "supports_none_reasoning_effort",
          "signature": "def supports_none_reasoning_effort(model: str) -> bool",
          "parameters": "(model: str)",
          "return_type": "bool",
          "docstring": "Check if the model supports 'none' reasoning effort.\n\n    Currently, GPT-5.1 and GPT-5.2 models support the 'none' reasoning effort level.",
          "decorators": [],
          "start_line": 85,
          "end_line": 90,
          "is_async": false
        },
        {
          "name": "is_openai_5_model",
          "signature": "def is_openai_5_model(model: str) -> bool",
          "parameters": "(model: str)",
          "return_type": "bool",
          "docstring": "Utility function to check if the model is a '5' model",
          "decorators": [],
          "start_line": 93,
          "end_line": 95,
          "is_async": false
        },
        {
          "name": "supports_verbosity_control",
          "signature": "def supports_verbosity_control(model: str) -> bool",
          "parameters": "(model: str)",
          "return_type": "bool",
          "docstring": "Check if the model supports verbosity control, currently only GPT-5 models support this",
          "decorators": [],
          "start_line": 98,
          "end_line": 100,
          "is_async": false
        },
        {
          "name": "accepts_developer_role",
          "signature": "def accepts_developer_role(model: str) -> bool",
          "parameters": "(model: str)",
          "return_type": "bool",
          "docstring": "Checks if the model accepts the 'developer' role. Note that not all reasoning models accept this role.\n\n    See: https://community.openai.com/t/developer-role-not-accepted-for-o1-o1-mini-o3-mini/1110750/7",
          "decorators": [],
          "start_line": 103,
          "end_line": 111,
          "is_async": false
        },
        {
          "name": "supports_temperature_param",
          "signature": "def supports_temperature_param(model: str) -> bool",
          "parameters": "(model: str)",
          "return_type": "bool",
          "docstring": "Certain OpenAI models don't support configuring the temperature.\n\n    Example error: 400 - {'error': {'message': \"Unsupported parameter: 'temperature' is not supported with this model.\", 'type': 'invalid_request_error', 'param': 'temperature', 'code': 'unsupported_parameter'}}",
          "decorators": [],
          "start_line": 114,
          "end_line": 122,
          "is_async": false
        },
        {
          "name": "supports_parallel_tool_calling",
          "signature": "def supports_parallel_tool_calling(model: str) -> bool",
          "parameters": "(model: str)",
          "return_type": "bool",
          "docstring": "Certain OpenAI models don't support parallel tool calls.",
          "decorators": [],
          "start_line": 125,
          "end_line": 131,
          "is_async": false
        },
        {
          "name": "supports_structured_output",
          "signature": "def supports_structured_output(llm_config: LLMConfig) -> bool",
          "parameters": "(llm_config: LLMConfig)",
          "return_type": "bool",
          "docstring": "Certain providers don't support structured output.",
          "decorators": [],
          "start_line": 135,
          "end_line": 143,
          "is_async": false
        },
        {
          "name": "requires_auto_tool_choice",
          "signature": "def requires_auto_tool_choice(llm_config: LLMConfig) -> bool",
          "parameters": "(llm_config: LLMConfig)",
          "return_type": "bool",
          "docstring": "Certain providers require the tool choice to be set to 'auto'.",
          "decorators": [],
          "start_line": 147,
          "end_line": 155,
          "is_async": false
        },
        {
          "name": "use_responses_api",
          "signature": "def use_responses_api(llm_config: LLMConfig) -> bool",
          "parameters": "(llm_config: LLMConfig)",
          "return_type": "bool",
          "docstring": null,
          "decorators": [],
          "start_line": 158,
          "end_line": 160,
          "is_async": false
        },
        {
          "name": "supports_content_none",
          "signature": "def supports_content_none(llm_config: LLMConfig) -> bool",
          "parameters": "(llm_config: LLMConfig)",
          "return_type": "bool",
          "docstring": "Certain providers don't support the content None.",
          "decorators": [],
          "start_line": 163,
          "end_line": 167,
          "is_async": false
        },
        {
          "name": "fill_image_content_in_messages",
          "signature": "def fill_image_content_in_messages(openai_message_list: List[dict], pydantic_message_list: List[PydanticMessage]) -> List[dict]",
          "parameters": "(openai_message_list: List[dict], pydantic_message_list: List[PydanticMessage])",
          "return_type": "List[dict]",
          "docstring": "Converts image content to openai format.",
          "decorators": [],
          "start_line": 1085,
          "end_line": 1130,
          "is_async": false
        },
        {
          "name": "fill_image_content_in_responses_input",
          "signature": "def fill_image_content_in_responses_input(openai_message_list: List[dict], pydantic_message_list: List[PydanticMessage]) -> List[dict]",
          "parameters": "(openai_message_list: List[dict], pydantic_message_list: List[PydanticMessage])",
          "return_type": "List[dict]",
          "docstring": "Rewrite user messages in the Responses API input to embed multi-modal parts inside\n    the message's content array (not as top-level items).\n\n    Expected structure for Responses API input messages:\n      { \"type\": \"message\", \"role\": \"user\", \"content\": [\n           {\"type\": \"input_text\", \"text\": \"...\"},\n           {\"type\": \"input_image\", \"image_url\": {\"url\": \"data:<mime>;base64,<data>\", \"detail\": \"auto\"}}\n         ] }\n\n    Non-user items are left unchanged.",
          "decorators": [],
          "start_line": 1133,
          "end_line": 1190,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044030
    },
    "letta/local_llm/chat_completion_proxy.py": {
      "path": "letta/local_llm/chat_completion_proxy.py",
      "contentHash": "13c21577945550c037dc68ca0c7892d5",
      "mtime": 1767315072016.5435,
      "functions": [
        {
          "name": "get_chat_completion",
          "signature": "def get_chat_completion(\n    model,\n    # no model required (except for Ollama), since the model is fixed to whatever you set in your own backend\n    messages,\n    functions=None,\n    functions_python=None,\n    function_call=\"auto\",\n    context_window=None,\n    user=None,\n    # required\n    wrapper=None,\n    endpoint=None,\n    endpoint_type=None,\n    # optional cleanup\n    function_correction=True,\n    # extra hints to allow for additional prompt formatting hacks\n    # TODO this could alternatively be supported via passing function_call=\"send_message\" into the wrapper\n    first_message=False,\n    # optional auth headers\n    auth_type=None,\n    auth_key=None,\n) -> ChatCompletionResponse",
          "parameters": "(\n    model,\n    # no model required (except for Ollama), since the model is fixed to whatever you set in your own backend\n    messages,\n    functions=None,\n    functions_python=None,\n    function_call=\"auto\",\n    context_window=None,\n    user=None,\n    # required\n    wrapper=None,\n    endpoint=None,\n    endpoint_type=None,\n    # optional cleanup\n    function_correction=True,\n    # extra hints to allow for additional prompt formatting hacks\n    # TODO this could alternatively be supported via passing function_call=\"send_message\" into the wrapper\n    first_message=False,\n    # optional auth headers\n    auth_type=None,\n    auth_key=None,\n)",
          "return_type": "ChatCompletionResponse",
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 254,
          "is_async": false
        },
        {
          "name": "generate_grammar_and_documentation",
          "signature": "def generate_grammar_and_documentation(\n    functions_python: dict,\n    add_inner_thoughts_top_level: bool,\n    add_inner_thoughts_param_level: bool,\n    allow_only_inner_thoughts: bool,\n)",
          "parameters": "(\n    functions_python: dict,\n    add_inner_thoughts_top_level: bool,\n    add_inner_thoughts_param_level: bool,\n    allow_only_inner_thoughts: bool,\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 257,
          "end_line": 284,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044030
    },
    "letta/local_llm/function_parser.py": {
      "path": "letta/local_llm/function_parser.py",
      "contentHash": "700361246efe4dc673982314cfa46d86",
      "mtime": 1767315072016.5435,
      "functions": [
        {
          "name": "insert_heartbeat",
          "signature": "def insert_heartbeat(message)",
          "parameters": "(message)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 27,
          "is_async": false
        },
        {
          "name": "heartbeat_correction",
          "signature": "def heartbeat_correction(message_history, new_message)",
          "parameters": "(message_history, new_message)",
          "return_type": null,
          "docstring": "Add heartbeats where we think the agent forgot to add them themselves\n\n    If the last message in the stack is a user message and the new message is an assistant func call, fix the heartbeat\n\n    See: https://github.com/letta-ai/letta/issues/601",
          "decorators": [],
          "start_line": 30,
          "end_line": 63,
          "is_async": false
        },
        {
          "name": "patch_function",
          "signature": "def patch_function(message_history, new_message)",
          "parameters": "(message_history, new_message)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 66,
          "end_line": 68,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044030
    },
    "letta/local_llm/grammars/gbnf_grammar_generator.py": {
      "path": "letta/local_llm/grammars/gbnf_grammar_generator.py",
      "contentHash": "6ac84700365a04acc92160b57f155a50",
      "mtime": 1767315072020.5435,
      "functions": [
        {
          "name": "map_pydantic_type_to_gbnf",
          "signature": "def map_pydantic_type_to_gbnf(pydantic_type: Type[Any]) -> str",
          "parameters": "(pydantic_type: Type[Any])",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 47,
          "end_line": 80,
          "is_async": false
        },
        {
          "name": "format_model_and_field_name",
          "signature": "def format_model_and_field_name(model_name: str) -> str",
          "parameters": "(model_name: str)",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 83,
          "end_line": 87,
          "is_async": false
        },
        {
          "name": "generate_list_rule",
          "signature": "def generate_list_rule(element_type)",
          "parameters": "(element_type)",
          "return_type": null,
          "docstring": "Generate a GBNF rule for a list of a given element type.\n\n    :param element_type: The type of the elements in the list (e.g., 'string').\n    :return: A string representing the GBNF rule for a list of the given type.",
          "decorators": [],
          "start_line": 90,
          "end_line": 100,
          "is_async": false
        },
        {
          "name": "get_members_structure",
          "signature": "def get_members_structure(cls, rule_name)",
          "parameters": "(cls, rule_name)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 103,
          "end_line": 140,
          "is_async": false
        },
        {
          "name": "regex_to_gbnf",
          "signature": "def regex_to_gbnf(regex_pattern: str) -> str",
          "parameters": "(regex_pattern: str)",
          "return_type": "str",
          "docstring": "Translate a basic regex pattern to a GBNF rule.\n    Note: This function handles only a subset of simple regex patterns.",
          "decorators": [],
          "start_line": 143,
          "end_line": 157,
          "is_async": false
        },
        {
          "name": "generate_gbnf_integer_rules",
          "signature": "def generate_gbnf_integer_rules(max_digit=None, min_digit=None)",
          "parameters": "(max_digit=None, min_digit=None)",
          "return_type": null,
          "docstring": "Generate GBNF Integer Rules\n\n    Generates GBNF (Generalized Backus-Naur Form) rules for integers based on the given maximum and minimum digits.\n\n    Parameters:\n        max_digit (int): The maximum number of digits for the integer. Default is None.\n        min_digit (int): The minimum number of digits for the integer. Default is None.\n\n    Returns:\n        integer_rule (str): The identifier for the integer rule generated.\n        additional_rules (list): A list of additional rules generated based on the given maximum and minimum digits.",
          "decorators": [],
          "start_line": 160,
          "end_line": 204,
          "is_async": false
        },
        {
          "name": "generate_gbnf_float_rules",
          "signature": "def generate_gbnf_float_rules(max_digit=None, min_digit=None, max_precision=None, min_precision=None)",
          "parameters": "(max_digit=None, min_digit=None, max_precision=None, min_precision=None)",
          "return_type": null,
          "docstring": "Generate GBNF float rules based on the given constraints.\n\n    :param max_digit: Maximum number of digits in the integer part (default: None)\n    :param min_digit: Minimum number of digits in the integer part (default: None)\n    :param max_precision: Maximum number of digits in the fractional part (default: None)\n    :param min_precision: Minimum number of digits in the fractional part (default: None)\n    :return: A tuple containing the float rule and additional rules as a list\n\n    Example Usage:\n    max_digit = 3\n    min_digit = 1\n    max_precision = 2\n    min_precision = 1\n    generate_gbnf_float_rules(max_digit, min_digit, max_precision, min_precision)\n\n    Output:\n    ('float-3-1-2-1', ['integer-part-max3-min1 ::= [0-9] [0-9] [0-9]?', 'fractional-part-max2-min1 ::= [0-9] [0-9]?', 'float-3-1-2-1 ::= integer-part-max3-min1 \".\" fractional-part-max2-min\n    *1'])\n\n    Note:\n    GBNF stands for Generalized Backus-Naur Form, which is a notation technique to specify the syntax of programming languages or other formal grammars.",
          "decorators": [],
          "start_line": 207,
          "end_line": 266,
          "is_async": false
        },
        {
          "name": "generate_gbnf_rule_for_type",
          "signature": "def generate_gbnf_rule_for_type(\n    model_name, field_name, field_type, is_optional, processed_models, created_rules, field_info=None\n) -> Tuple[str, list]",
          "parameters": "(\n    model_name, field_name, field_type, is_optional, processed_models, created_rules, field_info=None\n)",
          "return_type": "Tuple[str, list]",
          "docstring": "Generate GBNF rule for a given field type.\n\n    :param model_name: Name of the model.\n\n    :param field_name: Name of the field.\n    :param field_type: Type of the field.\n    :param is_optional: Whether the field is optional.\n    :param processed_models: List of processed models.\n    :param created_rules: List of created rules.\n    :param field_info: Additional information about the field (optional).\n\n    :return: Tuple containing the GBNF type and a list of additional rules.\n    :rtype: Tuple[str, list]",
          "decorators": [],
          "start_line": 269,
          "end_line": 424,
          "is_async": false
        },
        {
          "name": "generate_gbnf_grammar",
          "signature": "def generate_gbnf_grammar(model: Type[BaseModel], processed_models: set, created_rules: dict) -> (list, bool, bool)",
          "parameters": "(model: Type[BaseModel], processed_models: set, created_rules: dict)",
          "return_type": "(list, bool, bool)",
          "docstring": "Generate GBnF Grammar\n\n    Generates a GBnF grammar for a given model.\n\n    :param model: A Pydantic model class to generate the grammar for. Must be a subclass of BaseModel.\n    :param processed_models: A set of already processed models to prevent infinite recursion.\n    :param created_rules: A dict containing already created rules to prevent duplicates.\n    :return: A list of GBnF grammar rules in string format. And two booleans indicating if an extra markdown or triple quoted string is in the grammar.\n    Example Usage:\n    ```\n    model = MyModel\n    processed_models = set()\n    created_rules = dict()\n\n    gbnf_grammar = generate_gbnf_grammar(model, processed_models, created_rules)\n    ```",
          "decorators": [],
          "start_line": 427,
          "end_line": 507,
          "is_async": false
        },
        {
          "name": "generate_gbnf_grammar_from_pydantic_models",
          "signature": "def generate_gbnf_grammar_from_pydantic_models(\n    models: List[Type[BaseModel]],\n    outer_object_name: str = None,\n    outer_object_content: str = None,\n    list_of_outputs: bool = False,\n    add_inner_thoughts: bool = False,\n    allow_only_inner_thoughts: bool = False,\n) -> str",
          "parameters": "(\n    models: List[Type[BaseModel]],\n    outer_object_name: str = None,\n    outer_object_content: str = None,\n    list_of_outputs: bool = False,\n    add_inner_thoughts: bool = False,\n    allow_only_inner_thoughts: bool = False,\n)",
          "return_type": "str",
          "docstring": "Generate GBNF Grammar from Pydantic Models.\n\n    This method takes a list of Pydantic models and uses them to generate a GBNF grammar string. The generated grammar string can be used for parsing and validating data using the generated\n    * grammar.\n\n    Args:\n        models (List[Type[BaseModel]]): A list of Pydantic models to generate the grammar from.\n        outer_object_name (str): Outer object name for the GBNF grammar. If None, no outer object will be generated. Eg. \"function\" for function calling.\n        outer_object_content (str): Content for the outer rule in the GBNF grammar. Eg. \"function_parameters\" or \"params\" for function calling.\n        list_of_outputs (str, optional): Allows a list of output objects\n        add_inner_thoughts (bool): Add inner thoughts field on the top level.\n        allow_only_inner_thoughts (bool): Allow inner thoughts without a function call.\n    Returns:\n        str: The generated GBNF grammar string.\n\n    Examples:\n        models = [UserModel, PostModel]\n        grammar = generate_gbnf_grammar_from_pydantic(models)\n        print(grammar)\n        # Output:\n        # root ::= UserModel | PostModel\n        # ...",
          "decorators": [],
          "start_line": 510,
          "end_line": 595,
          "is_async": false
        },
        {
          "name": "get_primitive_grammar",
          "signature": "def get_primitive_grammar(grammar)",
          "parameters": "(grammar)",
          "return_type": null,
          "docstring": "Returns the needed GBNF primitive grammar for a given GBNF grammar string.\n\n    Args:\n        grammar (str): The string containing the GBNF grammar.\n\n    Returns:\n        str: GBNF primitive grammar string.",
          "decorators": [],
          "start_line": 598,
          "end_line": 662,
          "is_async": false
        },
        {
          "name": "generate_markdown_documentation",
          "signature": "def generate_markdown_documentation(\n    pydantic_models: List[Type[BaseModel]], model_prefix=\"Model\", fields_prefix=\"Fields\", documentation_with_field_description=True\n) -> str",
          "parameters": "(\n    pydantic_models: List[Type[BaseModel]], model_prefix=\"Model\", fields_prefix=\"Fields\", documentation_with_field_description=True\n)",
          "return_type": "str",
          "docstring": "Generate markdown documentation for a list of Pydantic models.\n\n    Args:\n        pydantic_models (List[Type[BaseModel]]): List of Pydantic model classes.\n        model_prefix (str): Prefix for the model section.\n        fields_prefix (str): Prefix for the fields section.\n        documentation_with_field_description (bool): Include field descriptions in the documentation.\n\n    Returns:\n        str: Generated text documentation.",
          "decorators": [],
          "start_line": 665,
          "end_line": 726,
          "is_async": false
        },
        {
          "name": "generate_field_markdown",
          "signature": "def generate_field_markdown(\n    field_name: str, field_type: Type[Any], model: Type[BaseModel], depth=1, documentation_with_field_description=True\n) -> str",
          "parameters": "(\n    field_name: str, field_type: Type[Any], model: Type[BaseModel], depth=1, documentation_with_field_description=True\n)",
          "return_type": "str",
          "docstring": "Generate markdown documentation for a Pydantic model field.\n\n    Args:\n        field_name (str): Name of the field.\n        field_type (Type[Any]): Type of the field.\n        model (Type[BaseModel]): Pydantic model class.\n        depth (int): Indentation depth in the documentation.\n        documentation_with_field_description (bool): Include field descriptions in the documentation.\n\n    Returns:\n        str: Generated text documentation for the field.",
          "decorators": [],
          "start_line": 729,
          "end_line": 800,
          "is_async": false
        },
        {
          "name": "format_json_example",
          "signature": "def format_json_example(example: dict, depth: int) -> str",
          "parameters": "(example: dict, depth: int)",
          "return_type": "str",
          "docstring": "Format a JSON example into a readable string with indentation.\n\n    Args:\n        example (dict): JSON example to be formatted.\n        depth (int): Indentation depth.\n\n    Returns:\n        str: Formatted JSON example string.",
          "decorators": [],
          "start_line": 803,
          "end_line": 820,
          "is_async": false
        },
        {
          "name": "generate_text_documentation",
          "signature": "def generate_text_documentation(\n    pydantic_models: List[Type[BaseModel]], model_prefix=\"Model\", fields_prefix=\"Fields\", documentation_with_field_description=True\n) -> str",
          "parameters": "(\n    pydantic_models: List[Type[BaseModel]], model_prefix=\"Model\", fields_prefix=\"Fields\", documentation_with_field_description=True\n)",
          "return_type": "str",
          "docstring": "Generate text documentation for a list of Pydantic models.\n\n    Args:\n        pydantic_models (List[Type[BaseModel]]): List of Pydantic model classes.\n        model_prefix (str): Prefix for the model section.\n        fields_prefix (str): Prefix for the fields section.\n        documentation_with_field_description (bool): Include field descriptions in the documentation.\n\n    Returns:\n        str: Generated text documentation.",
          "decorators": [],
          "start_line": 823,
          "end_line": 884,
          "is_async": false
        },
        {
          "name": "generate_field_text",
          "signature": "def generate_field_text(\n    field_name: str, field_type: Type[Any], model: Type[BaseModel], depth=1, documentation_with_field_description=True\n) -> str",
          "parameters": "(\n    field_name: str, field_type: Type[Any], model: Type[BaseModel], depth=1, documentation_with_field_description=True\n)",
          "return_type": "str",
          "docstring": "Generate text documentation for a Pydantic model field.\n\n    Args:\n        field_name (str): Name of the field.\n        field_type (Type[Any]): Type of the field.\n        model (Type[BaseModel]): Pydantic model class.\n        depth (int): Indentation depth in the documentation.\n        documentation_with_field_description (bool): Include field descriptions in the documentation.\n\n    Returns:\n        str: Generated text documentation for the field.",
          "decorators": [],
          "start_line": 887,
          "end_line": 950,
          "is_async": false
        },
        {
          "name": "format_multiline_description",
          "signature": "def format_multiline_description(description: str, indent_level: int) -> str",
          "parameters": "(description: str, indent_level: int)",
          "return_type": "str",
          "docstring": "Format a multiline description with proper indentation.\n\n    Args:\n        description (str): Multiline description.\n        indent_level (int): Indentation level.\n\n    Returns:\n        str: Formatted multiline description.",
          "decorators": [],
          "start_line": 953,
          "end_line": 965,
          "is_async": false
        },
        {
          "name": "save_gbnf_grammar_and_documentation",
          "signature": "def save_gbnf_grammar_and_documentation(\n    grammar, documentation, grammar_file_path=\"./grammar.gbnf\", documentation_file_path=\"./grammar_documentation.md\"\n)",
          "parameters": "(\n    grammar, documentation, grammar_file_path=\"./grammar.gbnf\", documentation_file_path=\"./grammar_documentation.md\"\n)",
          "return_type": null,
          "docstring": "Save GBNF grammar and documentation to specified files.\n\n    Args:\n        grammar (str): GBNF grammar string.\n        documentation (str): Documentation string.\n        grammar_file_path (str): File path to save the GBNF grammar.\n        documentation_file_path (str): File path to save the documentation.\n\n    Returns:\n        None",
          "decorators": [],
          "start_line": 968,
          "end_line": 995,
          "is_async": false
        },
        {
          "name": "remove_empty_lines",
          "signature": "def remove_empty_lines(string)",
          "parameters": "(string)",
          "return_type": null,
          "docstring": "Remove empty lines from a string.\n\n    Args:\n        string (str): Input string.\n\n    Returns:\n        str: String with empty lines removed.",
          "decorators": [],
          "start_line": 998,
          "end_line": 1011,
          "is_async": false
        },
        {
          "name": "generate_and_save_gbnf_grammar_and_documentation",
          "signature": "def generate_and_save_gbnf_grammar_and_documentation(\n    pydantic_model_list,\n    grammar_file_path=\"./generated_grammar.gbnf\",\n    documentation_file_path=\"./generated_grammar_documentation.md\",\n    outer_object_name: str = None,\n    outer_object_content: str = None,\n    model_prefix: str = \"Output Model\",\n    fields_prefix: str = \"Output Fields\",\n    list_of_outputs: bool = False,\n    documentation_with_field_description=True,\n)",
          "parameters": "(\n    pydantic_model_list,\n    grammar_file_path=\"./generated_grammar.gbnf\",\n    documentation_file_path=\"./generated_grammar_documentation.md\",\n    outer_object_name: str = None,\n    outer_object_content: str = None,\n    model_prefix: str = \"Output Model\",\n    fields_prefix: str = \"Output Fields\",\n    list_of_outputs: bool = False,\n    documentation_with_field_description=True,\n)",
          "return_type": null,
          "docstring": "Generate GBNF grammar and documentation, and save them to specified files.\n\n    Args:\n        pydantic_model_list: List of Pydantic model classes.\n        grammar_file_path (str): File path to save the generated GBNF grammar.\n        documentation_file_path (str): File path to save the generated documentation.\n        outer_object_name (str): Outer object name for the GBNF grammar. If None, no outer object will be generated. Eg. \"function\" for function calling.\n        outer_object_content (str): Content for the outer rule in the GBNF grammar. Eg. \"function_parameters\" or \"params\" for function calling.\n        model_prefix (str): Prefix for the model section in the documentation.\n        fields_prefix (str): Prefix for the fields section in the documentation.\n        list_of_outputs (bool): Whether the output is a list of items.\n        documentation_with_field_description (bool): Include field descriptions in the documentation.\n\n    Returns:\n        None",
          "decorators": [],
          "start_line": 1014,
          "end_line": 1047,
          "is_async": false
        },
        {
          "name": "generate_gbnf_grammar_and_documentation",
          "signature": "def generate_gbnf_grammar_and_documentation(\n    pydantic_model_list,\n    outer_object_name: str = None,\n    outer_object_content: str = None,\n    model_prefix: str = \"Output Model\",\n    fields_prefix: str = \"Output Fields\",\n    list_of_outputs: bool = False,\n    add_inner_thoughts: bool = False,\n    allow_only_inner_thoughts: bool = False,\n    documentation_with_field_description=True,\n)",
          "parameters": "(\n    pydantic_model_list,\n    outer_object_name: str = None,\n    outer_object_content: str = None,\n    model_prefix: str = \"Output Model\",\n    fields_prefix: str = \"Output Fields\",\n    list_of_outputs: bool = False,\n    add_inner_thoughts: bool = False,\n    allow_only_inner_thoughts: bool = False,\n    documentation_with_field_description=True,\n)",
          "return_type": null,
          "docstring": "Generate GBNF grammar and documentation for a list of Pydantic models.\n\n    Args:\n        pydantic_model_list: List of Pydantic model classes.\n        outer_object_name (str): Outer object name for the GBNF grammar. If None, no outer object will be generated. Eg. \"function\" for function calling.\n        outer_object_content (str): Content for the outer rule in the GBNF grammar. Eg. \"function_parameters\" or \"params\" for function calling.\n        model_prefix (str): Prefix for the model section in the documentation.\n        fields_prefix (str): Prefix for the fields section in the documentation.\n        list_of_outputs (bool): Whether the output is a list of items.\n        add_inner_thoughts (bool): Add inner thoughts field on the top level.\n        allow_only_inner_thoughts (bool): Allow inner thoughts without a function call.\n        documentation_with_field_description (bool): Include field descriptions in the documentation.\n\n    Returns:\n        tuple: GBNF grammar string, documentation string.",
          "decorators": [],
          "start_line": 1050,
          "end_line": 1085,
          "is_async": false
        },
        {
          "name": "generate_gbnf_grammar_and_documentation_from_dictionaries",
          "signature": "def generate_gbnf_grammar_and_documentation_from_dictionaries(\n    dictionaries: List[dict],\n    outer_object_name: str = None,\n    outer_object_content: str = None,\n    model_prefix: str = \"Output Model\",\n    fields_prefix: str = \"Output Fields\",\n    list_of_outputs: bool = False,\n    documentation_with_field_description=True,\n)",
          "parameters": "(\n    dictionaries: List[dict],\n    outer_object_name: str = None,\n    outer_object_content: str = None,\n    model_prefix: str = \"Output Model\",\n    fields_prefix: str = \"Output Fields\",\n    list_of_outputs: bool = False,\n    documentation_with_field_description=True,\n)",
          "return_type": null,
          "docstring": "Generate GBNF grammar and documentation from a list of dictionaries.\n\n    Args:\n        dictionaries (List[dict]): List of dictionaries representing Pydantic models.\n        outer_object_name (str): Outer object name for the GBNF grammar. If None, no outer object will be generated. Eg. \"function\" for function calling.\n        outer_object_content (str): Content for the outer rule in the GBNF grammar. Eg. \"function_parameters\" or \"params\" for function calling.\n        model_prefix (str): Prefix for the model section in the documentation.\n        fields_prefix (str): Prefix for the fields section in the documentation.\n        list_of_outputs (bool): Whether the output is a list of items.\n        documentation_with_field_description (bool): Include field descriptions in the documentation.\n\n    Returns:\n        tuple: GBNF grammar string, documentation string.",
          "decorators": [],
          "start_line": 1088,
          "end_line": 1118,
          "is_async": false
        },
        {
          "name": "create_dynamic_model_from_function",
          "signature": "def create_dynamic_model_from_function(func: Callable, add_inner_thoughts: bool = False)",
          "parameters": "(func: Callable, add_inner_thoughts: bool = False)",
          "return_type": null,
          "docstring": "Creates a dynamic Pydantic model from a given function's type hints and adds the function as a 'run' method.\n\n    Args:\n        func (Callable): A function with type hints from which to create the model.\n        add_inner_thoughts: Add an inner thoughts parameter on the params level\n\n    Returns:\n        A dynamic Pydantic model class with the provided function as a 'run' method.",
          "decorators": [],
          "start_line": 1121,
          "end_line": 1183,
          "is_async": false
        },
        {
          "name": "add_run_method_to_dynamic_model",
          "signature": "def add_run_method_to_dynamic_model(model: Type[BaseModel], func: Callable)",
          "parameters": "(model: Type[BaseModel], func: Callable)",
          "return_type": null,
          "docstring": "Add a 'run' method to a dynamic Pydantic model, using the provided function.\n\n    Args:\n        model (Type[BaseModel]): Dynamic Pydantic model class.\n        func (Callable): Function to be added as a 'run' method to the model.\n\n    Returns:\n        Type[BaseModel]: Pydantic model class with the added 'run' method.",
          "decorators": [],
          "start_line": 1186,
          "end_line": 1205,
          "is_async": false
        },
        {
          "name": "create_dynamic_models_from_dictionaries",
          "signature": "def create_dynamic_models_from_dictionaries(dictionaries: List[dict])",
          "parameters": "(dictionaries: List[dict])",
          "return_type": null,
          "docstring": "Create a list of dynamic Pydantic model classes from a list of dictionaries.\n\n    Args:\n        dictionaries (List[dict]): List of dictionaries representing model structures.\n\n    Returns:\n        List[Type[BaseModel]]: List of generated dynamic Pydantic model classes.",
          "decorators": [],
          "start_line": 1208,
          "end_line": 1223,
          "is_async": false
        },
        {
          "name": "map_grammar_names_to_pydantic_model_class",
          "signature": "def map_grammar_names_to_pydantic_model_class(pydantic_model_list)",
          "parameters": "(pydantic_model_list)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1226,
          "end_line": 1231,
          "is_async": false
        },
        {
          "name": "json_schema_to_python_types",
          "signature": "def json_schema_to_python_types(schema)",
          "parameters": "(schema)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1237,
          "end_line": 1246,
          "is_async": false
        },
        {
          "name": "list_to_enum",
          "signature": "def list_to_enum(enum_name, values)",
          "parameters": "(enum_name, values)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1249,
          "end_line": 1250,
          "is_async": false
        },
        {
          "name": "convert_dictionary_to_pydantic_model",
          "signature": "def convert_dictionary_to_pydantic_model(dictionary: dict, model_name: str = \"CustomModel\") -> Type[BaseModel]",
          "parameters": "(dictionary: dict, model_name: str = \"CustomModel\")",
          "return_type": "Type[BaseModel]",
          "docstring": "Convert a dictionary to a Pydantic model class.\n\n    Args:\n        dictionary (dict): Dictionary representing the model structure.\n        model_name (str): Name of the generated Pydantic model.\n\n    Returns:\n        Type[BaseModel]: Generated Pydantic model class.",
          "decorators": [],
          "start_line": 1253,
          "end_line": 1313,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044031
    },
    "letta/local_llm/json_parser.py": {
      "path": "letta/local_llm/json_parser.py",
      "contentHash": "0d1ccc2bd4c01516748c78525260b598",
      "mtime": 1767315072020.5435,
      "functions": [
        {
          "name": "clean_json_string_extra_backslash",
          "signature": "def clean_json_string_extra_backslash(s)",
          "parameters": "(s)",
          "return_type": null,
          "docstring": "Clean extra backslashes out from stringified JSON\n\n    NOTE: Google AI Gemini API likes to include these",
          "decorators": [],
          "start_line": 12,
          "end_line": 21,
          "is_async": false
        },
        {
          "name": "replace_escaped_underscores",
          "signature": "def replace_escaped_underscores(string: str)",
          "parameters": "(string: str)",
          "return_type": null,
          "docstring": "r\"\"\"Handles the case of escaped underscores, e.g.:\n\n    {\n      \"function\":\"send\\_message\",\n      \"params\": {\n        \"inner\\_thoughts\": \"User is asking for information about themselves. Retrieving data from core memory.\",\n        \"message\": \"I know that you are Chad. Is there something specific you would like to know or talk about regarding yourself?\"\n    \"\"\"",
          "decorators": [],
          "start_line": 24,
          "end_line": 33,
          "is_async": false
        },
        {
          "name": "extract_first_json",
          "signature": "def extract_first_json(string: str)",
          "parameters": "(string: str)",
          "return_type": null,
          "docstring": "Handles the case of two JSON objects back-to-back",
          "decorators": [],
          "start_line": 36,
          "end_line": 56,
          "is_async": false
        },
        {
          "name": "add_missing_heartbeat",
          "signature": "def add_missing_heartbeat(llm_json)",
          "parameters": "(llm_json)",
          "return_type": null,
          "docstring": "Manually insert heartbeat requests into messages that should have them\n\n    Use the following heuristic:\n      - if (function call is not send_message && prev message['role'] == user): insert heartbeat\n\n    Basically, if Letta is calling a function (not send_message) immediately after the user sending a message,\n    it probably is a retriever or insertion call, in which case we likely want to eventually reply with send_message\n\n            \"message\" = {\n            \"role\": \"assistant\",\n            \"content\": ...,\n            \"function_call\": {\n                \"name\": ...\n                \"arguments\": {\n                    \"arg1\": val1,\n                    ...\n                }\n            }\n        }",
          "decorators": [],
          "start_line": 59,
          "end_line": 80,
          "is_async": false
        },
        {
          "name": "clean_and_interpret_send_message_json",
          "signature": "def clean_and_interpret_send_message_json(json_string)",
          "parameters": "(json_string)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 83,
          "end_line": 108,
          "is_async": false
        },
        {
          "name": "repair_json_string",
          "signature": "def repair_json_string(json_string)",
          "parameters": "(json_string)",
          "return_type": null,
          "docstring": "This function repairs a JSON string where line feeds were accidentally added\n    within string literals. The line feeds are replaced with the escaped line\n    feed sequence '\\\\n'.",
          "decorators": [],
          "start_line": 111,
          "end_line": 133,
          "is_async": false
        },
        {
          "name": "repair_even_worse_json",
          "signature": "def repair_even_worse_json(json_string)",
          "parameters": "(json_string)",
          "return_type": null,
          "docstring": "This function repairs a malformed JSON string where string literals are broken up and\n    not properly enclosed in quotes. It aims to consolidate everything between 'message': and\n    the two ending curly braces into one string for the 'message' field.",
          "decorators": [],
          "start_line": 136,
          "end_line": 183,
          "is_async": false
        },
        {
          "name": "clean_json",
          "signature": "def clean_json(raw_llm_output, messages=None, functions=None)",
          "parameters": "(raw_llm_output, messages=None, functions=None)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 186,
          "end_line": 215,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044031
    },
    "letta/local_llm/koboldcpp/api.py": {
      "path": "letta/local_llm/koboldcpp/api.py",
      "contentHash": "7f016baa95aeb8dbc41c9e3d0bc8ee07",
      "mtime": 1767315072020.5435,
      "functions": [
        {
          "name": "get_koboldcpp_completion",
          "signature": "def get_koboldcpp_completion(endpoint, auth_type, auth_key, prompt, context_window, grammar=None)",
          "parameters": "(endpoint, auth_type, auth_key, prompt, context_window, grammar=None)",
          "return_type": null,
          "docstring": "See https://lite.koboldai.net/koboldcpp_api for API spec",
          "decorators": [],
          "start_line": 9,
          "end_line": 62,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044031
    },
    "letta/local_llm/llamacpp/api.py": {
      "path": "letta/local_llm/llamacpp/api.py",
      "contentHash": "0613773f6ff126ef3c32e1cdd93a6f6b",
      "mtime": 1767315072020.5435,
      "functions": [
        {
          "name": "get_llamacpp_completion",
          "signature": "def get_llamacpp_completion(endpoint, auth_type, auth_key, prompt, context_window, grammar=None)",
          "parameters": "(endpoint, auth_type, auth_key, prompt, context_window, grammar=None)",
          "return_type": null,
          "docstring": "See https://github.com/ggerganov/llama.cpp/blob/master/examples/server/README.md for instructions on how to run the LLM web server",
          "decorators": [],
          "start_line": 9,
          "end_line": 58,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044031
    },
    "letta/local_llm/lmstudio/api.py": {
      "path": "letta/local_llm/lmstudio/api.py",
      "contentHash": "d86b0e83a12067b3266fce2236df9b01",
      "mtime": 1767315072020.5435,
      "functions": [
        {
          "name": "get_lmstudio_completion_chatcompletions",
          "signature": "def get_lmstudio_completion_chatcompletions(endpoint, auth_type, auth_key, model, messages)",
          "parameters": "(endpoint, auth_type, auth_key, model, messages)",
          "return_type": null,
          "docstring": "This is the request we need to send\n\n    {\n    \"model\": \"deepseek-r1-distill-qwen-7b\",\n    \"messages\": [\n      { \"role\": \"system\", \"content\": \"Always answer in rhymes. Today is Thursday\" },\n      { \"role\": \"user\", \"content\": \"What day is it today?\" },\n      { \"role\": \"user\", \"content\": \"What day is it today?\" }],\n    \"temperature\": 0.7,\n    \"max_tokens\": -1,\n    \"stream\": false",
          "decorators": [],
          "start_line": 13,
          "end_line": 76,
          "is_async": false
        },
        {
          "name": "get_lmstudio_completion",
          "signature": "def get_lmstudio_completion(endpoint, auth_type, auth_key, prompt, context_window, api=\"completions\")",
          "parameters": "(endpoint, auth_type, auth_key, prompt, context_window, api=\"completions\")",
          "return_type": null,
          "docstring": "Based on the example for using LM Studio as a backend from https://github.com/lmstudio-ai/examples/tree/main/Hello%2C%20world%20-%20OpenAI%20python%20client",
          "decorators": [],
          "start_line": 79,
          "end_line": 174,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044031
    },
    "letta/local_llm/ollama/api.py": {
      "path": "letta/local_llm/ollama/api.py",
      "contentHash": "be9b771e43752da6d4e1f5b006006de0",
      "mtime": 1767315072020.5435,
      "functions": [
        {
          "name": "get_ollama_completion",
          "signature": "def get_ollama_completion(endpoint, auth_type, auth_key, model, prompt, context_window, grammar=None)",
          "parameters": "(endpoint, auth_type, auth_key, model, prompt, context_window, grammar=None)",
          "return_type": null,
          "docstring": "See https://github.com/jmorganca/ollama/blob/main/docs/api.md for instructions on how to run the LLM web server",
          "decorators": [],
          "start_line": 11,
          "end_line": 88,
          "is_async": false
        }
      ],
      "parsedAt": 1769608044031
    },
    "letta/local_llm/settings/settings.py": {
      "path": "letta/local_llm/settings/settings.py",
      "contentHash": "33a29eece442a44c74637519c22233b0",
      "mtime": 1767315072024.5437,
      "functions": [
        {
          "name": "get_completions_settings",
          "signature": "def get_completions_settings(defaults=\"simple\") -> dict",
          "parameters": "(defaults=\"simple\")",
          "return_type": "dict",
          "docstring": "Pull from the home directory settings if they exist, otherwise default",
          "decorators": [],
          "start_line": 13,
          "end_line": 70,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086629
    },
    "letta/local_llm/utils.py": {
      "path": "letta/local_llm/utils.py",
      "contentHash": "b47e38b21a30be6d7bcb0b814b88d47d",
      "mtime": 1767315072024.5437,
      "functions": [
        {
          "name": "post_json_auth_request",
          "signature": "def post_json_auth_request(uri, json_payload, auth_type, auth_key)",
          "parameters": "(uri, json_payload, auth_type, auth_key)",
          "return_type": null,
          "docstring": "Send a POST request with a JSON payload and optional authentication",
          "decorators": [],
          "start_line": 19,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "load_grammar_file",
          "signature": "def load_grammar_file(grammar)",
          "parameters": "(grammar)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 46,
          "end_line": 58,
          "is_async": false
        },
        {
          "name": "num_tokens_from_functions",
          "signature": "def num_tokens_from_functions(functions: List[dict], model: str = \"gpt-4\")",
          "parameters": "(functions: List[dict], model: str = \"gpt-4\")",
          "return_type": null,
          "docstring": "Return the number of tokens used by a list of functions.\n\n    Copied from https://community.openai.com/t/how-to-calculate-the-tokens-when-using-function-call/266573/11",
          "decorators": [],
          "start_line": 68,
          "end_line": 138,
          "is_async": false
        },
        {
          "name": "num_tokens_from_tool_calls",
          "signature": "def num_tokens_from_tool_calls(tool_calls: Union[List[dict], List[ToolCall]], model: str = \"gpt-4\")",
          "parameters": "(tool_calls: Union[List[dict], List[ToolCall]], model: str = \"gpt-4\")",
          "return_type": null,
          "docstring": "Based on above code (num_tokens_from_functions).\n\n    Example to encode:\n    [{\n        'id': '8b6707cf-2352-4804-93db-0423f',\n        'type': 'function',\n        'function': {\n            'name': 'send_message',\n            'arguments': '{\\n  \"message\": \"More human than human is our motto.\"\\n}'\n        }\n    }]",
          "decorators": [],
          "start_line": 141,
          "end_line": 186,
          "is_async": false
        },
        {
          "name": "num_tokens_from_messages",
          "signature": "def num_tokens_from_messages(messages: List[dict], model: str = \"gpt-4\") -> int",
          "parameters": "(messages: List[dict], model: str = \"gpt-4\")",
          "return_type": "int",
          "docstring": "Return the number of tokens used by a list of messages.\n\n    From: https://github.com/openai/openai-cookbook/blob/main/examples/How_to_count_tokens_with_tiktoken.ipynb\n\n    For counting tokens in function calling RESPONSES, see:\n        https://hmarr.com/blog/counting-openai-tokens/, https://github.com/hmarr/openai-chat-tokens\n\n    For counting tokens in function calling REQUESTS, see:\n        https://community.openai.com/t/how-to-calculate-the-tokens-when-using-function-call/266573/11",
          "decorators": [],
          "start_line": 189,
          "end_line": 260,
          "is_async": false
        },
        {
          "name": "get_available_wrappers",
          "signature": "def get_available_wrappers() -> dict",
          "parameters": "()",
          "return_type": "dict",
          "docstring": null,
          "decorators": [],
          "start_line": 263,
          "end_line": 300,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086629
    },
    "letta/local_llm/vllm/api.py": {
      "path": "letta/local_llm/vllm/api.py",
      "contentHash": "012780ca0f82b6389ea7d8aba7c268ab",
      "mtime": 1767315072024.5437,
      "functions": [
        {
          "name": "get_vllm_completion",
          "signature": "def get_vllm_completion(endpoint, auth_type, auth_key, model, prompt, context_window, user, grammar=None)",
          "parameters": "(endpoint, auth_type, auth_key, model, prompt, context_window, user, grammar=None)",
          "return_type": null,
          "docstring": "https://github.com/vllm-project/vllm/blob/main/examples/api_client.py",
          "decorators": [],
          "start_line": 9,
          "end_line": 66,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086629
    },
    "letta/local_llm/webui/api.py": {
      "path": "letta/local_llm/webui/api.py",
      "contentHash": "90e36a98a8bdee53d6a9e93f114c32e4",
      "mtime": 1767315072024.5437,
      "functions": [
        {
          "name": "get_webui_completion",
          "signature": "def get_webui_completion(endpoint, auth_type, auth_key, prompt, context_window, grammar=None)",
          "parameters": "(endpoint, auth_type, auth_key, prompt, context_window, grammar=None)",
          "return_type": null,
          "docstring": "Compatibility for the new OpenAI API: https://github.com/oobabooga/text-generation-webui/wiki/12-%E2%80%90-OpenAI-API#examples",
          "decorators": [],
          "start_line": 9,
          "end_line": 60,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086629
    },
    "letta/local_llm/webui/legacy_api.py": {
      "path": "letta/local_llm/webui/legacy_api.py",
      "contentHash": "e80b15465d368b5fa3f34d27e57ca323",
      "mtime": 1767315072024.5437,
      "functions": [
        {
          "name": "get_webui_completion",
          "signature": "def get_webui_completion(endpoint, auth_type, auth_key, prompt, context_window, grammar=None)",
          "parameters": "(endpoint, auth_type, auth_key, prompt, context_window, grammar=None)",
          "return_type": null,
          "docstring": "See https://github.com/oobabooga/text-generation-webui for instructions on how to run the LLM web server",
          "decorators": [],
          "start_line": 9,
          "end_line": 58,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086629
    },
    "letta/log.py": {
      "path": "letta/log.py",
      "contentHash": "2be9d9b82d97dcd3441cc0bc3655c5db",
      "mtime": 1767315072024.5437,
      "functions": [
        {
          "name": "etup_logfile()",
          "signature": "def etup_logfile() - -> ath\":\n",
          "parameters": " -",
          "return_type": "ath\":\n",
          "docstring": "\"ensure the logger filepath is in place\n\n    Returns: the logfile Path\n    \"\"\"",
          "decorators": [],
          "start_line": 183,
          "end_line": 191,
          "is_async": false
        },
        {
          "name": "et_console_formatter()",
          "signature": "def et_console_formatter() - -> r:\n",
          "parameters": " -",
          "return_type": "r:\n",
          "docstring": "\"Determine the appropriate console formatter based on settings.\"\"\"",
          "decorators": [],
          "start_line": 195,
          "end_line": 202,
          "is_async": false
        },
        {
          "name": "et_file_formatter()",
          "signature": "def et_file_formatter() - -> r:\n",
          "parameters": " -",
          "return_type": "r:\n",
          "docstring": "\"Determine the appropriate file formatter based on settings.\"\"\"",
          "decorators": [],
          "start_line": 205,
          "end_line": 212,
          "is_async": false
        },
        {
          "name": "t_logger(n",
          "signature": "def t_logger(name: Optional[str] = None) - -> ogging.Logger\":\n",
          "parameters": "ame: Optional[str] = None) -",
          "return_type": "ogging.Logger\":\n",
          "docstring": "\"returns the project logger, scoped to a child name if provided\n    Args:\n        name: will define a child logger\n    \"\"\"",
          "decorators": [],
          "start_line": 284,
          "end_line": 292,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086629
    },
    "letta/log_context.py": {
      "path": "letta/log_context.py",
      "contentHash": "20134719d6acc6274beb27e3a0143d20",
      "mtime": 1767315072024.5437,
      "functions": [
        {
          "name": "set_log_context",
          "signature": "def set_log_context(key: str, value: Any) -> None",
          "parameters": "(key: str, value: Any)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 7,
          "end_line": 10,
          "is_async": false
        },
        {
          "name": "get_log_context",
          "signature": "def get_log_context(key: Optional[str] = None) -> Any",
          "parameters": "(key: Optional[str] = None)",
          "return_type": "Any",
          "docstring": null,
          "decorators": [],
          "start_line": 13,
          "end_line": 17,
          "is_async": false
        },
        {
          "name": "clear_log_context",
          "signature": "def clear_log_context() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 20,
          "end_line": 21,
          "is_async": false
        },
        {
          "name": "update_log_context",
          "signature": "def update_log_context(**kwargs: Any) -> None",
          "parameters": "(**kwargs: Any)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 27,
          "is_async": false
        },
        {
          "name": "remove_log_context",
          "signature": "def remove_log_context(key: str) -> None",
          "parameters": "(key: str)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 30,
          "end_line": 33,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086629
    },
    "letta/main.py": {
      "path": "letta/main.py",
      "contentHash": "858def9b34509d9b366c4d8b4275044f",
      "mtime": 1767315072024.5437,
      "functions": [
        {
          "name": "main",
          "signature": "def main(ctx: typer.Context)",
          "parameters": "(ctx: typer.Context)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@app.callback(invoke_without_command=True)"
          ],
          "start_line": 15,
          "end_line": 18,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086629
    },
    "letta/memory.py": {
      "path": "letta/memory.py",
      "contentHash": "e6c060194403d150e06c57b129bc215f",
      "mtime": 1767315072024.5437,
      "functions": [
        {
          "name": "get_memory_functions",
          "signature": "def get_memory_functions(cls: Memory) -> Dict[str, Callable]",
          "parameters": "(cls: Memory)",
          "return_type": "Dict[str, Callable]",
          "docstring": "Get memory functions for a memory class",
          "decorators": [],
          "start_line": 20,
          "end_line": 40,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086630
    },
    "letta/monitoring/event_loop_watchdog.py": {
      "path": "letta/monitoring/event_loop_watchdog.py",
      "contentHash": "0cdffaa1f1f7e5650bd04e57cc7f9b77",
      "mtime": 1768610518518.1997,
      "functions": [
        {
          "name": "get_watchdog",
          "signature": "def get_watchdog() -> Optional[EventLoopWatchdog]",
          "parameters": "()",
          "return_type": "Optional[EventLoopWatchdog]",
          "docstring": "Get the global watchdog instance.",
          "decorators": [],
          "start_line": 296,
          "end_line": 298,
          "is_async": false
        },
        {
          "name": "start_watchdog",
          "signature": "def start_watchdog(loop: asyncio.AbstractEventLoop, check_interval: float = 5.0, timeout_threshold: float = 15.0)",
          "parameters": "(loop: asyncio.AbstractEventLoop, check_interval: float = 5.0, timeout_threshold: float = 15.0)",
          "return_type": null,
          "docstring": "Start the global watchdog.",
          "decorators": [],
          "start_line": 301,
          "end_line": 307,
          "is_async": false
        },
        {
          "name": "stop_watchdog",
          "signature": "def stop_watchdog()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Stop the global watchdog.",
          "decorators": [],
          "start_line": 310,
          "end_line": 315,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086630
    },
    "letta/openai_backcompat/openai_object.py": {
      "path": "letta/openai_backcompat/openai_object.py",
      "contentHash": "f3c79994c4da016fd8076153d6695a57",
      "mtime": 1767315072024.5437,
      "functions": [
        {
          "name": "get_object_classes",
          "signature": "def get_object_classes()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 27,
          "is_async": false
        },
        {
          "name": "convert_to_openai_object",
          "signature": "def convert_to_openai_object(\n    resp,\n    api_key=None,\n    api_version=None,\n    organization=None,\n    engine=None,\n    plain_old_data=False,\n)",
          "parameters": "(\n    resp,\n    api_key=None,\n    api_version=None,\n    organization=None,\n    engine=None,\n    plain_old_data=False,\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 400,
          "end_line": 437,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086630
    },
    "letta/orm/block.py": {
      "path": "letta/orm/block.py",
      "contentHash": "039a6568adcf53d594dc8b9f026493e2",
      "mtime": 1767315072024.5437,
      "functions": [
        {
          "name": "validate_value_length",
          "signature": "def validate_value_length(mapper, connection, target)",
          "parameters": "(mapper, connection, target)",
          "return_type": null,
          "docstring": "Ensure the value length does not exceed the limit.",
          "decorators": [
            "@event.listens_for(Block, \"before_insert\")",
            "@event.listens_for(Block, \"before_update\")"
          ],
          "start_line": 112,
          "end_line": 117,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086630
    },
    "letta/orm/message.py": {
      "path": "letta/orm/message.py",
      "contentHash": "c6cec5af66ffc04f411c3a0bf41dc276",
      "mtime": 1768610518518.1997,
      "functions": [
        {
          "name": "set_sequence_id_for_sqlite_bulk",
          "signature": "def set_sequence_id_for_sqlite_bulk(session, flush_context, instances)",
          "parameters": "(session, flush_context, instances)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@event.listens_for(Session, \"before_flush\")"
          ],
          "start_line": 123,
          "end_line": 193,
          "is_async": false
        },
        {
          "name": "set_sequence_id_for_sqlite",
          "signature": "def set_sequence_id_for_sqlite(mapper, connection, target)",
          "parameters": "(mapper, connection, target)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@event.listens_for(Message, \"before_insert\")"
          ],
          "start_line": 197,
          "end_line": 257,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086630
    },
    "letta/orm/mixins.py": {
      "path": "letta/orm/mixins.py",
      "contentHash": "cbb66dbb77d5afe3b6befdcf0b4f7f5f",
      "mtime": 1767315072028.5437,
      "functions": [
        {
          "name": "is_valid_uuid4",
          "signature": "def is_valid_uuid4(uuid_string: str) -> bool",
          "parameters": "(uuid_string: str)",
          "return_type": "bool",
          "docstring": "Check if a string is a valid UUID4.",
          "decorators": [],
          "start_line": 10,
          "end_line": 16,
          "is_async": false
        }
      ],
      "parsedAt": 1769608086630
    },
    "letta/orm/sqlalchemy_base.py": {
      "path": "letta/orm/sqlalchemy_base.py",
      "contentHash": "15bb6aaa52247f0f19ed15af2e0ee99b",
      "mtime": 1768610518518.1997,
      "functions": [
        {
          "name": "handle_db_timeout",
          "signature": "def handle_db_timeout(func)",
          "parameters": "(func)",
          "return_type": null,
          "docstring": "Decorator to handle SQLAlchemy TimeoutError and wrap it in a custom exception.",
          "decorators": [],
          "start_line": 28,
          "end_line": 51,
          "is_async": false
        },
        {
          "name": "is_postgresql_session",
          "signature": "def is_postgresql_session(session: Session) -> bool",
          "parameters": "(session: Session)",
          "return_type": "bool",
          "docstring": "Check if the database session is PostgreSQL instead of SQLite for setting query options.",
          "decorators": [],
          "start_line": 54,
          "end_line": 56,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100574
    },
    "letta/orm/sqlite_functions.py": {
      "path": "letta/orm/sqlite_functions.py",
      "contentHash": "cb98d6fa8e0955c5e9993666c671286b",
      "mtime": 1767315072032.544,
      "functions": [
        {
          "name": "adapt_array",
          "signature": "def adapt_array(arr)",
          "parameters": "(arr)",
          "return_type": null,
          "docstring": "Converts numpy array to binary for SQLite storage using sqlite-vec",
          "decorators": [],
          "start_line": 18,
          "end_line": 32,
          "is_async": false
        },
        {
          "name": "convert_array",
          "signature": "def convert_array(text)",
          "parameters": "(text)",
          "return_type": null,
          "docstring": "Converts binary back to numpy array using sqlite-vec format",
          "decorators": [],
          "start_line": 35,
          "end_line": 53,
          "is_async": false
        },
        {
          "name": "verify_embedding_dimension",
          "signature": "def verify_embedding_dimension(embedding: np.ndarray, expected_dim: int = MAX_EMBEDDING_DIM) -> bool",
          "parameters": "(embedding: np.ndarray, expected_dim: int = MAX_EMBEDDING_DIM)",
          "return_type": "bool",
          "docstring": "Verifies that an embedding has the expected dimension\n\n    Args:\n        embedding: Input embedding array\n        expected_dim: Expected embedding dimension (default: 4096)\n\n    Returns:\n        bool: True if dimension matches, False otherwise",
          "decorators": [],
          "start_line": 56,
          "end_line": 69,
          "is_async": false
        },
        {
          "name": "validate_and_transform_embedding",
          "signature": "def validate_and_transform_embedding(\n    embedding: Union[bytes, sqlite3.Binary, list, np.ndarray], expected_dim: int = MAX_EMBEDDING_DIM, dtype: np.dtype = np.float32\n) -> Optional[np.ndarray]",
          "parameters": "(\n    embedding: Union[bytes, sqlite3.Binary, list, np.ndarray], expected_dim: int = MAX_EMBEDDING_DIM, dtype: np.dtype = np.float32\n)",
          "return_type": "Optional[np.ndarray]",
          "docstring": "Validates and transforms embeddings to ensure correct dimensionality.\n\n    Args:\n        embedding: Input embedding in various possible formats\n        expected_dim: Expected embedding dimension (default 4096)\n        dtype: NumPy dtype for the embedding (default float32)\n\n    Returns:\n        np.ndarray: Validated and transformed embedding\n\n    Raises:\n        ValueError: If embedding dimension doesn't match expected dimension",
          "decorators": [],
          "start_line": 72,
          "end_line": 106,
          "is_async": false
        },
        {
          "name": "cosine_distance",
          "signature": "def cosine_distance(embedding1, embedding2, expected_dim=MAX_EMBEDDING_DIM)",
          "parameters": "(embedding1, embedding2, expected_dim=MAX_EMBEDDING_DIM)",
          "return_type": null,
          "docstring": "Calculate cosine distance between two embeddings\n\n    Args:\n        embedding1: First embedding\n        embedding2: Second embedding\n        expected_dim: Expected embedding dimension (default 4096)\n\n    Returns:\n        float: Cosine distance",
          "decorators": [],
          "start_line": 109,
          "end_line": 134,
          "is_async": false
        },
        {
          "name": "register_functions",
          "signature": "def register_functions(dbapi_connection, connection_record)",
          "parameters": "(dbapi_connection, connection_record)",
          "return_type": null,
          "docstring": "Register SQLite functions and enable sqlite-vec extension",
          "decorators": [
            "@event.listens_for(Engine, \"connect\")"
          ],
          "start_line": 140,
          "end_line": 183,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100574
    },
    "letta/otel/context.py": {
      "path": "letta/otel/context.py",
      "contentHash": "010791e844b8653a056eaa1afb3249bc",
      "mtime": 1767315072032.544,
      "functions": [
        {
          "name": "set_ctx_attributes",
          "signature": "def set_ctx_attributes(attrs: Dict[str, Any])",
          "parameters": "(attrs: Dict[str, Any])",
          "return_type": null,
          "docstring": "Set attributes in current context",
          "decorators": [],
          "start_line": 9,
          "end_line": 13,
          "is_async": false
        },
        {
          "name": "add_ctx_attribute",
          "signature": "def add_ctx_attribute(key: str, value: Any)",
          "parameters": "(key: str, value: Any)",
          "return_type": null,
          "docstring": "Add single attribute to current context",
          "decorators": [],
          "start_line": 16,
          "end_line": 20,
          "is_async": false
        },
        {
          "name": "get_ctx_attributes",
          "signature": "def get_ctx_attributes() -> Dict[str, Any]",
          "parameters": "()",
          "return_type": "Dict[str, Any]",
          "docstring": "Get all attributes from current context",
          "decorators": [],
          "start_line": 23,
          "end_line": 25,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100574
    },
    "letta/otel/db_pool_monitoring.py": {
      "path": "letta/otel/db_pool_monitoring.py",
      "contentHash": "8ad4fcb5009b865defdf1c176b4bf789",
      "mtime": 1767315072032.544,
      "functions": [
        {
          "name": "get_pool_monitor",
          "signature": "def get_pool_monitor() -> DatabasePoolMonitor",
          "parameters": "()",
          "return_type": "DatabasePoolMonitor",
          "docstring": "Get the global database pool monitor instance.",
          "decorators": [],
          "start_line": 302,
          "end_line": 304,
          "is_async": false
        },
        {
          "name": "setup_pool_monitoring",
          "signature": "def setup_pool_monitoring(engine: Engine | AsyncEngine, engine_name: str = \"default\") -> None",
          "parameters": "(engine: Engine | AsyncEngine, engine_name: str = \"default\")",
          "return_type": "None",
          "docstring": "Set up connection pool monitoring for the given engine.",
          "decorators": [],
          "start_line": 307,
          "end_line": 309,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100574
    },
    "letta/otel/metrics.py": {
      "path": "letta/otel/metrics.py",
      "contentHash": "a8ef4197cc5bd946aae455bbe61c3531",
      "mtime": 1767315072032.544,
      "functions": [
        {
          "name": "setup_metrics",
          "signature": "def setup_metrics(\n    endpoint: str,\n    app: FastAPI | None = None,\n    service_name: str = \"memgpt-server\",\n) -> None",
          "parameters": "(\n    endpoint: str,\n    app: FastAPI | None = None,\n    service_name: str = \"memgpt-server\",\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 104,
          "end_line": 132,
          "is_async": false
        },
        {
          "name": "get_letta_meter",
          "signature": "def get_letta_meter() -> Meter",
          "parameters": "()",
          "return_type": "Meter",
          "docstring": "Returns the global letta meter if metrics are initialized.",
          "decorators": [],
          "start_line": 135,
          "end_line": 139,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100575
    },
    "letta/otel/resource.py": {
      "path": "letta/otel/resource.py",
      "contentHash": "6ba5ea3ab7104959441ea9fe0210d4e9",
      "mtime": 1767315072032.544,
      "functions": [
        {
          "name": "get_resource",
          "signature": "def get_resource(service_name: str) -> Resource",
          "parameters": "(service_name: str)",
          "return_type": "Resource",
          "docstring": null,
          "decorators": [],
          "start_line": 41,
          "end_line": 56,
          "is_async": false
        },
        {
          "name": "is_pytest_environment",
          "signature": "def is_pytest_environment()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 59,
          "end_line": 60,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100575
    },
    "letta/otel/sqlalchemy_instrumentation.py": {
      "path": "letta/otel/sqlalchemy_instrumentation.py",
      "contentHash": "eda816dd1ebe56c8fa4aa6a19e3cbd4e",
      "mtime": 1767315072032.544,
      "functions": [
        {
          "name": "setup_sqlalchemy_sync_instrumentation",
          "signature": "def setup_sqlalchemy_sync_instrumentation(\n    engines: Optional[List[Engine]] = None,\n    config_overrides: Optional[Dict[str, Any]] = None,\n    lazy_loading_only: bool = True,\n) -> None",
          "parameters": "(\n    engines: Optional[List[Engine]] = None,\n    config_overrides: Optional[Dict[str, Any]] = None,\n    lazy_loading_only: bool = True,\n)",
          "return_type": "None",
          "docstring": "Set up SQLAlchemy synchronous operation instrumentation.\n\n    Args:\n        engines: List of SQLAlchemy engines to instrument. If None, will attempt\n                to discover engines automatically.\n        config_overrides: Dictionary of configuration overrides.\n        lazy_loading_only: If True, only instrument lazy loading operations.",
          "decorators": [],
          "start_line": 378,
          "end_line": 448,
          "is_async": false
        },
        {
          "name": "teardown_sqlalchemy_sync_instrumentation",
          "signature": "def teardown_sqlalchemy_sync_instrumentation() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": "Tear down SQLAlchemy synchronous operation instrumentation.",
          "decorators": [],
          "start_line": 451,
          "end_line": 494,
          "is_async": false
        },
        {
          "name": "configure_instrumentation",
          "signature": "def configure_instrumentation(**kwargs) -> None",
          "parameters": "(**kwargs)",
          "return_type": "None",
          "docstring": "Configure SQLAlchemy synchronous operation instrumentation.\n\n    Args:\n        **kwargs: Configuration options to update.",
          "decorators": [],
          "start_line": 497,
          "end_line": 504,
          "is_async": false
        },
        {
          "name": "get_instrumentation_config",
          "signature": "def get_instrumentation_config() -> Dict[str, Any]",
          "parameters": "()",
          "return_type": "Dict[str, Any]",
          "docstring": "Get current instrumentation configuration.",
          "decorators": [],
          "start_line": 507,
          "end_line": 509,
          "is_async": false
        },
        {
          "name": "is_instrumentation_active",
          "signature": "def is_instrumentation_active() -> bool",
          "parameters": "()",
          "return_type": "bool",
          "docstring": "Check if instrumentation is currently active.",
          "decorators": [],
          "start_line": 512,
          "end_line": 514,
          "is_async": false
        },
        {
          "name": "temporary_instrumentation",
          "signature": "def temporary_instrumentation(**config_overrides)",
          "parameters": "(**config_overrides)",
          "return_type": null,
          "docstring": "Context manager for temporary SQLAlchemy instrumentation.\n\n    Args:\n        **config_overrides: Configuration overrides for the instrumentation.",
          "decorators": [
            "@contextmanager"
          ],
          "start_line": 519,
          "end_line": 535,
          "is_async": false
        },
        {
          "name": "setup_fastapi_instrumentation",
          "signature": "def setup_fastapi_instrumentation(app)",
          "parameters": "(app)",
          "return_type": null,
          "docstring": "Set up SQLAlchemy instrumentation for FastAPI application.\n\n    Args:\n        app: FastAPI application instance",
          "decorators": [],
          "start_line": 539,
          "end_line": 553,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100575
    },
    "letta/otel/sqlalchemy_instrumentation_integration.py": {
      "path": "letta/otel/sqlalchemy_instrumentation_integration.py",
      "contentHash": "6ae353a7c656a7b3d0730abf1532a224",
      "mtime": 1767315072032.544,
      "functions": [
        {
          "name": "setup_letta_db_instrumentation",
          "signature": "def setup_letta_db_instrumentation(\n    enable_joined_monitoring: bool = True,\n    sql_truncate_length: int = 1000,\n    additional_config: Optional[Dict[str, Any]] = None,\n) -> None",
          "parameters": "(\n    enable_joined_monitoring: bool = True,\n    sql_truncate_length: int = 1000,\n    additional_config: Optional[Dict[str, Any]] = None,\n)",
          "return_type": "None",
          "docstring": "Set up SQLAlchemy instrumentation for Letta application.\n\n    Args:\n        enable_joined_monitoring: Whether to monitor joined loading operations\n        sql_truncate_length: Maximum length of SQL statements in traces\n        additional_config: Additional configuration options",
          "decorators": [],
          "start_line": 24,
          "end_line": 80,
          "is_async": false
        },
        {
          "name": "teardown_letta_db_instrumentation",
          "signature": "def teardown_letta_db_instrumentation() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": "Tear down SQLAlchemy instrumentation for Letta application.",
          "decorators": [],
          "start_line": 83,
          "end_line": 94,
          "is_async": false
        },
        {
          "name": "configure_letta_db_instrumentation",
          "signature": "def configure_letta_db_instrumentation(**kwargs) -> None",
          "parameters": "(**kwargs)",
          "return_type": "None",
          "docstring": "Configure SQLAlchemy instrumentation for Letta application.\n\n    Args:\n        **kwargs: Configuration options to update",
          "decorators": [],
          "start_line": 97,
          "end_line": 105,
          "is_async": false
        },
        {
          "name": "setup_fastapi_db_instrumentation",
          "signature": "def setup_fastapi_db_instrumentation(app, **config_kwargs)",
          "parameters": "(app, **config_kwargs)",
          "return_type": null,
          "docstring": "Set up SQLAlchemy instrumentation for FastAPI application.\n\n    Args:\n        app: FastAPI application instance\n        **config_kwargs: Configuration options for instrumentation",
          "decorators": [],
          "start_line": 109,
          "end_line": 124,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100575
    },
    "letta/otel/tracing.py": {
      "path": "letta/otel/tracing.py",
      "contentHash": "e76780fe7d71d3c935d52e0be29f92c9",
      "mtime": 1768610518518.1997,
      "functions": [
        {
          "name": "setup_tracing",
          "signature": "def setup_tracing(\n    endpoint: str,\n    app: Optional[FastAPI] = None,\n    service_name: str = \"memgpt-server\",\n) -> None",
          "parameters": "(\n    endpoint: str,\n    app: Optional[FastAPI] = None,\n    service_name: str = \"memgpt-server\",\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 146,
          "end_line": 226,
          "is_async": false
        },
        {
          "name": "trace_method",
          "signature": "def trace_method(func)",
          "parameters": "(func)",
          "return_type": null,
          "docstring": "Decorator that traces function execution with OpenTelemetry",
          "decorators": [],
          "start_line": 229,
          "end_line": 436,
          "is_async": false
        },
        {
          "name": "safe_json_dumps",
          "signature": "def safe_json_dumps(data) -> str",
          "parameters": "(data)",
          "return_type": "str",
          "docstring": "Safely serialize data to JSON, handling edge cases like byte arrays.\n\n    Used primarily for OTEL tracing to prevent serialization errors from\n    breaking the streaming flow when logging request/response data.\n\n    Args:\n        data: Data to serialize (dict, bytes, str, etc.)\n\n    Returns:\n        JSON string representation, or error message if serialization fails",
          "decorators": [],
          "start_line": 439,
          "end_line": 476,
          "is_async": false
        },
        {
          "name": "log_attributes",
          "signature": "def log_attributes(attributes: Dict[str, Any]) -> None",
          "parameters": "(attributes: Dict[str, Any])",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 479,
          "end_line": 482,
          "is_async": false
        },
        {
          "name": "log_event",
          "signature": "def log_event(name: str, attributes: Optional[Dict[str, Any]] = None, timestamp: Optional[int] = None) -> None",
          "parameters": "(name: str, attributes: Optional[Dict[str, Any]] = None, timestamp: Optional[int] = None)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 485,
          "end_line": 497,
          "is_async": false
        },
        {
          "name": "get_trace_id",
          "signature": "def get_trace_id() -> Optional[str]",
          "parameters": "()",
          "return_type": "Optional[str]",
          "docstring": null,
          "decorators": [],
          "start_line": 500,
          "end_line": 504,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100575
    },
    "letta/plugins/defaults.py": {
      "path": "letta/plugins/defaults.py",
      "contentHash": "abd0bf9843cb4553e5d73b6c888370ff",
      "mtime": 1767315072036.5442,
      "functions": [
        {
          "name": "is_experimental_enabled",
          "signature": "def is_experimental_enabled(feature_name: str, **kwargs) -> bool",
          "parameters": "(feature_name: str, **kwargs)",
          "return_type": "bool",
          "docstring": null,
          "decorators": [],
          "start_line": 4,
          "end_line": 11,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100575
    },
    "letta/plugins/plugins.py": {
      "path": "letta/plugins/plugins.py",
      "contentHash": "06f4903c28fc8d5811d90de02150720a",
      "mtime": 1767315072036.5442,
      "functions": [
        {
          "name": "get_plugin",
          "signature": "def get_plugin(plugin_type: str)",
          "parameters": "(plugin_type: str)",
          "return_type": null,
          "docstring": "Get a plugin instance",
          "decorators": [],
          "start_line": 28,
          "end_line": 42,
          "is_async": false
        },
        {
          "name": "get_experimental_checker",
          "signature": "def get_experimental_checker()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 51,
          "end_line": 55,
          "is_async": false
        },
        {
          "name": "get_summarizer",
          "signature": "def get_summarizer()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 58,
          "end_line": 62,
          "is_async": false
        },
        {
          "name": "reset_experimental_checker",
          "signature": "def reset_experimental_checker()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 65,
          "end_line": 67,
          "is_async": false
        },
        {
          "name": "reset_summarizer",
          "signature": "def reset_summarizer()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 70,
          "end_line": 72,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100575
    },
    "letta/prompts/gpt_system.py": {
      "path": "letta/prompts/gpt_system.py",
      "contentHash": "ebd113f0b1903d5a700f57656c11863a",
      "mtime": 1767315072036.5442,
      "functions": [
        {
          "name": "get_system_text",
          "signature": "def get_system_text(key)",
          "parameters": "(key)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 7,
          "end_line": 24,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100575
    },
    "letta/schemas/agent.py": {
      "path": "letta/schemas/agent.py",
      "contentHash": "99642d963cb817bdbcfbdbfacdf96db5",
      "mtime": 1768610518522.2,
      "functions": [
        {
          "name": "get_prompt_template_for_agent_type",
          "signature": "def get_prompt_template_for_agent_type(agent_type: Optional[AgentType] = None)",
          "parameters": "(agent_type: Optional[AgentType] = None)",
          "return_type": null,
          "docstring": "Deprecated. Templates are not used anymore; fast renderer handles formatting.",
          "decorators": [],
          "start_line": 524,
          "end_line": 526,
          "is_async": false
        }
      ],
      "parsedAt": 1769608100575
    },
    "letta/schemas/letta_message.py": {
      "path": "letta/schemas/letta_message.py",
      "contentHash": "824574da34b7bed99528ec1ecf7c9f61",
      "mtime": 1767315072040.5442,
      "functions": [
        {
          "name": "create_letta_message_union_schema",
          "signature": "def create_letta_message_union_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 427,
          "end_line": 458,
          "is_async": false
        },
        {
          "name": "create_letta_ping_schema",
          "signature": "def create_letta_ping_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 461,
          "end_line": 476,
          "is_async": false
        },
        {
          "name": "create_letta_error_message_schema",
          "signature": "def create_letta_error_message_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 479,
          "end_line": 514,
          "is_async": false
        }
      ],
      "parsedAt": 1769608123298
    },
    "letta/schemas/letta_message_content.py": {
      "path": "letta/schemas/letta_message_content.py",
      "contentHash": "a08f779d7703617d887aaf9fb0654c4c",
      "mtime": 1767315072040.5442,
      "functions": [
        {
          "name": "create_letta_user_message_content_union_schema",
          "signature": "def create_letta_user_message_content_union_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 111,
          "end_line": 124,
          "is_async": false
        },
        {
          "name": "get_letta_user_message_content_union_str_json_schema",
          "signature": "def get_letta_user_message_content_union_str_json_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 127,
          "end_line": 138,
          "is_async": false
        },
        {
          "name": "create_letta_assistant_message_content_union_schema",
          "signature": "def create_letta_assistant_message_content_union_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 152,
          "end_line": 163,
          "is_async": false
        },
        {
          "name": "get_letta_assistant_message_content_union_str_json_schema",
          "signature": "def get_letta_assistant_message_content_union_str_json_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 166,
          "end_line": 177,
          "is_async": false
        },
        {
          "name": "create_letta_message_content_union_schema",
          "signature": "def create_letta_message_content_union_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 314,
          "end_line": 337,
          "is_async": false
        },
        {
          "name": "get_letta_message_content_union_str_json_schema",
          "signature": "def get_letta_message_content_union_str_json_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 340,
          "end_line": 351,
          "is_async": false
        }
      ],
      "parsedAt": 1769608123298
    },
    "letta/schemas/mcp_server.py": {
      "path": "letta/schemas/mcp_server.py",
      "contentHash": "1c31fd7aaca7c2622c20db7ba7136b2a",
      "mtime": 1768610518522.2,
      "functions": [
        {
          "name": "convert_generic_to_union",
          "signature": "def convert_generic_to_union(server) -> MCPServerUnion",
          "parameters": "(server)",
          "return_type": "MCPServerUnion",
          "docstring": "Convert a generic MCPServer (from letta.schemas.mcp) to the appropriate MCPServerUnion type\n    based on the server_type field.\n\n    This is used to convert internal MCPServer representations to the API response types.\n\n    Args:\n        server: A GenericMCPServer instance from letta.schemas.mcp\n\n    Returns:\n        The appropriate MCPServerUnion type (StdioMCPServer, SSEMCPServer, or StreamableHTTPMCPServer)",
          "decorators": [],
          "start_line": 318,
          "end_line": 373,
          "is_async": true
        },
        {
          "name": "convert_update_to_internal",
          "signature": "def convert_update_to_internal(request: UpdateMCPServerRequest)",
          "parameters": "(request: UpdateMCPServerRequest)",
          "return_type": null,
          "docstring": "\"\"\"Convert external UpdateMCPServerRequest to internal UpdateMCPServer union used by the manager.\n\n    External API Request Structure (UpdateMCPServerRequest):\n    - server_name: Optional[str] (at top level)\n    - config: UpdateMCPServerUnion\n        - UpdateStdioMCPServer: command, args, env (flat fields)\n        - UpdateSSEMCPServer: server_url, auth_header, auth_token, custom_headers\n        - UpdateStreamableHTTPMCPServer: server_url, auth_header, auth_token, custom_headers\n\n    Internal Layer (schemas/mcp.py):\n    - UpdateStdioMCPServer: server_name, stdio_config (wrapped in StdioServerConfig)\n    - UpdateSSEMCPServer: server_name, server_url, token (not auth_token!), custom_headers\n    - UpdateStreamableHTTPMCPServer: server_name, server_url, auth_header, auth_token, custom_headers\n\n    This function:\n    1. Extracts server_name from request (top level)\n    2. Wraps stdio fields into StdioServerConfig\n    3. Maps auth_token  token for SSE (internal uses 'token')\n    4. Passes through auth_header + auth_token for StreamableHTTP\n    5. Strips 'Bearer ' prefix from tokens if present\n    \"\"\"",
          "decorators": [],
          "start_line": 376,
          "end_line": 480,
          "is_async": false
        }
      ],
      "parsedAt": 1769608123298
    },
    "letta/schemas/message.py": {
      "path": "letta/schemas/message.py",
      "contentHash": "f5f64f35ccb026a57fc768d19c3dc988",
      "mtime": 1768610518522.2,
      "functions": [
        {
          "name": "truncate_tool_return",
          "signature": "def truncate_tool_return(content: Optional[str], limit: Optional[int]) -> Optional[str]",
          "parameters": "(content: Optional[str], limit: Optional[int])",
          "return_type": "Optional[str]",
          "docstring": null,
          "decorators": [],
          "start_line": 66,
          "end_line": 71,
          "is_async": false
        },
        {
          "name": "add_inner_thoughts_to_tool_call",
          "signature": "def add_inner_thoughts_to_tool_call(\n    tool_call: OpenAIToolCall,\n    inner_thoughts: str,\n    inner_thoughts_key: str,\n) -> OpenAIToolCall",
          "parameters": "(\n    tool_call: OpenAIToolCall,\n    inner_thoughts: str,\n    inner_thoughts_key: str,\n)",
          "return_type": "OpenAIToolCall",
          "docstring": "Add inner thoughts (arg + value) to a tool call",
          "decorators": [],
          "start_line": 74,
          "end_line": 93,
          "is_async": false
        }
      ],
      "parsedAt": 1769608123299
    },
    "letta/schemas/openai/chat_completion_request.py": {
      "path": "letta/schemas/openai/chat_completion_request.py",
      "contentHash": "2404b87317ec841bffd7f472c2a4373c",
      "mtime": 1767315072044.5444,
      "functions": [
        {
          "name": "cast_message_to_subtype",
          "signature": "def cast_message_to_subtype(m_dict: dict) -> ChatMessage",
          "parameters": "(m_dict: dict)",
          "return_type": "ChatMessage",
          "docstring": "Cast a dictionary to one of the individual message types",
          "decorators": [],
          "start_line": 50,
          "end_line": 62,
          "is_async": false
        }
      ],
      "parsedAt": 1769608123299
    },
    "letta/schemas/openai/chat_completions.py": {
      "path": "letta/schemas/openai/chat_completions.py",
      "contentHash": "3ff65349d0b6e48abcc4b38d6303263e",
      "mtime": 1767315072044.5444,
      "functions": [
        {
          "name": "cast_message_to_subtype",
          "signature": "def cast_message_to_subtype(m_dict: dict) -> ChatMessage",
          "parameters": "(m_dict: dict)",
          "return_type": "ChatMessage",
          "docstring": "Cast a dictionary to one of the individual message types",
          "decorators": [],
          "start_line": 46,
          "end_line": 58,
          "is_async": false
        }
      ],
      "parsedAt": 1769608123299
    },
    "letta/schemas/usage.py": {
      "path": "letta/schemas/usage.py",
      "contentHash": "8dc07978fb32e9ee82f726fb441b0832",
      "mtime": 1767315072052.5447,
      "functions": [
        {
          "name": "normalize_cache_tokens",
          "signature": "def normalize_cache_tokens(\n    prompt_details: Union[\"UsageStatisticsPromptTokenDetails\", Dict[str, Any], None],\n) -> Tuple[int, int]",
          "parameters": "(\n    prompt_details: Union[\"UsageStatisticsPromptTokenDetails\", Dict[str, Any], None],\n)",
          "return_type": "Tuple[int, int]",
          "docstring": "Extract normalized cache token counts from provider-specific prompt details.\n\n    Handles both Pydantic model objects (from adapters) and dict objects (from database).\n\n    Provider mappings:\n    - OpenAI/Gemini: cached_tokens -> cached_input_tokens\n    - Anthropic: cache_read_tokens -> cached_input_tokens, cache_creation_tokens -> cache_write_tokens\n\n    Args:\n        prompt_details: Provider-specific prompt token details (model or dict)\n\n    Returns:\n        Tuple of (cached_input_tokens, cache_write_tokens)",
          "decorators": [],
          "start_line": 14,
          "end_line": 57,
          "is_async": false
        },
        {
          "name": "normalize_reasoning_tokens",
          "signature": "def normalize_reasoning_tokens(\n    completion_details: Union[\"UsageStatisticsCompletionTokenDetails\", Dict[str, Any], None],\n) -> int",
          "parameters": "(\n    completion_details: Union[\"UsageStatisticsCompletionTokenDetails\", Dict[str, Any], None],\n)",
          "return_type": "int",
          "docstring": "Extract normalized reasoning token count from provider-specific completion details.\n\n    Handles both Pydantic model objects (from adapters) and dict objects (from database).\n\n    Provider mappings:\n    - OpenAI: completion_tokens_details.reasoning_tokens\n    - Gemini: thoughts_token_count (mapped to reasoning_tokens in UsageStatistics)\n    - Anthropic: thinking tokens are included in completion_tokens, not separately tracked\n\n    Args:\n        completion_details: Provider-specific completion token details (model or dict)\n\n    Returns:\n        The reasoning token count",
          "decorators": [],
          "start_line": 60,
          "end_line": 90,
          "is_async": false
        }
      ],
      "parsedAt": 1769608131153
    },
    "letta/server/db.py": {
      "path": "letta/server/db.py",
      "contentHash": "3945d3df1920cf8a9e213f31da95e938",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "get_db_registry",
          "signature": "def get_db_registry() -> DatabaseRegistry",
          "parameters": "()",
          "return_type": "DatabaseRegistry",
          "docstring": "Get the global database registry instance.",
          "decorators": [],
          "start_line": 101,
          "end_line": 103,
          "is_async": false
        },
        {
          "name": "get_db_async",
          "signature": "def get_db_async() -> AsyncGenerator[AsyncSession, None]",
          "parameters": "()",
          "return_type": "AsyncGenerator[AsyncSession, None]",
          "docstring": "Get an async database session.",
          "decorators": [],
          "start_line": 107,
          "end_line": 110,
          "is_async": true
        },
        {
          "name": "close_db",
          "signature": "def close_db() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": "Close the database engine.",
          "decorators": [],
          "start_line": 114,
          "end_line": 116,
          "is_async": true
        }
      ],
      "parsedAt": 1769608131153
    },
    "letta/server/global_exception_handler.py": {
      "path": "letta/server/global_exception_handler.py",
      "contentHash": "81248cb3a3dc19a926bd1e3bed3e249f",
      "mtime": 1767315072052.5447,
      "functions": [
        {
          "name": "setup_global_exception_handlers",
          "signature": "def setup_global_exception_handlers()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Set up global exception handlers to catch exceptions that occur outside of request handling.\n    This includes:\n    - Uncaught exceptions in the main thread\n    - Exceptions in background threads\n    - Asyncio task exceptions",
          "decorators": [],
          "start_line": 14,
          "end_line": 67,
          "is_async": false
        },
        {
          "name": "setup_asyncio_exception_handler",
          "signature": "def setup_asyncio_exception_handler(loop)",
          "parameters": "(loop)",
          "return_type": null,
          "docstring": "Set up exception handler for asyncio loop.\n    Call this with your event loop.",
          "decorators": [],
          "start_line": 70,
          "end_line": 108,
          "is_async": false
        }
      ],
      "parsedAt": 1769608131153
    },
    "letta/server/rest_api/app.py": {
      "path": "letta/server/rest_api/app.py",
      "contentHash": "28eae91690eb9e40865043c7f5ebeead",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "generate_openapi_schema",
          "signature": "def generate_openapi_schema(app: FastAPI)",
          "parameters": "(app: FastAPI)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 97,
          "end_line": 123,
          "is_async": false
        },
        {
          "name": "generate_password",
          "signature": "def generate_password()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 127,
          "end_line": 130,
          "is_async": false
        },
        {
          "name": "lifespan",
          "signature": "def lifespan(app_: FastAPI)",
          "parameters": "(app_: FastAPI)",
          "return_type": null,
          "docstring": "FastAPI lifespan context manager with setup before the app starts pre-yield and on shutdown after the yield.",
          "decorators": [
            "@asynccontextmanager"
          ],
          "start_line": 137,
          "end_line": 214,
          "is_async": true
        },
        {
          "name": "create_application",
          "signature": "def create_application() -> \"FastAPI\"",
          "parameters": "()",
          "return_type": "\"FastAPI\"",
          "docstring": "the application start routine",
          "decorators": [],
          "start_line": 217,
          "end_line": 705,
          "is_async": false
        },
        {
          "name": "    port: Op",
          "signature": "def     port: Optional[int] = None,\n    host: Optional[str] = None,\n    debug: bool = False,\n    reload: bool = False,\n):\n    \"\"\"Conve",
          "parameters": "tional[int] = None,\n    host: Optional[str] = None,\n    debug: bool = False,\n    reload: bool = False,\n):\n    \"\"\"Conve",
          "return_type": null,
          "docstring": "method to start the server from within Python\"\"\"\n    if debug:",
          "decorators": [],
          "start_line": 711,
          "end_line": 817,
          "is_async": false
        }
      ],
      "parsedAt": 1769608131154
    },
    "letta/server/rest_api/auth/index.py": {
      "path": "letta/server/rest_api/auth/index.py",
      "contentHash": "b716446df48e5391b4483a0b9aa073c2",
      "mtime": 1767315072052.5447,
      "functions": [
        {
          "name": "setup_auth_router",
          "signature": "def setup_auth_router(server: SyncServer, interface: QueuingInterface, password: str) -> APIRouter",
          "parameters": "(server: SyncServer, interface: QueuingInterface, password: str)",
          "return_type": "APIRouter",
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 42,
          "is_async": false
        }
      ],
      "parsedAt": 1769608131154
    },
    "letta/server/rest_api/auth_token.py": {
      "path": "letta/server/rest_api/auth_token.py",
      "contentHash": "aefeb5e8d75e5caf1c86b534239c5923",
      "mtime": 1767315072056.545,
      "functions": [
        {
          "name": "get_current_user",
          "signature": "def get_current_user(server: SyncServer, password: str, auth: HTTPAuthorizationCredentials = Depends(security)) -> uuid.UUID",
          "parameters": "(server: SyncServer, password: str, auth: HTTPAuthorizationCredentials = Depends(security))",
          "return_type": "uuid.UUID",
          "docstring": null,
          "decorators": [],
          "start_line": 11,
          "end_line": 22,
          "is_async": false
        }
      ],
      "parsedAt": 1769608131154
    },
    "letta/server/rest_api/dependencies.py": {
      "path": "letta/server/rest_api/dependencies.py",
      "contentHash": "97d513bf5d5b3a945b32a6582de368e5",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "get_headers",
          "signature": "def get_headers(\n    actor_id: Optional[str] = Header(None, alias=\"user_id\"),\n    user_agent: Optional[str] = Header(None, alias=\"User-Agent\"),\n    project_id: Optional[str] = Header(None, alias=\"X-Project-Id\"),\n    letta_source: Optional[str] = Header(None, alias=\"X-Letta-Source\"),\n    sdk_version: Optional[str] = Header(None, alias=\"X-Stainless-Package-Version\"),\n    message_async: Optional[str] = Header(None, alias=\"X-Experimental-Message-Async\"),\n    letta_v1_agent: Optional[str] = Header(None, alias=\"X-Experimental-Letta-V1-Agent\"),\n    letta_v1_agent_message_async: Optional[str] = Header(None, alias=\"X-Experimental-Letta-V1-Agent-Message-Async\"),\n    modal_sandbox: Optional[str] = Header(None, alias=\"X-Experimental-Modal-Sandbox\"),\n) -> HeaderParams",
          "parameters": "(\n    actor_id: Optional[str] = Header(None, alias=\"user_id\"),\n    user_agent: Optional[str] = Header(None, alias=\"User-Agent\"),\n    project_id: Optional[str] = Header(None, alias=\"X-Project-Id\"),\n    letta_source: Optional[str] = Header(None, alias=\"X-Letta-Source\"),\n    sdk_version: Optional[str] = Header(None, alias=\"X-Stainless-Package-Version\"),\n    message_async: Optional[str] = Header(None, alias=\"X-Experimental-Message-Async\"),\n    letta_v1_agent: Optional[str] = Header(None, alias=\"X-Experimental-Letta-V1-Agent\"),\n    letta_v1_agent_message_async: Optional[str] = Header(None, alias=\"X-Experimental-Letta-V1-Agent-Message-Async\"),\n    modal_sandbox: Optional[str] = Header(None, alias=\"X-Experimental-Modal-Sandbox\"),\n)",
          "return_type": "HeaderParams",
          "docstring": "Dependency injection function to extract common headers from requests.",
          "decorators": [],
          "start_line": 32,
          "end_line": 57,
          "is_async": false
        },
        {
          "name": "get_letta_server",
          "signature": "def get_letta_server() -> \"SyncServer\"",
          "parameters": "()",
          "return_type": "\"SyncServer\"",
          "docstring": null,
          "decorators": [],
          "start_line": 61,
          "end_line": 67,
          "is_async": true
        }
      ],
      "parsedAt": 1769608131154
    },
    "letta/server/rest_api/middleware/request_id.py": {
      "path": "letta/server/rest_api/middleware/request_id.py",
      "contentHash": "0eedca641d9451f4f72c717d6636936b",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "get_request_id",
          "signature": "def get_request_id() -> Optional[str]",
          "parameters": "()",
          "return_type": "Optional[str]",
          "docstring": "Get the request ID from the current context.",
          "decorators": [],
          "start_line": 27,
          "end_line": 29,
          "is_async": false
        }
      ],
      "parsedAt": 1769608138679
    },
    "letta/server/rest_api/proxy_helpers.py": {
      "path": "letta/server/rest_api/proxy_helpers.py",
      "contentHash": "8bfeedb4c2427e30dab2f3dc75e05bb3",
      "mtime": 1767315072056.545,
      "functions": [
        {
          "name": "strip_policy_specs",
          "signature": "def strip_policy_specs(text: str) -> str",
          "parameters": "(text: str)",
          "return_type": "str",
          "docstring": "Remove Claude policy injection blocks from message text.\n\n    Claude injects policy instructions in two forms:\n    1. Appended with prefix: 'user: <policy_spec>...'\n    2. As entire message: '<policy_spec>...'\n\n    We truncate everything from the policy start marker onwards since it's all injected policy content.",
          "decorators": [],
          "start_line": 19,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "extract_user_messages",
          "signature": "def extract_user_messages(body: bytes) -> list[str]",
          "parameters": "(body: bytes)",
          "return_type": "list[str]",
          "docstring": "Extract user messages from request body.",
          "decorators": [],
          "start_line": 46,
          "end_line": 77,
          "is_async": false
        },
        {
          "name": "extract_assistant_message",
          "signature": "def extract_assistant_message(response_data: dict) -> str",
          "parameters": "(response_data: dict)",
          "return_type": "str",
          "docstring": "Extract assistant message from response data.",
          "decorators": [],
          "start_line": 80,
          "end_line": 94,
          "is_async": false
        },
        {
          "name": "is_topic_detection_response",
          "signature": "def is_topic_detection_response(message: str) -> bool",
          "parameters": "(message: str)",
          "return_type": "bool",
          "docstring": "Check if the assistant message is a topic detection response (contains isNewTopic key).\n    These are Claude Code metadata responses that should not be persisted as conversation.",
          "decorators": [],
          "start_line": 97,
          "end_line": 111,
          "is_async": false
        },
        {
          "name": "prepare_headers",
          "signature": "def prepare_headers(request: Request, proxy_name: str, use_bearer_auth: bool = False) -> dict | None",
          "parameters": "(request: Request, proxy_name: str, use_bearer_auth: bool = False)",
          "return_type": "dict | None",
          "docstring": "Prepare headers for forwarding to Anthropic-compatible API.\n\n    Args:\n        request: The incoming FastAPI request\n        proxy_name: Name of the proxy for logging (e.g., \"Anthropic Proxy\", \"Z.ai Proxy\")\n        use_bearer_auth: If True, convert x-api-key to Bearer token in Authorization header (for Z.ai)\n\n    Returns:\n        Dictionary of headers to forward, or None if authentication fails",
          "decorators": [],
          "start_line": 114,
          "end_line": 172,
          "is_async": false
        },
        {
          "name": "format_memory_blocks",
          "signature": "def format_memory_blocks(blocks, agent_id: str) -> str",
          "parameters": "(blocks, agent_id: str)",
          "return_type": "str",
          "docstring": "Format memory blocks for injection into system prompt.",
          "decorators": [],
          "start_line": 175,
          "end_line": 228,
          "is_async": false
        },
        {
          "name": "build_response_from_chunks",
          "signature": "def build_response_from_chunks(chunks: list[bytes]) -> str",
          "parameters": "(chunks: list[bytes])",
          "return_type": "str",
          "docstring": "Build complete response text from streaming chunks.",
          "decorators": [],
          "start_line": 231,
          "end_line": 258,
          "is_async": false
        },
        {
          "name": "inject_memory_context",
          "signature": "def inject_memory_context(\n    server,\n    agent,\n    actor,\n    request_data: dict,\n    proxy_name: str,\n) -> dict",
          "parameters": "(\n    server,\n    agent,\n    actor,\n    request_data: dict,\n    proxy_name: str,\n)",
          "return_type": "dict",
          "docstring": "Inject memory context into the request system prompt.\n\n    Args:\n        server: SyncServer instance\n        agent: Agent to get memory from\n        actor: Actor performing the operation\n        request_data: Request data dictionary to modify\n        proxy_name: Name of the proxy for logging (e.g., \"Anthropic Proxy\", \"Z.ai Proxy\")\n\n    Returns:\n        Modified request data with memory context injected",
          "decorators": [],
          "start_line": 261,
          "end_line": 331,
          "is_async": true
        },
        {
          "name": "persist_messages_background",
          "signature": "def persist_messages_background(\n    server,\n    agent,\n    actor,\n    user_messages: list[str],\n    assistant_message: str,\n    model_name: str,\n    proxy_name: str,\n)",
          "parameters": "(\n    server,\n    agent,\n    actor,\n    user_messages: list[str],\n    assistant_message: str,\n    model_name: str,\n    proxy_name: str,\n)",
          "return_type": null,
          "docstring": "Background task to persist messages without blocking the response.\n\n    This runs asynchronously after the response is returned to minimize latency.\n\n    Args:\n        server: SyncServer instance\n        agent: Agent to persist messages for\n        actor: Actor performing the operation\n        user_messages: List of user messages to persist\n        assistant_message: Assistant message to persist\n        model_name: Model name for the messages\n        proxy_name: Name of the proxy for logging (e.g., \"Anthropic Proxy\", \"Z.ai Proxy\")",
          "decorators": [],
          "start_line": 334,
          "end_line": 371,
          "is_async": true
        },
        {
          "name": "check_for_duplicate_message",
          "signature": "def check_for_duplicate_message(server, agent, actor, user_messages: list[str], proxy_name: str) -> list[str]",
          "parameters": "(server, agent, actor, user_messages: list[str], proxy_name: str)",
          "return_type": "list[str]",
          "docstring": "Check if the last user message is a duplicate of the most recent persisted message.\n\n    Returns a filtered list with duplicates removed to prevent race conditions.\n\n    Args:\n        server: SyncServer instance\n        agent: Agent to check messages for\n        actor: Actor performing the operation\n        user_messages: List of user messages to check\n        proxy_name: Name of the proxy for logging\n\n    Returns:\n        Filtered list of user messages (empty if duplicate detected)",
          "decorators": [],
          "start_line": 374,
          "end_line": 417,
          "is_async": true
        },
        {
          "name": "backfill_agent_project_id",
          "signature": "def backfill_agent_project_id(server, agent, actor, project_id: str)",
          "parameters": "(server, agent, actor, project_id: str)",
          "return_type": null,
          "docstring": "Temporary helper to backfill project_id for legacy agents.\n\n    TODO(@caren): Remove this function after all existing Claude Code agents have been backfilled.\n\n    Args:\n        server: SyncServer instance\n        agent: Agent to update\n        actor: Actor performing the operation\n        project_id: Project ID to set\n\n    Returns:\n        Updated agent or original agent if update fails",
          "decorators": [],
          "start_line": 420,
          "end_line": 449,
          "is_async": true
        },
        {
          "name": "get_or_create_claude_code_agent",
          "signature": "def get_or_create_claude_code_agent(\n    server,\n    actor,\n    project_id: str = None,\n    agent_id: str = None,\n)",
          "parameters": "(\n    server,\n    actor,\n    project_id: str = None,\n    agent_id: str = None,\n)",
          "return_type": null,
          "docstring": "Get or create a special agent for Claude Code sessions.\n\n    Args:\n        server: SyncServer instance\n        actor: Actor performing the operation (user ID)\n        project_id: Optional project ID to associate the agent with\n        agent_id: Optional specific agent ID to use (from X-LETTA-AGENT-ID header)\n\n    Returns:\n        Agent instance",
          "decorators": [],
          "start_line": 452,
          "end_line": 565,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138679
    },
    "letta/server/rest_api/redis_stream_manager.py": {
      "path": "letta/server/rest_api/redis_stream_manager.py",
      "contentHash": "f9795c7d69c837b50a40dd734e823056",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "create_background_stream_processor",
          "signature": "def create_background_stream_processor(\n    stream_generator: AsyncGenerator[str | bytes | tuple[str | bytes, int], None],\n    redis_client: AsyncRedisClient,\n    run_id: str,\n    writer: Optional[RedisSSEStreamWriter] = None,\n    run_manager: Optional[RunManager] = None,\n    actor: Optional[User] = None,\n    conversation_id: Optional[str] = None,\n) -> None",
          "parameters": "(\n    stream_generator: AsyncGenerator[str | bytes | tuple[str | bytes, int], None],\n    redis_client: AsyncRedisClient,\n    run_id: str,\n    writer: Optional[RedisSSEStreamWriter] = None,\n    run_manager: Optional[RunManager] = None,\n    actor: Optional[User] = None,\n    conversation_id: Optional[str] = None,\n)",
          "return_type": "None",
          "docstring": "Process a stream in the background and store chunks to Redis.\n\n    This function consumes the stream generator and writes all chunks\n    to Redis for later retrieval.\n\n    Args:\n        stream_generator: The async generator yielding SSE chunks\n        redis_client: Redis client instance\n        run_id: The run ID to store chunks under\n        writer: Optional pre-configured writer (creates new if not provided)\n        run_manager: Optional run manager for updating run status\n        actor: Optional actor for run status updates\n        conversation_id: Optional conversation ID for releasing lock on terminal states",
          "decorators": [],
          "start_line": 198,
          "end_line": 410,
          "is_async": true
        },
        {
          "name": "redis_sse_stream_generator",
          "signature": "def redis_sse_stream_generator(\n    redis_client: AsyncRedisClient,\n    run_id: str,\n    starting_after: Optional[int] = None,\n    poll_interval: float = 0.1,\n    batch_size: int = 100,\n) -> AsyncIterator[str]",
          "parameters": "(\n    redis_client: AsyncRedisClient,\n    run_id: str,\n    starting_after: Optional[int] = None,\n    poll_interval: float = 0.1,\n    batch_size: int = 100,\n)",
          "return_type": "AsyncIterator[str]",
          "docstring": "Generate SSE events from Redis stream chunks.\n\n    This generator reads chunks stored in Redis streams and yields them as SSE events.\n    It supports cursor-based recovery by allowing you to start from a specific seq_id.\n\n    Args:\n        redis_client: Redis client instance\n        run_id: The run ID to read chunks for\n        starting_after: Sequential ID (integer) to start reading from (default: None for beginning)\n        poll_interval: Seconds to wait between polls when no new data (default: 0.1)\n        batch_size: Number of entries to read per batch (default: 100)\n\n    Yields:\n        SSE-formatted chunks from the Redis stream",
          "decorators": [],
          "start_line": 413,
          "end_line": 476,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138679
    },
    "letta/server/rest_api/routers/openai/chat_completions/chat_completions.py": {
      "path": "letta/server/rest_api/routers/openai/chat_completions/chat_completions.py",
      "contentHash": "6599220c4430bdc67f327af6c0923e73",
      "mtime": 1767315072056.545,
      "functions": [
        {
          "name": "create_chat_completions",
          "signature": "def create_chat_completions(\n    agent_id: str,\n    completion_request: CompletionCreateParams = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: str,\n    completion_request: CompletionCreateParams = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.post(\n    \"/{agent_id}/chat/completions\",\n    response_model=None,\n    operation_id=\"create_chat_completions\",\n    responses={\n        200: {\n            \"description\": \"Successful response\",\n            \"content\": {\"text/event-stream\": {}},\n        }\n    },\n)"
          ],
          "start_line": 39,
          "end_line": 69,
          "is_async": true
        },
        {
          "name": "send_message_to_agent_chat_completions",
          "signature": "def send_message_to_agent_chat_completions(\n    server: \"SyncServer\",\n    letta_agent: Agent,\n    actor: User,\n    messages: Union[List[Message], List[MessageCreate]],\n    assistant_message_tool_name: str = DEFAULT_MESSAGE_TOOL,\n    assistant_message_tool_kwarg: str = DEFAULT_MESSAGE_TOOL_KWARG,\n) -> StreamingResponse",
          "parameters": "(\n    server: \"SyncServer\",\n    letta_agent: Agent,\n    actor: User,\n    messages: Union[List[Message], List[MessageCreate]],\n    assistant_message_tool_name: str = DEFAULT_MESSAGE_TOOL,\n    assistant_message_tool_kwarg: str = DEFAULT_MESSAGE_TOOL_KWARG,\n)",
          "return_type": "StreamingResponse",
          "docstring": "Split off into a separate function so that it can be imported in the /chat/completion proxy.",
          "decorators": [],
          "start_line": 72,
          "end_line": 132,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138680
    },
    "letta/server/rest_api/routers/v1/agents.py": {
      "path": "letta/server/rest_api/routers/v1/agents.py",
      "contentHash": "7aa7a6c0012b05e435cebaa1ab6aa67c",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "list_agents",
          "signature": "def list_agents(\n    name: str | None = Query(None, description=\"Name of the agent\"),\n    tags: list[str] | None = Query(None, description=\"List of tags to filter agents by\"),\n    match_all_tags: bool = Query(\n        False,\n        description=\"If True, only returns agents that match ALL given tags. Otherwise, return agents that have ANY of the passed-in tags.\",\n    ),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: str | None = Query(None, description=\"Cursor for pagination\"),\n    after: str | None = Query(None, description=\"Cursor for pagination\"),\n    limit: int | None = Query(50, description=\"Limit for pagination\"),\n    query_text: str | None = Query(None, description=\"Search agents by name\"),\n    project_id: str | None = Query(None, description=\"Search agents by project ID - this will default to your default project on cloud\"),\n    template_id: str | None = Query(None, description=\"Search agents by template ID\"),\n    base_template_id: str | None = Query(None, description=\"Search agents by base template ID\"),\n    identity_id: str | None = Query(None, description=\"Search agents by identity ID\"),\n    identifier_keys: list[str] | None = Query(None, description=\"Search agents by identifier keys\"),\n    include_relationships: list[str] | None = Query(\n        None,\n        description=(\n            \"Specify which relational fields (e.g., 'tools', 'sources', 'memory') to include in the response. \"\n            \"If not provided, all relationships are loaded by default. \"\n            \"Using this can optimize performance by reducing unnecessary joins.\"\n            \"This is a legacy parameter, and no longer supported after 1.0.0 SDK versions.\"\n        ),\n        deprecated=True,\n    ),\n    include: List[AgentRelationships] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\", \"last_run_completion\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    ascending: bool = Query(\n        False,\n        description=\"Whether to sort agents oldest to newest (True) or newest to oldest (False, default)\",\n        deprecated=True,\n    ),\n    sort_by: str | None = Query(\n        \"created_at\",\n        description=\"Field to sort by. Options: 'created_at' (default), 'last_run_completion'\",\n        deprecated=True,\n    ),\n    show_hidden_agents: bool | None = Query(\n        False,\n        include_in_schema=False,\n        description=\"If set to True, include agents marked as hidden in the results.\",\n    ),\n    last_stop_reason: Optional[StopReasonType] = Query(None, description=\"Filter agents by their last stop reason.\"),\n)",
          "parameters": "(\n    name: str | None = Query(None, description=\"Name of the agent\"),\n    tags: list[str] | None = Query(None, description=\"List of tags to filter agents by\"),\n    match_all_tags: bool = Query(\n        False,\n        description=\"If True, only returns agents that match ALL given tags. Otherwise, return agents that have ANY of the passed-in tags.\",\n    ),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: str | None = Query(None, description=\"Cursor for pagination\"),\n    after: str | None = Query(None, description=\"Cursor for pagination\"),\n    limit: int | None = Query(50, description=\"Limit for pagination\"),\n    query_text: str | None = Query(None, description=\"Search agents by name\"),\n    project_id: str | None = Query(None, description=\"Search agents by project ID - this will default to your default project on cloud\"),\n    template_id: str | None = Query(None, description=\"Search agents by template ID\"),\n    base_template_id: str | None = Query(None, description=\"Search agents by base template ID\"),\n    identity_id: str | None = Query(None, description=\"Search agents by identity ID\"),\n    identifier_keys: list[str] | None = Query(None, description=\"Search agents by identifier keys\"),\n    include_relationships: list[str] | None = Query(\n        None,\n        description=(\n            \"Specify which relational fields (e.g., 'tools', 'sources', 'memory') to include in the response. \"\n            \"If not provided, all relationships are loaded by default. \"\n            \"Using this can optimize performance by reducing unnecessary joins.\"\n            \"This is a legacy parameter, and no longer supported after 1.0.0 SDK versions.\"\n        ),\n        deprecated=True,\n    ),\n    include: List[AgentRelationships] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\", \"last_run_completion\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    ascending: bool = Query(\n        False,\n        description=\"Whether to sort agents oldest to newest (True) or newest to oldest (False, default)\",\n        deprecated=True,\n    ),\n    sort_by: str | None = Query(\n        \"created_at\",\n        description=\"Field to sort by. Options: 'created_at' (default), 'last_run_completion'\",\n        deprecated=True,\n    ),\n    show_hidden_agents: bool | None = Query(\n        False,\n        include_in_schema=False,\n        description=\"If set to True, include agents marked as hidden in the results.\",\n    ),\n    last_stop_reason: Optional[StopReasonType] = Query(None, description=\"Filter agents by their last stop reason.\"),\n)",
          "return_type": null,
          "docstring": "Get a list of all agents.",
          "decorators": [
            "@router.get(\"/\", response_model=list[AgentState], operation_id=\"list_agents\")"
          ],
          "start_line": 84,
          "end_line": 171,
          "is_async": true
        },
        {
          "name": "count_agents",
          "signature": "def count_agents(\n    name: str | None = Query(None, description=\"Name of the agent\"),\n    tags: list[str] | None = Query(None, description=\"List of tags to filter agents by\"),\n    match_all_tags: bool = Query(\n        False,\n        description=\"If True, only counts agents that match ALL given tags. Otherwise, counts agents that have ANY of the passed-in tags.\",\n    ),\n    query_text: str | None = Query(None, description=\"Search agents by name\"),\n    project_id: str | None = Query(None, description=\"Search agents by project ID - this will default to your default project on cloud\"),\n    template_id: str | None = Query(None, description=\"Search agents by template ID\"),\n    base_template_id: str | None = Query(None, description=\"Search agents by base template ID\"),\n    identity_id: str | None = Query(None, description=\"Search agents by identity ID\"),\n    identifier_keys: list[str] | None = Query(None, description=\"Search agents by identifier keys\"),\n    show_hidden_agents: bool | None = Query(\n        False,\n        include_in_schema=False,\n        description=\"If set to True, include agents marked as hidden in the results.\",\n    ),\n    last_stop_reason: Optional[StopReasonType] = Query(None, description=\"Filter agents by their last stop reason.\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    name: str | None = Query(None, description=\"Name of the agent\"),\n    tags: list[str] | None = Query(None, description=\"List of tags to filter agents by\"),\n    match_all_tags: bool = Query(\n        False,\n        description=\"If True, only counts agents that match ALL given tags. Otherwise, counts agents that have ANY of the passed-in tags.\",\n    ),\n    query_text: str | None = Query(None, description=\"Search agents by name\"),\n    project_id: str | None = Query(None, description=\"Search agents by project ID - this will default to your default project on cloud\"),\n    template_id: str | None = Query(None, description=\"Search agents by template ID\"),\n    base_template_id: str | None = Query(None, description=\"Search agents by base template ID\"),\n    identity_id: str | None = Query(None, description=\"Search agents by identity ID\"),\n    identifier_keys: list[str] | None = Query(None, description=\"Search agents by identifier keys\"),\n    show_hidden_agents: bool | None = Query(\n        False,\n        include_in_schema=False,\n        description=\"If set to True, include agents marked as hidden in the results.\",\n    ),\n    last_stop_reason: Optional[StopReasonType] = Query(None, description=\"Filter agents by their last stop reason.\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get the total number of agents with optional filtering.\n    Supports the same filters as list_agents for consistent querying.",
          "decorators": [
            "@router.get(\"/count\", response_model=int, operation_id=\"count_agents\")"
          ],
          "start_line": 175,
          "end_line": 226,
          "is_async": true
        },
        {
          "name": "export_agent",
          "signature": "def export_agent(\n    agent_id: str = AgentId,\n    max_steps: int = Query(100, deprecated=True),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    use_legacy_format: bool = Query(\n        False,\n        description=\"If True, exports using the legacy single-agent 'v1' format with inline tools/blocks. If False, exports using the new multi-entity 'v2' format, with separate agents, tools, blocks, files, etc.\",\n        deprecated=True,\n    ),\n    # do not remove, used to autogeneration of spec\n    # TODO: Think of a better way to export AgentFileSchema\n    spec: AgentFileSchema | None = None,\n    legacy_spec: AgentSchema | None = None,\n) -> JSONResponse",
          "parameters": "(\n    agent_id: str = AgentId,\n    max_steps: int = Query(100, deprecated=True),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    use_legacy_format: bool = Query(\n        False,\n        description=\"If True, exports using the legacy single-agent 'v1' format with inline tools/blocks. If False, exports using the new multi-entity 'v2' format, with separate agents, tools, blocks, files, etc.\",\n        deprecated=True,\n    ),\n    # do not remove, used to autogeneration of spec\n    # TODO: Think of a better way to export AgentFileSchema\n    spec: AgentFileSchema | None = None,\n    legacy_spec: AgentSchema | None = None,\n)",
          "return_type": "JSONResponse",
          "docstring": "Export the serialized JSON representation of an agent, formatted with indentation.",
          "decorators": [
            "@router.get(\"/{agent_id}/export\", response_class=IndentedORJSONResponse, operation_id=\"export_agent\")"
          ],
          "start_line": 237,
          "end_line": 259,
          "is_async": true
        },
        {
          "name": "import_agent_legacy",
          "signature": "def import_agent_legacy(\n    agent_json: dict,\n    server: \"SyncServer\",\n    actor: User,\n    append_copy_suffix: bool = True,\n    override_existing_tools: bool = True,\n    project_id: str | None = None,\n    strip_messages: bool = False,\n    env_vars: Optional[dict[str, Any]] = None,\n) -> List[str]",
          "parameters": "(\n    agent_json: dict,\n    server: \"SyncServer\",\n    actor: User,\n    append_copy_suffix: bool = True,\n    override_existing_tools: bool = True,\n    project_id: str | None = None,\n    strip_messages: bool = False,\n    env_vars: Optional[dict[str, Any]] = None,\n)",
          "return_type": "List[str]",
          "docstring": "Import an agent using the legacy AgentSchema format.",
          "decorators": [],
          "start_line": 268,
          "end_line": 293,
          "is_async": false
        },
        {
          "name": "import_agent",
          "signature": "def import_agent(\n    file: UploadFile = File(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_override_embedding_model: str | None = Header(None, alias=\"x-override-embedding-model\"),\n    # New fields (all optional)\n    override_existing_tools: bool = Form(\n        True,\n        description=\"If set to True, existing tools can get their source code overwritten by the uploaded tool definitions. Note that Letta core tools can never be updated externally.\",\n    ),\n    strip_messages: bool = Form(\n        False,\n        description=\"If set to True, strips all messages from the agent before importing.\",\n    ),\n    secrets: Optional[str] = Form(None, description=\"Secrets as a JSON string to pass to the agent for tool execution.\"),\n    name: Optional[str] = Form(\n        None,\n        description=\"If provided, overrides the agent name with this value.\",\n    ),\n    embedding: Optional[str] = Form(\n        None,\n        description=\"Embedding handle to override with.\",\n    ),\n    # Deprecated fields (maintain backward compatibility)\n    append_copy_suffix: bool = Form(\n        True,\n        description='If set to True, appends \"_copy\" to the end of the agent name.',\n        deprecated=True,\n    ),\n    override_name: Optional[str] = Form(\n        None,\n        description=\"If provided, overrides the agent name with this value. Use 'name' instead.\",\n        deprecated=True,\n    ),\n    override_embedding_handle: Optional[str] = Form(\n        None,\n        description=\"Override import with specific embedding handle. Use 'embedding' instead.\",\n        deprecated=True,\n    ),\n    project_id: str | None = Form(\n        None, description=\"The project ID to associate the uploaded agent with. This is now passed via headers.\", deprecated=True\n    ),\n    env_vars_json: Optional[str] = Form(\n        None,\n        description=\"Environment variables as a JSON string to pass to the agent for tool execution. Use 'secrets' instead.\",\n        deprecated=True,\n    ),\n)",
          "parameters": "(\n    file: UploadFile = File(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_override_embedding_model: str | None = Header(None, alias=\"x-override-embedding-model\"),\n    # New fields (all optional)\n    override_existing_tools: bool = Form(\n        True,\n        description=\"If set to True, existing tools can get their source code overwritten by the uploaded tool definitions. Note that Letta core tools can never be updated externally.\",\n    ),\n    strip_messages: bool = Form(\n        False,\n        description=\"If set to True, strips all messages from the agent before importing.\",\n    ),\n    secrets: Optional[str] = Form(None, description=\"Secrets as a JSON string to pass to the agent for tool execution.\"),\n    name: Optional[str] = Form(\n        None,\n        description=\"If provided, overrides the agent name with this value.\",\n    ),\n    embedding: Optional[str] = Form(\n        None,\n        description=\"Embedding handle to override with.\",\n    ),\n    # Deprecated fields (maintain backward compatibility)\n    append_copy_suffix: bool = Form(\n        True,\n        description='If set to True, appends \"_copy\" to the end of the agent name.',\n        deprecated=True,\n    ),\n    override_name: Optional[str] = Form(\n        None,\n        description=\"If provided, overrides the agent name with this value. Use 'name' instead.\",\n        deprecated=True,\n    ),\n    override_embedding_handle: Optional[str] = Form(\n        None,\n        description=\"Override import with specific embedding handle. Use 'embedding' instead.\",\n        deprecated=True,\n    ),\n    project_id: str | None = Form(\n        None, description=\"The project ID to associate the uploaded agent with. This is now passed via headers.\", deprecated=True\n    ),\n    env_vars_json: Optional[str] = Form(\n        None,\n        description=\"Environment variables as a JSON string to pass to the agent for tool execution. Use 'secrets' instead.\",\n        deprecated=True,\n    ),\n)",
          "return_type": null,
          "docstring": "Import a serialized agent file and recreate the agent(s) in the system.\n    Returns the IDs of all imported agents.",
          "decorators": [
            "@router.post(\"/import\", response_model=ImportedAgentsResponse, operation_id=\"import_agent\")"
          ],
          "start_line": 339,
          "end_line": 448,
          "is_async": true
        },
        {
          "name": "retrieve_agent_context_window",
          "signature": "def retrieve_agent_context_window(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieve the context window of a specific agent.",
          "decorators": [
            "@router.get(\"/{agent_id}/context\", response_model=ContextWindowOverview, operation_id=\"retrieve_agent_context_window\", deprecated=True)"
          ],
          "start_line": 452,
          "end_line": 461,
          "is_async": true
        },
        {
          "name": "create_agent",
          "signature": "def create_agent(\n    agent: CreateAgentRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: str | None = Header(\n        None, alias=\"X-Project\", description=\"The project slug to associate with the agent (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "parameters": "(\n    agent: CreateAgentRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: str | None = Header(\n        None, alias=\"X-Project\", description=\"The project slug to associate with the agent (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "return_type": null,
          "docstring": "Create an agent.",
          "decorators": [
            "@router.post(\"/\", response_model=AgentState, operation_id=\"create_agent\")"
          ],
          "start_line": 474,
          "end_line": 486,
          "is_async": true
        },
        {
          "name": "modify_agent",
          "signature": "def modify_agent(\n    agent_id: AgentId,\n    update_agent: UpdateAgent = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    update_agent: UpdateAgent = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Update an existing agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}\", response_model=AgentState, operation_id=\"modify_agent\")"
          ],
          "start_line": 490,
          "end_line": 498,
          "is_async": true
        },
        {
          "name": "list_tools_for_agent",
          "signature": "def list_tools_for_agent(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Tool ID cursor for pagination. Returns tools that come before this tool ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Tool ID cursor for pagination. Returns tools that come after this tool ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(10, description=\"Maximum number of tools to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for tools by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Tool ID cursor for pagination. Returns tools that come before this tool ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Tool ID cursor for pagination. Returns tools that come after this tool ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(10, description=\"Maximum number of tools to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for tools by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "return_type": null,
          "docstring": "Get tools from an existing agent.",
          "decorators": [
            "@router.get(\"/{agent_id}/tools\", response_model=list[Tool], operation_id=\"list_tools_for_agent\")"
          ],
          "start_line": 502,
          "end_line": 527,
          "is_async": true
        },
        {
          "name": "attach_tool_to_agent",
          "signature": "def attach_tool_to_agent(\n    tool_id: ToolId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    tool_id: ToolId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Attach a tool to an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/tools/attach/{tool_id}\", response_model=Optional[AgentState], operation_id=\"attach_tool_to_agent\")"
          ],
          "start_line": 531,
          "end_line": 545,
          "is_async": true
        },
        {
          "name": "detach_tool_from_agent",
          "signature": "def detach_tool_from_agent(\n    tool_id: ToolId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    tool_id: ToolId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Detach a tool from an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/tools/detach/{tool_id}\", response_model=Optional[AgentState], operation_id=\"detach_tool_from_agent\")"
          ],
          "start_line": 549,
          "end_line": 563,
          "is_async": true
        },
        {
          "name": "modify_approval_for_tool",
          "signature": "def modify_approval_for_tool(\n    tool_name: str,\n    agent_id: AgentId,\n    requires_approval: bool | None = Query(None, description=\"Whether the tool requires approval before execution\", deprecated=True),\n    request: ModifyApprovalRequest | None = Body(None),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    tool_name: str,\n    agent_id: AgentId,\n    requires_approval: bool | None = Query(None, description=\"Whether the tool requires approval before execution\", deprecated=True),\n    request: ModifyApprovalRequest | None = Body(None),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Modify the approval requirement for a tool attached to an agent.\n\n    Accepts requires_approval via request body (preferred) or query parameter (deprecated).",
          "decorators": [
            "@router.patch(\"/{agent_id}/tools/approval/{tool_name}\", response_model=Optional[AgentState], operation_id=\"modify_approval_for_tool\")"
          ],
          "start_line": 575,
          "end_line": 604,
          "is_async": true
        },
        {
          "name": "run_tool_for_agent",
          "signature": "def run_tool_for_agent(\n    agent_id: AgentId,\n    tool_name: str,\n    request: ToolExecuteRequest = Body(default=ToolExecuteRequest()),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    tool_name: str,\n    request: ToolExecuteRequest = Body(default=ToolExecuteRequest()),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Trigger a tool by name on a specific agent, providing the necessary arguments.\n\n    This endpoint executes a tool that is attached to the agent, using the agent's\n    state and environment variables for execution context.",
          "decorators": [
            "@router.post(\"/{agent_id}/tools/{tool_name}/run\", response_model=ToolExecutionResult, operation_id=\"run_tool_for_agent\")"
          ],
          "start_line": 608,
          "end_line": 674,
          "is_async": true
        },
        {
          "name": "attach_source",
          "signature": "def attach_source(\n    source_id: SourceId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source_id: SourceId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Attach a source to an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/sources/attach/{source_id}\", response_model=AgentState, operation_id=\"attach_source_to_agent\", deprecated=True)"
          ],
          "start_line": 678,
          "end_line": 701,
          "is_async": true
        },
        {
          "name": "attach_folder_to_agent",
          "signature": "def attach_folder_to_agent(\n    folder_id: SourceId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder_id: SourceId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Attach a folder to an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/folders/attach/{folder_id}\", response_model=Optional[AgentState], operation_id=\"attach_folder_to_agent\")"
          ],
          "start_line": 705,
          "end_line": 730,
          "is_async": true
        },
        {
          "name": "detach_source",
          "signature": "def detach_source(\n    source_id: SourceId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source_id: SourceId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Detach a source from an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/sources/detach/{source_id}\", response_model=AgentState, operation_id=\"detach_source_from_agent\", deprecated=True)"
          ],
          "start_line": 734,
          "end_line": 762,
          "is_async": true
        },
        {
          "name": "detach_folder_from_agent",
          "signature": "def detach_folder_from_agent(\n    folder_id: SourceId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder_id: SourceId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Detach a folder from an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/folders/detach/{folder_id}\", response_model=Optional[AgentState], operation_id=\"detach_folder_from_agent\")"
          ],
          "start_line": 766,
          "end_line": 796,
          "is_async": true
        },
        {
          "name": "close_all_files_for_agent",
          "signature": "def close_all_files_for_agent(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Closes all currently open files for a given agent.\n\n    This endpoint updates the file state for the agent so that no files are marked as open.\n    Typically used to reset the working memory view for the agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/files/close-all\", response_model=List[str], operation_id=\"close_all_files_for_agent\")"
          ],
          "start_line": 800,
          "end_line": 813,
          "is_async": true
        },
        {
          "name": "open_file_for_agent",
          "signature": "def open_file_for_agent(\n    file_id: FileId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    file_id: FileId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Opens a specific file for a given agent.\n\n    This endpoint marks a specific file as open in the agent's file state.\n    The file will be included in the agent's working memory view.\n    Returns a list of file names that were closed due to LRU eviction.",
          "decorators": [
            "@router.patch(\"/{agent_id}/files/{file_id}/open\", response_model=List[str], operation_id=\"open_file_for_agent\")"
          ],
          "start_line": 817,
          "end_line": 862,
          "is_async": true
        },
        {
          "name": "close_file_for_agent",
          "signature": "def close_file_for_agent(\n    file_id: FileId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    file_id: FileId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Closes a specific file for a given agent.\n\n    This endpoint marks a specific file as closed in the agent's file state.\n    The file will be removed from the agent's working memory view.",
          "decorators": [
            "@router.patch(\"/{agent_id}/files/{file_id}/close\", response_model=None, operation_id=\"close_file_for_agent\")"
          ],
          "start_line": 866,
          "end_line": 887,
          "is_async": true
        },
        {
          "name": "retrieve_agent",
          "signature": "def retrieve_agent(\n    agent_id: AgentId,\n    include_relationships: list[str] | None = Query(\n        None,\n        description=(\n            \"Specify which relational fields (e.g., 'tools', 'sources', 'memory') to include in the response. \"\n            \"If not provided, all relationships are loaded by default. \"\n            \"Using this can optimize performance by reducing unnecessary joins.\"\n            \"This is a legacy parameter, and no longer supported after 1.0.0 SDK versions.\"\n        ),\n        deprecated=True,\n    ),\n    include: List[AgentRelationships] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    include_relationships: list[str] | None = Query(\n        None,\n        description=(\n            \"Specify which relational fields (e.g., 'tools', 'sources', 'memory') to include in the response. \"\n            \"If not provided, all relationships are loaded by default. \"\n            \"Using this can optimize performance by reducing unnecessary joins.\"\n            \"This is a legacy parameter, and no longer supported after 1.0.0 SDK versions.\"\n        ),\n        deprecated=True,\n    ),\n    include: List[AgentRelationships] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get the state of the agent.",
          "decorators": [
            "@router.get(\"/{agent_id}\", response_model=AgentState, operation_id=\"retrieve_agent\")"
          ],
          "start_line": 891,
          "end_line": 920,
          "is_async": true
        },
        {
          "name": "delete_agent",
          "signature": "def delete_agent(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete an agent.",
          "decorators": [
            "@router.delete(\"/{agent_id}\", response_model=None, operation_id=\"delete_agent\")"
          ],
          "start_line": 924,
          "end_line": 934,
          "is_async": true
        },
        {
          "name": "list_agent_sources",
          "signature": "def list_agent_sources(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Source ID cursor for pagination. Returns sources that come before this source ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Source ID cursor for pagination. Returns sources that come after this source ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of sources to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for sources by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Source ID cursor for pagination. Returns sources that come before this source ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Source ID cursor for pagination. Returns sources that come after this source ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of sources to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for sources by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "return_type": null,
          "docstring": "Get the sources associated with an agent.",
          "decorators": [
            "@router.get(\"/{agent_id}/sources\", response_model=list[Source], operation_id=\"list_agent_sources\", deprecated=True)"
          ],
          "start_line": 938,
          "end_line": 965,
          "is_async": true
        },
        {
          "name": "list_folders_for_agent",
          "signature": "def list_folders_for_agent(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Source ID cursor for pagination. Returns sources that come before this source ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Source ID cursor for pagination. Returns sources that come after this source ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of sources to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for sources by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Source ID cursor for pagination. Returns sources that come before this source ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Source ID cursor for pagination. Returns sources that come after this source ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of sources to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for sources by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "return_type": null,
          "docstring": "Get the folders associated with an agent.",
          "decorators": [
            "@router.get(\"/{agent_id}/folders\", response_model=list[Source], operation_id=\"list_folders_for_agent\")"
          ],
          "start_line": 969,
          "end_line": 996,
          "is_async": true
        },
        {
          "name": "list_files_for_agent",
          "signature": "def list_files_for_agent(\n    agent_id: AgentId,\n    before: Optional[str] = Query(\n        None, description=\"File ID cursor for pagination. Returns files that come before this file ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"File ID cursor for pagination. Returns files that come after this file ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of files to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for files by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    cursor: Optional[str] = Query(\n        None, description=\"Pagination cursor from previous response (deprecated, use before/after)\", deprecated=True\n    ),\n    is_open: Optional[bool] = Query(None, description=\"Filter by open status (true for open files, false for closed files)\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    before: Optional[str] = Query(\n        None, description=\"File ID cursor for pagination. Returns files that come before this file ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"File ID cursor for pagination. Returns files that come after this file ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of files to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for files by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    cursor: Optional[str] = Query(\n        None, description=\"Pagination cursor from previous response (deprecated, use before/after)\", deprecated=True\n    ),\n    is_open: Optional[bool] = Query(None, description=\"Filter by open status (true for open files, false for closed files)\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get the files attached to an agent with their open/closed status.",
          "decorators": [
            "@router.get(\"/{agent_id}/files\", response_model=PaginatedAgentFiles, operation_id=\"list_files_for_agent\")"
          ],
          "start_line": 1000,
          "end_line": 1060,
          "is_async": true
        },
        {
          "name": "retrieve_agent_memory",
          "signature": "def retrieve_agent_memory(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieve the memory state of a specific agent.\n    This endpoint fetches the current memory state of the agent identified by the user ID and agent ID.",
          "decorators": [
            "@router.get(\"/{agent_id}/core-memory\", response_model=Memory, operation_id=\"retrieve_agent_memory\", deprecated=True)"
          ],
          "start_line": 1065,
          "end_line": 1076,
          "is_async": true
        },
        {
          "name": "retrieve_block_for_agent",
          "signature": "def retrieve_block_for_agent(\n    block_label: str,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_label: str,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieve a core memory block from an agent.",
          "decorators": [
            "@router.get(\"/{agent_id}/core-memory/blocks/{block_label}\", response_model=BlockResponse, operation_id=\"retrieve_core_memory_block\")"
          ],
          "start_line": 1080,
          "end_line": 1091,
          "is_async": true
        },
        {
          "name": "list_blocks_for_agent",
          "signature": "def list_blocks_for_agent(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Block ID cursor for pagination. Returns blocks that come before this block ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Block ID cursor for pagination. Returns blocks that come after this block ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of blocks to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for blocks by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Block ID cursor for pagination. Returns blocks that come before this block ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Block ID cursor for pagination. Returns blocks that come after this block ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of blocks to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for blocks by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "return_type": null,
          "docstring": "Retrieve the core memory blocks of a specific agent.",
          "decorators": [
            "@router.get(\"/{agent_id}/core-memory/blocks\", response_model=list[BlockResponse], operation_id=\"list_core_memory_blocks\")"
          ],
          "start_line": 1095,
          "end_line": 1123,
          "is_async": true
        },
        {
          "name": "modify_block_for_agent",
          "signature": "def modify_block_for_agent(\n    block_label: str,\n    agent_id: AgentId,\n    block_update: BlockUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_label: str,\n    agent_id: AgentId,\n    block_update: BlockUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Updates a core memory block of an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/core-memory/blocks/{block_label}\", response_model=BlockResponse, operation_id=\"modify_core_memory_block\")"
          ],
          "start_line": 1127,
          "end_line": 1146,
          "is_async": true
        },
        {
          "name": "attach_block_to_agent",
          "signature": "def attach_block_to_agent(\n    block_id: BlockId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_id: BlockId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Attach a core memory block to an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/core-memory/blocks/attach/{block_id}\", response_model=AgentState, operation_id=\"attach_core_memory_block\")"
          ],
          "start_line": 1150,
          "end_line": 1160,
          "is_async": true
        },
        {
          "name": "detach_block_from_agent",
          "signature": "def detach_block_from_agent(\n    block_id: BlockId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_id: BlockId,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Detach a core memory block from an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/core-memory/blocks/detach/{block_id}\", response_model=AgentState, operation_id=\"detach_core_memory_block\")"
          ],
          "start_line": 1164,
          "end_line": 1174,
          "is_async": true
        },
        {
          "name": "attach_archive_to_agent",
          "signature": "def attach_archive_to_agent(\n    archive_id: str,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    archive_id: str,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Attach an archive to an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/archives/attach/{archive_id}\", response_model=None, operation_id=\"attach_archive_to_agent\")"
          ],
          "start_line": 1178,
          "end_line": 1193,
          "is_async": true
        },
        {
          "name": "detach_archive_from_agent",
          "signature": "def detach_archive_from_agent(\n    archive_id: str,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    archive_id: str,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Detach an archive from an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/archives/detach/{archive_id}\", response_model=None, operation_id=\"detach_archive_from_agent\")"
          ],
          "start_line": 1197,
          "end_line": 1212,
          "is_async": true
        },
        {
          "name": "attach_identity_to_agent",
          "signature": "def attach_identity_to_agent(\n    identity_id: str,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    identity_id: str,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Attach an identity to an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/identities/attach/{identity_id}\", response_model=None, operation_id=\"attach_identity_to_agent\")"
          ],
          "start_line": 1216,
          "end_line": 1231,
          "is_async": true
        },
        {
          "name": "detach_identity_from_agent",
          "signature": "def detach_identity_from_agent(\n    identity_id: str,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    identity_id: str,\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Detach an identity from an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/identities/detach/{identity_id}\", response_model=None, operation_id=\"detach_identity_from_agent\")"
          ],
          "start_line": 1235,
          "end_line": 1250,
          "is_async": true
        },
        {
          "name": "list_passages",
          "signature": "def list_passages(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    after: str | None = Query(None, description=\"Unique ID of the memory to start the query range at.\"),\n    before: str | None = Query(None, description=\"Unique ID of the memory to end the query range at.\"),\n    limit: int | None = Query(100, description=\"How many results to include in the response.\"),\n    search: str | None = Query(None, description=\"Search passages by text\"),\n    ascending: bool | None = Query(\n        True, description=\"Whether to sort passages oldest to newest (True, default) or newest to oldest (False)\"\n    ),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    after: str | None = Query(None, description=\"Unique ID of the memory to start the query range at.\"),\n    before: str | None = Query(None, description=\"Unique ID of the memory to end the query range at.\"),\n    limit: int | None = Query(100, description=\"How many results to include in the response.\"),\n    search: str | None = Query(None, description=\"Search passages by text\"),\n    ascending: bool | None = Query(\n        True, description=\"Whether to sort passages oldest to newest (True, default) or newest to oldest (False)\"\n    ),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieve the memories in an agent's archival memory store (paginated query).",
          "decorators": [
            "@router.get(\"/{agent_id}/archival-memory\", response_model=list[Passage], operation_id=\"list_passages\", deprecated=True)"
          ],
          "start_line": 1254,
          "end_line": 1279,
          "is_async": true
        },
        {
          "name": "create_passage",
          "signature": "def create_passage(\n    agent_id: AgentId,\n    request: CreateArchivalMemory = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    request: CreateArchivalMemory = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Insert a memory into an agent's archival memory store.",
          "decorators": [
            "@router.post(\"/{agent_id}/archival-memory\", response_model=list[Passage], operation_id=\"create_passage\", deprecated=True)"
          ],
          "start_line": 1283,
          "end_line": 1296,
          "is_async": true
        },
        {
          "name": "search_archival_memory",
          "signature": "def search_archival_memory(\n    agent_id: AgentId,\n    query: str = Query(..., description=\"String to search for using semantic similarity\"),\n    tags: Optional[List[str]] = Query(None, description=\"Optional list of tags to filter search results\"),\n    tag_match_mode: Literal[\"any\", \"all\"] = Query(\n        \"any\", description=\"How to match tags - 'any' to match passages with any of the tags, 'all' to match only passages with all tags\"\n    ),\n    top_k: Optional[int] = Query(None, description=\"Maximum number of results to return. Uses system default if not specified\"),\n    start_datetime: Optional[datetime] = Query(None, description=\"Filter results to passages created after this datetime\"),\n    end_datetime: Optional[datetime] = Query(None, description=\"Filter results to passages created before this datetime\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    query: str = Query(..., description=\"String to search for using semantic similarity\"),\n    tags: Optional[List[str]] = Query(None, description=\"Optional list of tags to filter search results\"),\n    tag_match_mode: Literal[\"any\", \"all\"] = Query(\n        \"any\", description=\"How to match tags - 'any' to match passages with any of the tags, 'all' to match only passages with all tags\"\n    ),\n    top_k: Optional[int] = Query(None, description=\"Maximum number of results to return. Uses system default if not specified\"),\n    start_datetime: Optional[datetime] = Query(None, description=\"Filter results to passages created after this datetime\"),\n    end_datetime: Optional[datetime] = Query(None, description=\"Filter results to passages created before this datetime\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Search archival memory using semantic (embedding-based) search with optional temporal filtering.\n\n    This endpoint allows manual triggering of archival memory searches, enabling users to query\n    an agent's archival memory store directly via the API. The search uses the same functionality\n    as the agent's archival_memory_search tool but is accessible for external API usage.",
          "decorators": [
            "@router.get(\n    \"/{agent_id}/archival-memory/search\",\n    response_model=ArchivalMemorySearchResponse,\n    operation_id=\"search_archival_memory\",\n    deprecated=True,\n)"
          ],
          "start_line": 1305,
          "end_line": 1346,
          "is_async": true
        },
        {
          "name": "delete_passage",
          "signature": "def delete_passage(\n    memory_id: str,\n    agent_id: AgentId,\n    # memory_id: str = Query(..., description=\"Unique ID of the memory to be deleted.\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    memory_id: str,\n    agent_id: AgentId,\n    # memory_id: str = Query(..., description=\"Unique ID of the memory to be deleted.\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete a memory from an agent's archival memory store.",
          "decorators": [
            "@router.delete(\"/{agent_id}/archival-memory/{memory_id}\", response_model=None, operation_id=\"delete_passage\", deprecated=True)"
          ],
          "start_line": 1352,
          "end_line": 1365,
          "is_async": true
        },
        {
          "name": "list_messages",
          "signature": "def list_messages(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    group_id: str | None = Query(None, description=\"Group ID to filter messages by.\"),\n    conversation_id: str | None = Query(None, description=\"Conversation ID to filter messages by.\"),\n    use_assistant_message: bool = Query(True, description=\"Whether to use assistant messages\", deprecated=True),\n    assistant_message_tool_name: str = Query(DEFAULT_MESSAGE_TOOL, description=\"The name of the designated message tool.\", deprecated=True),\n    assistant_message_tool_kwarg: str = Query(DEFAULT_MESSAGE_TOOL_KWARG, description=\"The name of the message argument.\", deprecated=True),\n    include_err: bool | None = Query(\n        None, description=\"Whether to include error messages and error statuses. For debugging purposes only.\"\n    ),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    group_id: str | None = Query(None, description=\"Group ID to filter messages by.\"),\n    conversation_id: str | None = Query(None, description=\"Conversation ID to filter messages by.\"),\n    use_assistant_message: bool = Query(True, description=\"Whether to use assistant messages\", deprecated=True),\n    assistant_message_tool_name: str = Query(DEFAULT_MESSAGE_TOOL, description=\"The name of the designated message tool.\", deprecated=True),\n    assistant_message_tool_kwarg: str = Query(DEFAULT_MESSAGE_TOOL_KWARG, description=\"The name of the message argument.\", deprecated=True),\n    include_err: bool | None = Query(\n        None, description=\"Whether to include error messages and error statuses. For debugging purposes only.\"\n    ),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieve message history for an agent.",
          "decorators": [
            "@router.get(\"/{agent_id}/messages\", response_model=AgentMessagesResponse, operation_id=\"list_messages\")"
          ],
          "start_line": 1374,
          "end_line": 1417,
          "is_async": true
        },
        {
          "name": "modify_message",
          "signature": "def modify_message(\n    agent_id: AgentId,  # backwards compatible. Consider removing for v1\n    message_id: MessageId,\n    request: LettaMessageUpdateUnion = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,  # backwards compatible. Consider removing for v1\n    message_id: MessageId,\n    request: LettaMessageUpdateUnion = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Update the details of a message associated with an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/messages/{message_id}\", response_model=LettaMessageUnion, operation_id=\"modify_message\")"
          ],
          "start_line": 1421,
          "end_line": 1435,
          "is_async": true
        },
        {
          "name": "send_message",
          "signature": "def send_message(\n    request_obj: Request,  # FastAPI Request\n    agent_id: AgentId,\n    server: SyncServer = Depends(get_letta_server),\n    request: LettaStreamingRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n) -> StreamingResponse | LettaResponse",
          "parameters": "(\n    request_obj: Request,  # FastAPI Request\n    agent_id: AgentId,\n    server: SyncServer = Depends(get_letta_server),\n    request: LettaStreamingRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": "StreamingResponse | LettaResponse",
          "docstring": "Process a user message and return the agent's response.\n    This endpoint accepts a message from a user and processes it through the agent.\n\n    The response format is controlled by the `streaming` field in the request body:\n    - If `streaming=false` (default): Returns a complete LettaResponse with all messages\n    - If `streaming=true`: Returns a Server-Sent Events (SSE) stream\n\n    Additional streaming options (only used when streaming=true):\n    - `stream_tokens`: Stream individual tokens instead of complete steps\n    - `include_pings`: Include keepalive pings to prevent connection timeouts\n    - `background`: Process the request in the background",
          "decorators": [
            "@router.post(\n    \"/{agent_id}/messages\",\n    response_model=LettaResponse,\n    operation_id=\"send_message\",\n    responses={\n        200: {\n            \"description\": \"Successful response\",\n            \"content\": {\n                \"application/json\": {\"schema\": {\"$ref\": \"#/components/schemas/LettaResponse\"}},\n                \"text/event-stream\": {\"description\": \"Server-Sent Events stream (when streaming=true in request body)\"},\n            },\n        }\n    },\n)"
          ],
          "start_line": 1453,
          "end_line": 1610,
          "is_async": true
        },
        {
          "name": "send_message_streaming",
          "signature": "def send_message_streaming(\n    request_obj: Request,  # FastAPI Request\n    agent_id: AgentId,\n    server: SyncServer = Depends(get_letta_server),\n    request: LettaStreamingRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n) -> StreamingResponse | LettaResponse",
          "parameters": "(\n    request_obj: Request,  # FastAPI Request\n    agent_id: AgentId,\n    server: SyncServer = Depends(get_letta_server),\n    request: LettaStreamingRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": "StreamingResponse | LettaResponse",
          "docstring": "Process a user message and return the agent's response.\n\n    Deprecated: Use the `POST /{agent_id}/messages` endpoint with `streaming=true` in the request body instead.\n\n    This endpoint accepts a message from a user and processes it through the agent.\n    It will stream the steps of the response always, and stream the tokens if 'stream_tokens' is set to True.",
          "decorators": [
            "@router.post(\n    \"/{agent_id}/messages/stream\",\n    response_model=LettaStreamingResponse,\n    operation_id=\"create_agent_message_stream\",\n    responses={\n        200: {\n            \"description\": \"Successful response\",\n            \"content\": {\n                \"text/event-stream\": {\"description\": \"Server-Sent Events stream\"},\n            },\n        }\n    },\n    deprecated=True,\n)"
          ],
          "start_line": 1628,
          "end_line": 1658,
          "is_async": true
        },
        {
          "name": "cancel_message",
          "signature": "def cancel_message(\n    agent_id: AgentId,\n    request: CancelAgentRunRequest = Body(None),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n) -> dict",
          "parameters": "(\n    agent_id: AgentId,\n    request: CancelAgentRunRequest = Body(None),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": "dict",
          "docstring": "Cancel runs associated with an agent. If run_ids are passed in, cancel those in particular.\n\n    Note to cancel active runs associated with an agent, redis is required.",
          "decorators": [
            "@router.post(\"/{agent_id}/messages/cancel\", operation_id=\"cancel_message\")"
          ],
          "start_line": 1666,
          "end_line": 1727,
          "is_async": true
        },
        {
          "name": "search_messages",
          "signature": "def search_messages(\n    request: MessageSearchRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: MessageSearchRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Search messages across the entire organization with optional project and template filtering. Returns messages with FTS/vector ranks and total RRF score.\n\n    This is a cloud-only feature.",
          "decorators": [
            "@router.post(\"/messages/search\", response_model=List[MessageSearchResult], operation_id=\"search_messages\")"
          ],
          "start_line": 1731,
          "end_line": 1762,
          "is_async": true
        },
        {
          "name": "send_message_async",
          "signature": "def send_message_async(\n    agent_id: AgentId,\n    server: SyncServer = Depends(get_letta_server),\n    request: LettaAsyncRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    server: SyncServer = Depends(get_letta_server),\n    request: LettaAsyncRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Asynchronously process a user message and return a run object.\n    The actual processing happens in the background, and the status can be checked using the run ID.\n\n    This is \"asynchronous\" in the sense that it's a background run and explicitly must be fetched by the run ID.",
          "decorators": [
            "@router.post(\n    \"/{agent_id}/messages/async\",\n    response_model=PydanticRun,\n    operation_id=\"create_agent_message_async\",\n)"
          ],
          "start_line": 1902,
          "end_line": 2008,
          "is_async": true
        },
        {
          "name": "reset_messages",
          "signature": "def reset_messages(\n    agent_id: AgentId,\n    request: ResetMessagesRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    request: ResetMessagesRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Resets the messages for an agent",
          "decorators": [
            "@router.patch(\"/{agent_id}/reset-messages\", response_model=Optional[AgentState], operation_id=\"reset_messages\")"
          ],
          "start_line": 2021,
          "end_line": 2034,
          "is_async": true
        },
        {
          "name": "list_groups_for_agent",
          "signature": "def list_groups_for_agent(\n    agent_id: AgentId,\n    manager_type: str | None = Query(None, description=\"Manager type to filter groups by\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Group ID cursor for pagination. Returns groups that come before this group ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Group ID cursor for pagination. Returns groups that come after this group ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of groups to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for groups by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    manager_type: str | None = Query(None, description=\"Manager type to filter groups by\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Group ID cursor for pagination. Returns groups that come before this group ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Group ID cursor for pagination. Returns groups that come after this group ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of groups to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for groups by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "return_type": null,
          "docstring": "Lists the groups for an agent.",
          "decorators": [
            "@router.get(\"/{agent_id}/groups\", response_model=list[Group], operation_id=\"list_groups_for_agent\")"
          ],
          "start_line": 2038,
          "end_line": 2066,
          "is_async": true
        },
        {
          "name": "preview_model_request",
          "signature": "def preview_model_request(\n    agent_id: AgentId,\n    request: Union[LettaRequest, LettaStreamingRequest] = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    request: Union[LettaRequest, LettaStreamingRequest] = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Inspect the raw LLM request payload without sending it.\n\n    This endpoint processes the message through the agent loop up until\n    the LLM request, then returns the raw request payload that would\n    be sent to the LLM provider. Useful for debugging and inspection.",
          "decorators": [
            "@router.post(\n    \"/{agent_id}/messages/preview-raw-payload\",\n    response_model=Dict[str, Any],\n    operation_id=\"preview_model_request\",\n)"
          ],
          "start_line": 2074,
          "end_line": 2116,
          "is_async": true
        },
        {
          "name": "summarize_messages",
          "signature": "def summarize_messages(\n    agent_id: AgentId,\n    request: Optional[CompactionRequest] = Body(default=None),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    request: Optional[CompactionRequest] = Body(default=None),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Summarize an agent's conversation history.",
          "decorators": [
            "@router.post(\"/{agent_id}/summarize\", response_model=CompactionResponse, operation_id=\"summarize_messages\")"
          ],
          "start_line": 2133,
          "end_line": 2189,
          "is_async": true
        },
        {
          "name": "capture_messages",
          "signature": "def capture_messages(\n    agent_id: AgentId,\n    request: CaptureMessagesRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: AgentId,\n    request: CaptureMessagesRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Capture a list of messages for an agent.",
          "decorators": [
            "@router.post(\"/{agent_id}/messages/capture\", response_model=str, operation_id=\"capture_messages\", include_in_schema=False)"
          ],
          "start_line": 2200,
          "end_line": 2250,
          "is_async": true
        },
        {
          "name": "get_agent_webhook_config",
          "signature": "def get_agent_webhook_config(\n    agent_id: AgentId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n) -> AgentWebhookConfig",
          "parameters": "(\n    agent_id: AgentId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": "AgentWebhookConfig",
          "docstring": null,
          "decorators": [
            "@router.get(\"/{agent_id}/webhook\", response_model=AgentWebhookConfig, operation_id=\"get_agent_webhook_config\")"
          ],
          "start_line": 2254,
          "end_line": 2275,
          "is_async": true
        },
        {
          "name": "update_agent_webhook_config",
          "signature": "def update_agent_webhook_config(\n    agent_id: AgentId,\n    config: AgentWebhookConfigUpdate,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n) -> AgentWebhookConfig",
          "parameters": "(\n    agent_id: AgentId,\n    config: AgentWebhookConfigUpdate,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": "AgentWebhookConfig",
          "docstring": null,
          "decorators": [
            "@router.put(\"/{agent_id}/webhook\", response_model=AgentWebhookConfig, operation_id=\"update_agent_webhook_config\")"
          ],
          "start_line": 2279,
          "end_line": 2312,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138680
    },
    "letta/server/rest_api/routers/v1/anthropic.py": {
      "path": "letta/server/rest_api/routers/v1/anthropic.py",
      "contentHash": "ccaa6b51b66564480074350bcb8c7544",
      "mtime": 1767315072056.545,
      "functions": [
        {
          "name": "anthropic_messages_proxy",
          "signature": "def anthropic_messages_proxy(\n    request: Request,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: Request,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Proxy endpoint for Anthropic Messages API.\n\n    This endpoint forwards requests to the Anthropic API, allowing Claude Code CLI\n    to use Letta as a proxy by configuring anthropic_base_url.\n\n    Usage in Claude Code CLI settings.json:\n    {\n        \"env\": {\n            \"ANTHROPIC_BASE_URL\": \"http://localhost:3000/v1/anthropic\"\n        }\n    }",
          "decorators": [
            "@router.api_route(\"/v1/messages\", methods=[\"POST\"], operation_id=\"anthropic_messages_proxy\", include_in_schema=False)"
          ],
          "start_line": 32,
          "end_line": 261,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138680
    },
    "letta/server/rest_api/routers/v1/archives.py": {
      "path": "letta/server/rest_api/routers/v1/archives.py",
      "contentHash": "9606c579844dee94ebfa3cf29d3525c6",
      "mtime": 1767315072056.545,
      "functions": [
        {
          "name": "create_archive",
          "signature": "def create_archive(\n    archive: ArchiveCreateRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    archive: ArchiveCreateRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create a new archive.",
          "decorators": [
            "@router.post(\"/\", response_model=PydanticArchive, operation_id=\"create_archive\")"
          ],
          "start_line": 54,
          "end_line": 84,
          "is_async": true
        },
        {
          "name": "list_archives",
          "signature": "def list_archives(\n    before: Optional[str] = Query(\n        None,\n        description=\"Archive ID cursor for pagination. Returns archives that come before this archive ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Archive ID cursor for pagination. Returns archives that come after this archive ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of archives to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for archives by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    name: Optional[str] = Query(None, description=\"Filter by archive name (exact match)\"),\n    agent_id: Optional[str] = Query(None, description=\"Only archives attached to this agent ID\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    before: Optional[str] = Query(\n        None,\n        description=\"Archive ID cursor for pagination. Returns archives that come before this archive ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Archive ID cursor for pagination. Returns archives that come after this archive ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of archives to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for archives by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    name: Optional[str] = Query(None, description=\"Filter by archive name (exact match)\"),\n    agent_id: Optional[str] = Query(None, description=\"Only archives attached to this agent ID\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a list of all archives for the current organization with optional filters and pagination.",
          "decorators": [
            "@router.get(\"/\", response_model=List[PydanticArchive], operation_id=\"list_archives\")"
          ],
          "start_line": 88,
          "end_line": 120,
          "is_async": true
        },
        {
          "name": "retrieve_archive",
          "signature": "def retrieve_archive(\n    archive_id: ArchiveId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    archive_id: ArchiveId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a single archive by its ID.",
          "decorators": [
            "@router.get(\"/{archive_id}\", response_model=PydanticArchive, operation_id=\"retrieve_archive\")"
          ],
          "start_line": 124,
          "end_line": 136,
          "is_async": true
        },
        {
          "name": "modify_archive",
          "signature": "def modify_archive(\n    archive_id: ArchiveId,\n    archive: ArchiveUpdateRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    archive_id: ArchiveId,\n    archive: ArchiveUpdateRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Update an existing archive's name and/or description.",
          "decorators": [
            "@router.patch(\"/{archive_id}\", response_model=PydanticArchive, operation_id=\"modify_archive\")"
          ],
          "start_line": 140,
          "end_line": 155,
          "is_async": true
        },
        {
          "name": "delete_archive",
          "signature": "def delete_archive(\n    archive_id: ArchiveId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    archive_id: ArchiveId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete an archive by its ID.",
          "decorators": [
            "@router.delete(\"/{archive_id}\", status_code=204, operation_id=\"delete_archive\")"
          ],
          "start_line": 159,
          "end_line": 172,
          "is_async": true
        },
        {
          "name": "list_agents_for_archive",
          "signature": "def list_agents_for_archive(\n    archive_id: ArchiveId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come before this agent ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come after this agent ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of agents to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    include: List[AgentRelationships] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    archive_id: ArchiveId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come before this agent ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come after this agent ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of agents to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    include: List[AgentRelationships] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a list of agents that have access to an archive with pagination support.",
          "decorators": [
            "@router.get(\"/{archive_id}/agents\", response_model=List[AgentState], operation_id=\"list_agents_for_archive\")"
          ],
          "start_line": 176,
          "end_line": 209,
          "is_async": true
        },
        {
          "name": "create_passage_in_archive",
          "signature": "def create_passage_in_archive(\n    archive_id: ArchiveId,\n    passage: PassageCreateRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    archive_id: ArchiveId,\n    passage: PassageCreateRequest = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create a new passage in an archive.\n\n    This adds a passage to the archive and creates embeddings for vector storage.",
          "decorators": [
            "@router.post(\"/{archive_id}/passages\", response_model=Passage, operation_id=\"create_passage_in_archive\")"
          ],
          "start_line": 213,
          "end_line": 231,
          "is_async": true
        },
        {
          "name": "delete_passage_from_archive",
          "signature": "def delete_passage_from_archive(\n    archive_id: ArchiveId,\n    passage_id: PassageId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    archive_id: ArchiveId,\n    passage_id: PassageId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete a passage from an archive.\n\n    This permanently removes the passage from both the database and vector storage (if applicable).",
          "decorators": [
            "@router.delete(\"/{archive_id}/passages/{passage_id}\", status_code=204, operation_id=\"delete_passage_from_archive\")"
          ],
          "start_line": 235,
          "end_line": 252,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138680
    },
    "letta/server/rest_api/routers/v1/blocks.py": {
      "path": "letta/server/rest_api/routers/v1/blocks.py",
      "contentHash": "61c001bd6385e294dccb4b2bfba64659",
      "mtime": 1767315072056.545,
      "functions": [
        {
          "name": "list_blocks",
          "signature": "def list_blocks(\n    # query parameters\n    label: BlockLabelQuery = None,\n    templates_only: bool = Query(False, description=\"Whether to include only templates\"),\n    name: BlockNameQuery = None,\n    identity_id: IdentityIdQuery = None,\n    identifier_keys: Optional[List[str]] = Query(None, description=\"Search agents by identifier keys\"),\n    project_id: Optional[str] = Query(None, description=\"Search blocks by project id\"),\n    limit: Optional[int] = Query(50, description=\"Number of blocks to return\"),\n    before: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come before this block ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come after this block ID in the specified sort order\",\n    ),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for blocks by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    label_search: BlockLabelSearchQuery = None,\n    description_search: BlockDescriptionSearchQuery = None,\n    value_search: BlockValueSearchQuery = None,\n    connected_to_agents_count_gt: Optional[int] = Query(\n        None,\n        description=(\n            \"Filter blocks by the number of connected agents. \"\n            \"If provided, returns blocks that have more than this number of connected agents.\"\n        ),\n    ),\n    connected_to_agents_count_lt: Optional[int] = Query(\n        None,\n        description=(\n            \"Filter blocks by the number of connected agents. \"\n            \"If provided, returns blocks that have less than this number of connected agents.\"\n        ),\n    ),\n    connected_to_agents_count_eq: Optional[List[int]] = Query(\n        None,\n        description=(\n            \"Filter blocks by the exact number of connected agents. \"\n            \"If provided, returns blocks that have exactly this number of connected agents.\"\n        ),\n    ),\n    show_hidden_blocks: bool | None = Query(\n        False,\n        include_in_schema=False,\n        description=\"If set to True, include blocks marked as hidden in the results.\",\n    ),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    # query parameters\n    label: BlockLabelQuery = None,\n    templates_only: bool = Query(False, description=\"Whether to include only templates\"),\n    name: BlockNameQuery = None,\n    identity_id: IdentityIdQuery = None,\n    identifier_keys: Optional[List[str]] = Query(None, description=\"Search agents by identifier keys\"),\n    project_id: Optional[str] = Query(None, description=\"Search blocks by project id\"),\n    limit: Optional[int] = Query(50, description=\"Number of blocks to return\"),\n    before: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come before this block ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come after this block ID in the specified sort order\",\n    ),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for blocks by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    label_search: BlockLabelSearchQuery = None,\n    description_search: BlockDescriptionSearchQuery = None,\n    value_search: BlockValueSearchQuery = None,\n    connected_to_agents_count_gt: Optional[int] = Query(\n        None,\n        description=(\n            \"Filter blocks by the number of connected agents. \"\n            \"If provided, returns blocks that have more than this number of connected agents.\"\n        ),\n    ),\n    connected_to_agents_count_lt: Optional[int] = Query(\n        None,\n        description=(\n            \"Filter blocks by the number of connected agents. \"\n            \"If provided, returns blocks that have less than this number of connected agents.\"\n        ),\n    ),\n    connected_to_agents_count_eq: Optional[List[int]] = Query(\n        None,\n        description=(\n            \"Filter blocks by the exact number of connected agents. \"\n            \"If provided, returns blocks that have exactly this number of connected agents.\"\n        ),\n    ),\n    show_hidden_blocks: bool | None = Query(\n        False,\n        include_in_schema=False,\n        description=\"If set to True, include blocks marked as hidden in the results.\",\n    ),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.get(\"/\", response_model=List[BlockResponse], operation_id=\"list_blocks\")"
          ],
          "start_line": 28,
          "end_line": 101,
          "is_async": true
        },
        {
          "name": "count_blocks",
          "signature": "def count_blocks(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Count all blocks created by a user.",
          "decorators": [
            "@router.get(\"/count\", response_model=int, operation_id=\"count_blocks\")"
          ],
          "start_line": 105,
          "end_line": 113,
          "is_async": true
        },
        {
          "name": "create_block",
          "signature": "def create_block(\n    create_block: CreateBlock = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    create_block: CreateBlock = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.post(\"/\", response_model=BlockResponse, operation_id=\"create_block\")"
          ],
          "start_line": 117,
          "end_line": 124,
          "is_async": true
        },
        {
          "name": "modify_block",
          "signature": "def modify_block(\n    block_id: BlockId,\n    block_update: BlockUpdate = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_id: BlockId,\n    block_update: BlockUpdate = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.patch(\"/{block_id}\", response_model=BlockResponse, operation_id=\"modify_block\")"
          ],
          "start_line": 128,
          "end_line": 135,
          "is_async": true
        },
        {
          "name": "delete_block",
          "signature": "def delete_block(\n    block_id: BlockId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_id: BlockId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.delete(\"/{block_id}\", operation_id=\"delete_block\")"
          ],
          "start_line": 139,
          "end_line": 145,
          "is_async": true
        },
        {
          "name": "retrieve_block",
          "signature": "def retrieve_block(\n    block_id: BlockId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_id: BlockId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.get(\"/{block_id}\", response_model=BlockResponse, operation_id=\"retrieve_block\")"
          ],
          "start_line": 149,
          "end_line": 158,
          "is_async": true
        },
        {
          "name": "list_agents_for_block",
          "signature": "def list_agents_for_block(\n    block_id: BlockId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come before this agent ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come after this agent ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of agents to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    include_relationships: list[str] | None = Query(\n        None,\n        description=(\n            \"Specify which relational fields (e.g., 'tools', 'sources', 'memory') to include in the response. \"\n            \"If not provided, all relationships are loaded by default. \"\n            \"Using this can optimize performance by reducing unnecessary joins.\"\n            \"This is a legacy parameter, and no longer supported after 1.0.0 SDK versions.\"\n        ),\n        deprecated=True,\n    ),\n    include: List[AgentRelationships] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_id: BlockId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come before this agent ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come after this agent ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of agents to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    include_relationships: list[str] | None = Query(\n        None,\n        description=(\n            \"Specify which relational fields (e.g., 'tools', 'sources', 'memory') to include in the response. \"\n            \"If not provided, all relationships are loaded by default. \"\n            \"Using this can optimize performance by reducing unnecessary joins.\"\n            \"This is a legacy parameter, and no longer supported after 1.0.0 SDK versions.\"\n        ),\n        deprecated=True,\n    ),\n    include: List[AgentRelationships] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieves all agents associated with the specified block.\n    Raises a 404 if the block does not exist.",
          "decorators": [
            "@router.get(\"/{block_id}/agents\", response_model=List[AgentState], operation_id=\"list_agents_for_block\")"
          ],
          "start_line": 162,
          "end_line": 211,
          "is_async": true
        },
        {
          "name": "attach_identity_to_block",
          "signature": "def attach_identity_to_block(\n    identity_id: str,\n    block_id: BlockId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    identity_id: str,\n    block_id: BlockId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Attach an identity to a block.",
          "decorators": [
            "@router.patch(\"/{block_id}/identities/attach/{identity_id}\", response_model=BlockResponse, operation_id=\"attach_identity_to_block\")"
          ],
          "start_line": 215,
          "end_line": 230,
          "is_async": true
        },
        {
          "name": "detach_identity_from_block",
          "signature": "def detach_identity_from_block(\n    identity_id: str,\n    block_id: BlockId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    identity_id: str,\n    block_id: BlockId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Detach an identity from a block.",
          "decorators": [
            "@router.patch(\"/{block_id}/identities/detach/{identity_id}\", response_model=BlockResponse, operation_id=\"detach_identity_from_block\")"
          ],
          "start_line": 234,
          "end_line": 249,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138680
    },
    "letta/server/rest_api/routers/v1/chat_completions.py": {
      "path": "letta/server/rest_api/routers/v1/chat_completions.py",
      "contentHash": "24a64b992264fffe2c7dc1f5e39c261a",
      "mtime": 1767315072056.545,
      "functions": [
        {
          "name": "create_chat_completion",
          "signature": "def create_chat_completion(\n    request: ChatCompletionRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n) -> Union[ChatCompletion, StreamingResponse]",
          "parameters": "(\n    request: ChatCompletionRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": "Union[ChatCompletion, StreamingResponse]",
          "docstring": "Create a chat completion using a Letta agent (OpenAI-compatible).\n\n    This endpoint provides full OpenAI API compatibility. The agent is selected based on:\n    - The 'model' parameter in the request (should contain an agent ID in format 'agent-...')\n\n    When streaming is enabled (stream=true), the response will be Server-Sent Events\n    with ChatCompletionChunk objects.",
          "decorators": [
            "@router.post(\n    \"/chat/completions\",\n    response_model=ChatCompletion,\n    responses={\n        200: {\n            \"description\": \"Successful response\",\n            \"content\": {\n                \"application/json\": {\"schema\": {\"$ref\": \"#/components/schemas/ChatCompletion\"}},\n                \"text/event-stream\": {\"description\": \"Server-Sent Events stream (when stream=true)\"},\n            },\n        }\n    },\n    operation_id=\"create_chat_completion\",\n)"
          ],
          "start_line": 132,
          "end_line": 146,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138681
    },
    "letta/server/rest_api/routers/v1/conversations.py": {
      "path": "letta/server/rest_api/routers/v1/conversations.py",
      "contentHash": "461ffba424bd4acd6fec037fff485549",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "create_conversation",
          "signature": "def create_conversation(\n    agent_id: str = Query(..., description=\"The agent ID to create a conversation for\"),\n    conversation_create: CreateConversation = Body(default_factory=CreateConversation),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: str = Query(..., description=\"The agent ID to create a conversation for\"),\n    conversation_create: CreateConversation = Body(default_factory=CreateConversation),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create a new conversation for an agent.",
          "decorators": [
            "@router.post(\"/\", response_model=Conversation, operation_id=\"create_conversation\")"
          ],
          "start_line": 37,
          "end_line": 49,
          "is_async": true
        },
        {
          "name": "list_conversations",
          "signature": "def list_conversations(\n    agent_id: str = Query(..., description=\"The agent ID to list conversations for\"),\n    limit: int = Query(50, description=\"Maximum number of conversations to return\"),\n    after: Optional[str] = Query(None, description=\"Cursor for pagination (conversation ID)\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: str = Query(..., description=\"The agent ID to list conversations for\"),\n    limit: int = Query(50, description=\"Maximum number of conversations to return\"),\n    after: Optional[str] = Query(None, description=\"Cursor for pagination (conversation ID)\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List all conversations for an agent.",
          "decorators": [
            "@router.get(\"/\", response_model=List[Conversation], operation_id=\"list_conversations\")"
          ],
          "start_line": 53,
          "end_line": 67,
          "is_async": true
        },
        {
          "name": "retrieve_conversation",
          "signature": "def retrieve_conversation(\n    conversation_id: ConversationId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    conversation_id: ConversationId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieve a specific conversation.",
          "decorators": [
            "@router.get(\"/{conversation_id}\", response_model=Conversation, operation_id=\"retrieve_conversation\")"
          ],
          "start_line": 71,
          "end_line": 81,
          "is_async": true
        },
        {
          "name": "list_conversation_messages",
          "signature": "def list_conversation_messages(\n    conversation_id: ConversationId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the conversation\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the conversation\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n)",
          "parameters": "(\n    conversation_id: ConversationId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the conversation\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the conversation\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n)",
          "return_type": null,
          "docstring": "List all messages in a conversation.\n\n    Returns LettaMessage objects (UserMessage, AssistantMessage, etc.) for all\n    messages in the conversation, ordered by position (oldest first),\n    with support for cursor-based pagination.",
          "decorators": [
            "@router.get(\n    \"/{conversation_id}/messages\",\n    response_model=ConversationMessagesResponse,\n    operation_id=\"list_conversation_messages\",\n)"
          ],
          "start_line": 94,
          "end_line": 120,
          "is_async": true
        },
        {
          "name": "send_conversation_message",
          "signature": "def send_conversation_message(\n    conversation_id: ConversationId,\n    request: LettaStreamingRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n) -> StreamingResponse | LettaResponse",
          "parameters": "(\n    conversation_id: ConversationId,\n    request: LettaStreamingRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": "StreamingResponse | LettaResponse",
          "docstring": "Send a message to a conversation and get a streaming response.\n\n    This endpoint sends a message to an existing conversation and streams\n    the agent's response back.",
          "decorators": [
            "@router.post(\n    \"/{conversation_id}/messages\",\n    response_model=LettaStreamingResponse,\n    operation_id=\"send_conversation_message\",\n    responses={\n        200: {\n            \"description\": \"Successful response\",\n            \"content\": {\n                \"text/event-stream\": {\"description\": \"Server-Sent Events stream\"},\n            },\n        }\n    },\n)"
          ],
          "start_line": 136,
          "end_line": 169,
          "is_async": true
        },
        {
          "name": "retrieve_conversation_stream",
          "signature": "def retrieve_conversation_stream(\n    conversation_id: ConversationId,\n    request: RetrieveStreamRequest = Body(None),\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "parameters": "(\n    conversation_id: ConversationId,\n    request: RetrieveStreamRequest = Body(None),\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Resume the stream for the most recent active run in a conversation.\n\n    This endpoint allows you to reconnect to an active background stream\n    for a conversation, enabling recovery from network interruptions.",
          "decorators": [
            "@router.post(\n    \"/{conversation_id}/stream\",\n    response_model=None,\n    operation_id=\"retrieve_conversation_stream\",\n    responses={\n        200: {\n            \"description\": \"Successful response\",\n            \"content\": {\n                \"text/event-stream\": {\n                    \"description\": \"Server-Sent Events stream\",\n                    \"schema\": {\n                        \"oneOf\": [\n                            {\"$ref\": \"#/components/schemas/SystemMessage\"},\n                            {\"$ref\": \"#/components/schemas/UserMessage\"},\n                            {\"$ref\": \"#/components/schemas/ReasoningMessage\"},\n                            {\"$ref\": \"#/components/schemas/HiddenReasoningMessage\"},\n                            {\"$ref\": \"#/components/schemas/ToolCallMessage\"},\n                            {\"$ref\": \"#/components/schemas/ToolReturnMessage\"},\n                            {\"$ref\": \"#/components/schemas/AssistantMessage\"},\n                            {\"$ref\": \"#/components/schemas/ApprovalRequestMessage\"},\n                            {\"$ref\": \"#/components/schemas/ApprovalResponseMessage\"},\n                            {\"$ref\": \"#/components/schemas/LettaPing\"},\n                            {\"$ref\": \"#/components/schemas/LettaErrorMessage\"},\n                            {\"$ref\": \"#/components/schemas/LettaStopReason\"},\n                            {\"$ref\": \"#/components/schemas/LettaUsageStatistics\"},\n                        ]\n                    },\n                },\n            },\n        }\n    },\n)"
          ],
          "start_line": 204,
          "end_line": 273,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138681
    },
    "letta/server/rest_api/routers/v1/embeddings.py": {
      "path": "letta/server/rest_api/routers/v1/embeddings.py",
      "contentHash": "a90d5d9488f7c4dea605aa020ffa44bd",
      "mtime": 1767315072056.545,
      "functions": [
        {
          "name": "get_embeddings_total_storage_size",
          "signature": "def get_embeddings_total_storage_size(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    storage_unit: Optional[str] = Header(\"GB\", alias=\"storage_unit\"),  # Extract storage unit from header, default to GB\n)",
          "parameters": "(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    storage_unit: Optional[str] = Header(\"GB\", alias=\"storage_unit\"),  # Extract storage unit from header, default to GB\n)",
          "return_type": null,
          "docstring": "Get the total size of all embeddings in the database for a user in the storage unit given.",
          "decorators": [
            "@router.get(\"/total_storage_size\", response_model=float, operation_id=\"get_total_storage_size\")"
          ],
          "start_line": 12,
          "end_line": 21,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138681
    },
    "letta/server/rest_api/routers/v1/folders.py": {
      "path": "letta/server/rest_api/routers/v1/folders.py",
      "contentHash": "239e2b00c82c706772545229b6242026",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "count_folders",
          "signature": "def count_folders(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Count all data folders created by a user.",
          "decorators": [
            "@router.get(\"/count\", response_model=int, operation_id=\"count_folders\")"
          ],
          "start_line": 53,
          "end_line": 61,
          "is_async": true
        },
        {
          "name": "retrieve_folder",
          "signature": "def retrieve_folder(\n    folder_id: FolderId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder_id: FolderId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a folder by ID",
          "decorators": [
            "@router.get(\"/{folder_id}\", response_model=Folder, operation_id=\"retrieve_folder\")"
          ],
          "start_line": 65,
          "end_line": 76,
          "is_async": true
        },
        {
          "name": "get_folder_by_name",
          "signature": "def get_folder_by_name(\n    folder_name: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder_name: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "**Deprecated**: Please use the list endpoint `GET /v1/folders?name=` instead.\n\n\n    Get a folder by name.",
          "decorators": [
            "@router.get(\"/name/{folder_name}\", response_model=str, operation_id=\"get_folder_by_name\", deprecated=True)"
          ],
          "start_line": 80,
          "end_line": 94,
          "is_async": true
        },
        {
          "name": "retrieve_metadata",
          "signature": "def retrieve_metadata(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    include_detailed_per_source_metadata: bool = False,\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    include_detailed_per_source_metadata: bool = False,\n)",
          "return_type": null,
          "docstring": "Get aggregated metadata for all folders in an organization.\n\n    Returns structured metadata including:\n    - Total number of folders\n    - Total number of files across all folders\n    - Total size of all files\n    - Per-source breakdown with file details (file_name, file_size per file) if include_detailed_per_source_metadata is True",
          "decorators": [
            "@router.get(\"/metadata\", response_model=OrganizationSourcesStats, operation_id=\"retrieve_metadata\")"
          ],
          "start_line": 98,
          "end_line": 115,
          "is_async": true
        },
        {
          "name": "list_folders",
          "signature": "def list_folders(\n    before: Optional[str] = Query(\n        None, description=\"Folder ID cursor for pagination. Returns folders that come before this folder ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Folder ID cursor for pagination. Returns folders that come after this folder ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of folders to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for folders by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    name: Optional[str] = Query(None, description=\"Folder name to filter by\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    before: Optional[str] = Query(\n        None, description=\"Folder ID cursor for pagination. Returns folders that come before this folder ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Folder ID cursor for pagination. Returns folders that come after this folder ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of folders to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for folders by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    name: Optional[str] = Query(None, description=\"Folder name to filter by\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List all data folders created by a user.",
          "decorators": [
            "@router.get(\"/\", response_model=List[Folder], operation_id=\"list_folders\")"
          ],
          "start_line": 119,
          "end_line": 141,
          "is_async": true
        },
        {
          "name": "create_folder",
          "signature": "def create_folder(\n    folder_create: SourceCreate,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder_create: SourceCreate,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create a new data folder.",
          "decorators": [
            "@router.post(\"/\", response_model=Folder, operation_id=\"create_folder\")"
          ],
          "start_line": 145,
          "end_line": 176,
          "is_async": true
        },
        {
          "name": "modify_folder",
          "signature": "def modify_folder(\n    folder: SourceUpdate,\n    folder_id: FolderId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder: SourceUpdate,\n    folder_id: FolderId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Update the name or documentation of an existing data folder.",
          "decorators": [
            "@router.patch(\"/{folder_id}\", response_model=Folder, operation_id=\"modify_folder\")"
          ],
          "start_line": 180,
          "end_line": 192,
          "is_async": true
        },
        {
          "name": "delete_folder",
          "signature": "def delete_folder(\n    folder_id: FolderId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder_id: FolderId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete a data folder.",
          "decorators": [
            "@router.delete(\"/{folder_id}\", response_model=None, operation_id=\"delete_folder\")"
          ],
          "start_line": 196,
          "end_line": 230,
          "is_async": true
        },
        {
          "name": "upload_file_to_folder",
          "signature": "def upload_file_to_folder(\n    file: UploadFile,\n    folder_id: FolderId,\n    duplicate_handling: DuplicateFileHandling = Query(DuplicateFileHandling.SUFFIX, description=\"How to handle duplicate filenames\"),\n    name: Optional[str] = Query(None, description=\"Optional custom name to override the uploaded file's name\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    file: UploadFile,\n    folder_id: FolderId,\n    duplicate_handling: DuplicateFileHandling = Query(DuplicateFileHandling.SUFFIX, description=\"How to handle duplicate filenames\"),\n    name: Optional[str] = Query(None, description=\"Optional custom name to override the uploaded file's name\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Upload a file to a data folder.",
          "decorators": [
            "@router.post(\"/{folder_id}/upload\", response_model=FileMetadata, operation_id=\"upload_file_to_folder\")"
          ],
          "start_line": 234,
          "end_line": 371,
          "is_async": true
        },
        {
          "name": "list_agents_for_folder",
          "signature": "def list_agents_for_folder(\n    folder_id: FolderId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come before this agent ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come after this agent ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of agents to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder_id: FolderId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come before this agent ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come after this agent ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of agents to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get all agent IDs that have the specified folder attached.",
          "decorators": [
            "@router.get(\"/{folder_id}/agents\", response_model=List[str], operation_id=\"list_agents_for_folder\")"
          ],
          "start_line": 375,
          "end_line": 404,
          "is_async": true
        },
        {
          "name": "list_folder_passages",
          "signature": "def list_folder_passages(\n    folder_id: FolderId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Passage ID cursor for pagination. Returns passages that come before this passage ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Passage ID cursor for pagination. Returns passages that come after this passage ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of passages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for passages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder_id: FolderId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Passage ID cursor for pagination. Returns passages that come before this passage ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Passage ID cursor for pagination. Returns passages that come after this passage ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of passages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for passages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List all passages associated with a data folder.",
          "decorators": [
            "@router.get(\"/{folder_id}/passages\", response_model=List[Passage], operation_id=\"list_folder_passages\")"
          ],
          "start_line": 408,
          "end_line": 437,
          "is_async": true
        },
        {
          "name": "list_files_for_folder",
          "signature": "def list_files_for_folder(\n    folder_id: FolderId,\n    before: Optional[str] = Query(\n        None,\n        description=\"File ID cursor for pagination. Returns files that come before this file ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"File ID cursor for pagination. Returns files that come after this file ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(1000, description=\"Maximum number of files to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for files by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    include_content: bool = Query(False, description=\"Whether to include full file content\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder_id: FolderId,\n    before: Optional[str] = Query(\n        None,\n        description=\"File ID cursor for pagination. Returns files that come before this file ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"File ID cursor for pagination. Returns files that come after this file ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(1000, description=\"Maximum number of files to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for files by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    include_content: bool = Query(False, description=\"Whether to include full file content\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List paginated files associated with a data folder.",
          "decorators": [
            "@router.get(\"/{folder_id}/files\", response_model=List[FileMetadata], operation_id=\"list_files_for_folder\")"
          ],
          "start_line": 441,
          "end_line": 473,
          "is_async": true
        },
        {
          "name": "retrieve_file",
          "signature": "def retrieve_file(\n    folder_id: FolderId,\n    file_id: FileId,\n    include_content: bool = Query(False, description=\"Whether to include full file content\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder_id: FolderId,\n    file_id: FileId,\n    include_content: bool = Query(False, description=\"Whether to include full file content\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieve a file from a folder by ID.",
          "decorators": [
            "@router.get(\"/{folder_id}/files/{file_id}\", response_model=FileMetadata, operation_id=\"retrieve_file\")"
          ],
          "start_line": 477,
          "end_line": 497,
          "is_async": true
        },
        {
          "name": "delete_file_from_folder",
          "signature": "def delete_file_from_folder(\n    folder_id: FolderId,\n    file_id: FileId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    folder_id: FolderId,\n    file_id: FileId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete a file from a folder.",
          "decorators": [
            "@router.delete(\"/{folder_id}/{file_id}\", status_code=204, operation_id=\"delete_file_from_folder\")"
          ],
          "start_line": 552,
          "end_line": 577,
          "is_async": true
        },
        {
          "name": "load_file_to_source_async",
          "signature": "def load_file_to_source_async(server: SyncServer, source_id: str, job_id: str, filename: str, bytes: bytes, actor: User)",
          "parameters": "(server: SyncServer, source_id: str, job_id: str, filename: str, bytes: bytes, actor: User)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 580,
          "end_line": 593,
          "is_async": true
        },
        {
          "name": "sleeptime_document_ingest_async",
          "signature": "def sleeptime_document_ingest_async(server: SyncServer, source_id: str, actor: User, clear_history: bool = False)",
          "parameters": "(server: SyncServer, source_id: str, actor: User, clear_history: bool = False)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 596,
          "end_line": 601,
          "is_async": true
        },
        {
          "name": "load_file_to_source_cloud",
          "signature": "def load_file_to_source_cloud(\n    server: SyncServer,\n    agent_states: List[AgentState],\n    content: bytes,\n    source_id: str,\n    actor: User,\n    embedding_config: EmbeddingConfig,\n    file_metadata: FileMetadata,\n)",
          "parameters": "(\n    server: SyncServer,\n    agent_states: List[AgentState],\n    content: bytes,\n    source_id: str,\n    actor: User,\n    embedding_config: EmbeddingConfig,\n    file_metadata: FileMetadata,\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@trace_method"
          ],
          "start_line": 605,
          "end_line": 631,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138681
    },
    "letta/server/rest_api/routers/v1/groups.py": {
      "path": "letta/server/rest_api/routers/v1/groups.py",
      "contentHash": "5b4cf2b6998c7b2c6403b756d928165b",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "list_groups",
          "signature": "def list_groups(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    manager_type: Optional[ManagerType] = Query(None, description=\"Search groups by manager type\"),\n    before: Optional[str] = Query(\n        None, description=\"Group ID cursor for pagination. Returns groups that come before this group ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Group ID cursor for pagination. Returns groups that come after this group ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of groups to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for groups by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    project_id: Optional[str] = Query(None, description=\"Search groups by project id\"),\n    show_hidden_groups: bool | None = Query(\n        False,\n        include_in_schema=False,\n        description=\"If set to True, include groups marked as hidden in the results.\",\n    ),\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    manager_type: Optional[ManagerType] = Query(None, description=\"Search groups by manager type\"),\n    before: Optional[str] = Query(\n        None, description=\"Group ID cursor for pagination. Returns groups that come before this group ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Group ID cursor for pagination. Returns groups that come after this group ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of groups to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for groups by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    project_id: Optional[str] = Query(None, description=\"Search groups by project id\"),\n    show_hidden_groups: bool | None = Query(\n        False,\n        include_in_schema=False,\n        description=\"If set to True, include groups marked as hidden in the results.\",\n    ),\n)",
          "return_type": null,
          "docstring": "Fetch all multi-agent groups matching query.",
          "decorators": [
            "@router.get(\"/\", response_model=List[Group], operation_id=\"list_groups\")"
          ],
          "start_line": 21,
          "end_line": 56,
          "is_async": true
        },
        {
          "name": "count_groups",
          "signature": "def count_groups(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get the count of all groups associated with a given user.",
          "decorators": [
            "@router.get(\"/count\", response_model=int, operation_id=\"count_groups\")"
          ],
          "start_line": 60,
          "end_line": 68,
          "is_async": true
        },
        {
          "name": "retrieve_group",
          "signature": "def retrieve_group(\n    group_id: GroupId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    group_id: GroupId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieve the group by id.",
          "decorators": [
            "@router.get(\"/{group_id}\", response_model=Group, operation_id=\"retrieve_group\")"
          ],
          "start_line": 72,
          "end_line": 81,
          "is_async": true
        },
        {
          "name": "create_group",
          "signature": "def create_group(\n    group: GroupCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: Optional[str] = Header(\n        None, alias=\"X-Project\", description=\"The project slug to associate with the group (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "parameters": "(\n    group: GroupCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: Optional[str] = Header(\n        None, alias=\"X-Project\", description=\"The project slug to associate with the group (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "return_type": null,
          "docstring": "Create a new multi-agent group with the specified configuration.",
          "decorators": [
            "@router.post(\"/\", response_model=Group, operation_id=\"create_group\")"
          ],
          "start_line": 85,
          "end_line": 97,
          "is_async": true
        },
        {
          "name": "modify_group",
          "signature": "def modify_group(\n    group_id: GroupId,\n    group: GroupUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: Optional[str] = Header(\n        None, alias=\"X-Project\", description=\"The project slug to associate with the group (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "parameters": "(\n    group_id: GroupId,\n    group: GroupUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: Optional[str] = Header(\n        None, alias=\"X-Project\", description=\"The project slug to associate with the group (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "return_type": null,
          "docstring": "Create a new multi-agent group with the specified configuration.",
          "decorators": [
            "@router.patch(\"/{group_id}\", response_model=Group, operation_id=\"modify_group\")"
          ],
          "start_line": 101,
          "end_line": 114,
          "is_async": true
        },
        {
          "name": "delete_group",
          "signature": "def delete_group(\n    group_id: GroupId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    group_id: GroupId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete a multi-agent group.",
          "decorators": [
            "@router.delete(\"/{group_id}\", response_model=None, operation_id=\"delete_group\")"
          ],
          "start_line": 118,
          "end_line": 128,
          "is_async": true
        },
        {
          "name": "send_group_message",
          "signature": "def send_group_message(\n    group_id: GroupId,\n    server: SyncServer = Depends(get_letta_server),\n    request: LettaRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    group_id: GroupId,\n    server: SyncServer = Depends(get_letta_server),\n    request: LettaRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Process a user message and return the group's response.\n    This endpoint accepts a message from a user and processes it through through agents in the group based on the specified pattern",
          "decorators": [
            "@router.post(\n    \"/{group_id}/messages\",\n    response_model=LettaResponse,\n    operation_id=\"send_group_message\",\n)"
          ],
          "start_line": 136,
          "end_line": 158,
          "is_async": true
        },
        {
          "name": "send_group_message_streaming",
          "signature": "def send_group_message_streaming(\n    group_id: GroupId,\n    server: SyncServer = Depends(get_letta_server),\n    request: LettaStreamingRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    group_id: GroupId,\n    server: SyncServer = Depends(get_letta_server),\n    request: LettaStreamingRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Process a user message and return the group's responses.\n    This endpoint accepts a message from a user and processes it through agents in the group based on the specified pattern.\n    It will stream the steps of the response always, and stream the tokens if 'stream_tokens' is set to True.",
          "decorators": [
            "@router.post(\n    \"/{group_id}/messages/stream\",\n    response_model=None,\n    operation_id=\"send_group_message_streaming\",\n    responses={\n        200: {\n            \"description\": \"Successful response\",\n            \"content\": {\n                \"text/event-stream\": {\"description\": \"Server-Sent Events stream\"},\n            },\n        }\n    },\n)"
          ],
          "start_line": 174,
          "end_line": 197,
          "is_async": true
        },
        {
          "name": "modify_group_message",
          "signature": "def modify_group_message(\n    group_id: GroupId,\n    message_id: MessageId,\n    request: LettaMessageUpdateUnion = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    group_id: GroupId,\n    message_id: MessageId,\n    request: LettaMessageUpdateUnion = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Update the details of a message associated with an agent.",
          "decorators": [
            "@router.patch(\"/{group_id}/messages/{message_id}\", response_model=LettaMessageUnion, operation_id=\"modify_group_message\")"
          ],
          "start_line": 206,
          "end_line": 218,
          "is_async": true
        },
        {
          "name": "list_group_messages",
          "signature": "def list_group_messages(\n    group_id: GroupId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(10, description=\"Maximum number of messages to retrieve\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    use_assistant_message: bool = Query(True, description=\"Whether to use assistant messages\", deprecated=True),\n    assistant_message_tool_name: str = Query(DEFAULT_MESSAGE_TOOL, description=\"The name of the designated message tool.\", deprecated=True),\n    assistant_message_tool_kwarg: str = Query(DEFAULT_MESSAGE_TOOL_KWARG, description=\"The name of the message argument.\", deprecated=True),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    group_id: GroupId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(10, description=\"Maximum number of messages to retrieve\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    use_assistant_message: bool = Query(True, description=\"Whether to use assistant messages\", deprecated=True),\n    assistant_message_tool_name: str = Query(DEFAULT_MESSAGE_TOOL, description=\"The name of the designated message tool.\", deprecated=True),\n    assistant_message_tool_kwarg: str = Query(DEFAULT_MESSAGE_TOOL_KWARG, description=\"The name of the message argument.\", deprecated=True),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieve message history for an agent.",
          "decorators": [
            "@router.get(\"/{group_id}/messages\", response_model=GroupMessagesResponse, operation_id=\"list_group_messages\")"
          ],
          "start_line": 222,
          "end_line": 273,
          "is_async": true
        },
        {
          "name": "reset_group_messages",
          "signature": "def reset_group_messages(\n    group_id: GroupId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    group_id: GroupId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete the group messages for all agents that are part of the multi-agent group.",
          "decorators": [
            "@router.patch(\"/{group_id}/reset-messages\", response_model=None, operation_id=\"reset_group_messages\")"
          ],
          "start_line": 277,
          "end_line": 286,
          "is_async": true
        },
        {
          "name": "attach_block_to_group",
          "signature": "def attach_block_to_group(\n    block_id: str,\n    group_id: GroupId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_id: str,\n    group_id: GroupId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Attach a block to a group.\n    This will add the block to the group and all agents within the group.",
          "decorators": [
            "@router.patch(\"/{group_id}/blocks/attach/{block_id}\", response_model=None, operation_id=\"attach_block_to_group\")"
          ],
          "start_line": 290,
          "end_line": 306,
          "is_async": true
        },
        {
          "name": "detach_block_from_group",
          "signature": "def detach_block_from_group(\n    block_id: str,\n    group_id: GroupId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_id: str,\n    group_id: GroupId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Detach a block from a group.\n    This will remove the block from the group and all agents within the group.",
          "decorators": [
            "@router.patch(\"/{group_id}/blocks/detach/{block_id}\", response_model=None, operation_id=\"detach_block_from_group\")"
          ],
          "start_line": 310,
          "end_line": 326,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138681
    },
    "letta/server/rest_api/routers/v1/health.py": {
      "path": "letta/server/rest_api/routers/v1/health.py",
      "contentHash": "c9041f027b1301b0c949eac38efb8dfc",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "check_health",
          "signature": "def check_health()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Async health check endpoint.",
          "decorators": [
            "@router.get(\"/\", response_model=Health, operation_id=\"check_health\")"
          ],
          "start_line": 15,
          "end_line": 20,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138681
    },
    "letta/server/rest_api/routers/v1/identities.py": {
      "path": "letta/server/rest_api/routers/v1/identities.py",
      "contentHash": "f1bea700163ba81f3eddb73e312e2b59",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "list_identities",
          "signature": "def list_identities(\n    name: Optional[str] = Query(None),\n    project_id: Optional[str] = Query(\n        None,\n        deprecated=True,\n        description=\"[DEPRECATED: Use X-Project-Id header instead] Filter identities by project ID\",\n    ),\n    identifier_key: Optional[str] = Query(None),\n    identity_type: Optional[IdentityType] = Query(None),\n    before: Optional[str] = Query(\n        None,\n        description=\"Identity ID cursor for pagination. Returns identities that come before this identity ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Identity ID cursor for pagination. Returns identities that come after this identity ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of identities to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for identities by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    name: Optional[str] = Query(None),\n    project_id: Optional[str] = Query(\n        None,\n        deprecated=True,\n        description=\"[DEPRECATED: Use X-Project-Id header instead] Filter identities by project ID\",\n    ),\n    identifier_key: Optional[str] = Query(None),\n    identity_type: Optional[IdentityType] = Query(None),\n    before: Optional[str] = Query(\n        None,\n        description=\"Identity ID cursor for pagination. Returns identities that come before this identity ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Identity ID cursor for pagination. Returns identities that come after this identity ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of identities to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for identities by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a list of all identities in the database",
          "decorators": [
            "@router.get(\"/\", tags=[\"identities\"], response_model=List[Identity], operation_id=\"list_identities\")"
          ],
          "start_line": 26,
          "end_line": 68,
          "is_async": true
        },
        {
          "name": "count_identities",
          "signature": "def count_identities(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get count of all identities for a user",
          "decorators": [
            "@router.get(\"/count\", tags=[\"identities\"], response_model=int, operation_id=\"count_identities\")"
          ],
          "start_line": 72,
          "end_line": 83,
          "is_async": true
        },
        {
          "name": "retrieve_identity",
          "signature": "def retrieve_identity(\n    identity_id: IdentityId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    identity_id: IdentityId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.get(\"/{identity_id}\", tags=[\"identities\"], response_model=Identity, operation_id=\"retrieve_identity\")"
          ],
          "start_line": 87,
          "end_line": 93,
          "is_async": true
        },
        {
          "name": "create_identity",
          "signature": "def create_identity(\n    identity: IdentityCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: Optional[str] = Header(\n        None, alias=\"X-Project\", description=\"The project slug to associate with the identity (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "parameters": "(\n    identity: IdentityCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: Optional[str] = Header(\n        None, alias=\"X-Project\", description=\"The project slug to associate with the identity (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.post(\"/\", tags=[\"identities\"], response_model=Identity, operation_id=\"create_identity\")"
          ],
          "start_line": 97,
          "end_line": 106,
          "is_async": true
        },
        {
          "name": "upsert_identity",
          "signature": "def upsert_identity(\n    identity: IdentityUpsert = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: Optional[str] = Header(\n        None, alias=\"X-Project\", description=\"The project slug to associate with the identity (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "parameters": "(\n    identity: IdentityUpsert = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: Optional[str] = Header(\n        None, alias=\"X-Project\", description=\"The project slug to associate with the identity (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.put(\"/\", tags=[\"identities\"], response_model=Identity, operation_id=\"upsert_identity\")"
          ],
          "start_line": 110,
          "end_line": 119,
          "is_async": true
        },
        {
          "name": "modify_identity",
          "signature": "def modify_identity(\n    identity_id: IdentityId,\n    identity: IdentityUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    identity_id: IdentityId,\n    identity: IdentityUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.patch(\"/{identity_id}\", tags=[\"identities\"], response_model=Identity, operation_id=\"update_identity\")"
          ],
          "start_line": 123,
          "end_line": 130,
          "is_async": true
        },
        {
          "name": "upsert_properties_for_identity",
          "signature": "def upsert_properties_for_identity(\n    identity_id: IdentityId,\n    properties: List[IdentityProperty] = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    identity_id: IdentityId,\n    properties: List[IdentityProperty] = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.put(\"/{identity_id}/properties\", tags=[\"identities\"], operation_id=\"upsert_properties_for_identity\")"
          ],
          "start_line": 134,
          "end_line": 141,
          "is_async": true
        },
        {
          "name": "delete_identity",
          "signature": "def delete_identity(\n    identity_id: IdentityId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    identity_id: IdentityId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete an identity by its identifier key",
          "decorators": [
            "@router.delete(\"/{identity_id}\", tags=[\"identities\"], operation_id=\"delete_identity\")"
          ],
          "start_line": 145,
          "end_line": 154,
          "is_async": true
        },
        {
          "name": "list_agents_for_identity",
          "signature": "def list_agents_for_identity(\n    identity_id: IdentityId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come before this agent ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come after this agent ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of agents to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    include: List[AgentRelationships] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    identity_id: IdentityId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come before this agent ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come after this agent ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of agents to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    include: List[AgentRelationships] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get all agents associated with the specified identity.",
          "decorators": [
            "@router.get(\"/{identity_id}/agents\", response_model=List[AgentState], operation_id=\"list_agents_for_identity\")"
          ],
          "start_line": 158,
          "end_line": 192,
          "is_async": true
        },
        {
          "name": "list_blocks_for_identity",
          "signature": "def list_blocks_for_identity(\n    identity_id: IdentityId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come before this block ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come after this block ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of blocks to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for blocks by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    identity_id: IdentityId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come before this block ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come after this block ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of blocks to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for blocks by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get all blocks associated with the specified identity.",
          "decorators": [
            "@router.get(\"/{identity_id}/blocks\", response_model=List[BlockResponse], operation_id=\"list_blocks_for_identity\")"
          ],
          "start_line": 196,
          "end_line": 225,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138681
    },
    "letta/server/rest_api/routers/v1/internal_agents.py": {
      "path": "letta/server/rest_api/routers/v1/internal_agents.py",
      "contentHash": "63908212e2360a635ff9d24133c7617b",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "count_agents",
          "signature": "def count_agents(\n    exclude_hidden: bool = Query(True, description=\"If True, excludes hidden agents from the count. If False, includes all agents.\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    exclude_hidden: bool = Query(True, description=\"If True, excludes hidden agents from the count. If False, includes all agents.\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get the total number of agents for a user, with option to exclude hidden agents.",
          "decorators": [
            "@router.get(\"/count\", response_model=int, operation_id=\"count_internal_agents\")"
          ],
          "start_line": 12,
          "end_line": 30,
          "is_async": true
        },
        {
          "name": "modify_block_for_agent",
          "signature": "def modify_block_for_agent(\n    block_label: str,\n    agent_id: AgentId,\n    block_update: BlockUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_label: str,\n    agent_id: AgentId,\n    block_update: BlockUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Updates a core memory block of an agent.",
          "decorators": [
            "@router.patch(\"/{agent_id}/core-memory/blocks/{block_label}\", response_model=Block, operation_id=\"modify_internal_core_memory_block\")"
          ],
          "start_line": 34,
          "end_line": 53,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138681
    },
    "letta/server/rest_api/routers/v1/internal_blocks.py": {
      "path": "letta/server/rest_api/routers/v1/internal_blocks.py",
      "contentHash": "62d930da79901d14218eaa5a7ac32986",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "list_blocks",
          "signature": "def list_blocks(\n    # query parameters\n    label: BlockLabelQuery = None,\n    templates_only: bool = Query(False, description=\"Whether to include only templates\"),\n    name: BlockNameQuery = None,\n    identity_id: IdentityIdQuery = None,\n    identifier_keys: Optional[List[str]] = Query(None, description=\"Search agents by identifier keys\"),\n    project_id: Optional[str] = Query(None, description=\"Search blocks by project id\"),\n    limit: Optional[int] = Query(50, description=\"Number of blocks to return\"),\n    before: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come before this block ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come after this block ID in the specified sort order\",\n    ),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for blocks by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    label_search: BlockLabelSearchQuery = None,\n    description_search: BlockDescriptionSearchQuery = None,\n    value_search: BlockValueSearchQuery = None,\n    connected_to_agents_count_gt: Optional[int] = Query(\n        None,\n        description=(\n            \"Filter blocks by the number of connected agents. \"\n            \"If provided, returns blocks that have more than this number of connected agents.\"\n        ),\n    ),\n    connected_to_agents_count_lt: Optional[int] = Query(\n        None,\n        description=(\n            \"Filter blocks by the number of connected agents. \"\n            \"If provided, returns blocks that have less than this number of connected agents.\"\n        ),\n    ),\n    connected_to_agents_count_eq: Optional[List[int]] = Query(\n        None,\n        description=(\n            \"Filter blocks by the exact number of connected agents. \"\n            \"If provided, returns blocks that have exactly this number of connected agents.\"\n        ),\n    ),\n    show_hidden_blocks: bool | None = Query(\n        False,\n        include_in_schema=False,\n        description=\"If set to True, include blocks marked as hidden in the results.\",\n    ),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    # query parameters\n    label: BlockLabelQuery = None,\n    templates_only: bool = Query(False, description=\"Whether to include only templates\"),\n    name: BlockNameQuery = None,\n    identity_id: IdentityIdQuery = None,\n    identifier_keys: Optional[List[str]] = Query(None, description=\"Search agents by identifier keys\"),\n    project_id: Optional[str] = Query(None, description=\"Search blocks by project id\"),\n    limit: Optional[int] = Query(50, description=\"Number of blocks to return\"),\n    before: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come before this block ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Block ID cursor for pagination. Returns blocks that come after this block ID in the specified sort order\",\n    ),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for blocks by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    label_search: BlockLabelSearchQuery = None,\n    description_search: BlockDescriptionSearchQuery = None,\n    value_search: BlockValueSearchQuery = None,\n    connected_to_agents_count_gt: Optional[int] = Query(\n        None,\n        description=(\n            \"Filter blocks by the number of connected agents. \"\n            \"If provided, returns blocks that have more than this number of connected agents.\"\n        ),\n    ),\n    connected_to_agents_count_lt: Optional[int] = Query(\n        None,\n        description=(\n            \"Filter blocks by the number of connected agents. \"\n            \"If provided, returns blocks that have less than this number of connected agents.\"\n        ),\n    ),\n    connected_to_agents_count_eq: Optional[List[int]] = Query(\n        None,\n        description=(\n            \"Filter blocks by the exact number of connected agents. \"\n            \"If provided, returns blocks that have exactly this number of connected agents.\"\n        ),\n    ),\n    show_hidden_blocks: bool | None = Query(\n        False,\n        include_in_schema=False,\n        description=\"If set to True, include blocks marked as hidden in the results.\",\n    ),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.get(\"/\", response_model=List[Block], operation_id=\"list_internal_blocks\")"
          ],
          "start_line": 27,
          "end_line": 100,
          "is_async": true
        },
        {
          "name": "create_block",
          "signature": "def create_block(\n    create_block: CreateBlock = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    create_block: CreateBlock = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.post(\"/\", response_model=Block, operation_id=\"create_internal_block\")"
          ],
          "start_line": 104,
          "end_line": 111,
          "is_async": true
        },
        {
          "name": "delete_block",
          "signature": "def delete_block(\n    block_id: BlockId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_id: BlockId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.delete(\"/{block_id}\", operation_id=\"delete_internal_block\")"
          ],
          "start_line": 115,
          "end_line": 121,
          "is_async": true
        },
        {
          "name": "list_agents_for_block",
          "signature": "def list_agents_for_block(\n    block_id: BlockId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come before this agent ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come after this agent ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of agents to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    include_relationships: list[str] | None = Query(\n        None,\n        description=(\n            \"Specify which relational fields (e.g., 'tools', 'sources', 'memory') to include in the response. \"\n            \"If not provided, all relationships are loaded by default. \"\n            \"Using this can optimize performance by reducing unnecessary joins.\"\n            \"This is a legacy parameter, and no longer supported after 1.0.0 SDK versions.\"\n        ),\n        deprecated=True,\n    ),\n    include: List[str] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block_id: BlockId,\n    before: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come before this agent ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Agent ID cursor for pagination. Returns agents that come after this agent ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of agents to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for agents by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    include_relationships: list[str] | None = Query(\n        None,\n        description=(\n            \"Specify which relational fields (e.g., 'tools', 'sources', 'memory') to include in the response. \"\n            \"If not provided, all relationships are loaded by default. \"\n            \"Using this can optimize performance by reducing unnecessary joins.\"\n            \"This is a legacy parameter, and no longer supported after 1.0.0 SDK versions.\"\n        ),\n        deprecated=True,\n    ),\n    include: List[str] = Query(\n        [],\n        description=(\"Specify which relational fields to include in the response. No relationships are included by default.\"),\n    ),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieves all agents associated with the specified block.\n    Raises a 404 if the block does not exist.",
          "decorators": [
            "@router.get(\"/{block_id}/agents\", response_model=List[AgentState], operation_id=\"list_agents_for_internal_block\")"
          ],
          "start_line": 125,
          "end_line": 174,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138681
    },
    "letta/server/rest_api/routers/v1/internal_runs.py": {
      "path": "letta/server/rest_api/routers/v1/internal_runs.py",
      "contentHash": "ecc532266c48ef8bcb79724add36f5a3",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "convert_statuses_to_enum",
          "signature": "def convert_statuses_to_enum(statuses: Optional[List[str]]) -> Optional[List[RunStatus]]",
          "parameters": "(statuses: Optional[List[str]])",
          "return_type": "Optional[List[RunStatus]]",
          "docstring": "Convert a list of status strings to RunStatus enum values.\n\n    Args:\n        statuses: List of status strings or None\n\n    Returns:\n        List of RunStatus enum values or None if input is None",
          "decorators": [],
          "start_line": 16,
          "end_line": 27,
          "is_async": false
        },
        {
          "name": "list_runs",
          "signature": "def list_runs(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    agent_id: Optional[str] = Query(None, description=\"The unique identifier of the agent associated with the run.\"),\n    agent_ids: Optional[List[str]] = Query(\n        None,\n        description=\"The unique identifiers of the agents associated with the run. Deprecated in favor of agent_id field.\",\n        deprecated=True,\n    ),\n    statuses: Optional[List[str]] = Query(None, description=\"Filter runs by status. Can specify multiple statuses.\"),\n    background: Optional[bool] = Query(None, description=\"If True, filters for runs that were created in background mode.\"),\n    stop_reason: Optional[StopReasonType] = Query(None, description=\"Filter runs by stop reason.\"),\n    template_family: Optional[str] = Query(None, description=\"Filter runs by template family (base_template_id).\"),\n    step_count: Optional[int] = Query(None, description=\"Filter runs by step count. Must be provided with step_count_operator.\"),\n    step_count_operator: ComparisonOperator = Query(\n        ComparisonOperator.EQ,\n        description=\"Operator for step_count filter: 'eq' for equals, 'gte' for greater than or equal, 'lte' for less than or equal.\",\n    ),\n    tools_used: Optional[List[str]] = Query(None, description=\"Filter runs that used any of the specified tools.\"),\n    before: Optional[str] = Query(\n        None, description=\"Run ID cursor for pagination. Returns runs that come before this run ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Run ID cursor for pagination. Returns runs that come after this run ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of runs to return\", ge=1, le=1000),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for runs by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\", \"duration\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    active: bool = Query(False, description=\"Filter for active runs.\"),\n    ascending: bool = Query(\n        False,\n        description=\"Whether to sort agents oldest to newest (True) or newest to oldest (False, default). Deprecated in favor of order field.\",\n        deprecated=True,\n    ),\n    project_id: Optional[str] = Query(None, description=\"Filter runs by project ID.\"),\n    conversation_id: Optional[str] = Query(None, description=\"Filter runs by conversation ID.\"),\n    duration_percentile: Optional[int] = Query(\n        None, description=\"Filter runs by duration percentile (1-100). Returns runs slower than this percentile.\"\n    ),\n    duration_value: Optional[int] = Query(\n        None, description=\"Duration value in nanoseconds for filtering. Must be used with duration_operator.\"\n    ),\n    duration_operator: Optional[Literal[\"gt\", \"lt\", \"eq\"]] = Query(\n        None, description=\"Comparison operator for duration filter: 'gt' (greater than), 'lt' (less than), 'eq' (equals).\"\n    ),\n    start_date: Optional[datetime] = Query(None, description=\"Filter runs created on or after this date (ISO 8601 format).\"),\n    end_date: Optional[datetime] = Query(None, description=\"Filter runs created on or before this date (ISO 8601 format).\"),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    agent_id: Optional[str] = Query(None, description=\"The unique identifier of the agent associated with the run.\"),\n    agent_ids: Optional[List[str]] = Query(\n        None,\n        description=\"The unique identifiers of the agents associated with the run. Deprecated in favor of agent_id field.\",\n        deprecated=True,\n    ),\n    statuses: Optional[List[str]] = Query(None, description=\"Filter runs by status. Can specify multiple statuses.\"),\n    background: Optional[bool] = Query(None, description=\"If True, filters for runs that were created in background mode.\"),\n    stop_reason: Optional[StopReasonType] = Query(None, description=\"Filter runs by stop reason.\"),\n    template_family: Optional[str] = Query(None, description=\"Filter runs by template family (base_template_id).\"),\n    step_count: Optional[int] = Query(None, description=\"Filter runs by step count. Must be provided with step_count_operator.\"),\n    step_count_operator: ComparisonOperator = Query(\n        ComparisonOperator.EQ,\n        description=\"Operator for step_count filter: 'eq' for equals, 'gte' for greater than or equal, 'lte' for less than or equal.\",\n    ),\n    tools_used: Optional[List[str]] = Query(None, description=\"Filter runs that used any of the specified tools.\"),\n    before: Optional[str] = Query(\n        None, description=\"Run ID cursor for pagination. Returns runs that come before this run ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Run ID cursor for pagination. Returns runs that come after this run ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of runs to return\", ge=1, le=1000),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for runs by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\", \"duration\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    active: bool = Query(False, description=\"Filter for active runs.\"),\n    ascending: bool = Query(\n        False,\n        description=\"Whether to sort agents oldest to newest (True) or newest to oldest (False, default). Deprecated in favor of order field.\",\n        deprecated=True,\n    ),\n    project_id: Optional[str] = Query(None, description=\"Filter runs by project ID.\"),\n    conversation_id: Optional[str] = Query(None, description=\"Filter runs by conversation ID.\"),\n    duration_percentile: Optional[int] = Query(\n        None, description=\"Filter runs by duration percentile (1-100). Returns runs slower than this percentile.\"\n    ),\n    duration_value: Optional[int] = Query(\n        None, description=\"Duration value in nanoseconds for filtering. Must be used with duration_operator.\"\n    ),\n    duration_operator: Optional[Literal[\"gt\", \"lt\", \"eq\"]] = Query(\n        None, description=\"Comparison operator for duration filter: 'gt' (greater than), 'lt' (less than), 'eq' (equals).\"\n    ),\n    start_date: Optional[datetime] = Query(None, description=\"Filter runs created on or after this date (ISO 8601 format).\"),\n    end_date: Optional[datetime] = Query(None, description=\"Filter runs created on or before this date (ISO 8601 format).\"),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List all runs.",
          "decorators": [
            "@router.get(\"/\", response_model=List[Run], operation_id=\"list_internal_runs\")"
          ],
          "start_line": 31,
          "end_line": 133,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138681
    },
    "letta/server/rest_api/routers/v1/internal_templates.py": {
      "path": "letta/server/rest_api/routers/v1/internal_templates.py",
      "contentHash": "ed5f6808e10d11ba97dada917ccc98ef",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "create_group",
          "signature": "def create_group(\n    group: InternalTemplateGroupCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    group: InternalTemplateGroupCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create a new multi-agent group with the specified configuration.",
          "decorators": [
            "@router.post(\"/groups\", response_model=Group, operation_id=\"create_internal_template_group\")"
          ],
          "start_line": 16,
          "end_line": 25,
          "is_async": true
        },
        {
          "name": "create_agent",
          "signature": "def create_agent(\n    agent: InternalTemplateAgentCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent: InternalTemplateAgentCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create a new agent with template-related fields.",
          "decorators": [
            "@router.post(\"/agents\", response_model=AgentState, operation_id=\"create_internal_template_agent\")"
          ],
          "start_line": 29,
          "end_line": 39,
          "is_async": true
        },
        {
          "name": "create_block",
          "signature": "def create_block(\n    block: InternalTemplateBlockCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    block: InternalTemplateBlockCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create a new block with template-related fields.",
          "decorators": [
            "@router.post(\"/blocks\", response_model=Block, operation_id=\"create_internal_template_block\")"
          ],
          "start_line": 43,
          "end_line": 53,
          "is_async": true
        },
        {
          "name": "create_blocks_batch",
          "signature": "def create_blocks_batch(\n    blocks: List[InternalTemplateBlockCreate] = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    blocks: List[InternalTemplateBlockCreate] = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create multiple blocks with template-related fields.",
          "decorators": [
            "@router.post(\"/blocks/batch\", response_model=List[Block], operation_id=\"create_internal_template_blocks_batch\")"
          ],
          "start_line": 57,
          "end_line": 71,
          "is_async": true
        },
        {
          "name": "list_deployment_entities",
          "signature": "def list_deployment_entities(\n    deployment_id: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    entity_types: Optional[List[str]] = Query(None, description=\"Filter by entity types (block, agent, group)\"),\n)",
          "parameters": "(\n    deployment_id: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    entity_types: Optional[List[str]] = Query(None, description=\"Filter by entity types (block, agent, group)\"),\n)",
          "return_type": null,
          "docstring": "List all entities (blocks, agents, groups) with the specified deployment_id.\n    Optionally filter by entity types.",
          "decorators": [
            "@router.get(\"/deployment/{deployment_id}\", response_model=ListDeploymentEntitiesResponse, operation_id=\"list_deployment_entities\")"
          ],
          "start_line": 104,
          "end_line": 209,
          "is_async": true
        },
        {
          "name": "delete_deployment",
          "signature": "def delete_deployment(\n    deployment_id: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    deployment_id: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete all entities (blocks, agents, groups) with the specified deployment_id.\n    Deletion order: blocks -> agents -> groups to maintain referential integrity.",
          "decorators": [
            "@router.delete(\"/deployment/{deployment_id}\", response_model=DeleteDeploymentResponse, operation_id=\"delete_deployment\")"
          ],
          "start_line": 213,
          "end_line": 293,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138681
    },
    "letta/server/rest_api/routers/v1/jobs.py": {
      "path": "letta/server/rest_api/routers/v1/jobs.py",
      "contentHash": "6c721fe746643fde27d9d376bc06cd43",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "list_jobs",
          "signature": "def list_jobs(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    source_id: Optional[str] = Query(\n        None, description=\"Deprecated: Use `folder_id` parameter instead. Only list jobs associated with the source.\", deprecated=True\n    ),\n    before: Optional[str] = Query(\n        None, description=\"Job ID cursor for pagination. Returns jobs that come before this job ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Job ID cursor for pagination. Returns jobs that come after this job ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of jobs to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for jobs by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    active: bool = Query(False, description=\"Filter for active jobs.\"),\n    ascending: bool = Query(\n        True,\n        description=\"Whether to sort jobs oldest to newest (True, default) or newest to oldest (False). Deprecated in favor of order field.\",\n        deprecated=True,\n    ),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    source_id: Optional[str] = Query(\n        None, description=\"Deprecated: Use `folder_id` parameter instead. Only list jobs associated with the source.\", deprecated=True\n    ),\n    before: Optional[str] = Query(\n        None, description=\"Job ID cursor for pagination. Returns jobs that come before this job ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Job ID cursor for pagination. Returns jobs that come after this job ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of jobs to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for jobs by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    active: bool = Query(False, description=\"Filter for active jobs.\"),\n    ascending: bool = Query(\n        True,\n        description=\"Whether to sort jobs oldest to newest (True, default) or newest to oldest (False). Deprecated in favor of order field.\",\n        deprecated=True,\n    ),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List all jobs.",
          "decorators": [
            "@router.get(\"/\", response_model=List[Job], operation_id=\"list_jobs\")"
          ],
          "start_line": 17,
          "end_line": 64,
          "is_async": true
        },
        {
          "name": "list_active_jobs",
          "signature": "def list_active_jobs(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    source_id: Optional[str] = Query(\n        None, description=\"Deprecated: Use `folder_id` parameter instead. Only list jobs associated with the source.\", deprecated=True\n    ),\n    before: Optional[str] = Query(None, description=\"Cursor for pagination\"),\n    after: Optional[str] = Query(None, description=\"Cursor for pagination\"),\n    limit: Optional[int] = Query(50, description=\"Limit for pagination\"),\n    ascending: bool = Query(True, description=\"Whether to sort jobs oldest to newest (True, default) or newest to oldest (False)\"),\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    source_id: Optional[str] = Query(\n        None, description=\"Deprecated: Use `folder_id` parameter instead. Only list jobs associated with the source.\", deprecated=True\n    ),\n    before: Optional[str] = Query(None, description=\"Cursor for pagination\"),\n    after: Optional[str] = Query(None, description=\"Cursor for pagination\"),\n    limit: Optional[int] = Query(50, description=\"Limit for pagination\"),\n    ascending: bool = Query(True, description=\"Whether to sort jobs oldest to newest (True, default) or newest to oldest (False)\"),\n)",
          "return_type": null,
          "docstring": "List all active jobs.",
          "decorators": [
            "@router.get(\"/active\", response_model=List[Job], operation_id=\"list_active_jobs\", deprecated=True)"
          ],
          "start_line": 68,
          "end_line": 91,
          "is_async": true
        },
        {
          "name": "retrieve_job",
          "signature": "def retrieve_job(\n    job_id: JobId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    job_id: JobId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Get the status of a job.",
          "decorators": [
            "@router.get(\"/{job_id}\", response_model=Job, operation_id=\"retrieve_job\")"
          ],
          "start_line": 95,
          "end_line": 104,
          "is_async": true
        },
        {
          "name": "cancel_job",
          "signature": "def cancel_job(\n    job_id: JobId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    job_id: JobId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Cancel a job by its job_id.\n\n    This endpoint marks a job as cancelled, which will cause any associated\n    agent execution to terminate as soon as possible.",
          "decorators": [
            "@router.patch(\"/{job_id}/cancel\", response_model=Job, operation_id=\"cancel_job\")"
          ],
          "start_line": 108,
          "end_line": 129,
          "is_async": true
        },
        {
          "name": "delete_job",
          "signature": "def delete_job(\n    job_id: JobId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    job_id: JobId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Delete a job by its job_id.",
          "decorators": [
            "@router.delete(\"/{job_id}\", response_model=Job, operation_id=\"delete_job\")"
          ],
          "start_line": 133,
          "end_line": 142,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138682
    },
    "letta/server/rest_api/routers/v1/llms.py": {
      "path": "letta/server/rest_api/routers/v1/llms.py",
      "contentHash": "428501ef17daf4028625d6c88e8eb321",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "list_llm_models",
          "signature": "def list_llm_models(\n    provider_category: Optional[List[ProviderCategory]] = Query(None),\n    provider_name: Optional[str] = Query(None),\n    provider_type: Optional[ProviderType] = Query(None),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    provider_category: Optional[List[ProviderCategory]] = Query(None),\n    provider_name: Optional[str] = Query(None),\n    provider_type: Optional[ProviderType] = Query(None),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List available LLM models using the asynchronous implementation for improved performance.\n\n    Returns Model format which extends LLMConfig with additional metadata fields.\n    Legacy LLMConfig fields are marked as deprecated but still available for backward compatibility.",
          "decorators": [
            "@router.get(\"/\", response_model=List[Model], operation_id=\"list_models\")"
          ],
          "start_line": 16,
          "end_line": 39,
          "is_async": true
        },
        {
          "name": "list_embedding_models",
          "signature": "def list_embedding_models(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List available embedding models using the asynchronous implementation for improved performance.\n\n    Returns EmbeddingModel format which extends EmbeddingConfig with additional metadata fields.\n    Legacy EmbeddingConfig fields are marked as deprecated but still available for backward compatibility.",
          "decorators": [
            "@router.get(\"/embedding\", response_model=List[EmbeddingModel], operation_id=\"list_embedding_models\")"
          ],
          "start_line": 43,
          "end_line": 57,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138682
    },
    "letta/server/rest_api/routers/v1/mcp_servers.py": {
      "path": "letta/server/rest_api/routers/v1/mcp_servers.py",
      "contentHash": "e994be4bcf8c752634bebceed16ee6b6",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "create_mcp_server",
          "signature": "def create_mcp_server(\n    request: CreateMCPServerRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: CreateMCPServerRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Add a new MCP server to the Letta MCP server config",
          "decorators": [
            "@router.post(\n    \"/\",\n    response_model=MCPServerUnion,\n    operation_id=\"mcp_create_mcp_server\",\n)"
          ],
          "start_line": 42,
          "end_line": 53,
          "is_async": true
        },
        {
          "name": "list_mcp_servers",
          "signature": "def list_mcp_servers(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a list of all configured MCP servers",
          "decorators": [
            "@router.get(\n    \"/\",\n    response_model=List[MCPServerUnion],\n    operation_id=\"mcp_list_mcp_servers\",\n)"
          ],
          "start_line": 61,
          "end_line": 73,
          "is_async": true
        },
        {
          "name": "retrieve_mcp_server",
          "signature": "def retrieve_mcp_server(\n    mcp_server_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    mcp_server_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a specific MCP server",
          "decorators": [
            "@router.get(\n    \"/{mcp_server_id}\",\n    response_model=MCPServerUnion,\n    operation_id=\"mcp_retrieve_mcp_server\",\n)"
          ],
          "start_line": 81,
          "end_line": 91,
          "is_async": true
        },
        {
          "name": "delete_mcp_server",
          "signature": "def delete_mcp_server(\n    mcp_server_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    mcp_server_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete an MCP server by its ID",
          "decorators": [
            "@router.delete(\n    \"/{mcp_server_id}\",\n    status_code=204,\n    operation_id=\"mcp_delete_mcp_server\",\n)"
          ],
          "start_line": 99,
          "end_line": 108,
          "is_async": true
        },
        {
          "name": "update_mcp_server",
          "signature": "def update_mcp_server(\n    mcp_server_id: str,\n    request: UpdateMCPServerRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    mcp_server_id: str,\n    request: UpdateMCPServerRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Update an existing MCP server configuration",
          "decorators": [
            "@router.patch(\n    \"/{mcp_server_id}\",\n    response_model=MCPServerUnion,\n    operation_id=\"mcp_update_mcp_server\",\n)"
          ],
          "start_line": 116,
          "end_line": 131,
          "is_async": true
        },
        {
          "name": "list_tools_for_mcp_server",
          "signature": "def list_tools_for_mcp_server(\n    mcp_server_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    mcp_server_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a list of all tools for a specific MCP server",
          "decorators": [
            "@router.get(\"/{mcp_server_id}/tools\", response_model=List[Tool], operation_id=\"mcp_list_tools_for_mcp_server\")"
          ],
          "start_line": 135,
          "end_line": 146,
          "is_async": true
        },
        {
          "name": "retrieve_mcp_tool",
          "signature": "def retrieve_mcp_tool(\n    mcp_server_id: str,\n    tool_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    mcp_server_id: str,\n    tool_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a specific MCP tool by its ID",
          "decorators": [
            "@router.get(\"/{mcp_server_id}/tools/{tool_id}\", response_model=Tool, operation_id=\"mcp_retrieve_mcp_tool\")"
          ],
          "start_line": 150,
          "end_line": 161,
          "is_async": true
        },
        {
          "name": "run_mcp_tool",
          "signature": "def run_mcp_tool(\n    mcp_server_id: str,\n    tool_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    request: ToolExecuteRequest = Body(default=ToolExecuteRequest()),\n)",
          "parameters": "(\n    mcp_server_id: str,\n    tool_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    request: ToolExecuteRequest = Body(default=ToolExecuteRequest()),\n)",
          "return_type": null,
          "docstring": "Execute a specific MCP tool\n\n    The request body should contain the tool arguments in the ToolExecuteRequest format.",
          "decorators": [
            "@router.post(\"/{mcp_server_id}/tools/{tool_id}/run\", response_model=ToolExecutionResult, operation_id=\"mcp_run_tool\")"
          ],
          "start_line": 165,
          "end_line": 192,
          "is_async": true
        },
        {
          "name": "refresh_mcp_server_tools",
          "signature": "def refresh_mcp_server_tools(\n    mcp_server_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    agent_id: Optional[str] = None,\n)",
          "parameters": "(\n    mcp_server_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    agent_id: Optional[str] = None,\n)",
          "return_type": null,
          "docstring": "Refresh tools for an MCP server by:\n    1. Fetching current tools from the MCP server\n    2. Deleting tools that no longer exist on the server\n    3. Updating schemas for existing tools\n    4. Adding new tools from the server\n\n    Returns a summary of changes made.",
          "decorators": [
            "@router.patch(\"/{mcp_server_id}/refresh\", operation_id=\"mcp_refresh_mcp_server_tools\")"
          ],
          "start_line": 196,
          "end_line": 213,
          "is_async": true
        },
        {
          "name": "connect_mcp_server",
          "signature": "def connect_mcp_server(\n    mcp_server_id: str,\n    request: Request,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n) -> StreamingResponse",
          "parameters": "(\n    mcp_server_id: str,\n    request: Request,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": "StreamingResponse",
          "docstring": "Connect to an MCP server with support for OAuth via SSE.\n    Returns a stream of events handling authorization state and exchange if OAuth is required.",
          "decorators": [
            "@router.get(\n    \"/connect/{mcp_server_id}\",\n    response_model=None,\n    # TODO: make this into a model?\n    responses={\n        200: {\n            \"description\": \"Successful response\",\n            \"content\": {\n                \"text/event-stream\": {\"description\": \"Server-Sent Events stream\"},\n            },\n        }\n    },\n    operation_id=\"mcp_connect_mcp_server\",\n)"
          ],
          "start_line": 230,
          "end_line": 312,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138682
    },
    "letta/server/rest_api/routers/v1/messages.py": {
      "path": "letta/server/rest_api/routers/v1/messages.py",
      "contentHash": "ac90b1e377964dc09d097c8bd2a2caea",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "list_all_messages",
          "signature": "def list_all_messages(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    conversation_id: Optional[str] = Query(None, description=\"Conversation ID to filter messages by\"),\n)",
          "parameters": "(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    conversation_id: Optional[str] = Query(None, description=\"Conversation ID to filter messages by\"),\n)",
          "return_type": null,
          "docstring": "List messages across all agents for the current user.",
          "decorators": [
            "@router.get(\"/\", response_model=MessagesResponse, operation_id=\"list_all_messages\")"
          ],
          "start_line": 30,
          "end_line": 57,
          "is_async": true
        },
        {
          "name": "search_all_messages",
          "signature": "def search_all_messages(\n    request: SearchAllMessagesRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: SearchAllMessagesRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Search messages across the organization with optional agent filtering.\n    Returns messages with FTS/vector ranks and total RRF score.\n\n    This is a cloud-only feature.",
          "decorators": [
            "@router.post(\"/search\", response_model=List[LettaMessageSearchResult], operation_id=\"search_all_messages\")"
          ],
          "start_line": 61,
          "end_line": 84,
          "is_async": true
        },
        {
          "name": "create_batch",
          "signature": "def create_batch(\n    request: Request,\n    payload: CreateBatch = Body(..., description=\"Messages and config for all agents\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: Request,\n    payload: CreateBatch = Body(..., description=\"Messages and config for all agents\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Submit a batch of agent runs for asynchronous processing.\n\n    Creates a job that will fan out messages to all listed agents and process them in parallel.\n    The request will be rejected if it exceeds 256MB.",
          "decorators": [
            "@router.post(\n    \"/batches\",\n    response_model=BatchJob,\n    operation_id=\"create_batch\",\n)"
          ],
          "start_line": 92,
          "end_line": 150,
          "is_async": true
        },
        {
          "name": "retrieve_batch",
          "signature": "def retrieve_batch(\n    batch_id: str,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    batch_id: str,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Retrieve the status and details of a batch run.",
          "decorators": [
            "@router.get(\"/batches/{batch_id}\", response_model=BatchJob, operation_id=\"retrieve_batch\")"
          ],
          "start_line": 154,
          "end_line": 164,
          "is_async": true
        },
        {
          "name": "list_batches",
          "signature": "def list_batches(\n    before: Optional[str] = Query(\n        None, description=\"Job ID cursor for pagination. Returns jobs that come before this job ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Job ID cursor for pagination. Returns jobs that come after this job ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of jobs to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for jobs by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    before: Optional[str] = Query(\n        None, description=\"Job ID cursor for pagination. Returns jobs that come before this job ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Job ID cursor for pagination. Returns jobs that come after this job ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of jobs to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for jobs by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "List all batch runs.",
          "decorators": [
            "@router.get(\"/batches\", response_model=List[BatchJob], operation_id=\"list_batches\")"
          ],
          "start_line": 168,
          "end_line": 197,
          "is_async": true
        },
        {
          "name": "list_messages_for_batch",
          "signature": "def list_messages_for_batch(\n    batch_id: str,\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    agent_id: Optional[str] = Query(None, description=\"Filter messages by agent ID\"),\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "parameters": "(\n    batch_id: str,\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    agent_id: Optional[str] = Query(None, description=\"Filter messages by agent ID\"),\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Get response messages for a specific batch job.",
          "decorators": [
            "@router.get(\n    \"/batches/{batch_id}/messages\",\n    response_model=LettaBatchMessages,\n    operation_id=\"list_messages_for_batch\",\n)"
          ],
          "start_line": 205,
          "end_line": 236,
          "is_async": true
        },
        {
          "name": "cancel_batch",
          "signature": "def cancel_batch(\n    batch_id: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    batch_id: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Cancel a batch run.",
          "decorators": [
            "@router.patch(\"/batches/{batch_id}/cancel\", operation_id=\"cancel_batch\")"
          ],
          "start_line": 240,
          "end_line": 266,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138682
    },
    "letta/server/rest_api/routers/v1/organizations.py": {
      "path": "letta/server/rest_api/routers/v1/organizations.py",
      "contentHash": "21eaff4403194d97f099b0ea7c4165a1",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "get_all_orgs",
          "signature": "def get_all_orgs(\n    after: Optional[str] = Query(None),\n    limit: Optional[int] = Query(50),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    after: Optional[str] = Query(None),\n    limit: Optional[int] = Query(50),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Get a list of all orgs in the database",
          "decorators": [
            "@router.get(\"/\", tags=[\"admin\"], response_model=List[Organization], operation_id=\"list_orgs\")"
          ],
          "start_line": 16,
          "end_line": 24,
          "is_async": true
        },
        {
          "name": "create_org",
          "signature": "def create_org(\n    request: OrganizationCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    request: OrganizationCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Create a new org in the database",
          "decorators": [
            "@router.post(\"/\", tags=[\"admin\"], response_model=Organization, operation_id=\"create_organization\")"
          ],
          "start_line": 28,
          "end_line": 37,
          "is_async": true
        },
        {
          "name": "delete_org",
          "signature": "def delete_org(\n    org_id: str = Query(..., description=\"The org_id key to be deleted.\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    org_id: str = Query(..., description=\"The org_id key to be deleted.\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.delete(\"/\", tags=[\"admin\"], response_model=Organization, operation_id=\"delete_organization_by_id\")"
          ],
          "start_line": 41,
          "end_line": 49,
          "is_async": true
        },
        {
          "name": "update_org",
          "signature": "def update_org(\n    org_id: str = Query(..., description=\"The org_id key to be updated.\"),\n    request: OrganizationUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    org_id: str = Query(..., description=\"The org_id key to be updated.\"),\n    request: OrganizationUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.patch(\"/\", tags=[\"admin\"], response_model=Organization, operation_id=\"update_organization\")"
          ],
          "start_line": 53,
          "end_line": 58,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138682
    },
    "letta/server/rest_api/routers/v1/passages.py": {
      "path": "letta/server/rest_api/routers/v1/passages.py",
      "contentHash": "1a1b5c5d0dcb6e1c1a5e6367e8ba75f6",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "search_passages",
          "signature": "def search_passages(\n    request: PassageSearchRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: PassageSearchRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Search passages across the organization with optional agent and archive filtering.\n    Returns passages with relevance scores.\n\n    This endpoint supports semantic search through passages:\n    - If neither agent_id nor archive_id is provided, searches ALL passages in the organization\n    - If agent_id is provided, searches passages across all archives attached to that agent\n    - If archive_id is provided, searches passages within that specific archive\n    - If both are provided, agent_id takes precedence",
          "decorators": [
            "@router.post(\"/search\", response_model=List[PassageSearchResult], operation_id=\"search_passages\")"
          ],
          "start_line": 39,
          "end_line": 108,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138682
    },
    "letta/server/rest_api/routers/v1/providers.py": {
      "path": "letta/server/rest_api/routers/v1/providers.py",
      "contentHash": "aa631ffa766e4f4755f5a9ae5872f23b",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "list_providers",
          "signature": "def list_providers(\n    before: Optional[str] = Query(\n        None,\n        description=\"Provider ID cursor for pagination. Returns providers that come before this provider ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Provider ID cursor for pagination. Returns providers that come after this provider ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of providers to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for providers by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    name: Optional[str] = Query(None, description=\"Filter providers by name\"),\n    provider_type: Optional[ProviderType] = Query(None, description=\"Filter providers by type\"),\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    before: Optional[str] = Query(\n        None,\n        description=\"Provider ID cursor for pagination. Returns providers that come before this provider ID in the specified sort order\",\n    ),\n    after: Optional[str] = Query(\n        None,\n        description=\"Provider ID cursor for pagination. Returns providers that come after this provider ID in the specified sort order\",\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of providers to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for providers by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    name: Optional[str] = Query(None, description=\"Filter providers by name\"),\n    provider_type: Optional[ProviderType] = Query(None, description=\"Filter providers by type\"),\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Get a list of all custom providers.",
          "decorators": [
            "@router.get(\"/\", response_model=List[Provider], operation_id=\"list_providers\")"
          ],
          "start_line": 18,
          "end_line": 51,
          "is_async": true
        },
        {
          "name": "retrieve_provider",
          "signature": "def retrieve_provider(\n    provider_id: ProviderId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    provider_id: ProviderId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Get a provider by ID.",
          "decorators": [
            "@router.get(\"/{provider_id}\", response_model=Provider, operation_id=\"retrieve_provider\")"
          ],
          "start_line": 55,
          "end_line": 64,
          "is_async": true
        },
        {
          "name": "create_provider",
          "signature": "def create_provider(\n    request: ProviderCreate = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    request: ProviderCreate = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Create a new custom provider.",
          "decorators": [
            "@router.post(\"/\", response_model=Provider, operation_id=\"create_provider\")"
          ],
          "start_line": 68,
          "end_line": 85,
          "is_async": true
        },
        {
          "name": "modify_provider",
          "signature": "def modify_provider(\n    provider_id: ProviderId,\n    request: ProviderUpdate = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    provider_id: ProviderId,\n    request: ProviderUpdate = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Update an existing custom provider.",
          "decorators": [
            "@router.patch(\"/{provider_id}\", response_model=Provider, operation_id=\"modify_provider\")"
          ],
          "start_line": 89,
          "end_line": 99,
          "is_async": true
        },
        {
          "name": "check_provider",
          "signature": "def check_provider(\n    request: ProviderCheck = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    request: ProviderCheck = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Verify the API key and additional parameters for a provider.",
          "decorators": [
            "@router.post(\"/check\", response_model=None, operation_id=\"check_provider\")"
          ],
          "start_line": 103,
          "end_line": 116,
          "is_async": true
        },
        {
          "name": "check_existing_provider",
          "signature": "def check_existing_provider(\n    provider_id: ProviderId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    provider_id: ProviderId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Verify the API key and additional parameters for an existing provider.",
          "decorators": [
            "@router.post(\"/{provider_id}/check\", response_model=None, operation_id=\"check_existing_provider\")"
          ],
          "start_line": 120,
          "end_line": 144,
          "is_async": true
        },
        {
          "name": "delete_provider",
          "signature": "def delete_provider(\n    provider_id: ProviderId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    provider_id: ProviderId,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Delete an existing custom provider.",
          "decorators": [
            "@router.delete(\"/{provider_id}\", response_model=None, operation_id=\"delete_provider\")"
          ],
          "start_line": 148,
          "end_line": 158,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138682
    },
    "letta/server/rest_api/routers/v1/runs.py": {
      "path": "letta/server/rest_api/routers/v1/runs.py",
      "contentHash": "68d819ef940248b14270b9d3adbdf84b",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "convert_statuses_to_enum",
          "signature": "def convert_statuses_to_enum(statuses: Optional[List[str]]) -> Optional[List[RunStatus]]",
          "parameters": "(statuses: Optional[List[str]])",
          "return_type": "Optional[List[RunStatus]]",
          "docstring": "Convert a list of status strings to RunStatus enum values.\n\n    Args:\n        statuses: List of status strings or None\n\n    Returns:\n        List of RunStatus enum values or None if input is None",
          "decorators": [],
          "start_line": 32,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "list_runs",
          "signature": "def list_runs(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    agent_id: Optional[str] = Query(None, description=\"The unique identifier of the agent associated with the run.\"),\n    agent_ids: Optional[List[str]] = Query(\n        None,\n        description=\"The unique identifiers of the agents associated with the run. Deprecated in favor of agent_id field.\",\n        deprecated=True,\n    ),\n    statuses: Optional[List[str]] = Query(None, description=\"Filter runs by status. Can specify multiple statuses.\"),\n    background: Optional[bool] = Query(None, description=\"If True, filters for runs that were created in background mode.\"),\n    stop_reason: Optional[StopReasonType] = Query(None, description=\"Filter runs by stop reason.\"),\n    conversation_id: Optional[str] = Query(None, description=\"Filter runs by conversation ID.\"),\n    before: Optional[str] = Query(\n        None, description=\"Run ID cursor for pagination. Returns runs that come before this run ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Run ID cursor for pagination. Returns runs that come after this run ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of runs to return\", ge=1, le=1000),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for runs by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    active: bool = Query(False, description=\"Filter for active runs.\"),\n    ascending: bool = Query(\n        False,\n        description=\"Whether to sort agents oldest to newest (True) or newest to oldest (False, default). Deprecated in favor of order field.\",\n        deprecated=True,\n    ),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    agent_id: Optional[str] = Query(None, description=\"The unique identifier of the agent associated with the run.\"),\n    agent_ids: Optional[List[str]] = Query(\n        None,\n        description=\"The unique identifiers of the agents associated with the run. Deprecated in favor of agent_id field.\",\n        deprecated=True,\n    ),\n    statuses: Optional[List[str]] = Query(None, description=\"Filter runs by status. Can specify multiple statuses.\"),\n    background: Optional[bool] = Query(None, description=\"If True, filters for runs that were created in background mode.\"),\n    stop_reason: Optional[StopReasonType] = Query(None, description=\"Filter runs by stop reason.\"),\n    conversation_id: Optional[str] = Query(None, description=\"Filter runs by conversation ID.\"),\n    before: Optional[str] = Query(\n        None, description=\"Run ID cursor for pagination. Returns runs that come before this run ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Run ID cursor for pagination. Returns runs that come after this run ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of runs to return\", ge=1, le=1000),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for runs by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    active: bool = Query(False, description=\"Filter for active runs.\"),\n    ascending: bool = Query(\n        False,\n        description=\"Whether to sort agents oldest to newest (True) or newest to oldest (False, default). Deprecated in favor of order field.\",\n        deprecated=True,\n    ),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List all runs.",
          "decorators": [
            "@router.get(\"/\", response_model=List[Run], operation_id=\"list_runs\")"
          ],
          "start_line": 47,
          "end_line": 115,
          "is_async": true
        },
        {
          "name": "list_active_runs",
          "signature": "def list_active_runs(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    agent_id: Optional[str] = Query(None, description=\"The unique identifier of the agent associated with the run.\"),\n    background: Optional[bool] = Query(None, description=\"If True, filters for runs that were created in background mode.\"),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    agent_id: Optional[str] = Query(None, description=\"The unique identifier of the agent associated with the run.\"),\n    background: Optional[bool] = Query(None, description=\"If True, filters for runs that were created in background mode.\"),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List all active runs.",
          "decorators": [
            "@router.get(\"/active\", response_model=List[Run], operation_id=\"list_active_runs\", deprecated=True)"
          ],
          "start_line": 119,
          "end_line": 140,
          "is_async": true
        },
        {
          "name": "retrieve_run",
          "signature": "def retrieve_run(\n    run_id: str,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    run_id: str,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Get the status of a run.",
          "decorators": [
            "@router.get(\"/{run_id}\", response_model=Run, operation_id=\"retrieve_run\")"
          ],
          "start_line": 144,
          "end_line": 154,
          "is_async": true
        },
        {
          "name": "list_messages_for_run",
          "signature": "def list_messages_for_run(\n    run_id: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "parameters": "(\n    run_id: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "return_type": null,
          "docstring": "Get response messages associated with a run.",
          "decorators": [
            "@router.get(\n    \"/{run_id}/messages\",\n    response_model=RunMessagesResponse,\n    operation_id=\"list_messages_for_run\",\n)"
          ],
          "start_line": 167,
          "end_line": 185,
          "is_async": true
        },
        {
          "name": "retrieve_usage_for_run",
          "signature": "def retrieve_usage_for_run(\n    run_id: str,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    run_id: str,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Get usage statistics for a run.",
          "decorators": [
            "@router.get(\"/{run_id}/usage\", response_model=UsageStatistics, operation_id=\"retrieve_usage_for_run\")"
          ],
          "start_line": 189,
          "end_line": 200,
          "is_async": true
        },
        {
          "name": "retrieve_metrics_for_run",
          "signature": "def retrieve_metrics_for_run(\n    run_id: str,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    run_id: str,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Get run metrics by run ID.",
          "decorators": [
            "@router.get(\"/{run_id}/metrics\", response_model=RunMetrics, operation_id=\"retrieve_metrics_for_run\")"
          ],
          "start_line": 204,
          "end_line": 214,
          "is_async": true
        },
        {
          "name": "list_steps_for_run",
          "signature": "def list_steps_for_run(\n    run_id: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(None, description=\"Cursor for pagination\"),\n    after: Optional[str] = Query(None, description=\"Cursor for pagination\"),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for steps by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "parameters": "(\n    run_id: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    before: Optional[str] = Query(None, description=\"Cursor for pagination\"),\n    after: Optional[str] = Query(None, description=\"Cursor for pagination\"),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for steps by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n)",
          "return_type": null,
          "docstring": "Get steps associated with a run with filtering options.",
          "decorators": [
            "@router.get(\n    \"/{run_id}/steps\",\n    response_model=List[Step],\n    operation_id=\"list_steps_for_run\",\n)"
          ],
          "start_line": 222,
          "end_line": 247,
          "is_async": true
        },
        {
          "name": "delete_run",
          "signature": "def delete_run(\n    run_id: str,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    run_id: str,\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Delete a run by its run_id.",
          "decorators": [
            "@router.delete(\"/{run_id}\", response_model=None, operation_id=\"delete_run\")"
          ],
          "start_line": 251,
          "end_line": 261,
          "is_async": true
        },
        {
          "name": "retrieve_stream_for_run",
          "signature": "def retrieve_stream_for_run(\n    run_id: str,\n    request: RetrieveStreamRequest = Body(None),\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    run_id: str,\n    request: RetrieveStreamRequest = Body(None),\n    headers: HeaderParams = Depends(get_headers),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.post(\n    \"/{run_id}/stream\",\n    response_model=None,\n    operation_id=\"retrieve_stream_for_run\",\n    responses={\n        200: {\n            \"description\": \"Successful response\",\n            \"content\": {\n                # Align streaming schema with agents.create_stream so SDKs accept approval messages\n                \"text/event-stream\": {\n                    \"description\": \"Server-Sent Events stream\",\n                    \"schema\": {\n                        \"oneOf\": [\n                            {\"$ref\": \"#/components/schemas/SystemMessage\"},\n                            {\"$ref\": \"#/components/schemas/UserMessage\"},\n                            {\"$ref\": \"#/components/schemas/ReasoningMessage\"},\n                            {\"$ref\": \"#/components/schemas/HiddenReasoningMessage\"},\n                            {\"$ref\": \"#/components/schemas/ToolCallMessage\"},\n                            {\"$ref\": \"#/components/schemas/ToolReturnMessage\"},\n                            {\"$ref\": \"#/components/schemas/AssistantMessage\"},\n                            {\"$ref\": \"#/components/schemas/ApprovalRequestMessage\"},\n                            {\"$ref\": \"#/components/schemas/ApprovalResponseMessage\"},\n                            {\"$ref\": \"#/components/schemas/LettaPing\"},\n                            {\"$ref\": \"#/components/schemas/LettaErrorMessage\"},\n                            {\"$ref\": \"#/components/schemas/LettaStopReason\"},\n                            {\"$ref\": \"#/components/schemas/LettaUsageStatistics\"},\n                        ]\n                    },\n                },\n            },\n        }\n    },\n)"
          ],
          "start_line": 297,
          "end_line": 348,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138682
    },
    "letta/server/rest_api/routers/v1/sandbox_configs.py": {
      "path": "letta/server/rest_api/routers/v1/sandbox_configs.py",
      "contentHash": "b38b8a36b17d66a9d894e7c539b8ce35",
      "mtime": 1767315072060.5452,
      "functions": [
        {
          "name": "create_sandbox_config",
          "signature": "def create_sandbox_config(\n    config_create: SandboxConfigCreate,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    config_create: SandboxConfigCreate,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.post(\"/\", response_model=PydanticSandboxConfig)"
          ],
          "start_line": 35,
          "end_line": 42,
          "is_async": true
        },
        {
          "name": "create_default_e2b_sandbox_config",
          "signature": "def create_default_e2b_sandbox_config(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.post(\"/e2b/default\", response_model=PydanticSandboxConfig)"
          ],
          "start_line": 46,
          "end_line": 51,
          "is_async": true
        },
        {
          "name": "create_default_local_sandbox_config",
          "signature": "def create_default_local_sandbox_config(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.post(\"/local/default\", response_model=PydanticSandboxConfig)"
          ],
          "start_line": 55,
          "end_line": 60,
          "is_async": true
        },
        {
          "name": "create_custom_local_sandbox_config",
          "signature": "def create_custom_local_sandbox_config(\n    local_sandbox_config: LocalSandboxConfig,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    local_sandbox_config: LocalSandboxConfig,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create or update a custom LocalSandboxConfig, including pip_requirements.",
          "decorators": [
            "@router.post(\"/local\", response_model=PydanticSandboxConfig)"
          ],
          "start_line": 64,
          "end_line": 87,
          "is_async": true
        },
        {
          "name": "update_sandbox_config",
          "signature": "def update_sandbox_config(\n    config_update: SandboxConfigUpdate,\n    sandbox_config_id: SandboxConfigId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    config_update: SandboxConfigUpdate,\n    sandbox_config_id: SandboxConfigId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.patch(\"/{sandbox_config_id}\", response_model=PydanticSandboxConfig)"
          ],
          "start_line": 91,
          "end_line": 98,
          "is_async": true
        },
        {
          "name": "delete_sandbox_config",
          "signature": "def delete_sandbox_config(\n    sandbox_config_id: SandboxConfigId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    sandbox_config_id: SandboxConfigId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.delete(\"/{sandbox_config_id}\", status_code=204)"
          ],
          "start_line": 102,
          "end_line": 108,
          "is_async": true
        },
        {
          "name": "list_sandbox_configs",
          "signature": "def list_sandbox_configs(\n    limit: int = Query(1000, description=\"Number of results to return\"),\n    after: Optional[str] = Query(None, description=\"Pagination cursor to fetch the next set of results\"),\n    sandbox_type: Optional[SandboxType] = Query(None, description=\"Filter for this specific sandbox type\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    limit: int = Query(1000, description=\"Number of results to return\"),\n    after: Optional[str] = Query(None, description=\"Pagination cursor to fetch the next set of results\"),\n    sandbox_type: Optional[SandboxType] = Query(None, description=\"Filter for this specific sandbox type\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.get(\"/\", response_model=List[PydanticSandboxConfig])"
          ],
          "start_line": 112,
          "end_line": 120,
          "is_async": true
        },
        {
          "name": "force_recreate_local_sandbox_venv",
          "signature": "def force_recreate_local_sandbox_venv(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Forcefully recreate the virtual environment for the local sandbox.\n    Deletes and recreates the venv, then reinstalls required dependencies.",
          "decorators": [
            "@router.post(\"/local/recreate-venv\", response_model=PydanticSandboxConfig)"
          ],
          "start_line": 124,
          "end_line": 154,
          "is_async": true
        },
        {
          "name": "create_sandbox_env_var",
          "signature": "def create_sandbox_env_var(\n    env_var_create: SandboxEnvironmentVariableCreate,\n    sandbox_config_id: SandboxConfigId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    env_var_create: SandboxEnvironmentVariableCreate,\n    sandbox_config_id: SandboxConfigId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.post(\"/{sandbox_config_id}/environment-variable\", response_model=PydanticEnvVar)"
          ],
          "start_line": 161,
          "end_line": 168,
          "is_async": true
        },
        {
          "name": "update_sandbox_env_var",
          "signature": "def update_sandbox_env_var(\n    env_var_id: str,\n    env_var_update: SandboxEnvironmentVariableUpdate,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    env_var_id: str,\n    env_var_update: SandboxEnvironmentVariableUpdate,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.patch(\"/environment-variable/{env_var_id}\", response_model=PydanticEnvVar)"
          ],
          "start_line": 172,
          "end_line": 179,
          "is_async": true
        },
        {
          "name": "delete_sandbox_env_var",
          "signature": "def delete_sandbox_env_var(\n    env_var_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    env_var_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.delete(\"/environment-variable/{env_var_id}\", status_code=204)"
          ],
          "start_line": 183,
          "end_line": 189,
          "is_async": true
        },
        {
          "name": "list_sandbox_env_vars",
          "signature": "def list_sandbox_env_vars(\n    sandbox_config_id: SandboxConfigId,\n    limit: int = Query(1000, description=\"Number of results to return\"),\n    after: Optional[str] = Query(None, description=\"Pagination cursor to fetch the next set of results\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    sandbox_config_id: SandboxConfigId,\n    limit: int = Query(1000, description=\"Number of results to return\"),\n    after: Optional[str] = Query(None, description=\"Pagination cursor to fetch the next set of results\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.get(\"/{sandbox_config_id}/environment-variable\", response_model=List[PydanticEnvVar])"
          ],
          "start_line": 193,
          "end_line": 201,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138682
    },
    "letta/server/rest_api/routers/v1/sources.py": {
      "path": "letta/server/rest_api/routers/v1/sources.py",
      "contentHash": "97f285996c9676064aa5a6a0d3de5bbc",
      "mtime": 1768610518526.2,
      "functions": [
        {
          "name": "count_sources",
          "signature": "def count_sources(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Count all data sources created by a user.",
          "decorators": [
            "@router.get(\"/count\", response_model=int, operation_id=\"count_sources\", deprecated=True)"
          ],
          "start_line": 51,
          "end_line": 59,
          "is_async": true
        },
        {
          "name": "retrieve_source",
          "signature": "def retrieve_source(\n    source_id: SourceId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source_id: SourceId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get all sources",
          "decorators": [
            "@router.get(\"/{source_id}\", response_model=Source, operation_id=\"retrieve_source\", deprecated=True)"
          ],
          "start_line": 63,
          "end_line": 73,
          "is_async": true
        },
        {
          "name": "get_source_id_by_name",
          "signature": "def get_source_id_by_name(\n    source_name: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source_name: str,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a source by name",
          "decorators": [
            "@router.get(\"/name/{source_name}\", response_model=str, operation_id=\"get_source_id_by_name\", deprecated=True)"
          ],
          "start_line": 77,
          "end_line": 88,
          "is_async": true
        },
        {
          "name": "get_sources_metadata",
          "signature": "def get_sources_metadata(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    include_detailed_per_source_metadata: bool = False,\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    include_detailed_per_source_metadata: bool = False,\n)",
          "return_type": null,
          "docstring": "Get aggregated metadata for all sources in an organization.\n\n    Returns structured metadata including:\n    - Total number of sources\n    - Total number of files across all sources\n    - Total size of all files\n    - Per-source breakdown with file details (file_name, file_size per file) if include_detailed_per_source_metadata is True",
          "decorators": [
            "@router.get(\"/metadata\", response_model=OrganizationSourcesStats, operation_id=\"get_sources_metadata\", deprecated=True)"
          ],
          "start_line": 92,
          "end_line": 109,
          "is_async": true
        },
        {
          "name": "list_sources",
          "signature": "def list_sources(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List all data sources created by a user.",
          "decorators": [
            "@router.get(\"/\", response_model=List[Source], operation_id=\"list_sources\", deprecated=True)"
          ],
          "start_line": 113,
          "end_line": 121,
          "is_async": true
        },
        {
          "name": "create_source",
          "signature": "def create_source(\n    source_create: SourceCreate,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source_create: SourceCreate,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create a new data source.",
          "decorators": [
            "@router.post(\"/\", response_model=Source, operation_id=\"create_source\", deprecated=True)"
          ],
          "start_line": 125,
          "end_line": 156,
          "is_async": true
        },
        {
          "name": "modify_source",
          "signature": "def modify_source(\n    source: SourceUpdate,\n    source_id: SourceId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source: SourceUpdate,\n    source_id: SourceId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Update the name or documentation of an existing data source.",
          "decorators": [
            "@router.patch(\"/{source_id}\", response_model=Source, operation_id=\"modify_source\", deprecated=True)"
          ],
          "start_line": 160,
          "end_line": 172,
          "is_async": true
        },
        {
          "name": "delete_source",
          "signature": "def delete_source(\n    source_id: SourceId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source_id: SourceId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete a data source.",
          "decorators": [
            "@router.delete(\"/{source_id}\", response_model=None, operation_id=\"delete_source\", deprecated=True)"
          ],
          "start_line": 176,
          "end_line": 210,
          "is_async": true
        },
        {
          "name": "upload_file_to_source",
          "signature": "def upload_file_to_source(\n    file: UploadFile,\n    source_id: SourceId,\n    duplicate_handling: DuplicateFileHandling = Query(DuplicateFileHandling.SUFFIX, description=\"How to handle duplicate filenames\"),\n    name: Optional[str] = Query(None, description=\"Optional custom name to override the uploaded file's name\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    file: UploadFile,\n    source_id: SourceId,\n    duplicate_handling: DuplicateFileHandling = Query(DuplicateFileHandling.SUFFIX, description=\"How to handle duplicate filenames\"),\n    name: Optional[str] = Query(None, description=\"Optional custom name to override the uploaded file's name\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Upload a file to a data source.",
          "decorators": [
            "@router.post(\"/{source_id}/upload\", response_model=FileMetadata, operation_id=\"upload_file_to_source\", deprecated=True)"
          ],
          "start_line": 214,
          "end_line": 350,
          "is_async": true
        },
        {
          "name": "get_agents_for_source",
          "signature": "def get_agents_for_source(\n    source_id: SourceId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source_id: SourceId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get all agent IDs that have the specified source attached.",
          "decorators": [
            "@router.get(\"/{source_id}/agents\", response_model=List[str], operation_id=\"get_agents_for_source\", deprecated=True)"
          ],
          "start_line": 354,
          "end_line": 363,
          "is_async": true
        },
        {
          "name": "list_source_passages",
          "signature": "def list_source_passages(\n    source_id: SourceId,\n    after: Optional[str] = Query(None, description=\"Message after which to retrieve the returned messages.\"),\n    before: Optional[str] = Query(None, description=\"Message before which to retrieve the returned messages.\"),\n    limit: int = Query(100, description=\"Maximum number of messages to retrieve.\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source_id: SourceId,\n    after: Optional[str] = Query(None, description=\"Message after which to retrieve the returned messages.\"),\n    before: Optional[str] = Query(None, description=\"Message before which to retrieve the returned messages.\"),\n    limit: int = Query(100, description=\"Maximum number of messages to retrieve.\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List all passages associated with a data source.",
          "decorators": [
            "@router.get(\"/{source_id}/passages\", response_model=List[Passage], operation_id=\"list_source_passages\", deprecated=True)"
          ],
          "start_line": 367,
          "end_line": 385,
          "is_async": true
        },
        {
          "name": "list_source_files",
          "signature": "def list_source_files(\n    source_id: SourceId,\n    limit: int = Query(1000, description=\"Number of files to return\"),\n    after: Optional[str] = Query(None, description=\"Pagination cursor to fetch the next set of results\"),\n    include_content: bool = Query(False, description=\"Whether to include full file content\"),\n    check_status_updates: bool = Query(\n        True,\n        description=\"Whether to check and update file processing status (from the vector db service). If False, will not fetch and update the status, which may lead to performance gains.\",\n    ),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source_id: SourceId,\n    limit: int = Query(1000, description=\"Number of files to return\"),\n    after: Optional[str] = Query(None, description=\"Pagination cursor to fetch the next set of results\"),\n    include_content: bool = Query(False, description=\"Whether to include full file content\"),\n    check_status_updates: bool = Query(\n        True,\n        description=\"Whether to check and update file processing status (from the vector db service). If False, will not fetch and update the status, which may lead to performance gains.\",\n    ),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "List paginated files associated with a data source.",
          "decorators": [
            "@router.get(\"/{source_id}/files\", response_model=List[FileMetadata], operation_id=\"list_source_files\", deprecated=True)"
          ],
          "start_line": 389,
          "end_line": 413,
          "is_async": true
        },
        {
          "name": "get_file_metadata",
          "signature": "def get_file_metadata(\n    source_id: SourceId,\n    file_id: FileId,\n    include_content: bool = Query(False, description=\"Whether to include full file content\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source_id: SourceId,\n    file_id: FileId,\n    include_content: bool = Query(False, description=\"Whether to include full file content\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Retrieve metadata for a specific file by its ID.",
          "decorators": [
            "@router.get(\"/{source_id}/files/{file_id}\", response_model=FileMetadata, operation_id=\"get_file_metadata\", deprecated=True)"
          ],
          "start_line": 417,
          "end_line": 437,
          "is_async": true
        },
        {
          "name": "delete_file_from_source",
          "signature": "def delete_file_from_source(\n    source_id: SourceId,\n    file_id: FileId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    source_id: SourceId,\n    file_id: FileId,\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete a data source.",
          "decorators": [
            "@router.delete(\"/{source_id}/{file_id}\", status_code=204, operation_id=\"delete_file_from_source\", deprecated=True)"
          ],
          "start_line": 443,
          "end_line": 468,
          "is_async": true
        },
        {
          "name": "load_file_to_source_async",
          "signature": "def load_file_to_source_async(server: SyncServer, source_id: str, job_id: str, filename: str, bytes: bytes, actor: User)",
          "parameters": "(server: SyncServer, source_id: str, job_id: str, filename: str, bytes: bytes, actor: User)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 471,
          "end_line": 484,
          "is_async": true
        },
        {
          "name": "sleeptime_document_ingest_async",
          "signature": "def sleeptime_document_ingest_async(server: SyncServer, source_id: str, actor: User, clear_history: bool = False)",
          "parameters": "(server: SyncServer, source_id: str, actor: User, clear_history: bool = False)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 487,
          "end_line": 492,
          "is_async": true
        },
        {
          "name": "load_file_to_source_cloud",
          "signature": "def load_file_to_source_cloud(\n    server: SyncServer,\n    agent_states: List[AgentState],\n    content: bytes,\n    source_id: str,\n    actor: User,\n    embedding_config: EmbeddingConfig,\n    file_metadata: FileMetadata,\n)",
          "parameters": "(\n    server: SyncServer,\n    agent_states: List[AgentState],\n    content: bytes,\n    source_id: str,\n    actor: User,\n    embedding_config: EmbeddingConfig,\n    file_metadata: FileMetadata,\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@trace_method"
          ],
          "start_line": 496,
          "end_line": 522,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138683
    },
    "letta/server/rest_api/routers/v1/steps.py": {
      "path": "letta/server/rest_api/routers/v1/steps.py",
      "contentHash": "f2f83276298c08b083f6c51681ef1c2a",
      "mtime": 1767315072064.5452,
      "functions": [
        {
          "name": "list_steps",
          "signature": "def list_steps(\n    before: Optional[str] = Query(None, description=\"Return steps before this step ID\"),\n    after: Optional[str] = Query(None, description=\"Return steps after this step ID\"),\n    limit: Optional[int] = Query(50, description=\"Maximum number of steps to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for steps by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    start_date: Optional[str] = Query(None, description='Return steps after this ISO datetime (e.g. \"2025-01-29T15:01:19-08:00\")'),\n    end_date: Optional[str] = Query(None, description='Return steps before this ISO datetime (e.g. \"2025-01-29T15:01:19-08:00\")'),\n    model: Optional[str] = Query(None, description=\"Filter by the name of the model used for the step\"),\n    agent_id: Optional[str] = Query(None, description=\"Filter by the ID of the agent that performed the step\"),\n    trace_ids: Optional[list[str]] = Query(None, description=\"Filter by trace ids returned by the server\"),\n    feedback: Optional[Literal[\"positive\", \"negative\"]] = Query(None, description=\"Filter by feedback\"),\n    has_feedback: Optional[bool] = Query(None, description=\"Filter by whether steps have feedback (true) or not (false)\"),\n    tags: Optional[list[str]] = Query(None, description=\"Filter by tags\"),\n    project_id: Optional[str] = Query(None, description=\"Filter by the project ID that is associated with the step (cloud only).\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: Optional[str] = Header(\n        None, alias=\"X-Project\", description=\"Filter by project slug to associate with the group (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "parameters": "(\n    before: Optional[str] = Query(None, description=\"Return steps before this step ID\"),\n    after: Optional[str] = Query(None, description=\"Return steps after this step ID\"),\n    limit: Optional[int] = Query(50, description=\"Maximum number of steps to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for steps by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    start_date: Optional[str] = Query(None, description='Return steps after this ISO datetime (e.g. \"2025-01-29T15:01:19-08:00\")'),\n    end_date: Optional[str] = Query(None, description='Return steps before this ISO datetime (e.g. \"2025-01-29T15:01:19-08:00\")'),\n    model: Optional[str] = Query(None, description=\"Filter by the name of the model used for the step\"),\n    agent_id: Optional[str] = Query(None, description=\"Filter by the ID of the agent that performed the step\"),\n    trace_ids: Optional[list[str]] = Query(None, description=\"Filter by trace ids returned by the server\"),\n    feedback: Optional[Literal[\"positive\", \"negative\"]] = Query(None, description=\"Filter by feedback\"),\n    has_feedback: Optional[bool] = Query(None, description=\"Filter by whether steps have feedback (true) or not (false)\"),\n    tags: Optional[list[str]] = Query(None, description=\"Filter by tags\"),\n    project_id: Optional[str] = Query(None, description=\"Filter by the project ID that is associated with the step (cloud only).\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    x_project: Optional[str] = Header(\n        None, alias=\"X-Project\", description=\"Filter by project slug to associate with the group (cloud only).\"\n    ),  # Only handled by next js middleware\n)",
          "return_type": null,
          "docstring": "List steps with optional pagination and date filters.",
          "decorators": [
            "@router.get(\"/\", response_model=List[Step], operation_id=\"list_steps\")"
          ],
          "start_line": 22,
          "end_line": 68,
          "is_async": true
        },
        {
          "name": "retrieve_step",
          "signature": "def retrieve_step(\n    step_id: StepId,\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "parameters": "(\n    step_id: StepId,\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Get a step by ID.",
          "decorators": [
            "@router.get(\"/{step_id}\", response_model=Step, operation_id=\"retrieve_step\")"
          ],
          "start_line": 72,
          "end_line": 81,
          "is_async": true
        },
        {
          "name": "retrieve_metrics_for_step",
          "signature": "def retrieve_metrics_for_step(\n    step_id: StepId,\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "parameters": "(\n    step_id: StepId,\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Get step metrics by step ID.",
          "decorators": [
            "@router.get(\"/{step_id}/metrics\", response_model=StepMetrics, operation_id=\"retrieve_metrics_for_step\")"
          ],
          "start_line": 85,
          "end_line": 94,
          "is_async": true
        },
        {
          "name": "retrieve_trace_for_step",
          "signature": "def retrieve_trace_for_step(\n    step_id: StepId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    step_id: StepId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.get(\"/{step_id}/trace\", response_model=Optional[ProviderTrace], operation_id=\"retrieve_trace_for_step\")"
          ],
          "start_line": 98,
          "end_line": 112,
          "is_async": true
        },
        {
          "name": "modify_feedback_for_step",
          "signature": "def modify_feedback_for_step(\n    step_id: StepId,\n    request: ModifyFeedbackRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "parameters": "(\n    step_id: StepId,\n    request: ModifyFeedbackRequest = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Modify feedback for a given step.",
          "decorators": [
            "@router.patch(\"/{step_id}/feedback\", response_model=Step, operation_id=\"modify_feedback_for_step\")"
          ],
          "start_line": 121,
          "end_line": 131,
          "is_async": true
        },
        {
          "name": "list_messages_for_step",
          "signature": "def list_messages_for_step(\n    step_id: StepId,\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Sort by field\"),\n)",
          "parameters": "(\n    step_id: StepId,\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n    before: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come before this message ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Message ID cursor for pagination. Returns messages that come after this message ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(100, description=\"Maximum number of messages to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for messages by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Sort by field\"),\n)",
          "return_type": null,
          "docstring": "List messages for a given step.",
          "decorators": [
            "@router.get(\"/{step_id}/messages\", response_model=List[LettaMessageUnion], operation_id=\"list_messages_for_step\")"
          ],
          "start_line": 135,
          "end_line": 158,
          "is_async": true
        },
        {
          "name": "update_step_transaction_id",
          "signature": "def update_step_transaction_id(\n    transaction_id: str,\n    step_id: StepId,\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "parameters": "(\n    transaction_id: str,\n    step_id: StepId,\n    headers: HeaderParams = Depends(get_headers),\n    server: SyncServer = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Update the transaction ID for a step.",
          "decorators": [
            "@router.patch(\"/{step_id}/transaction/{transaction_id}\", response_model=Step, operation_id=\"update_step_transaction_id\")"
          ],
          "start_line": 162,
          "end_line": 172,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138683
    },
    "letta/server/rest_api/routers/v1/tags.py": {
      "path": "letta/server/rest_api/routers/v1/tags.py",
      "contentHash": "a1e6ce9b37de939831aa473b4dafd38c",
      "mtime": 1767315072064.5452,
      "functions": [
        {
          "name": "list_tags",
          "signature": "def list_tags(\n    before: Optional[str] = Query(\n        None, description=\"Tag cursor for pagination. Returns tags that come before this tag in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Tag cursor for pagination. Returns tags that come after this tag in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of tags to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for tags. 'asc' for alphabetical order, 'desc' for reverse alphabetical order\"\n    ),\n    order_by: Literal[\"name\"] = Query(\"name\", description=\"Field to sort by\"),\n    query_text: Optional[str] = Query(\n        None, description=\"Filter tags by text search. Deprecated, please use name field instead\", deprecated=True\n    ),\n    name: Optional[str] = Query(None, description=\"Filter tags by name\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    before: Optional[str] = Query(\n        None, description=\"Tag cursor for pagination. Returns tags that come before this tag in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Tag cursor for pagination. Returns tags that come after this tag in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of tags to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"asc\", description=\"Sort order for tags. 'asc' for alphabetical order, 'desc' for reverse alphabetical order\"\n    ),\n    order_by: Literal[\"name\"] = Query(\"name\", description=\"Field to sort by\"),\n    query_text: Optional[str] = Query(\n        None, description=\"Filter tags by text search. Deprecated, please use name field instead\", deprecated=True\n    ),\n    name: Optional[str] = Query(None, description=\"Filter tags by name\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get the list of all agent tags that have been created.",
          "decorators": [
            "@router.get(\"/\", tags=[\"admin\"], response_model=List[str], operation_id=\"list_tags\")"
          ],
          "start_line": 15,
          "end_line": 42,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138683
    },
    "letta/server/rest_api/routers/v1/telemetry.py": {
      "path": "letta/server/rest_api/routers/v1/telemetry.py",
      "contentHash": "40114ea904cc339d20b284b6378248b2",
      "mtime": 1767315072064.5452,
      "functions": [
        {
          "name": "retrieve_provider_trace",
          "signature": "def retrieve_provider_trace(\n    step_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    step_id: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "**DEPRECATED**: Use `GET /steps/{step_id}/trace` instead.\n\n    Retrieve provider trace by step ID.",
          "decorators": [
            "@router.get(\"/{step_id}\", response_model=Optional[ProviderTrace], operation_id=\"retrieve_provider_trace\", deprecated=True)"
          ],
          "start_line": 14,
          "end_line": 33,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138683
    },
    "letta/server/rest_api/routers/v1/tools.py": {
      "path": "letta/server/rest_api/routers/v1/tools.py",
      "contentHash": "d139b2059822e5a2f7826994f9dd5bdf",
      "mtime": 1768610518530.2002,
      "functions": [
        {
          "name": "delete_tool",
          "signature": "def delete_tool(\n    tool_id: ToolId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    tool_id: ToolId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete a tool by name",
          "decorators": [
            "@router.delete(\"/{tool_id}\", operation_id=\"delete_tool\")"
          ],
          "start_line": 53,
          "end_line": 62,
          "is_async": true
        },
        {
          "name": "count_tools",
          "signature": "def count_tools(\n    name: Optional[str] = None,\n    names: Optional[List[str]] = Query(None, description=\"Filter by specific tool names\"),\n    tool_ids: Optional[List[str]] = Query(\n        None, description=\"Filter by specific tool IDs - accepts repeated params or comma-separated values\"\n    ),\n    search: Optional[str] = Query(None, description=\"Search tool names (case-insensitive partial match)\"),\n    tool_types: Optional[List[str]] = Query(None, description=\"Filter by tool type(s) - accepts repeated params or comma-separated values\"),\n    exclude_tool_types: Optional[List[str]] = Query(\n        None, description=\"Tool type(s) to exclude - accepts repeated params or comma-separated values\"\n    ),\n    return_only_letta_tools: Optional[bool] = Query(False, description=\"Count only tools with tool_type starting with 'letta_'\"),\n    exclude_letta_tools: Optional[bool] = Query(False, description=\"Exclude built-in Letta tools from the count\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    name: Optional[str] = None,\n    names: Optional[List[str]] = Query(None, description=\"Filter by specific tool names\"),\n    tool_ids: Optional[List[str]] = Query(\n        None, description=\"Filter by specific tool IDs - accepts repeated params or comma-separated values\"\n    ),\n    search: Optional[str] = Query(None, description=\"Search tool names (case-insensitive partial match)\"),\n    tool_types: Optional[List[str]] = Query(None, description=\"Filter by tool type(s) - accepts repeated params or comma-separated values\"),\n    exclude_tool_types: Optional[List[str]] = Query(\n        None, description=\"Tool type(s) to exclude - accepts repeated params or comma-separated values\"\n    ),\n    return_only_letta_tools: Optional[bool] = Query(False, description=\"Count only tools with tool_type starting with 'letta_'\"),\n    exclude_letta_tools: Optional[bool] = Query(False, description=\"Exclude built-in Letta tools from the count\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a count of all tools available to agents belonging to the org of the user.",
          "decorators": [
            "@router.get(\"/count\", response_model=int, operation_id=\"count_tools\")"
          ],
          "start_line": 66,
          "end_line": 153,
          "is_async": true
        },
        {
          "name": "retrieve_tool",
          "signature": "def retrieve_tool(\n    tool_id: ToolId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    tool_id: ToolId,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a tool by ID",
          "decorators": [
            "@router.get(\"/{tool_id}\", response_model=Tool, operation_id=\"retrieve_tool\")"
          ],
          "start_line": 157,
          "end_line": 170,
          "is_async": true
        },
        {
          "name": "list_tools",
          "signature": "def list_tools(\n    before: Optional[str] = Query(\n        None, description=\"Tool ID cursor for pagination. Returns tools that come before this tool ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Tool ID cursor for pagination. Returns tools that come after this tool ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of tools to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for tools by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    name: Optional[str] = Query(None, description=\"Filter by single tool name\"),\n    names: Optional[List[str]] = Query(None, description=\"Filter by specific tool names\"),\n    tool_ids: Optional[List[str]] = Query(\n        None, description=\"Filter by specific tool IDs - accepts repeated params or comma-separated values\"\n    ),\n    search: Optional[str] = Query(None, description=\"Search tool names (case-insensitive partial match)\"),\n    tool_types: Optional[List[str]] = Query(None, description=\"Filter by tool type(s) - accepts repeated params or comma-separated values\"),\n    exclude_tool_types: Optional[List[str]] = Query(\n        None, description=\"Tool type(s) to exclude - accepts repeated params or comma-separated values\"\n    ),\n    return_only_letta_tools: Optional[bool] = Query(False, description=\"Return only tools with tool_type starting with 'letta_'\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    before: Optional[str] = Query(\n        None, description=\"Tool ID cursor for pagination. Returns tools that come before this tool ID in the specified sort order\"\n    ),\n    after: Optional[str] = Query(\n        None, description=\"Tool ID cursor for pagination. Returns tools that come after this tool ID in the specified sort order\"\n    ),\n    limit: Optional[int] = Query(50, description=\"Maximum number of tools to return\"),\n    order: Literal[\"asc\", \"desc\"] = Query(\n        \"desc\", description=\"Sort order for tools by creation time. 'asc' for oldest first, 'desc' for newest first\"\n    ),\n    order_by: Literal[\"created_at\"] = Query(\"created_at\", description=\"Field to sort by\"),\n    name: Optional[str] = Query(None, description=\"Filter by single tool name\"),\n    names: Optional[List[str]] = Query(None, description=\"Filter by specific tool names\"),\n    tool_ids: Optional[List[str]] = Query(\n        None, description=\"Filter by specific tool IDs - accepts repeated params or comma-separated values\"\n    ),\n    search: Optional[str] = Query(None, description=\"Search tool names (case-insensitive partial match)\"),\n    tool_types: Optional[List[str]] = Query(None, description=\"Filter by tool type(s) - accepts repeated params or comma-separated values\"),\n    exclude_tool_types: Optional[List[str]] = Query(\n        None, description=\"Tool type(s) to exclude - accepts repeated params or comma-separated values\"\n    ),\n    return_only_letta_tools: Optional[bool] = Query(False, description=\"Return only tools with tool_type starting with 'letta_'\"),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a list of all tools available to agents.",
          "decorators": [
            "@router.get(\"/\", response_model=List[Tool], operation_id=\"list_tools\")"
          ],
          "start_line": 174,
          "end_line": 274,
          "is_async": true
        },
        {
          "name": "search_tools",
          "signature": "def search_tools(\n    request: ToolSearchRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: ToolSearchRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Search tools using semantic search.\n\n    Requires tool embedding to be enabled (embed_tools=True). Uses vector search,\n    full-text search, or hybrid mode to find tools matching the query.\n\n    Returns tools ranked by relevance with their search scores.",
          "decorators": [
            "@router.post(\"/search\", response_model=List[ToolSearchResult], operation_id=\"search_tools\")"
          ],
          "start_line": 278,
          "end_line": 314,
          "is_async": true
        },
        {
          "name": "create_tool",
          "signature": "def create_tool(\n    request: ToolCreate = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: ToolCreate = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create a new tool",
          "decorators": [
            "@router.post(\"/\", response_model=Tool, operation_id=\"create_tool\")"
          ],
          "start_line": 318,
          "end_line": 334,
          "is_async": true
        },
        {
          "name": "upsert_tool",
          "signature": "def upsert_tool(\n    request: ToolCreate = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: ToolCreate = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Create or update a tool",
          "decorators": [
            "@router.put(\"/\", response_model=Tool, operation_id=\"upsert_tool\")"
          ],
          "start_line": 338,
          "end_line": 355,
          "is_async": true
        },
        {
          "name": "modify_tool",
          "signature": "def modify_tool(\n    tool_id: ToolId,\n    request: ToolUpdate = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    tool_id: ToolId,\n    request: ToolUpdate = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Update an existing tool",
          "decorators": [
            "@router.patch(\"/{tool_id}\", response_model=Tool, operation_id=\"modify_tool\")"
          ],
          "start_line": 359,
          "end_line": 373,
          "is_async": true
        },
        {
          "name": "upsert_base_tools",
          "signature": "def upsert_base_tools(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Upsert base tools",
          "decorators": [
            "@router.post(\"/add-base-tools\", response_model=List[Tool], operation_id=\"add_base_tools\")"
          ],
          "start_line": 377,
          "end_line": 385,
          "is_async": true
        },
        {
          "name": "run_tool_from_source",
          "signature": "def run_tool_from_source(\n    server: SyncServer = Depends(get_letta_server),\n    request: ToolRunFromSource = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: SyncServer = Depends(get_letta_server),\n    request: ToolRunFromSource = Body(...),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Attempt to build a tool from source, then run it on the provided arguments",
          "decorators": [
            "@router.post(\"/run\", response_model=ToolReturnMessage, operation_id=\"run_tool_from_source\")"
          ],
          "start_line": 389,
          "end_line": 409,
          "is_async": true
        },
        {
          "name": "list_mcp_servers",
          "signature": "def list_mcp_servers(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a list of all configured MCP servers",
          "decorators": [
            "@router.get(\n    \"/mcp/servers\",\n    response_model=dict[str, Union[SSEServerConfig, StdioServerConfig, StreamableHTTPServerConfig]],\n    operation_id=\"list_mcp_servers\",\n)"
          ],
          "start_line": 418,
          "end_line": 433,
          "is_async": true
        },
        {
          "name": "list_mcp_tools_by_server",
          "signature": "def list_mcp_tools_by_server(\n    mcp_server_name: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    mcp_server_name: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Get a list of all tools for a specific MCP server",
          "decorators": [
            "@router.get(\"/mcp/servers/{mcp_server_name}/tools\", response_model=List[MCPTool], operation_id=\"list_mcp_tools_by_server\")"
          ],
          "start_line": 439,
          "end_line": 458,
          "is_async": true
        },
        {
          "name": "resync_mcp_server_tools",
          "signature": "def resync_mcp_server_tools(\n    mcp_server_name: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    agent_id: Optional[str] = None,\n)",
          "parameters": "(\n    mcp_server_name: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    agent_id: Optional[str] = None,\n)",
          "return_type": null,
          "docstring": "Resync tools for an MCP server by:\n    1. Fetching current tools from the MCP server\n    2. Deleting tools that no longer exist on the server\n    3. Updating schemas for existing tools\n    4. Adding new tools from the server\n\n    Returns a summary of changes made.",
          "decorators": [
            "@router.post(\"/mcp/servers/{mcp_server_name}/resync\", operation_id=\"resync_mcp_server_tools\")"
          ],
          "start_line": 462,
          "end_line": 479,
          "is_async": true
        },
        {
          "name": "add_mcp_tool",
          "signature": "def add_mcp_tool(\n    mcp_server_name: str,\n    mcp_tool_name: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    mcp_server_name: str,\n    mcp_tool_name: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Register a new MCP tool as a Letta server by MCP server + tool name",
          "decorators": [
            "@router.post(\"/mcp/servers/{mcp_server_name}/{mcp_tool_name}\", response_model=Tool, operation_id=\"add_mcp_tool\")"
          ],
          "start_line": 483,
          "end_line": 526,
          "is_async": true
        },
        {
          "name": "add_mcp_server_to_config",
          "signature": "def add_mcp_server_to_config(\n    request: Union[StdioServerConfig, SSEServerConfig, StreamableHTTPServerConfig] = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: Union[StdioServerConfig, SSEServerConfig, StreamableHTTPServerConfig] = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Add a new MCP server to the Letta MCP server config",
          "decorators": [
            "@router.put(\n    \"/mcp/servers\",\n    response_model=List[Union[StdioServerConfig, SSEServerConfig, StreamableHTTPServerConfig]],\n    operation_id=\"add_mcp_server\",\n)"
          ],
          "start_line": 534,
          "end_line": 565,
          "is_async": true
        },
        {
          "name": "update_mcp_server",
          "signature": "def update_mcp_server(\n    mcp_server_name: str,\n    request: Union[UpdateStdioMCPServer, UpdateSSEMCPServer, UpdateStreamableHTTPMCPServer] = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    mcp_server_name: str,\n    request: Union[UpdateStdioMCPServer, UpdateSSEMCPServer, UpdateStreamableHTTPMCPServer] = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Update an existing MCP server configuration",
          "decorators": [
            "@router.patch(\n    \"/mcp/servers/{mcp_server_name}\",\n    response_model=Union[StdioServerConfig, SSEServerConfig, StreamableHTTPServerConfig],\n    operation_id=\"update_mcp_server\",\n)"
          ],
          "start_line": 573,
          "end_line": 590,
          "is_async": true
        },
        {
          "name": "delete_mcp_server_from_config",
          "signature": "def delete_mcp_server_from_config(\n    mcp_server_name: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    mcp_server_name: str,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Delete a MCP server configuration",
          "decorators": [
            "@router.delete(\n    \"/mcp/servers/{mcp_server_name}\",\n    response_model=List[Union[StdioServerConfig, SSEServerConfig, StreamableHTTPServerConfig]],\n    operation_id=\"delete_mcp_server\",\n)"
          ],
          "start_line": 598,
          "end_line": 620,
          "is_async": true
        },
        {
          "name": "test_mcp_server",
          "signature": "def test_mcp_server(\n    request: Union[StdioServerConfig, SSEServerConfig, StreamableHTTPServerConfig] = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: Union[StdioServerConfig, SSEServerConfig, StreamableHTTPServerConfig] = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Test connection to an MCP server without adding it.\n    Returns the list of available tools if successful.",
          "decorators": [
            "@deprecated(\"Deprecated in favor of /mcp/servers/connect which handles OAuth flow via SSE stream\")",
            "@router.post(\"/mcp/servers/test\", operation_id=\"test_mcp_server\")"
          ],
          "start_line": 625,
          "end_line": 653,
          "is_async": true
        },
        {
          "name": "connect_mcp_server",
          "signature": "def connect_mcp_server(\n    request: Union[StdioServerConfig, SSEServerConfig, StreamableHTTPServerConfig] = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    http_request: Request = None,\n) -> StreamingResponse",
          "parameters": "(\n    request: Union[StdioServerConfig, SSEServerConfig, StreamableHTTPServerConfig] = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n    http_request: Request = None,\n)",
          "return_type": "StreamingResponse",
          "docstring": "Connect to an MCP server with support for OAuth via SSE.\n    Returns a stream of events handling authorization state and exchange if OAuth is required.",
          "decorators": [
            "@router.post(\n    \"/mcp/servers/connect\",\n    response_model=None,\n    responses={\n        200: {\n            \"description\": \"Successful response\",\n            \"content\": {\n                \"text/event-stream\": {\"description\": \"Server-Sent Events stream\"},\n            },\n        }\n    },\n    operation_id=\"connect_mcp_server\",\n)"
          ],
          "start_line": 669,
          "end_line": 759,
          "is_async": true
        },
        {
          "name": "generate_json_schema",
          "signature": "def generate_json_schema(\n    request: CodeInput = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: CodeInput = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Generate a JSON schema from the given source code defining a function or class.\n    Supports both Python and TypeScript source code.",
          "decorators": [
            "@router.post(\"/generate-schema\", response_model=Dict[str, Any], operation_id=\"generate_json_schema\")"
          ],
          "start_line": 768,
          "end_line": 784,
          "is_async": true
        },
        {
          "name": "execute_mcp_tool",
          "signature": "def execute_mcp_tool(\n    mcp_server_name: str,\n    tool_name: str,\n    request: ToolExecuteRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    mcp_server_name: str,\n    tool_name: str,\n    request: ToolExecuteRequest = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Execute a specific MCP tool from a configured server.\n    Returns the tool execution result.",
          "decorators": [
            "@router.post(\"/mcp/servers/{mcp_server_name}/tools/{tool_name}/execute\", operation_id=\"execute_mcp_tool\")"
          ],
          "start_line": 793,
          "end_line": 833,
          "is_async": true
        },
        {
          "name": "mcp_oauth_callback",
          "signature": "def mcp_oauth_callback(\n    session_id: str,\n    code: Optional[str] = Query(None, description=\"OAuth authorization code\"),\n    state: Optional[str] = Query(None, description=\"OAuth state parameter\"),\n    error: Optional[str] = Query(None, description=\"OAuth error\"),\n    error_description: Optional[str] = Query(None, description=\"OAuth error description\"),\n)",
          "parameters": "(\n    session_id: str,\n    code: Optional[str] = Query(None, description=\"OAuth authorization code\"),\n    state: Optional[str] = Query(None, description=\"OAuth state parameter\"),\n    error: Optional[str] = Query(None, description=\"OAuth error\"),\n    error_description: Optional[str] = Query(None, description=\"OAuth error description\"),\n)",
          "return_type": null,
          "docstring": "Handle OAuth callback for MCP server authentication.",
          "decorators": [
            "@router.get(\"/mcp/oauth/callback/{session_id}\", operation_id=\"mcp_oauth_callback\")"
          ],
          "start_line": 838,
          "end_line": 871,
          "is_async": true
        },
        {
          "name": "generate_tool_from_prompt",
          "signature": "def generate_tool_from_prompt(\n    request: GenerateToolInput = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: GenerateToolInput = Body(...),\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Generate a tool from the given user prompt.",
          "decorators": [
            "@router.post(\"/generate-tool\", response_model=GenerateToolOutput, operation_id=\"generate_tool\")"
          ],
          "start_line": 889,
          "end_line": 975,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138683
    },
    "letta/server/rest_api/routers/v1/users.py": {
      "path": "letta/server/rest_api/routers/v1/users.py",
      "contentHash": "2ddd24a7557a4033a5c34cfa053b9cd0",
      "mtime": 1767315072064.5452,
      "functions": [
        {
          "name": "list_users",
          "signature": "def list_users(\n    after: Optional[str] = Query(None),\n    limit: Optional[int] = Query(50),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    after: Optional[str] = Query(None),\n    limit: Optional[int] = Query(50),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Get a list of all users in the database",
          "decorators": [
            "@router.get(\"/\", tags=[\"admin\"], response_model=List[User], operation_id=\"list_users\")"
          ],
          "start_line": 17,
          "end_line": 25,
          "is_async": true
        },
        {
          "name": "create_user",
          "signature": "def create_user(\n    request: UserCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    request: UserCreate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Create a new user in the database",
          "decorators": [
            "@router.post(\"/\", tags=[\"admin\"], response_model=User, operation_id=\"create_user\")"
          ],
          "start_line": 29,
          "end_line": 38,
          "is_async": true
        },
        {
          "name": "update_user",
          "signature": "def update_user(\n    user: UserUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    user: UserUpdate = Body(...),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": "Update a user in the database",
          "decorators": [
            "@router.put(\"/\", tags=[\"admin\"], response_model=User, operation_id=\"update_user\")"
          ],
          "start_line": 42,
          "end_line": 50,
          "is_async": true
        },
        {
          "name": "delete_user",
          "signature": "def delete_user(\n    user_id: str = Query(..., description=\"The user_id key to be deleted.\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "parameters": "(\n    user_id: str = Query(..., description=\"The user_id key to be deleted.\"),\n    server: \"SyncServer\" = Depends(get_letta_server),\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@router.delete(\"/\", tags=[\"admin\"], response_model=User, operation_id=\"delete_user\")"
          ],
          "start_line": 54,
          "end_line": 62,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138683
    },
    "letta/server/rest_api/routers/v1/voice.py": {
      "path": "letta/server/rest_api/routers/v1/voice.py",
      "contentHash": "2f1ed0771ffaf290a848f803ee853698",
      "mtime": 1767315072064.5452,
      "functions": [
        {
          "name": "create_voice_chat_completions",
          "signature": "def create_voice_chat_completions(\n    agent_id: str,\n    completion_request: Dict[str, Any] = Body(...),  # The validation is soft in case providers like VAPI send extra params\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    agent_id: str,\n    completion_request: Dict[str, Any] = Body(...),  # The validation is soft in case providers like VAPI send extra params\n    server: \"SyncServer\" = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "DEPRECATED: This voice-beta endpoint has been deprecated.\n\n    The voice functionality has been integrated into the main chat completions endpoint.\n    Please use the standard /v1/agents/{agent_id}/messages endpoint instead.\n\n    This endpoint will be removed in a future version.",
          "decorators": [
            "@router.post(\n    \"/{agent_id}/chat/completions\",\n    response_model=None,\n    operation_id=\"create_voice_chat_completions\",\n    deprecated=True,\n    responses={\n        200: {\n            \"description\": \"Successful response\",\n            \"content\": {\"text/event-stream\": {}},\n        },\n        410: {\n            \"description\": \"Endpoint deprecated\",\n            \"content\": {\"application/json\": {\"example\": {\"detail\": \"This endpoint has been deprecated\"}}},\n        },\n    },\n)"
          ],
          "start_line": 33,
          "end_line": 54,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138683
    },
    "letta/server/rest_api/routers/v1/zai.py": {
      "path": "letta/server/rest_api/routers/v1/zai.py",
      "contentHash": "7a2870bd908cf56a9d2d0a0bed6c431f",
      "mtime": 1767315072064.5452,
      "functions": [
        {
          "name": "zai_messages_proxy",
          "signature": "def zai_messages_proxy(\n    request: Request,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "parameters": "(\n    request: Request,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n)",
          "return_type": null,
          "docstring": "Proxy endpoint for Z.ai Messages API.\n\n    This endpoint forwards requests to the Z.ai API, allowing Claude Code CLI\n    to use Letta as a proxy by configuring anthropic_base_url.\n\n    Usage in Claude Code CLI settings.json:\n    {\n        \"env\": {\n            \"ANTHROPIC_BASE_URL\": \"http://localhost:3000/v1/zai\"\n        }\n    }",
          "decorators": [
            "@router.api_route(\"/v1/messages\", methods=[\"POST\"], operation_id=\"zai_messages_proxy\", include_in_schema=False)"
          ],
          "start_line": 32,
          "end_line": 257,
          "is_async": true
        },
        {
          "name": "all_proxy(\n    end",
          "signature": "def all_proxy(\n    endpoint: str,\n    request: Request,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n):\n    \"\"\"",
          "parameters": "point: str,\n    request: Request,\n    server: SyncServer = Depends(get_letta_server),\n    headers: HeaderParams = Depends(get_headers),\n):\n    \"\"\"",
          "return_type": null,
          "docstring": "atch-all proxy for other Z.ai API endpoints.\n\n    This forwards all other requests (like /v1/messages/count_tokens) directly to Z.ai\n    without message capture or memory injection.\n    \"\"\"\n    # Sk",
          "decorators": [
            "pi_route(\n    \"/v1/{endpoint:path}\",\n    methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\"],\n    operation_id=\"zai_catchall_proxy\",\n    include_in_schema=False,\n)\nasync de"
          ],
          "start_line": 266,
          "end_line": 331,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138683
    },
    "letta/server/rest_api/static_files.py": {
      "path": "letta/server/rest_api/static_files.py",
      "contentHash": "00eee4e4b1dccc03d07e321662a3ecbe",
      "mtime": 1767315072064.5452,
      "functions": [
        {
          "name": "mount_static_files",
          "signature": "def mount_static_files(app: FastAPI)",
          "parameters": "(app: FastAPI)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 21,
          "end_line": 60,
          "is_async": false
        }
      ],
      "parsedAt": 1769608138683
    },
    "letta/server/rest_api/streaming_response.py": {
      "path": "letta/server/rest_api/streaming_response.py",
      "contentHash": "0abb27defc8b0c7fac684d120c548341",
      "mtime": 1767315072064.5452,
      "functions": [
        {
          "name": "add_keepalive_to_stream",
          "signature": "def add_keepalive_to_stream(\n    stream_generator: AsyncIterator[str | bytes],\n    run_id: str,\n    keepalive_interval: float = 30.0,\n) -> AsyncIterator[str | bytes]",
          "parameters": "(\n    stream_generator: AsyncIterator[str | bytes],\n    run_id: str,\n    keepalive_interval: float = 30.0,\n)",
          "return_type": "AsyncIterator[str | bytes]",
          "docstring": "Adds periodic keepalive messages to a stream to prevent connection timeouts.\n\n    Sends a keepalive ping every `keepalive_interval` seconds, regardless of\n    whether data is flowing. This ensures connections stay alive during long\n    operations like tool execution.\n\n    Args:\n        stream_generator: The original stream generator to wrap\n        keepalive_interval: Seconds between keepalive messages (default: 30)\n\n    Yields:\n        Original stream chunks interspersed with keepalive messages",
          "decorators": [],
          "start_line": 37,
          "end_line": 110,
          "is_async": true
        },
        {
          "name": "cancellation_aware_stream_wrapper",
          "signature": "def cancellation_aware_stream_wrapper(\n    stream_generator: AsyncIterator[str | bytes],\n    run_manager: RunManager,\n    run_id: str,\n    actor: User,\n    cancellation_check_interval: float = 0.5,\n) -> AsyncIterator[str | bytes]",
          "parameters": "(\n    stream_generator: AsyncIterator[str | bytes],\n    run_manager: RunManager,\n    run_id: str,\n    actor: User,\n    cancellation_check_interval: float = 0.5,\n)",
          "return_type": "AsyncIterator[str | bytes]",
          "docstring": "Wraps a stream generator to provide real-time run cancellation checking.\n\n    This wrapper periodically checks for run cancellation while streaming and\n    can interrupt the stream at any point, not just at step boundaries.\n\n    Args:\n        stream_generator: The original stream generator to wrap\n        run_manager: Run manager instance for checking run status\n        run_id: ID of the run to monitor for cancellation\n        actor: User/actor making the request\n        cancellation_check_interval: How often to check for cancellation (seconds)\n\n    Yields:\n        Stream chunks from the original generator until cancelled\n\n    Raises:\n        asyncio.CancelledError: If the run is cancelled during streaming",
          "decorators": [],
          "start_line": 114,
          "end_line": 177,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138684
    },
    "letta/server/rest_api/utils.py": {
      "path": "letta/server/rest_api/utils.py",
      "contentHash": "5181ce869b896eb634614069353134d9",
      "mtime": 1767315072064.5452,
      "functions": [
        {
          "name": "sse_formatter",
          "signature": "def sse_formatter(data: Union[dict, str]) -> str",
          "parameters": "(data: Union[dict, str])",
          "return_type": "str",
          "docstring": "Prefix with 'data: ', and always include double newlines",
          "decorators": [],
          "start_line": 59,
          "end_line": 64,
          "is_async": false
        },
        {
          "name": "sse_async_generator",
          "signature": "def sse_async_generator(\n    generator: AsyncGenerator,\n    usage_task: Optional[asyncio.Task] = None,\n    finish_message=True,\n    request_start_timestamp_ns: Optional[int] = None,\n    llm_config: Optional[LLMConfig] = None,\n)",
          "parameters": "(\n    generator: AsyncGenerator,\n    usage_task: Optional[asyncio.Task] = None,\n    finish_message=True,\n    request_start_timestamp_ns: Optional[int] = None,\n    llm_config: Optional[LLMConfig] = None,\n)",
          "return_type": null,
          "docstring": "Wraps a generator for use in Server-Sent Events (SSE), handling errors and ensuring a completion message.\n\n    Args:\n    - generator: An asynchronous generator yielding data chunks.\n    - usage_task: Optional task that will return usage statistics.\n    - finish_message: Whether to send a completion message.\n    - request_start_timestamp_ns: Optional ns timestamp when the request started, used to measure time to first token.\n\n    Yields:\n    - Formatted Server-Sent Event strings.",
          "decorators": [],
          "start_line": 67,
          "end_line": 149,
          "is_async": true
        },
        {
          "name": "capture_sentry_exception",
          "signature": "def capture_sentry_exception(e: BaseException)",
          "parameters": "(e: BaseException)",
          "return_type": null,
          "docstring": "This will capture the exception in sentry, since the exception handler upstack (in FastAPI) won't catch it, because this may be a 200 response",
          "decorators": [],
          "start_line": 152,
          "end_line": 155,
          "is_async": false
        },
        {
          "name": "create_input_messages",
          "signature": "def create_input_messages(\n    input_messages: List[MessageCreate], agent_id: str, timezone: str, run_id: str, actor: User\n) -> List[Message]",
          "parameters": "(\n    input_messages: List[MessageCreate], agent_id: str, timezone: str, run_id: str, actor: User\n)",
          "return_type": "List[Message]",
          "docstring": "Converts a user input message into the internal structured format.\n\n    TODO (cliandy): this effectively duplicates the functionality of `convert_message_creates_to_messages`,\n    we should unify this when it's clear what message attributes we need.",
          "decorators": [],
          "start_line": 158,
          "end_line": 171,
          "is_async": true
        },
        {
          "name": "create_approval_response_message_from_input",
          "signature": "def create_approval_response_message_from_input(\n    agent_state: AgentState, input_message: ApprovalCreate, run_id: Optional[str] = None\n) -> List[Message]",
          "parameters": "(\n    agent_state: AgentState, input_message: ApprovalCreate, run_id: Optional[str] = None\n)",
          "return_type": "List[Message]",
          "docstring": null,
          "decorators": [],
          "start_line": 174,
          "end_line": 213,
          "is_async": false
        },
        {
          "name": "create_tool_returns_for_denials",
          "signature": "def create_tool_returns_for_denials(\n    tool_calls: List[OpenAIToolCall],\n    denial_reason: str,\n    timezone: str,\n) -> List[ToolReturn]",
          "parameters": "(\n    tool_calls: List[OpenAIToolCall],\n    denial_reason: str,\n    timezone: str,\n)",
          "return_type": "List[ToolReturn]",
          "docstring": "Create ToolReturn objects with error status for denied tool calls.\n\n    This is used when tool calls are denied either by:\n    - User explicitly denying approval\n    - Run cancellation (automated denial)\n\n    Args:\n        tool_calls: List of tool calls that were denied\n        denial_reason: Reason for denial (e.g., user reason or cancellation message)\n        timezone: Agent timezone for timestamp formatting\n\n    Returns:\n        List of ToolReturn objects with error status",
          "decorators": [],
          "start_line": 216,
          "end_line": 250,
          "is_async": false
        },
        {
          "name": "create_tool_message_from_returns",
          "signature": "def create_tool_message_from_returns(\n    agent_id: str,\n    model: str,\n    tool_returns: List[ToolReturn],\n    run_id: Optional[str] = None,\n    step_id: Optional[str] = None,\n) -> Message",
          "parameters": "(\n    agent_id: str,\n    model: str,\n    tool_returns: List[ToolReturn],\n    run_id: Optional[str] = None,\n    step_id: Optional[str] = None,\n)",
          "return_type": "Message",
          "docstring": "Create a tool message with error returns for denied/failed tool calls.\n\n    This creates a properly formatted tool message that can be added to the\n    conversation history to reflect tool call denials or failures.\n\n    Args:\n        agent_id: ID of the agent\n        model: Model identifier\n        tool_returns: List of ToolReturn objects (typically with error status)\n        run_id: Optional run ID\n        step_id: Optional step ID\n\n    Returns:\n        Message with role=\"tool\" containing the tool returns",
          "decorators": [],
          "start_line": 253,
          "end_line": 287,
          "is_async": false
        },
        {
          "name": "create_approval_request_message_from_llm_response",
          "signature": "def create_approval_request_message_from_llm_response(\n    agent_id: str,\n    model: str,\n    requested_tool_calls: List[OpenAIToolCall],\n    allowed_tool_calls: List[OpenAIToolCall] = [],\n    reasoning_content: Optional[List[Union[TextContent, ReasoningContent, RedactedReasoningContent, OmittedReasoningContent]]] = None,\n    pre_computed_assistant_message_id: Optional[str] = None,\n    step_id: str | None = None,\n    run_id: str = None,\n) -> Message",
          "parameters": "(\n    agent_id: str,\n    model: str,\n    requested_tool_calls: List[OpenAIToolCall],\n    allowed_tool_calls: List[OpenAIToolCall] = [],\n    reasoning_content: Optional[List[Union[TextContent, ReasoningContent, RedactedReasoningContent, OmittedReasoningContent]]] = None,\n    pre_computed_assistant_message_id: Optional[str] = None,\n    step_id: str | None = None,\n    run_id: str = None,\n)",
          "return_type": "Message",
          "docstring": null,
          "decorators": [],
          "start_line": 290,
          "end_line": 355,
          "is_async": false
        },
        {
          "name": "decrement_message_uuid",
          "signature": "def decrement_message_uuid(message_id: str)",
          "parameters": "(message_id: str)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 358,
          "end_line": 363,
          "is_async": false
        },
        {
          "name": "create_letta_messages_from_llm_response",
          "signature": "def create_letta_messages_from_llm_response(\n    agent_id: str,\n    model: str,\n    function_name: Optional[str],\n    function_arguments: Optional[Dict],\n    tool_execution_result: Optional[ToolExecutionResult],\n    tool_call_id: Optional[str],\n    function_response: Optional[str],\n    timezone: str,\n    run_id: str | None = None,\n    step_id: str = None,\n    continue_stepping: bool = False,\n    heartbeat_reason: Optional[str] = None,\n    reasoning_content: Optional[\n        List[Union[TextContent, ReasoningContent, RedactedReasoningContent, OmittedReasoningContent | SummarizedReasoningContent]]\n    ] = None,\n    pre_computed_assistant_message_id: Optional[str] = None,\n    llm_batch_item_id: Optional[str] = None,\n    is_approval_response: bool | None = None,\n    # force set request_heartbeat, useful for v2 loop to ensure matching tool rules\n    force_set_request_heartbeat: bool = True,\n    add_heartbeat_on_continue: bool = True,\n) -> List[Message]",
          "parameters": "(\n    agent_id: str,\n    model: str,\n    function_name: Optional[str],\n    function_arguments: Optional[Dict],\n    tool_execution_result: Optional[ToolExecutionResult],\n    tool_call_id: Optional[str],\n    function_response: Optional[str],\n    timezone: str,\n    run_id: str | None = None,\n    step_id: str = None,\n    continue_stepping: bool = False,\n    heartbeat_reason: Optional[str] = None,\n    reasoning_content: Optional[\n        List[Union[TextContent, ReasoningContent, RedactedReasoningContent, OmittedReasoningContent | SummarizedReasoningContent]]\n    ] = None,\n    pre_computed_assistant_message_id: Optional[str] = None,\n    llm_batch_item_id: Optional[str] = None,\n    is_approval_response: bool | None = None,\n    # force set request_heartbeat, useful for v2 loop to ensure matching tool rules\n    force_set_request_heartbeat: bool = True,\n    add_heartbeat_on_continue: bool = True,\n)",
          "return_type": "List[Message]",
          "docstring": null,
          "decorators": [],
          "start_line": 366,
          "end_line": 499,
          "is_async": false
        },
        {
          "name": "create_parallel_tool_messages_from_llm_response",
          "signature": "def create_parallel_tool_messages_from_llm_response(\n    agent_id: str,\n    model: str,\n    tool_call_specs: List[Dict[str, Any]],  # List of tool call specs: {\"name\": str, \"arguments\": Dict, \"id\": Optional[str]}\n    tool_execution_results: List[ToolExecutionResult],\n    function_responses: List[Optional[str]],\n    timezone: str,\n    run_id: Optional[str] = None,\n    step_id: Optional[str] = None,\n    reasoning_content: Optional[\n        List[Union[TextContent, ReasoningContent, RedactedReasoningContent, OmittedReasoningContent | SummarizedReasoningContent]]\n    ] = None,\n    pre_computed_assistant_message_id: Optional[str] = None,\n    llm_batch_item_id: Optional[str] = None,\n    is_approval_response: bool = False,\n    tool_returns: List[ToolReturn] = [],\n) -> List[Message]",
          "parameters": "(\n    agent_id: str,\n    model: str,\n    tool_call_specs: List[Dict[str, Any]],  # List of tool call specs: {\"name\": str, \"arguments\": Dict, \"id\": Optional[str]}\n    tool_execution_results: List[ToolExecutionResult],\n    function_responses: List[Optional[str]],\n    timezone: str,\n    run_id: Optional[str] = None,\n    step_id: Optional[str] = None,\n    reasoning_content: Optional[\n        List[Union[TextContent, ReasoningContent, RedactedReasoningContent, OmittedReasoningContent | SummarizedReasoningContent]]\n    ] = None,\n    pre_computed_assistant_message_id: Optional[str] = None,\n    llm_batch_item_id: Optional[str] = None,\n    is_approval_response: bool = False,\n    tool_returns: List[ToolReturn] = [],\n)",
          "return_type": "List[Message]",
          "docstring": "Build two messages representing a parallel tool-call step:\n    - One assistant message with ALL tool_calls populated (tool_call_id left empty)\n    - One tool message with ALL tool_returns populated (tool_call_id left empty)\n\n    Notes:\n    - Consumers should read tool_calls/tool_returns arrays for per-call details.\n    - The tool message's content includes only the first call's packaged response for\n      backward-compatibility with legacy renderers. UIs should prefer tool_returns.\n    - When invoked for an approval response, the assistant message is omitted (the approval\n      tool call was previously surfaced).",
          "decorators": [],
          "start_line": 502,
          "end_line": 611,
          "is_async": false
        },
        {
          "name": "create_heartbeat_system_message",
          "signature": "def create_heartbeat_system_message(\n    agent_id: str,\n    model: str,\n    function_call_success: bool,\n    timezone: str,\n    llm_batch_item_id: Optional[str] = None,\n    heartbeat_reason: Optional[str] = None,\n    run_id: Optional[str] = None,\n) -> Message",
          "parameters": "(\n    agent_id: str,\n    model: str,\n    function_call_success: bool,\n    timezone: str,\n    llm_batch_item_id: Optional[str] = None,\n    heartbeat_reason: Optional[str] = None,\n    run_id: Optional[str] = None,\n)",
          "return_type": "Message",
          "docstring": null,
          "decorators": [],
          "start_line": 614,
          "end_line": 639,
          "is_async": false
        },
        {
          "name": "create_assistant_messages_from_openai_response",
          "signature": "def create_assistant_messages_from_openai_response(\n    response_text: str,\n    agent_id: str,\n    model: str,\n    timezone: str,\n) -> List[Message]",
          "parameters": "(\n    response_text: str,\n    agent_id: str,\n    model: str,\n    timezone: str,\n)",
          "return_type": "List[Message]",
          "docstring": "Converts an OpenAI response into Messages that follow the internal\n    paradigm where LLM responses are structured as tool calls instead of content.",
          "decorators": [],
          "start_line": 642,
          "end_line": 664,
          "is_async": false
        },
        {
          "name": "convert_in_context_letta_messages_to_openai",
          "signature": "def convert_in_context_letta_messages_to_openai(in_context_messages: List[Message], exclude_system_messages: bool = False) -> List[dict]",
          "parameters": "(in_context_messages: List[Message], exclude_system_messages: bool = False)",
          "return_type": "List[dict]",
          "docstring": "Flattens Letta's messages (with system, user, assistant, tool roles, etc.)\n    into standard OpenAI chat messages (system, user, assistant).\n\n    Transformation rules:\n      1. Assistant + send_message tool_call => content = tool_call's \"message\"\n      2. Tool (role=tool) referencing send_message => skip\n      3. User messages might store actual text inside JSON => parse that into content\n      4. System => pass through as normal",
          "decorators": [],
          "start_line": 667,
          "end_line": 747,
          "is_async": false
        },
        {
          "name": "get_user_message_from_chat_completions_request",
          "signature": "def get_user_message_from_chat_completions_request(completion_request: CompletionCreateParams) -> List[MessageCreate]",
          "parameters": "(completion_request: CompletionCreateParams)",
          "return_type": "List[MessageCreate]",
          "docstring": null,
          "decorators": [],
          "start_line": 750,
          "end_line": 774,
          "is_async": false
        },
        {
          "name": "capture_and_persist_messages",
          "signature": "def capture_and_persist_messages(\n    server,\n    agent,\n    actor,\n    user_messages: list[str],\n    assistant_message: str,\n    model: Optional[str] = None,\n) -> Dict[str, Any]",
          "parameters": "(\n    server,\n    agent,\n    actor,\n    user_messages: list[str],\n    assistant_message: str,\n    model: Optional[str] = None,\n)",
          "return_type": "Dict[str, Any]",
          "docstring": "Capture user and assistant messages and persist them to the database.\n\n    Args:\n        server: SyncServer instance\n        agent_id: Agent ID to associate messages with\n        actor: Actor performing the operation\n        user_messages: List of user message texts\n        assistant_message: Assistant response text\n        model: Optional model name used for the response\n\n    Returns:\n        dict with success status, message count, and any run IDs",
          "decorators": [],
          "start_line": 782,
          "end_line": 860,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138684
    },
    "letta/server/static_files/assets/index-048c9598.js": {
      "path": "letta/server/static_files/assets/index-048c9598.js",
      "contentHash": "7529e92f9d6499248686565a3ce95766",
      "mtime": 1767315072068.5454,
      "functions": [
        {
          "name": "t",
          "signature": "function t(l)",
          "parameters": "(l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1,
          "end_line": 1,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "r",
          "signature": "function r(l)",
          "parameters": "(l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1,
          "end_line": 1,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "pc",
          "signature": "function pc(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "lt",
          "signature": "function lt(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Yi",
          "signature": "function Yi()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Vo",
          "signature": "function Vo(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Gi",
          "signature": "function Gi(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "mc",
          "signature": "function mc(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Uo",
          "signature": "function Uo(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "hc",
          "signature": "function hc(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "gl",
          "signature": "function gl(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "yr",
          "signature": "function yr(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "er",
          "signature": "function er(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "vc",
          "signature": "function vc(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 9,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ji",
          "signature": "function Ji(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 17,
          "end_line": 17,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "n",
          "signature": "function n(C,P)",
          "parameters": "(C,P)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 25,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "t",
          "signature": "function t(C)",
          "parameters": "(C)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 25,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "r",
          "signature": "function r(C)",
          "parameters": "(C)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 25,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "l",
          "signature": "function l(C,P)",
          "parameters": "(C,P)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 25,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "d",
          "signature": "function d(C)",
          "parameters": "(C)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 25,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "v",
          "signature": "function v(C)",
          "parameters": "(C)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 25,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "E",
          "signature": "function E(C,P)",
          "parameters": "(C,P)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 25,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ne",
          "signature": "function Ne()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 25,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "it",
          "signature": "function it()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 25,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "hl",
          "signature": "function hl(C)",
          "parameters": "(C)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 25,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "vl",
          "signature": "function vl(C,P)",
          "parameters": "(C,P)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 25,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "y",
          "signature": "function y(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 33,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Tn",
          "signature": "function Tn(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 33,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Jn",
          "signature": "function Jn(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 33,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Nc",
          "signature": "function Nc(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 33,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Pc",
          "signature": "function Pc(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 33,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "zc",
          "signature": "function zc(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 33,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "se",
          "signature": "function se(e,n,t,r,l,o,u)",
          "parameters": "(e,n,t,r,l,o,u)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 33,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Bo",
          "signature": "function Bo(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 33,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Wo",
          "signature": "function Wo(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 33,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "at",
          "signature": "function at(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 33,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "yt",
          "signature": "function yt(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 34,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "kl",
          "signature": "function kl(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": "/**\n * @license React\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */",
          "decorators": [],
          "start_line": 34,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Lc",
          "signature": "function Lc(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Zl",
          "signature": "function Zl(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Tc",
          "signature": "function Tc(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "fn",
          "signature": "function fn(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "us",
          "signature": "function us(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Rc",
          "signature": "function Rc(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "tr",
          "signature": "function tr(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "is",
          "signature": "function is(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Lr",
          "signature": "function Lr(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Xl",
          "signature": "function Xl(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Hu",
          "signature": "function Hu(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ss",
          "signature": "function ss(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Gl",
          "signature": "function Gl(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Uu",
          "signature": "function Uu(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Jl",
          "signature": "function Jl(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Qn",
          "signature": "function Qn(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ql",
          "signature": "function ql(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "$u",
          "signature": "function $u(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "as",
          "signature": "function as(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Au",
          "signature": "function Au(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "cs",
          "signature": "function cs(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "bl",
          "signature": "function bl(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Rt",
          "signature": "function Rt(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ds",
          "signature": "function ds(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ps",
          "signature": "function ps(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "eo",
          "signature": "function eo(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "no",
          "signature": "function no(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Zo",
          "signature": "function Zo(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Bu",
          "signature": "function Bu(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ms",
          "signature": "function ms(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "hs",
          "signature": "function hs()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "vs",
          "signature": "function vs(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ys",
          "signature": "function ys()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "gs",
          "signature": "function gs(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Mt",
          "signature": "function Mt(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Dc",
          "signature": "function Dc(e,n,t,r,l,o,u,i,s)",
          "parameters": "(e,n,t,r,l,o,u,i,s)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ic",
          "signature": "function Ic(e,n,t,r,l,o,u,i,s)",
          "parameters": "(e,n,t,r,l,o,u,i,s)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Vc",
          "signature": "function Vc(e,n,t,r,l,o,u,i,s)",
          "parameters": "(e,n,t,r,l,o,u,i,s)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Rn",
          "signature": "function Rn(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ws",
          "signature": "function ws(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Wu",
          "signature": "function Wu(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Fc",
          "signature": "function Fc(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ss",
          "signature": "function Ss(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ks",
          "signature": "function ks(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Bc",
          "signature": "function Bc(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Kc",
          "signature": "function Kc(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "wt",
          "signature": "function wt(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Or",
          "signature": "function Or(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Yc",
          "signature": "function Yc(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Zc",
          "signature": "function Zc(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "uo",
          "signature": "function uo(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Cl",
          "signature": "function Cl(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Zt",
          "signature": "function Zt(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Xc",
          "signature": "function Xc(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Go",
          "signature": "function Go(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ns",
          "signature": "function Ns(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ku",
          "signature": "function Ku(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ft",
          "signature": "function ft(e,n,t,r,l,o)",
          "parameters": "(e,n,t,r,l,o)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Jc",
          "signature": "function Jc(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Rs",
          "signature": "function Rs(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "wr",
          "signature": "function wr(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Yu",
          "signature": "function Yu(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "qc",
          "signature": "function qc()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "dt",
          "signature": "function dt(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "jt",
          "signature": "function jt(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "bc",
          "signature": "function bc(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ef",
          "signature": "function ef(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "qo",
          "signature": "function qo(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "so",
          "signature": "function so(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ms",
          "signature": "function Ms(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Os",
          "signature": "function Os()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "kr",
          "signature": "function kr(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ir",
          "signature": "function ir()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Zu",
          "signature": "function Zu()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "we",
          "signature": "function we(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "mf",
          "signature": "function mf(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "nu",
          "signature": "function nu()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "js",
          "signature": "function js(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Is",
          "signature": "function Is(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Nf",
          "signature": "function Nf(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Pf",
          "signature": "function Pf(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ei",
          "signature": "function ei(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Vs",
          "signature": "function Vs(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Lf",
          "signature": "function Lf(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "tl",
          "signature": "function tl(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Tf",
          "signature": "function Tf(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ti",
          "signature": "function ti()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Hs",
          "signature": "function Hs(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Rf",
          "signature": "function Rf(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Mf",
          "signature": "function Mf(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Of",
          "signature": "function Of(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Df",
          "signature": "function Df(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "jf",
          "signature": "function jf(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Vt",
          "signature": "function Vt(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ri",
          "signature": "function ri(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "li",
          "signature": "function li(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Us",
          "signature": "function Us(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "$s",
          "signature": "function $s()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ru",
          "signature": "function ru(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "If",
          "signature": "function If(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "oi",
          "signature": "function oi(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "sr",
          "signature": "function sr(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "rl",
          "signature": "function rl(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "pn",
          "signature": "function pn(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ii",
          "signature": "function ii(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Zs",
          "signature": "function Zs(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "D",
          "signature": "function D(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ml",
          "signature": "function Ml(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ft",
          "signature": "function Ft(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Xs",
          "signature": "function Xs(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ol",
          "signature": "function Ol(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ht",
          "signature": "function Ht(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ir",
          "signature": "function Ir(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Mn",
          "signature": "function Mn(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "si",
          "signature": "function si(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 37,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ai",
          "signature": "function ai(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 37,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "cr",
          "signature": "function cr(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Vr",
          "signature": "function Vr()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "mo",
          "signature": "function mo(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Qf",
          "signature": "function Qf(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Dl",
          "signature": "function Dl(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "on",
          "signature": "function on(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "fi",
          "signature": "function fi(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Sn",
          "signature": "function Sn(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Gt",
          "signature": "function Gt(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Fn",
          "signature": "function Fn(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ll",
          "signature": "function ll(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "mn",
          "signature": "function mn(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "j",
          "signature": "function j(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "O",
          "signature": "function O(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "qn",
          "signature": "function qn(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "de",
          "signature": "function de(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Fr",
          "signature": "function Fr()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "di",
          "signature": "function di(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Gs",
          "signature": "function Gs(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Hr",
          "signature": "function Hr(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "pi",
          "signature": "function pi(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Js",
          "signature": "function Js(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Zf",
          "signature": "function Zf(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "hn",
          "signature": "function hn()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "gn",
          "signature": "function gn(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "qs",
          "signature": "function qs(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "lu",
          "signature": "function lu(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ou",
          "signature": "function ou(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "bs",
          "signature": "function bs(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "mi",
          "signature": "function mi(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "go",
          "signature": "function go(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "wo",
          "signature": "function wo(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "hi",
          "signature": "function hi(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "fr",
          "signature": "function fr(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ea",
          "signature": "function ea()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "bn",
          "signature": "function bn()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "uu",
          "signature": "function uu(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ze",
          "signature": "function ze(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "su",
          "signature": "function su()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "au",
          "signature": "function au(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "So",
          "signature": "function So(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Xn",
          "signature": "function Xn(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "xe",
          "signature": "function xe(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "cu",
          "signature": "function cu(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "na",
          "signature": "function na(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ke",
          "signature": "function Ke(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "fu",
          "signature": "function fu(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ta",
          "signature": "function ta(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Be",
          "signature": "function Be(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "un",
          "signature": "function un(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Er",
          "signature": "function Er(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "vi",
          "signature": "function vi(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Wr",
          "signature": "function Wr(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "yi",
          "signature": "function yi(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ko",
          "signature": "function ko(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "gi",
          "signature": "function gi(e,n,t,r,l,o,u)",
          "parameters": "(e,n,t,r,l,o,u)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "la",
          "signature": "function la(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "wi",
          "signature": "function wi(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Eo",
          "signature": "function Eo(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "mt",
          "signature": "function mt(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "dr",
          "signature": "function dr(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Si",
          "signature": "function Si(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "oa",
          "signature": "function oa(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "En",
          "signature": "function En(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "du",
          "signature": "function du(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "nt",
          "signature": "function nt()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ia",
          "signature": "function ia(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "pu",
          "signature": "function pu(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Qr",
          "signature": "function Qr(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "mu",
          "signature": "function mu()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ne",
          "signature": "function ne()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "hu",
          "signature": "function hu(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "vu",
          "signature": "function vu(e,n,t,r,l,o)",
          "parameters": "(e,n,t,r,l,o)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "yu",
          "signature": "function yu()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "je",
          "signature": "function je()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Wt",
          "signature": "function Wt(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Fl",
          "signature": "function Fl(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Hl",
          "signature": "function Hl(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "sa",
          "signature": "function sa()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "aa",
          "signature": "function aa(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ca",
          "signature": "function ca(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "fa",
          "signature": "function fa(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "da",
          "signature": "function da(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "pa",
          "signature": "function pa(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ma",
          "signature": "function ma(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ki",
          "signature": "function ki(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Qt",
          "signature": "function Qt(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ha",
          "signature": "function ha()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "xr",
          "signature": "function xr(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "il",
          "signature": "function il(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ei",
          "signature": "function Ei(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "gu",
          "signature": "function gu(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "va",
          "signature": "function va(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ya",
          "signature": "function ya(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ga",
          "signature": "function ga(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "wa",
          "signature": "function wa(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "wu",
          "signature": "function wu()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Sa",
          "signature": "function Sa(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ka",
          "signature": "function ka(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ea",
          "signature": "function Ea(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Jf",
          "signature": "function Jf(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ca",
          "signature": "function Ca()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "qf",
          "signature": "function qf(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "bf",
          "signature": "function bf(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "xa",
          "signature": "function xa(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Na",
          "signature": "function Na(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 38,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "tt",
          "signature": "function tt(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ul",
          "signature": "function Ul(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Co",
          "signature": "function Co(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Pa",
          "signature": "function Pa(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "za",
          "signature": "function za(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ci",
          "signature": "function Ci(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "xi",
          "signature": "function xi(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "oe",
          "signature": "function oe(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ni",
          "signature": "function Ni(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Pi",
          "signature": "function Pi(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "La",
          "signature": "function La(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ta",
          "signature": "function Ta(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ra",
          "signature": "function Ra(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "xo",
          "signature": "function xo(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "zi",
          "signature": "function zi(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ma",
          "signature": "function Ma(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Li",
          "signature": "function Li(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Po",
          "signature": "function Po(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Oa",
          "signature": "function Oa(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Su",
          "signature": "function Su(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "pr",
          "signature": "function pr(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "od",
          "signature": "function od(e,n,t,r,l,o,u)",
          "parameters": "(e,n,t,r,l,o,u)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ti",
          "signature": "function Ti(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "$l",
          "signature": "function $l(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Da",
          "signature": "function Da(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ye",
          "signature": "function Ye(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ud",
          "signature": "function ud(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ht",
          "signature": "function ht(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "te",
          "signature": "function te(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "id",
          "signature": "function id(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "sd",
          "signature": "function sd(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Bn",
          "signature": "function Bn(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Lo",
          "signature": "function Lo(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "cd",
          "signature": "function cd(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Pt",
          "signature": "function Pt(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "sl",
          "signature": "function sl(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "To",
          "signature": "function To(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Fa",
          "signature": "function Fa(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ha",
          "signature": "function Ha(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Mi",
          "signature": "function Mi(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ro",
          "signature": "function Ro(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Mo",
          "signature": "function Mo(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Xe",
          "signature": "function Xe(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ua",
          "signature": "function Ua(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Oi",
          "signature": "function Oi(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Pe",
          "signature": "function Pe(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "$a",
          "signature": "function $a(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "De",
          "signature": "function De(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "fd",
          "signature": "function fd(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Aa",
          "signature": "function Aa(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Di",
          "signature": "function Di(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ji",
          "signature": "function ji(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ii",
          "signature": "function Ii(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ue",
          "signature": "function ue()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "an",
          "signature": "function an(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Me",
          "signature": "function Me(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "pe",
          "signature": "function pe(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ba",
          "signature": "function Ba(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "jo",
          "signature": "function jo(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Io",
          "signature": "function Io(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "pd",
          "signature": "function pd(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "be",
          "signature": "function be(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Vi",
          "signature": "function Vi(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "xu",
          "signature": "function xu(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ln",
          "signature": "function Ln(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Cn",
          "signature": "function Cn(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Wa",
          "signature": "function Wa(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Qa",
          "signature": "function Qa()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Nu",
          "signature": "function Nu()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Jr",
          "signature": "function Jr(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "md",
          "signature": "function md()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "hd",
          "signature": "function hd()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ka",
          "signature": "function Ka(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ya",
          "signature": "function Ya(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "wn",
          "signature": "function wn(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "vd",
          "signature": "function vd(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Gn",
          "signature": "function Gn()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Fi",
          "signature": "function Fi(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "A",
          "signature": "function A(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "yd",
          "signature": "function yd(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Za",
          "signature": "function Za(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "gd",
          "signature": "function gd(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "wd",
          "signature": "function wd(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ga",
          "signature": "function Ga(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Sd",
          "signature": "function Sd(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ee",
          "signature": "function Ee(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Pu",
          "signature": "function Pu(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "kd",
          "signature": "function kd(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "cn",
          "signature": "function cn(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "zr",
          "signature": "function zr(e,n,t,r,l,o)",
          "parameters": "(e,n,t,r,l,o)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "xn",
          "signature": "function xn(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "cl",
          "signature": "function cl(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Al",
          "signature": "function Al(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Bl",
          "signature": "function Bl(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ed",
          "signature": "function Ed(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "zu",
          "signature": "function zu(e,n,t,r,l,o,u,i,s)",
          "parameters": "(e,n,t,r,l,o,u,i,s)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Cd",
          "signature": "function Cd(e,n,t)",
          "parameters": "(e,n,t)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ja",
          "signature": "function Ja(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "qa",
          "signature": "function qa(e,n,t,r,l,o,u,i,s)",
          "parameters": "(e,n,t,r,l,o,u,i,s)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "fl",
          "signature": "function fl(e,n,t,r)",
          "parameters": "(e,n,t,r)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "qr",
          "signature": "function qr(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Hi",
          "signature": "function Hi(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Lu",
          "signature": "function Lu(e,n)",
          "parameters": "(e,n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "xd",
          "signature": "function xd()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Tu",
          "signature": "function Tu(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "dl",
          "signature": "function dl(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ru",
          "signature": "function Ru(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "pl",
          "signature": "function pl(e)",
          "parameters": "(e)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ui",
          "signature": "function Ui()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ml",
          "signature": "function ml(e,n,t,r,l)",
          "parameters": "(e,n,t,r,l)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "ec",
          "signature": "function ec()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Ld",
          "signature": "function Ld()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Td",
          "signature": "function Td()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        },
        {
          "name": "Rd",
          "signature": "function Rd()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 40,
          "is_async": false,
          "is_generator": false
        }
      ],
      "parsedAt": 1769608138685
    },
    "letta/server/utils.py": {
      "path": "letta/server/utils.py",
      "contentHash": "a268a2cfadd5ad22a00ccdf9754b1183",
      "mtime": 1767315072068.5454,
      "functions": [
        {
          "name": "condition_to_stop_receiving",
          "signature": "def condition_to_stop_receiving(response)",
          "parameters": "(response)",
          "return_type": null,
          "docstring": "Determines when to stop listening to the server",
          "decorators": [],
          "start_line": 1,
          "end_line": 6,
          "is_async": false
        },
        {
          "name": "print_server_response",
          "signature": "def print_server_response(response)",
          "parameters": "(response)",
          "return_type": null,
          "docstring": "Turn response json into a nice print",
          "decorators": [],
          "start_line": 9,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "shorten_key_middle",
          "signature": "def shorten_key_middle(key_string, chars_each_side=3)",
          "parameters": "(key_string, chars_each_side=3)",
          "return_type": null,
          "docstring": "Shortens a key string by showing a specified number of characters on each side and adding an ellipsis in the middle.\n\n    Args:\n    key_string (str): The key string to be shortened.\n    chars_each_side (int): The number of characters to show on each side of the ellipsis.\n\n    Returns:\n    str: The shortened key string with an ellipsis in the middle.",
          "decorators": [],
          "start_line": 29,
          "end_line": 46,
          "is_async": false
        }
      ],
      "parsedAt": 1769608138685
    },
    "letta/server/ws_api/example_client.py": {
      "path": "letta/server/ws_api/example_client.py",
      "contentHash": "38a1731d60cd56da6942f141676e4878",
      "mtime": 1767315072068.5454,
      "functions": [
        {
          "name": "send_message_and_print_replies",
          "signature": "def send_message_and_print_replies(websocket, user_message, agent_id)",
          "parameters": "(websocket, user_message, agent_id)",
          "return_type": null,
          "docstring": "Send a message over websocket protocol and wait for the reply stream to end",
          "decorators": [],
          "start_line": 20,
          "end_line": 37,
          "is_async": true
        },
        {
          "name": "basic_cli_client",
          "signature": "def basic_cli_client()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Basic example of a Letta CLI client that connects to a Letta server.py process via WebSockets\n\n    Meant to illustrate how to use the server.py process, so limited in features (only supports sending user messages)",
          "decorators": [],
          "start_line": 40,
          "end_line": 101,
          "is_async": true
        }
      ],
      "parsedAt": 1769608138685
    },
    "letta/server/ws_api/protocol.py": {
      "path": "letta/server/ws_api/protocol.py",
      "contentHash": "15f5fdb1df81394f9fe3131380050ea3",
      "mtime": 1767315072068.5454,
      "functions": [
        {
          "name": "server_error",
          "signature": "def server_error(msg)",
          "parameters": "(msg)",
          "return_type": null,
          "docstring": "General server error",
          "decorators": [],
          "start_line": 6,
          "end_line": 13,
          "is_async": false
        },
        {
          "name": "server_command_response",
          "signature": "def server_command_response(status)",
          "parameters": "(status)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 16,
          "end_line": 22,
          "is_async": false
        },
        {
          "name": "server_agent_response_error",
          "signature": "def server_agent_response_error(msg)",
          "parameters": "(msg)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 25,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "server_agent_response_start",
          "signature": "def server_agent_response_start()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 39,
          "is_async": false
        },
        {
          "name": "server_agent_response_end",
          "signature": "def server_agent_response_end()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 42,
          "end_line": 47,
          "is_async": false
        },
        {
          "name": "server_agent_internal_monologue",
          "signature": "def server_agent_internal_monologue(msg)",
          "parameters": "(msg)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 50,
          "end_line": 57,
          "is_async": false
        },
        {
          "name": "server_agent_assistant_message",
          "signature": "def server_agent_assistant_message(msg)",
          "parameters": "(msg)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 60,
          "end_line": 67,
          "is_async": false
        },
        {
          "name": "server_agent_function_message",
          "signature": "def server_agent_function_message(msg)",
          "parameters": "(msg)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 70,
          "end_line": 77,
          "is_async": false
        },
        {
          "name": "client_user_message",
          "signature": "def client_user_message(msg, agent_id=None)",
          "parameters": "(msg, agent_id=None)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 83,
          "end_line": 90,
          "is_async": false
        },
        {
          "name": "client_command_create",
          "signature": "def client_command_create(config)",
          "parameters": "(config)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 93,
          "end_line": 100,
          "is_async": false
        }
      ],
      "parsedAt": 1769608138685
    },
    "letta/server/ws_api/server.py": {
      "path": "letta/server/ws_api/server.py",
      "contentHash": "f49b2cbec8f0d2dbb4de43319de18a9b",
      "mtime": 1767315072068.5454,
      "functions": [
        {
          "name": "start_server",
          "signature": "def start_server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 109,
          "end_line": 137,
          "is_async": false
        }
      ],
      "parsedAt": 1769608763533
    },
    "letta/services/block_manager.py": {
      "path": "letta/services/block_manager.py",
      "contentHash": "333ceaf1e6f81a016fabe096d738af2f",
      "mtime": 1768610518530.2002,
      "functions": [
        {
          "name": "validate_block_limit_constraint",
          "signature": "def validate_block_limit_constraint(update_data: dict, existing_block: BlockModel) -> None",
          "parameters": "(update_data: dict, existing_block: BlockModel)",
          "return_type": "None",
          "docstring": "Validates that block limit constraints are satisfied when updating a block.\n\n    Rules:\n    - If limit is being updated, it must be >= the length of the value (existing or new)\n    - If value is being updated, its length must not exceed the limit (existing or new)\n\n    Args:\n        update_data: Dictionary of fields to update\n        existing_block: The current block being updated\n\n    Raises:\n        LettaInvalidArgumentError: If validation fails",
          "decorators": [],
          "start_line": 28,
          "end_line": 59,
          "is_async": false
        },
        {
          "name": "validate_block_creation",
          "signature": "def validate_block_creation(block_data: dict) -> None",
          "parameters": "(block_data: dict)",
          "return_type": "None",
          "docstring": "Validates that block limit constraints are satisfied when creating a block.\n\n    Rules:\n    - If both value and limit are provided, limit must be >= value length\n\n    Args:\n        block_data: Dictionary of block fields for creation\n\n    Raises:\n        LettaInvalidArgumentError: If validation fails",
          "decorators": [],
          "start_line": 62,
          "end_line": 81,
          "is_async": false
        }
      ],
      "parsedAt": 1769608763534
    },
    "letta/services/context_window_calculator/token_counter.py": {
      "path": "letta/services/context_window_calculator/token_counter.py",
      "contentHash": "2fefaafee110961b676fbc1f28474f2d",
      "mtime": 1767315072072.5454,
      "functions": [
        {
          "name": "create_token_counter",
          "signature": "def create_token_counter(\n    model_endpoint_type: ProviderType,\n    model: Optional[str] = None,\n    actor: \"User\" = None,\n    agent_id: Optional[str] = None,\n) -> \"TokenCounter\"",
          "parameters": "(\n    model_endpoint_type: ProviderType,\n    model: Optional[str] = None,\n    actor: \"User\" = None,\n    agent_id: Optional[str] = None,\n)",
          "return_type": "\"TokenCounter\"",
          "docstring": "Factory function to create the appropriate token counter based on model configuration.\n\n    Returns:\n        The appropriate TokenCounter instance",
          "decorators": [],
          "start_line": 269,
          "end_line": 317,
          "is_async": false
        }
      ],
      "parsedAt": 1769608763534
    },
    "letta/services/file_processor/file_types.py": {
      "path": "letta/services/file_processor/file_types.py",
      "contentHash": "ef4269d8b05f801aac7cc38777d9b901",
      "mtime": 1767315072072.5454,
      "functions": [
        {
          "name": "register_mime_types",
          "signature": "def register_mime_types() -> None",
          "parameters": "()",
          "return_type": "None",
          "docstring": "Register all supported file types with Python's mimetypes module.",
          "decorators": [],
          "start_line": 282,
          "end_line": 284,
          "is_async": false
        },
        {
          "name": "get_allowed_media_types",
          "signature": "def get_allowed_media_types() -> Set[str]",
          "parameters": "()",
          "return_type": "Set[str]",
          "docstring": "Get set of all allowed MIME types for file uploads.",
          "decorators": [],
          "start_line": 287,
          "end_line": 289,
          "is_async": false
        },
        {
          "name": "get_extension_to_mime_type_map",
          "signature": "def get_extension_to_mime_type_map() -> Dict[str, str]",
          "parameters": "()",
          "return_type": "Dict[str, str]",
          "docstring": "Get mapping from file extensions to MIME types.",
          "decorators": [],
          "start_line": 292,
          "end_line": 294,
          "is_async": false
        },
        {
          "name": "get_simple_text_mime_types",
          "signature": "def get_simple_text_mime_types() -> Set[str]",
          "parameters": "()",
          "return_type": "Set[str]",
          "docstring": "Get set of MIME types that represent simple text files.",
          "decorators": [],
          "start_line": 297,
          "end_line": 299,
          "is_async": false
        },
        {
          "name": "is_simple_text_mime_type",
          "signature": "def is_simple_text_mime_type(mime_type: str) -> bool",
          "parameters": "(mime_type: str)",
          "return_type": "bool",
          "docstring": "Check if a MIME type represents simple text.",
          "decorators": [],
          "start_line": 302,
          "end_line": 304,
          "is_async": false
        }
      ],
      "parsedAt": 1769608763534
    },
    "letta/services/graphiti_archival_memory.py": {
      "path": "letta/services/graphiti_archival_memory.py",
      "contentHash": "35bad2a9e1b1fc962eac5a2bb7fa9be2",
      "mtime": 1751863219390.7659,
      "functions": [
        {
          "name": "create_graphiti_archival_tools",
          "signature": "def create_graphiti_archival_tools(graphiti_memory: GraphitiArchivalMemory) -> List[Tool]",
          "parameters": "(graphiti_memory: GraphitiArchivalMemory)",
          "return_type": "List[Tool]",
          "docstring": "Create the archival memory tools that agents can use",
          "decorators": [],
          "start_line": 238,
          "end_line": 320,
          "is_async": false
        }
      ],
      "parsedAt": 1769608763534
    },
    "letta/services/group_manager.py": {
      "path": "letta/services/group_manager.py",
      "contentHash": "4b749fa0f15a135d95103a980a49606e",
      "mtime": 1768610518530.2002,
      "functions": [
        {
          "name": "ursor_filter(s",
          "signature": "def ursor_filter(sort_col, id_col, ref_sort_col, ref_id, forward: bool):\n",
          "parameters": "ort_col, id_col, ref_sort_col, ref_id, forward: bool):\n",
          "return_type": null,
          "docstring": "\"\n    Returns a SQLAlchemy filter expression for cursor-based pagination for groups.\n\n    If `forward` is True, returns records after the reference.\n    If `forward` is False, returns records before the reference.\n    \"\"\"",
          "decorators": [],
          "start_line": 498,
          "end_line": 514,
          "is_async": false
        },
        {
          "name": "pply_group_pagination_async(q",
          "signature": "def pply_group_pagination_async(query, before: Optional[str], after: Optional[str], session, ascending: bool = True) - -> y:\n",
          "parameters": "uery, before: Optional[str], after: Optional[str], session, ascending: bool = True) -",
          "return_type": "y:\n",
          "docstring": "\"Apply cursor-based pagination to group queries.\"\"\"",
          "decorators": [],
          "start_line": 517,
          "end_line": 542,
          "is_async": true
        }
      ],
      "parsedAt": 1769608763534
    },
    "letta/services/helpers/agent_manager_helper.py": {
      "path": "letta/services/helpers/agent_manager_helper.py",
      "contentHash": "583e12bd8856e184a417d854b98c812b",
      "mtime": 1768610518534.2002,
      "functions": [
        {
          "name": "derive_system_message",
          "signature": "def derive_system_message(agent_type: AgentType, enable_sleeptime: Optional[bool] = None, system: Optional[str] = None) -> str",
          "parameters": "(agent_type: AgentType, enable_sleeptime: Optional[bool] = None, system: Optional[str] = None)",
          "return_type": "str",
          "docstring": "Derive the appropriate system message based on agent type and configuration.\n\n    This function determines which system prompt template to use based on the\n    agent's type and whether sleeptime functionality is enabled. If a custom\n    system message is provided, it returns that instead.\n\n    Args:\n        agent_type: The type of agent (e.g., memgpt_agent, sleeptime_agent, react_agent)\n        enable_sleeptime: Whether sleeptime tools should be available (affects prompt choice)\n        system: Optional custom system message to use instead of defaults\n\n    Returns:\n        The system message string appropriate for the agent configuration\n\n    Raises:\n        ValueError: If an invalid or unsupported agent type is provided",
          "decorators": [],
          "start_line": 164,
          "end_line": 226,
          "is_async": false
        },
        {
          "name": "safe_format",
          "signature": "def safe_format(template: str, variables: dict) -> str",
          "parameters": "(template: str, variables: dict)",
          "return_type": "str",
          "docstring": "Safely formats a template string, preserving empty {} and {unknown_vars}\n    while substituting known variables.\n\n    If we simply use {} in format_map, it'll be treated as a positional field",
          "decorators": [],
          "start_line": 236,
          "end_line": 247,
          "is_async": false
        },
        {
          "name": "compile_system_message",
          "signature": "def compile_system_message(\n    system_prompt: str,\n    in_context_memory: Memory,\n    in_context_memory_last_edit: datetime,  # TODO move this inside of BaseMemory?\n    timezone: str,\n    user_defined_variables: Optional[dict] = None,\n    append_icm_if_missing: bool = True,\n    template_format: Literal[\"f-string\", \"mustache\"] = \"f-string\",\n    previous_message_count: int = 0,\n    archival_memory_size: int | None = 0,\n    tool_rules_solver: Optional[ToolRulesSolver] = None,\n    sources: Optional[List] = None,\n    max_files_open: Optional[int] = None,\n    llm_config: Optional[object] = None,\n) -> str",
          "parameters": "(\n    system_prompt: str,\n    in_context_memory: Memory,\n    in_context_memory_last_edit: datetime,  # TODO move this inside of BaseMemory?\n    timezone: str,\n    user_defined_variables: Optional[dict] = None,\n    append_icm_if_missing: bool = True,\n    template_format: Literal[\"f-string\", \"mustache\"] = \"f-string\",\n    previous_message_count: int = 0,\n    archival_memory_size: int | None = 0,\n    tool_rules_solver: Optional[ToolRulesSolver] = None,\n    sources: Optional[List] = None,\n    max_files_open: Optional[int] = None,\n    llm_config: Optional[object] = None,\n)",
          "return_type": "str",
          "docstring": "Prepare the final/full system message that will be fed into the LLM API\n\n    The base system message may be templated, in which case we need to render the variables.\n\n    The following are reserved variables:\n      - CORE_MEMORY: the in-context memory of the LLM",
          "decorators": [
            "@trace_method"
          ],
          "start_line": 251,
          "end_line": 328,
          "is_async": false
        },
        {
          "name": "initialize_message_sequence",
          "signature": "def initialize_message_sequence(\n    agent_state: AgentState,\n    memory_edit_timestamp: Optional[datetime] = None,\n    include_initial_boot_message: bool = True,\n    previous_message_count: int = 0,\n    archival_memory_size: int = 0,\n) -> List[dict]",
          "parameters": "(\n    agent_state: AgentState,\n    memory_edit_timestamp: Optional[datetime] = None,\n    include_initial_boot_message: bool = True,\n    previous_message_count: int = 0,\n    archival_memory_size: int = 0,\n)",
          "return_type": "List[dict]",
          "docstring": null,
          "decorators": [
            "@trace_method"
          ],
          "start_line": 332,
          "end_line": 398,
          "is_async": false
        },
        {
          "name": "initialize_message_sequence_async",
          "signature": "def initialize_message_sequence_async(\n    agent_state: AgentState,\n    memory_edit_timestamp: Optional[datetime] = None,\n    include_initial_boot_message: bool = True,\n    previous_message_count: int = 0,\n    archival_memory_size: int = 0,\n) -> List[dict]",
          "parameters": "(\n    agent_state: AgentState,\n    memory_edit_timestamp: Optional[datetime] = None,\n    include_initial_boot_message: bool = True,\n    previous_message_count: int = 0,\n    archival_memory_size: int = 0,\n)",
          "return_type": "List[dict]",
          "docstring": null,
          "decorators": [
            "@trace_method"
          ],
          "start_line": 402,
          "end_line": 471,
          "is_async": true
        },
        {
          "name": "package_initial_message_sequence",
          "signature": "def package_initial_message_sequence(\n    agent_id: str, initial_message_sequence: List[MessageCreate], model: str, timezone: str, actor: User\n) -> List[Message]",
          "parameters": "(\n    agent_id: str, initial_message_sequence: List[MessageCreate], model: str, timezone: str, actor: User\n)",
          "return_type": "List[Message]",
          "docstring": null,
          "decorators": [],
          "start_line": 474,
          "end_line": 561,
          "is_async": false
        },
        {
          "name": "check_supports_structured_output",
          "signature": "def check_supports_structured_output(model: str, tool_rules: List[ToolRule]) -> bool",
          "parameters": "(model: str, tool_rules: List[ToolRule])",
          "return_type": "bool",
          "docstring": null,
          "decorators": [],
          "start_line": 564,
          "end_line": 570,
          "is_async": false
        },
        {
          "name": "get_column_names_from_includes_params",
          "signature": "def get_column_names_from_includes_params(\n    include_relationships: Optional[List[str]] = None, includes: Optional[List[str]] = None\n) -> Set[str]",
          "parameters": "(\n    include_relationships: Optional[List[str]] = None, includes: Optional[List[str]] = None\n)",
          "return_type": "Set[str]",
          "docstring": null,
          "decorators": [],
          "start_line": 821,
          "end_line": 849,
          "is_async": false
        },
        {
          "name": "build_passage_query",
          "signature": "def build_passage_query(\n    actor: User,\n    agent_id: Optional[str] = None,\n    file_id: Optional[str] = None,\n    query_text: Optional[str] = None,\n    start_date: Optional[datetime] = None,\n    end_date: Optional[datetime] = None,\n    before: Optional[str] = None,\n    after: Optional[str] = None,\n    source_id: Optional[str] = None,\n    embed_query: bool = False,\n    ascending: bool = True,\n    embedding_config: Optional[EmbeddingConfig] = None,\n    agent_only: bool = False,\n) -> Select",
          "parameters": "(\n    actor: User,\n    agent_id: Optional[str] = None,\n    file_id: Optional[str] = None,\n    query_text: Optional[str] = None,\n    start_date: Optional[datetime] = None,\n    end_date: Optional[datetime] = None,\n    before: Optional[str] = None,\n    after: Optional[str] = None,\n    source_id: Optional[str] = None,\n    embed_query: bool = False,\n    ascending: bool = True,\n    embedding_config: Optional[EmbeddingConfig] = None,\n    agent_only: bool = False,\n)",
          "return_type": "Select",
          "docstring": "Helper function to build the base passage query with all filters applied.\n    Supports both before and after pagination across merged source and agent passages.\n\n    Returns the query before any limit or count operations are applied.",
          "decorators": [],
          "start_line": 852,
          "end_line": 1068,
          "is_async": true
        },
        {
          "name": "build_source_passage_query",
          "signature": "def build_source_passage_query(\n    actor: User,\n    agent_id: Optional[str] = None,\n    file_id: Optional[str] = None,\n    query_text: Optional[str] = None,\n    start_date: Optional[datetime] = None,\n    end_date: Optional[datetime] = None,\n    before: Optional[str] = None,\n    after: Optional[str] = None,\n    source_id: Optional[str] = None,\n    embed_query: bool = False,\n    ascending: bool = True,\n    embedding_config: Optional[EmbeddingConfig] = None,\n) -> Select",
          "parameters": "(\n    actor: User,\n    agent_id: Optional[str] = None,\n    file_id: Optional[str] = None,\n    query_text: Optional[str] = None,\n    start_date: Optional[datetime] = None,\n    end_date: Optional[datetime] = None,\n    before: Optional[str] = None,\n    after: Optional[str] = None,\n    source_id: Optional[str] = None,\n    embed_query: bool = False,\n    ascending: bool = True,\n    embedding_config: Optional[EmbeddingConfig] = None,\n)",
          "return_type": "Select",
          "docstring": "Build query for source passages with all filters applied.",
          "decorators": [],
          "start_line": 1071,
          "end_line": 1174,
          "is_async": true
        },
        {
          "name": "build_agent_passage_query",
          "signature": "def build_agent_passage_query(\n    actor: User,\n    agent_id: Optional[str] = None,\n    archive_id: Optional[str] = None,\n    query_text: Optional[str] = None,\n    start_date: Optional[datetime] = None,\n    end_date: Optional[datetime] = None,\n    before: Optional[str] = None,\n    after: Optional[str] = None,\n    embed_query: bool = False,\n    ascending: bool = True,\n    embedding_config: Optional[EmbeddingConfig] = None,\n) -> Select",
          "parameters": "(\n    actor: User,\n    agent_id: Optional[str] = None,\n    archive_id: Optional[str] = None,\n    query_text: Optional[str] = None,\n    start_date: Optional[datetime] = None,\n    end_date: Optional[datetime] = None,\n    before: Optional[str] = None,\n    after: Optional[str] = None,\n    embed_query: bool = False,\n    ascending: bool = True,\n    embedding_config: Optional[EmbeddingConfig] = None,\n)",
          "return_type": "Select",
          "docstring": "Build query for agent/archive passages with all filters applied.\n\n    Can provide agent_id, archive_id, both, or neither (org-wide search).\n    If both are provided, agent_id takes precedence.",
          "decorators": [],
          "start_line": 1177,
          "end_line": 1292,
          "is_async": true
        },
        {
          "name": "calculate_base_tools",
          "signature": "def calculate_base_tools(is_v2: bool) -> Set[str]",
          "parameters": "(is_v2: bool)",
          "return_type": "Set[str]",
          "docstring": null,
          "decorators": [],
          "start_line": 1295,
          "end_line": 1299,
          "is_async": false
        },
        {
          "name": "calculate_multi_agent_tools",
          "signature": "def calculate_multi_agent_tools() -> Set[str]",
          "parameters": "()",
          "return_type": "Set[str]",
          "docstring": "Calculate multi-agent tools, excluding local-only tools in production environment.",
          "decorators": [],
          "start_line": 1302,
          "end_line": 1307,
          "is_async": false
        },
        {
          "name": "validate_agent_exists_async",
          "signature": "def validate_agent_exists_async(session, agent_id: str, actor: User) -> None",
          "parameters": "(session, agent_id: str, actor: User)",
          "return_type": "None",
          "docstring": "Validate that an agent exists and user has access to it using raw SQL for efficiency.\n\n    Args:\n        session: Database session\n        agent_id: ID of the agent to validate\n        actor: User performing the action\n\n    Raises:\n        NoResultFound: If agent doesn't exist or user doesn't have access",
          "decorators": [
            "@trace_method"
          ],
          "start_line": 1311,
          "end_line": 1329,
          "is_async": true
        }
      ],
      "parsedAt": 1769608763535
    },
    "letta/services/helpers/tool_execution_helper.py": {
      "path": "letta/services/helpers/tool_execution_helper.py",
      "contentHash": "b4e6f59f7faf6891269e7c723e70fb93",
      "mtime": 1767315072076.5457,
      "functions": [
        {
          "name": "find_python_executable",
          "signature": "def find_python_executable(local_configs: LocalSandboxConfig) -> str",
          "parameters": "(local_configs: LocalSandboxConfig)",
          "return_type": "str",
          "docstring": "Determines the Python executable path based on sandbox configuration and platform.\n    Resolves any '~' (tilde) paths to absolute paths.\n\n    Returns:\n        str: Full path to the Python binary.",
          "decorators": [],
          "start_line": 20,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "run_subprocess",
          "signature": "def run_subprocess(command: list, env: Optional[Dict[str, str]] = None, fail_msg: str = \"Command failed\")",
          "parameters": "(command: list, env: Optional[Dict[str, str]] = None, fail_msg: str = \"Command failed\")",
          "return_type": null,
          "docstring": "Helper to execute a subprocess with logging and error handling.\n\n    Args:\n        command (list): The command to run as a list of arguments.\n        env (dict, optional): The environment variables to use for the process.\n        fail_msg (str): The error message to log in case of failure.\n\n    Raises:\n        RuntimeError: If the subprocess execution fails.",
          "decorators": [],
          "start_line": 46,
          "end_line": 68,
          "is_async": false
        },
        {
          "name": "ensure_pip_is_up_to_date",
          "signature": "def ensure_pip_is_up_to_date(python_exec: str, env: Optional[Dict[str, str]] = None)",
          "parameters": "(python_exec: str, env: Optional[Dict[str, str]] = None)",
          "return_type": null,
          "docstring": "Ensures pip, setuptools, and wheel are up to date before installing any other dependencies.\n\n    Args:\n        python_exec (str): Path to the Python executable to use.\n        env (dict, optional): Environment variables to pass to subprocess.",
          "decorators": [],
          "start_line": 71,
          "end_line": 83,
          "is_async": false
        },
        {
          "name": "install_pip_requirements_for_sandbox",
          "signature": "def install_pip_requirements_for_sandbox(\n    local_configs: LocalSandboxConfig,\n    upgrade: bool = True,\n    user_install_if_no_venv: bool = False,\n    env: Optional[Dict[str, str]] = None,\n    tool: Optional[\"Tool\"] = None,\n)",
          "parameters": "(\n    local_configs: LocalSandboxConfig,\n    upgrade: bool = True,\n    user_install_if_no_venv: bool = False,\n    env: Optional[Dict[str, str]] = None,\n    tool: Optional[\"Tool\"] = None,\n)",
          "return_type": null,
          "docstring": "Installs the specified pip requirements inside the correct environment (venv or system).\n    Installs both sandbox-level and tool-specific pip requirements.",
          "decorators": [],
          "start_line": 86,
          "end_line": 147,
          "is_async": false
        },
        {
          "name": "create_venv_for_local_sandbox",
          "signature": "def create_venv_for_local_sandbox(sandbox_dir_path: str, venv_path: str, env: Dict[str, str], force_recreate: bool)",
          "parameters": "(sandbox_dir_path: str, venv_path: str, env: Dict[str, str], force_recreate: bool)",
          "return_type": null,
          "docstring": "Creates a virtual environment for the sandbox. If force_recreate is True, deletes and recreates the venv.\n\n    Args:\n        sandbox_dir_path (str): Path to the sandbox directory.\n        venv_path (str): Path to the virtual environment directory.\n        env (dict): Environment variables to use.\n        force_recreate (bool): If True, delete and recreate the virtual environment.",
          "decorators": [],
          "start_line": 150,
          "end_line": 192,
          "is_async": false
        },
        {
          "name": "add_imports_and_pydantic_schemas_for_args",
          "signature": "def add_imports_and_pydantic_schemas_for_args(args_json_schema: dict) -> str",
          "parameters": "(args_json_schema: dict)",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 195,
          "end_line": 206,
          "is_async": false
        },
        {
          "name": "prepare_local_sandbox",
          "signature": "def prepare_local_sandbox(\n    local_cfg: LocalSandboxConfig,\n    env: Dict[str, str],\n    force_recreate: bool = False,\n) -> None",
          "parameters": "(\n    local_cfg: LocalSandboxConfig,\n    env: Dict[str, str],\n    force_recreate: bool = False,\n)",
          "return_type": "None",
          "docstring": "Ensure the sandbox virtual-env is freshly created and that\n    requirements are installed.  Uses your existing helpers.",
          "decorators": [],
          "start_line": 209,
          "end_line": 233,
          "is_async": false
        }
      ],
      "parsedAt": 1769608763535
    },
    "letta/services/helpers/tool_parser_helper.py": {
      "path": "letta/services/helpers/tool_parser_helper.py",
      "contentHash": "0412d599d8f3eec7234cb0f41e1084d8",
      "mtime": 1767315072076.5457,
      "functions": [
        {
          "name": "parse_stdout_best_effort",
          "signature": "def parse_stdout_best_effort(text: Union[str, bytes]) -> tuple[Any, AgentState | None]",
          "parameters": "(text: Union[str, bytes])",
          "return_type": "tuple[Any, AgentState | None]",
          "docstring": "Decode and unpickle the result from the function execution if possible.\n    Returns (function_return_value, agent_state).",
          "decorators": [],
          "start_line": 12,
          "end_line": 23,
          "is_async": false
        },
        {
          "name": "parse_function_arguments",
          "signature": "def parse_function_arguments(source_code: str, tool_name: str)",
          "parameters": "(source_code: str, tool_name: str)",
          "return_type": null,
          "docstring": "Get arguments of a function from its source code",
          "decorators": [],
          "start_line": 26,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "convert_param_to_str_value",
          "signature": "def convert_param_to_str_value(param_type: str, raw_value: JsonValue) -> str",
          "parameters": "(param_type: str, raw_value: JsonValue)",
          "return_type": "str",
          "docstring": "Convert parameter to Python code representation based on JSON schema type.\n    TODO (cliandy): increase sanitization checks here to fail at the right place",
          "decorators": [],
          "start_line": 38,
          "end_line": 66,
          "is_async": false
        },
        {
          "name": "runtime_override_tool_json_schema",
          "signature": "def runtime_override_tool_json_schema(\n    tool_list: list[JsonDict],\n    response_format: ResponseFormatUnion | None,\n    request_heartbeat: bool = True,\n    terminal_tools: set[str] | None = None,\n) -> list[JsonDict]",
          "parameters": "(\n    tool_list: list[JsonDict],\n    response_format: ResponseFormatUnion | None,\n    request_heartbeat: bool = True,\n    terminal_tools: set[str] | None = None,\n)",
          "return_type": "list[JsonDict]",
          "docstring": "Override the tool JSON schemas at runtime if certain conditions are met.\n\n    Cases:\n        1. We will inject `send_message` tool calls with `response_format` if provided\n        2. Tools will have an additional `request_heartbeat` parameter added (except for terminal tools).",
          "decorators": [],
          "start_line": 69,
          "end_line": 104,
          "is_async": false
        }
      ],
      "parsedAt": 1769608763535
    },
    "letta/services/mcp/oauth_utils.py": {
      "path": "letta/services/mcp/oauth_utils.py",
      "contentHash": "17f74e03e7d6027951d10f072e5c7304",
      "mtime": 1768610518534.2002,
      "functions": [
        {
          "name": "create_oauth_provider",
          "signature": "def create_oauth_provider(\n    session_id: str,\n    server_url: str,\n    redirect_uri: str,\n    mcp_manager: \"MCPManager\",\n    actor: PydanticUser,\n    logo_uri: Optional[str] = None,\n    url_callback: Optional[Callable[[str], None]] = None,\n) -> OAuthClientProvider",
          "parameters": "(\n    session_id: str,\n    server_url: str,\n    redirect_uri: str,\n    mcp_manager: \"MCPManager\",\n    actor: PydanticUser,\n    logo_uri: Optional[str] = None,\n    url_callback: Optional[Callable[[str], None]] = None,\n)",
          "return_type": "OAuthClientProvider",
          "docstring": "Create an OAuth provider for MCP server authentication.\n\n    DEPRECATED: Use ServerSideOAuth from letta.services.mcp.server_side_oauth instead.\n    This function is kept for backwards compatibility but will be removed in a future version.",
          "decorators": [],
          "start_line": 188,
          "end_line": 254,
          "is_async": true
        },
        {
          "name": "cleanup_expired_oauth_sessions",
          "signature": "def cleanup_expired_oauth_sessions(max_age_hours: int = 24) -> None",
          "parameters": "(max_age_hours: int = 24)",
          "return_type": "None",
          "docstring": "Clean up expired OAuth sessions.",
          "decorators": [],
          "start_line": 257,
          "end_line": 269,
          "is_async": true
        },
        {
          "name": "oauth_stream_event",
          "signature": "def oauth_stream_event(event: OauthStreamEvent, **kwargs) -> str",
          "parameters": "(event: OauthStreamEvent, **kwargs)",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 272,
          "end_line": 275,
          "is_async": false
        },
        {
          "name": "drill_down_exception",
          "signature": "def drill_down_exception(exception, depth=0, max_depth=5)",
          "parameters": "(exception, depth=0, max_depth=5)",
          "return_type": null,
          "docstring": "Recursively drill down into nested exceptions to find the root cause",
          "decorators": [],
          "start_line": 278,
          "end_line": 315,
          "is_async": false
        }
      ],
      "parsedAt": 1769608763535
    },
    "letta/services/message_manager.py": {
      "path": "letta/services/message_manager.py",
      "contentHash": "97ca6aea43ebbbac5fae42c10c42b60b",
      "mtime": 1768610518534.2002,
      "functions": [
        {
          "name": "backfill_missing_tool_call_ids",
          "signature": "def backfill_missing_tool_call_ids(messages: list, agent_id: Optional[str] = None, actor: Optional[PydanticUser] = None) -> list",
          "parameters": "(messages: list, agent_id: Optional[str] = None, actor: Optional[PydanticUser] = None)",
          "return_type": "list",
          "docstring": "Backfill missing tool_call_id values in tool messages from historical bug (oct 1-6, 2025)\n\n    Args:\n        messages: List of messages to backfill\n        agent_id: Optional agent ID for logging\n        actor: Optional actor information for logging\n\n    Returns:\n        List of messages with tool_call_ids backfilled where appropriate",
          "decorators": [
            "@trace_method"
          ],
          "start_line": 30,
          "end_line": 119,
          "is_async": false
        }
      ],
      "parsedAt": 1769608839135
    },
    "letta/services/passage_manager.py": {
      "path": "letta/services/passage_manager.py",
      "contentHash": "7d9dd2430e0d6df05190fbf3cadead53",
      "mtime": 1768610518534.2002,
      "functions": [
        {
          "name": "get_openai_embedding",
          "signature": "def get_openai_embedding(text: str, model: str, endpoint: str) -> List[float]",
          "parameters": "(text: str, model: str, endpoint: str)",
          "return_type": "List[float]",
          "docstring": null,
          "decorators": [
            "@lru_cache(maxsize=8192)"
          ],
          "start_line": 36,
          "end_line": 41,
          "is_async": false
        },
        {
          "name": "get_openai_embedding_async",
          "signature": "def get_openai_embedding_async(text: str, model: str, endpoint: str) -> list[float]",
          "parameters": "(text: str, model: str, endpoint: str)",
          "return_type": "list[float]",
          "docstring": null,
          "decorators": [
            "@async_redis_cache(key_func=lambda text, model, endpoint: f\"{model}:{endpoint}:{text}\")"
          ],
          "start_line": 45,
          "end_line": 50,
          "is_async": true
        }
      ],
      "parsedAt": 1769608839136
    },
    "letta/services/sandbox_credentials_service_test.py": {
      "path": "letta/services/sandbox_credentials_service_test.py",
      "contentHash": "8d267ed730a7277ced74387eec3cc673",
      "mtime": 1767315072080.546,
      "functions": [
        {
          "name": "test_credentials_not_configured",
          "signature": "def test_credentials_not_configured()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that credentials fetch returns empty dict when URL is not configured.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 23,
          "end_line": 29,
          "is_async": true
        },
        {
          "name": "test_credentials_fetch_success",
          "signature": "def test_credentials_fetch_success()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test successful credentials fetch.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 33,
          "end_line": 62,
          "is_async": true
        },
        {
          "name": "test_credentials_fetch_without_auth",
          "signature": "def test_credentials_fetch_without_auth()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test credentials fetch without authentication key.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 66,
          "end_line": 86,
          "is_async": true
        },
        {
          "name": "test_credentials_fetch_timeout",
          "signature": "def test_credentials_fetch_timeout()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test credentials fetch timeout handling.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 90,
          "end_line": 104,
          "is_async": true
        },
        {
          "name": "test_credentials_fetch_http_error",
          "signature": "def test_credentials_fetch_http_error()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test credentials fetch HTTP error handling.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 108,
          "end_line": 128,
          "is_async": true
        },
        {
          "name": "test_credentials_fetch_invalid_response",
          "signature": "def test_credentials_fetch_invalid_response()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test credentials fetch with invalid response format.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 132,
          "end_line": 149,
          "is_async": true
        }
      ],
      "parsedAt": 1769608839136
    },
    "letta/services/summarizer/summarizer.py": {
      "path": "letta/services/summarizer/summarizer.py",
      "contentHash": "703aa300adc23f0b87c43dfe70229238",
      "mtime": 1768610518538.2002,
      "functions": [
        {
          "name": "simple_formatter",
          "signature": "def simple_formatter(\n    messages: List[Message],\n    include_system: bool = False,\n    tool_return_truncation_chars: int | None = None,\n) -> str",
          "parameters": "(\n    messages: List[Message],\n    include_system: bool = False,\n    tool_return_truncation_chars: int | None = None,\n)",
          "return_type": "str",
          "docstring": "Go from an OpenAI-style list of messages to a concatenated string.\n\n    Optionally clamps tool-return content to avoid ballooning the summarizer transcript.",
          "decorators": [],
          "start_line": 306,
          "end_line": 320,
          "is_async": false
        },
        {
          "name": "middle_truncate_text",
          "signature": "def middle_truncate_text(\n    text: str,\n    budget_chars: int,\n    head_frac: float = 0.3,\n    tail_frac: float = 0.3,\n) -> tuple[str, int]",
          "parameters": "(\n    text: str,\n    budget_chars: int,\n    head_frac: float = 0.3,\n    tail_frac: float = 0.3,\n)",
          "return_type": "tuple[str, int]",
          "docstring": "Middle-truncate a string to fit within a character budget.\n\n    Keeps the first `head_frac` and last `tail_frac` portions (by budget chars)\n    and drops the middle. Returns (truncated_text, dropped_char_count).\n\n    Fractions are relative to budget, not original text length.",
          "decorators": [],
          "start_line": 323,
          "end_line": 357,
          "is_async": false
        },
        {
          "name": "build_summary_request_text",
          "signature": "def build_summary_request_text(retain_count: int, evicted_messages: List[str], in_context_messages: List[str]) -> str",
          "parameters": "(retain_count: int, evicted_messages: List[str], in_context_messages: List[str])",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 360,
          "end_line": 381,
          "is_async": false
        }
      ],
      "parsedAt": 1769608839136
    },
    "letta/services/summarizer/summarizer_all.py": {
      "path": "letta/services/summarizer/summarizer_all.py",
      "contentHash": "01ce8db7c460a705a86731be70fa4031",
      "mtime": 1767315072084.546,
      "functions": [
        {
          "name": "summarize_all",
          "signature": "def summarize_all(\n    # Required to tag LLM calls\n    actor: User,\n    # LLM config for the summarizer model\n    llm_config: LLMConfig,\n    # Actual summarization configuration\n    summarizer_config: CompactionSettings,\n    in_context_messages: List[Message],\n    # new_messages: List[Message],\n) -> str",
          "parameters": "(\n    # Required to tag LLM calls\n    actor: User,\n    # LLM config for the summarizer model\n    llm_config: LLMConfig,\n    # Actual summarization configuration\n    summarizer_config: CompactionSettings,\n    in_context_messages: List[Message],\n    # new_messages: List[Message],\n)",
          "return_type": "str",
          "docstring": "Summarize the entire conversation history into a single summary.\n\n    Returns:\n    - The summary string",
          "decorators": [
            "@trace_method"
          ],
          "start_line": 15,
          "end_line": 56,
          "is_async": true
        }
      ],
      "parsedAt": 1769608839136
    },
    "letta/services/summarizer/summarizer_sliding_window.py": {
      "path": "letta/services/summarizer/summarizer_sliding_window.py",
      "contentHash": "3d3726451304ce71b3289648165cd95b",
      "mtime": 1767315072084.546,
      "functions": [
        {
          "name": "count_tokens",
          "signature": "def count_tokens(actor: User, llm_config: LLMConfig, messages: List[Message]) -> int",
          "parameters": "(actor: User, llm_config: LLMConfig, messages: List[Message])",
          "return_type": "int",
          "docstring": "Count tokens in messages using the appropriate token counter for the model configuration.",
          "decorators": [],
          "start_line": 27,
          "end_line": 42,
          "is_async": true
        },
        {
          "name": "summarize_via_sliding_window",
          "signature": "def summarize_via_sliding_window(\n    # Required to tag LLM calls\n    actor: User,\n    # Actual summarization configuration\n    llm_config: LLMConfig,\n    summarizer_config: CompactionSettings,\n    in_context_messages: List[Message],\n    # new_messages: List[Message],\n) -> Tuple[str, List[Message]]",
          "parameters": "(\n    # Required to tag LLM calls\n    actor: User,\n    # Actual summarization configuration\n    llm_config: LLMConfig,\n    summarizer_config: CompactionSettings,\n    in_context_messages: List[Message],\n    # new_messages: List[Message],\n)",
          "return_type": "Tuple[str, List[Message]]",
          "docstring": "If the total tokens is greater than the context window limit (or force=True),\n    then summarize and rearrange the in-context messages (with the summary in front).\n\n    Finding the summarization cutoff point (target of final post-summarize count is N% of configured context window):\n    1. Start at a message index cutoff (1-N%)\n    2. Count tokens with system prompt, prior summary (if it exists), and messages past cutoff point (messages[0] + messages[cutoff:])\n    3. Is count(post_sum_messages) <= N% of configured context window?\n      3a. Yes -> create new summary with [prior summary, cutoff:], and safety truncate summary with char count\n      3b. No -> increment cutoff by 10%, and repeat\n\n    Returns:\n    - The summary string\n    - The list of message IDs to keep in-context",
          "decorators": [
            "@trace_method"
          ],
          "start_line": 46,
          "end_line": 148,
          "is_async": true
        }
      ],
      "parsedAt": 1769608839137
    },
    "letta/services/tool_executor/graphiti_tool_executor.py": {
      "path": "letta/services/tool_executor/graphiti_tool_executor.py",
      "contentHash": "d677cf4a0f6c8c095275e0fd0674955d",
      "mtime": 1751863385658.9077,
      "functions": [
        {
          "name": "create_graphiti_tool_executor_factory",
          "signature": "def create_graphiti_tool_executor_factory(graphiti_url: str = \"http://192.168.50.90:8001\")",
          "parameters": "(graphiti_url: str = \"http://192.168.50.90:8001\")",
          "return_type": null,
          "docstring": "Factory function to create GraphitiToolExecutor instances.\n    This can be used to replace the default CoreToolExecutor in dependency injection.",
          "decorators": [],
          "start_line": 138,
          "end_line": 151,
          "is_async": false
        }
      ],
      "parsedAt": 1769608839137
    },
    "letta/services/tool_manager.py": {
      "path": "letta/services/tool_manager.py",
      "contentHash": "224e08421e4433f5f76b9ee68a4b17df",
      "mtime": 1768610518538.2002,
      "functions": [
        {
          "name": "modal_tool_wrapper",
          "signature": "def modal_tool_wrapper(tool: PydanticTool, actor: PydanticUser, sandbox_env_vars: dict = None, project_id: str = \"default\")",
          "parameters": "(tool: PydanticTool, actor: PydanticUser, sandbox_env_vars: dict = None, project_id: str = \"default\")",
          "return_type": null,
          "docstring": "Create a Modal function wrapper for a tool",
          "decorators": [],
          "start_line": 87,
          "end_line": 228,
          "is_async": false
        }
      ],
      "parsedAt": 1769608839138
    },
    "letta/services/tool_sandbox/modal_version_manager.py": {
      "path": "letta/services/tool_sandbox/modal_version_manager.py",
      "contentHash": "5bc4ad96df7fb751c86d38e01128a395",
      "mtime": 1767315072088.5461,
      "functions": [
        {
          "name": "get_version_manager",
          "signature": "def get_version_manager() -> ModalVersionManager",
          "parameters": "()",
          "return_type": "ModalVersionManager",
          "docstring": "Get the global Modal version manager instance.",
          "decorators": [],
          "start_line": 269,
          "end_line": 274,
          "is_async": false
        }
      ],
      "parsedAt": 1769608839138
    },
    "letta/services/tool_sandbox/safe_pickle.py": {
      "path": "letta/services/tool_sandbox/safe_pickle.py",
      "contentHash": "5963eb1a1477873d9cc96be521403b82",
      "mtime": 1767315072088.5461,
      "functions": [
        {
          "name": "safe_pickle_dumps",
          "signature": "def safe_pickle_dumps(obj: Any, max_size: int = MAX_PICKLE_SIZE) -> bytes",
          "parameters": "(obj: Any, max_size: int = MAX_PICKLE_SIZE)",
          "return_type": "bytes",
          "docstring": "Safely pickle an object with size and recursion limits.\n\n    Args:\n        obj: The object to pickle\n        max_size: Maximum allowed pickle size in bytes\n\n    Returns:\n        bytes: The pickled object\n\n    Raises:\n        SafePickleError: If pickling fails or exceeds limits",
          "decorators": [],
          "start_line": 42,
          "end_line": 86,
          "is_async": false
        },
        {
          "name": "safe_pickle_loads",
          "signature": "def safe_pickle_loads(data: bytes) -> Any",
          "parameters": "(data: bytes)",
          "return_type": "Any",
          "docstring": "Safely unpickle data with error handling.\n\n    Args:\n        data: The pickled data\n\n    Returns:\n        Any: The unpickled object\n\n    Raises:\n        SafePickleError: If unpickling fails",
          "decorators": [],
          "start_line": 89,
          "end_line": 112,
          "is_async": false
        },
        {
          "name": "try_pickle_with_fallback",
          "signature": "def try_pickle_with_fallback(obj: Any, fallback_value: Any = None, max_size: int = MAX_PICKLE_SIZE) -> Tuple[Optional[bytes], bool]",
          "parameters": "(obj: Any, fallback_value: Any = None, max_size: int = MAX_PICKLE_SIZE)",
          "return_type": "Tuple[Optional[bytes], bool]",
          "docstring": "Try to pickle an object with fallback on failure.\n\n    Args:\n        obj: The object to pickle\n        fallback_value: Value to use if pickling fails\n        max_size: Maximum allowed pickle size\n\n    Returns:\n        Tuple of (pickled_data or None, success_flag)",
          "decorators": [],
          "start_line": 115,
          "end_line": 137,
          "is_async": false
        },
        {
          "name": "validate_pickleable",
          "signature": "def validate_pickleable(obj: Any) -> bool",
          "parameters": "(obj: Any)",
          "return_type": "bool",
          "docstring": "Check if an object can be safely pickled.\n\n    Args:\n        obj: The object to validate\n\n    Returns:\n        bool: True if the object can be pickled safely",
          "decorators": [],
          "start_line": 140,
          "end_line": 154,
          "is_async": false
        },
        {
          "name": "sanitize_for_pickle",
          "signature": "def sanitize_for_pickle(obj: Any) -> Any",
          "parameters": "(obj: Any)",
          "return_type": "Any",
          "docstring": "Sanitize an object for safe pickling.\n\n    This function attempts to make an object pickleable by converting\n    problematic types to safe alternatives.\n\n    Args:\n        obj: The object to sanitize\n\n    Returns:\n        Any: A sanitized version of the object",
          "decorators": [],
          "start_line": 157,
          "end_line": 193,
          "is_async": false
        }
      ],
      "parsedAt": 1769608839138
    },
    "letta/services/tool_schema_generator.py": {
      "path": "letta/services/tool_schema_generator.py",
      "contentHash": "ca9fa9f9ba6300c25d7cc283901fa503",
      "mtime": 1767315072088.5461,
      "functions": [
        {
          "name": "generate_schema_for_tool_creation",
          "signature": "def generate_schema_for_tool_creation(\n    tool: PydanticTool,\n) -> Optional[dict]",
          "parameters": "(\n    tool: PydanticTool,\n)",
          "return_type": "Optional[dict]",
          "docstring": "Generate JSON schema for tool creation based on the provided parameters.\n\n    Args:\n        tool: The tool being created\n\n    Returns:\n        Generated JSON schema or None if not applicable",
          "decorators": [
            "@trace_method"
          ],
          "start_line": 18,
          "end_line": 100,
          "is_async": false
        },
        {
          "name": "generate_schema_for_tool_update",
          "signature": "def generate_schema_for_tool_update(\n    current_tool: PydanticTool,\n    json_schema: Optional[dict] = None,\n    args_json_schema: Optional[dict] = None,\n    source_code: Optional[str] = None,\n    source_type: Optional[ToolSourceType] = None,\n) -> Optional[dict]",
          "parameters": "(\n    current_tool: PydanticTool,\n    json_schema: Optional[dict] = None,\n    args_json_schema: Optional[dict] = None,\n    source_code: Optional[str] = None,\n    source_type: Optional[ToolSourceType] = None,\n)",
          "return_type": "Optional[dict]",
          "docstring": "Generate JSON schema for tool update based on the provided parameters.\n\n    Args:\n        current_tool: The current tool being updated\n        json_schema: Directly provided JSON schema (takes precedence)\n        args_json_schema: Schema for just the arguments\n        source_code: Updated source code (only used if explicitly updating source)\n        source_type: Source type for the tool\n\n    Returns:\n        Updated JSON schema or None if no update needed",
          "decorators": [],
          "start_line": 103,
          "end_line": 151,
          "is_async": false
        }
      ],
      "parsedAt": 1769608839138
    },
    "letta/services/webhook_service_test.py": {
      "path": "letta/services/webhook_service_test.py",
      "contentHash": "636c18a72a5f33c7445283ca3eb85179",
      "mtime": 1767315072088.5461,
      "functions": [
        {
          "name": "test_webhook_not_configured",
          "signature": "def test_webhook_not_configured()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that webhook does not send when URL is not configured.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 26,
          "end_line": 31,
          "is_async": true
        },
        {
          "name": "test_webhook_success",
          "signature": "def test_webhook_success()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test successful webhook notification.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 35,
          "end_line": 57,
          "is_async": true
        },
        {
          "name": "test_webhook_without_auth",
          "signature": "def test_webhook_without_auth()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test webhook notification without authentication key.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 61,
          "end_line": 79,
          "is_async": true
        },
        {
          "name": "test_webhook_timeout",
          "signature": "def test_webhook_timeout()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test webhook notification timeout handling.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 83,
          "end_line": 96,
          "is_async": true
        },
        {
          "name": "test_webhook_http_error",
          "signature": "def test_webhook_http_error()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test webhook notification HTTP error handling.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 100,
          "end_line": 119,
          "is_async": true
        }
      ],
      "parsedAt": 1769608839138
    },
    "letta/streaming_utils.py": {
      "path": "letta/streaming_utils.py",
      "contentHash": "480b7b155130c31c427747d20879bbc7",
      "mtime": 1767315072088.5461,
      "functions": [
        {
          "name": "sanitize_streamed_message_content",
          "signature": "def sanitize_streamed_message_content(text: str) -> str",
          "parameters": "(text: str)",
          "return_type": "str",
          "docstring": "Remove trailing JSON delimiters that can leak into assistant text.\n\n    Specifically handles cases where a message string is immediately followed\n    by a JSON delimiter in the stream (e.g., '\"', '\",', '\"}', '\" ]').\n    Internal commas inside the message are preserved.",
          "decorators": [],
          "start_line": 347,
          "end_line": 363,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900558
    },
    "letta/system.py": {
      "path": "letta/system.py",
      "contentHash": "8d046d0e7e78c5a6c0a0471bdd6697ea",
      "mtime": 1767315072088.5461,
      "functions": [
        {
          "name": "get_initial_boot_messages",
          "signature": "def get_initial_boot_messages(version, timezone, tool_call_id)",
          "parameters": "(version, timezone, tool_call_id)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 18,
          "end_line": 93,
          "is_async": false
        },
        {
          "name": "get_heartbeat",
          "signature": "def get_heartbeat(timezone, reason: str = \"Automated timer\", include_location: bool = False, location_name: str = \"San Francisco, CA, USA\")",
          "parameters": "(timezone, reason: str = \"Automated timer\", include_location: bool = False, location_name: str = \"San Francisco, CA, USA\")",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 96,
          "end_line": 108,
          "is_async": false
        },
        {
          "name": "get_login_event",
          "signature": "def get_login_event(timezone, last_login=\"Never (first login)\", include_location=False, location_name=\"San Francisco, CA, USA\")",
          "parameters": "(timezone, last_login=\"Never (first login)\", include_location=False, location_name=\"San Francisco, CA, USA\")",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 111,
          "end_line": 123,
          "is_async": false
        },
        {
          "name": "package_user_message",
          "signature": "def package_user_message(\n    user_message: str,\n    timezone: str,\n    include_location: bool = False,\n    location_name: Optional[str] = \"San Francisco, CA, USA\",\n    name: Optional[str] = None,\n)",
          "parameters": "(\n    user_message: str,\n    timezone: str,\n    include_location: bool = False,\n    location_name: Optional[str] = \"San Francisco, CA, USA\",\n    name: Optional[str] = None,\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 126,
          "end_line": 147,
          "is_async": false
        },
        {
          "name": "package_function_response",
          "signature": "def package_function_response(was_success: bool, response_string: Any, timezone: str | None) -> str",
          "parameters": "(was_success: bool, response_string: Any, timezone: str | None)",
          "return_type": "str",
          "docstring": "Package a function response with status and timestamp.\n\n    Args:\n        was_success: Whether the function execution succeeded\n        response_string: The function response - can be a string or dict. Dicts are NOT pre-encoded to avoid double JSON encoding.\n        timezone: The timezone to use for the timestamp\n\n    Returns:\n        JSON string with status, message, and time",
          "decorators": [],
          "start_line": 150,
          "end_line": 168,
          "is_async": false
        },
        {
          "name": "package_system_message",
          "signature": "def package_system_message(system_message, timezone, message_type=\"system_alert\")",
          "parameters": "(system_message, timezone, message_type=\"system_alert\")",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 171,
          "end_line": 188,
          "is_async": false
        },
        {
          "name": "package_summarize_message",
          "signature": "def package_summarize_message(summary, summary_message_count, hidden_message_count, total_message_count, timezone)",
          "parameters": "(summary, summary_message_count, hidden_message_count, total_message_count, timezone)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 191,
          "end_line": 204,
          "is_async": false
        },
        {
          "name": "package_summarize_message_no_counts",
          "signature": "def package_summarize_message_no_counts(summary, timezone)",
          "parameters": "(summary, timezone)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 207,
          "end_line": 220,
          "is_async": false
        },
        {
          "name": "package_summarize_message_no_summary",
          "signature": "def package_summarize_message_no_summary(hidden_message_count, message=None, timezone=None)",
          "parameters": "(hidden_message_count, message=None, timezone=None)",
          "return_type": null,
          "docstring": "Add useful metadata to the summary message",
          "decorators": [],
          "start_line": 223,
          "end_line": 239,
          "is_async": false
        },
        {
          "name": "get_token_limit_warning",
          "signature": "def get_token_limit_warning()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 242,
          "end_line": 250,
          "is_async": false
        },
        {
          "name": "unpack_message",
          "signature": "def unpack_message(packed_message: str) -> str",
          "parameters": "(packed_message: str)",
          "return_type": "str",
          "docstring": "Take a packed message string and attempt to extract the inner message content",
          "decorators": [],
          "start_line": 253,
          "end_line": 277,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900558
    },
    "letta/utils.py": {
      "path": "letta/utils.py",
      "contentHash": "7d9dccf5d6e5300843b85a7d627c5f41",
      "mtime": 1768610518538.2002,
      "functions": [
        {
          "name": "smart_urljoin",
          "signature": "def smart_urljoin(base_url: str, relative_url: str) -> str",
          "parameters": "(base_url: str, relative_url: str)",
          "return_type": "str",
          "docstring": "urljoin is stupid and wants a trailing / at the end of the endpoint address, or it will chop the suffix off",
          "decorators": [],
          "start_line": 480,
          "end_line": 484,
          "is_async": false
        },
        {
          "name": "get_tool_call_id",
          "signature": "def get_tool_call_id() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 487,
          "end_line": 491,
          "is_async": false
        },
        {
          "name": "assistant_function_to_tool",
          "signature": "def assistant_function_to_tool(assistant_message: dict) -> dict",
          "parameters": "(assistant_message: dict)",
          "return_type": "dict",
          "docstring": null,
          "decorators": [],
          "start_line": 494,
          "end_line": 505,
          "is_async": false
        },
        {
          "name": "is_optional_type",
          "signature": "def is_optional_type(hint)",
          "parameters": "(hint)",
          "return_type": null,
          "docstring": "Check if the type hint is an Optional type.",
          "decorators": [],
          "start_line": 508,
          "end_line": 512,
          "is_async": false
        },
        {
          "name": "enforce_types",
          "signature": "def enforce_types(func)",
          "parameters": "(func)",
          "return_type": null,
          "docstring": "Enforces that values passed in match the expected types.\n        Technically will handle coroutines as well.\n\n    TODO (cliandy): use stricter pydantic fields",
          "decorators": [],
          "start_line": 515,
          "end_line": 568,
          "is_async": false
        },
        {
          "name": "annotate_message_json_list_with_tool_calls",
          "signature": "def annotate_message_json_list_with_tool_calls(messages: list[dict], allow_tool_roles: bool = False)",
          "parameters": "(messages: list[dict], allow_tool_roles: bool = False)",
          "return_type": null,
          "docstring": "Add in missing tool_call_id fields to a list of messages using function call style\n\n    Walk through the list forwards:\n    - If we encounter an assistant message that calls a function (\"function_call\") but doesn't have a \"tool_call_id\" field\n      - Generate the tool_call_id\n    - Then check if the subsequent message is a role == \"function\" message\n      - If so, then att",
          "decorators": [],
          "start_line": 571,
          "end_line": 683,
          "is_async": false
        },
        {
          "name": "version_less_than",
          "signature": "def version_less_than(version_a: str, version_b: str) -> bool",
          "parameters": "(version_a: str, version_b: str)",
          "return_type": "bool",
          "docstring": "Compare versions to check if version_a is less than version_b.",
          "decorators": [],
          "start_line": 686,
          "end_line": 700,
          "is_async": false
        },
        {
          "name": "create_random_username",
          "signature": "def create_random_username() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Generate a random username by combining an adjective and a noun.",
          "decorators": [],
          "start_line": 703,
          "end_line": 707,
          "is_async": false
        },
        {
          "name": "verify_first_message_correctness",
          "signature": "def verify_first_message_correctness(\n    response: ChatCompletionResponse, require_send_message: bool = True, require_monologue: bool = False\n) -> bool",
          "parameters": "(\n    response: ChatCompletionResponse, require_send_message: bool = True, require_monologue: bool = False\n)",
          "return_type": "bool",
          "docstring": "Can be used to enforce that the first message always uses send_message",
          "decorators": [],
          "start_line": 710,
          "end_line": 756,
          "is_async": false
        },
        {
          "name": "is_valid_url",
          "signature": "def is_valid_url(url)",
          "parameters": "(url)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 759,
          "end_line": 764,
          "is_async": false
        },
        {
          "name": "suppress_stdout",
          "signature": "def suppress_stdout()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Used to temporarily stop stdout (eg for the 'MockLLM' message)",
          "decorators": [
            "@contextmanager"
          ],
          "start_line": 768,
          "end_line": 776,
          "is_async": false
        },
        {
          "name": "open_folder_in_explorer",
          "signature": "def open_folder_in_explorer(folder_path)",
          "parameters": "(folder_path)",
          "return_type": null,
          "docstring": "Opens the specified folder in the system's native file explorer.\n\n    :param folder_path: Absolute path to the folder to be opened.",
          "decorators": [],
          "start_line": 779,
          "end_line": 802,
          "is_async": false
        },
        {
          "name": "printd",
          "signature": "def printd(*args, **kwargs)",
          "parameters": "(*args, **kwargs)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 824,
          "end_line": 826,
          "is_async": false
        },
        {
          "name": "united_diff",
          "signature": "def united_diff(str1: str, str2: str) -> str",
          "parameters": "(str1: str, str2: str)",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 829,
          "end_line": 833,
          "is_async": false
        },
        {
          "name": "parse_json",
          "signature": "def parse_json(string) -> dict",
          "parameters": "(string)",
          "return_type": "dict",
          "docstring": "Parse JSON string into JSON with both json and demjson",
          "decorators": [],
          "start_line": 836,
          "end_line": 854,
          "is_async": false
        },
        {
          "name": "validate_function_response",
          "signature": "def validate_function_response(\n    function_response: Any, return_char_limit: int, strict: bool = False, truncate: bool = True\n) -> str | dict[str, Any]",
          "parameters": "(\n    function_response: Any, return_char_limit: int, strict: bool = False, truncate: bool = True\n)",
          "return_type": "str | dict[str, Any]",
          "docstring": "Check to make sure that a function used by Letta returned a valid response. Truncates to return_char_limit if necessary.\n\n    This makes sure that we can coerce the function_response into a string or dict that meets our criteria. We handle some soft coercion.\n    If strict is True, we raise a ValueError if function_response is not a string or None.\n\n    Returns:\n        str or dict: Validated response. Dicts are returned as-is to avoid double JSON encoding by package_function_response.",
          "decorators": [],
          "start_line": 857,
          "end_line": 898,
          "is_async": false
        },
        {
          "name": "list_agent_config_files",
          "signature": "def list_agent_config_files(sort=\"last_modified\")",
          "parameters": "(sort=\"last_modified\")",
          "return_type": null,
          "docstring": "List all agent config files, ignoring dotfiles.",
          "decorators": [],
          "start_line": 901,
          "end_line": 919,
          "is_async": false
        },
        {
          "name": "list_human_files",
          "signature": "def list_human_files()",
          "parameters": "()",
          "return_type": null,
          "docstring": "List all humans files",
          "decorators": [],
          "start_line": 922,
          "end_line": 935,
          "is_async": false
        },
        {
          "name": "list_persona_files",
          "signature": "def list_persona_files()",
          "parameters": "()",
          "return_type": null,
          "docstring": "List all personas files",
          "decorators": [],
          "start_line": 938,
          "end_line": 951,
          "is_async": false
        },
        {
          "name": "get_human_text",
          "signature": "def get_human_text(name: str, enforce_limit=True)",
          "parameters": "(name: str, enforce_limit=True)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 954,
          "end_line": 964,
          "is_async": false
        },
        {
          "name": "get_persona_text",
          "signature": "def get_persona_text(name: str, enforce_limit=True)",
          "parameters": "(name: str, enforce_limit=True)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 967,
          "end_line": 979,
          "is_async": false
        },
        {
          "name": "get_schema_diff",
          "signature": "def get_schema_diff(schema_a, schema_b)",
          "parameters": "(schema_a, schema_b)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 982,
          "end_line": 993,
          "is_async": false
        },
        {
          "name": "create_uuid_from_string",
          "signature": "def create_uuid_from_string(val: str)",
          "parameters": "(val: str)",
          "return_type": null,
          "docstring": "Generate consistent UUID from a string\n    from: https://samos-it.com/posts/python-create-uuid-from-random-string-of-words.html",
          "decorators": [],
          "start_line": 996,
          "end_line": 1002,
          "is_async": false
        },
        {
          "name": "sanitize_filename",
          "signature": "def sanitize_filename(filename: str, add_uuid_suffix: bool = False) -> str",
          "parameters": "(filename: str, add_uuid_suffix: bool = False)",
          "return_type": "str",
          "docstring": "Sanitize the given filename to prevent directory traversal, invalid characters,\n    and reserved names while ensuring it fits within the maximum length allowed by the filesystem.\n\n    Parameters:\n        filename (str): The user-provided filename.\n        add_uuid_suffix (bool): If True, adds a UUID suffix for uniqueness (legacy behavior).\n\n    Returns:\n        str: A sanitized filename.",
          "decorators": [],
          "start_line": 1005,
          "end_line": 1047,
          "is_async": false
        },
        {
          "name": "get_friendly_error_msg",
          "signature": "def get_friendly_error_msg(function_name: str, exception_name: str, exception_message: str)",
          "parameters": "(function_name: str, exception_name: str, exception_message: str)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1050,
          "end_line": 1056,
          "is_async": false
        },
        {
          "name": "parse_stderr_error_msg",
          "signature": "def parse_stderr_error_msg(stderr_txt: str, last_n_lines: int = 3) -> tuple[str, str]",
          "parameters": "(stderr_txt: str, last_n_lines: int = 3)",
          "return_type": "tuple[str, str]",
          "docstring": "Parses out from the last `last_n_line` of `stderr_txt` the Exception type and message.",
          "decorators": [],
          "start_line": 1059,
          "end_line": 1070,
          "is_async": false
        },
        {
          "name": "run_async_task",
          "signature": "def run_async_task(coro: Coroutine[Any, Any, Any]) -> Any",
          "parameters": "(coro: Coroutine[Any, Any, Any])",
          "return_type": "Any",
          "docstring": "Safely runs an asynchronous coroutine in a synchronous context.\n\n    If an event loop is already running, it uses `asyncio.ensure_future`.\n    Otherwise, it creates a new event loop and runs the coroutine.\n\n    Args:\n        coro: The coroutine to execute.\n\n    Returns:\n        The result of the coroutine.",
          "decorators": [],
          "start_line": 1073,
          "end_line": 1092,
          "is_async": false
        },
        {
          "name": "log_telemetry",
          "signature": "def log_telemetry(logger: Logger, event: str, **kwargs)",
          "parameters": "(logger: Logger, event: str, **kwargs)",
          "return_type": null,
          "docstring": "Logs telemetry events with a timestamp.\n\n    :param logger: A logger\n    :param event: A string describing the event.\n    :param kwargs: Additional key-value pairs for logging metadata.",
          "decorators": [],
          "start_line": 1095,
          "end_line": 1108,
          "is_async": false
        },
        {
          "name": "make_key",
          "signature": "def make_key(*args, **kwargs)",
          "parameters": "(*args, **kwargs)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1111,
          "end_line": 1112,
          "is_async": false
        },
        {
          "name": "get_background_task_count",
          "signature": "def get_background_task_count() -> int",
          "parameters": "()",
          "return_type": "int",
          "docstring": "Get the current number of background tasks for debugging/monitoring.",
          "decorators": [],
          "start_line": 1119,
          "end_line": 1121,
          "is_async": false
        },
        {
          "name": "safe_create_task",
          "signature": "def safe_create_task(coro, label: str = \"background task\")",
          "parameters": "(coro, label: str = \"background task\")",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@trace_method"
          ],
          "start_line": 1125,
          "end_line": 1170,
          "is_async": false
        },
        {
          "name": "safe_create_task_with_return",
          "signature": "def safe_create_task_with_return(coro, label: str = \"background task\")",
          "parameters": "(coro, label: str = \"background task\")",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@trace_method"
          ],
          "start_line": 1174,
          "end_line": 1203,
          "is_async": false
        },
        {
          "name": "safe_create_shielded_task",
          "signature": "def safe_create_shielded_task(coro, label: str = \"shielded background task\")",
          "parameters": "(coro, label: str = \"shielded background task\")",
          "return_type": null,
          "docstring": "Create a shielded background task that cannot be cancelled externally.\n\n    This is useful for critical operations that must complete even if the\n    parent operation is cancelled. The task is internally shielded but the\n    returned task can still have callbacks added to it.",
          "decorators": [],
          "start_line": 1206,
          "end_line": 1246,
          "is_async": false
        },
        {
          "name": "safe_create_file_processing_task",
          "signature": "def safe_create_file_processing_task(coro, file_metadata, server, actor, logger: Logger, label: str = \"file processing task\")",
          "parameters": "(coro, file_metadata, server, actor, logger: Logger, label: str = \"file processing task\")",
          "return_type": null,
          "docstring": "Create a task for file processing that updates file status on failure.\n\n    This is a specialized version of safe_create_task that ensures file\n    status is properly updated to ERROR with a meaningful message if the\n    task fails.\n\n    Args:\n        coro: The coroutine to execute\n        file_metadata: FileMetadata object being processed\n        server: Server instance with file_manager\n        actor: User performing the operation\n        logger: Logger instance for error logging\n        label: Description of the task for logging",
          "decorators": [],
          "start_line": 1249,
          "end_line": 1291,
          "is_async": false
        },
        {
          "name": "get_latest_alembic_revision",
          "signature": "def get_latest_alembic_revision() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Get the current alembic revision ID from the alembic_version table.",
          "decorators": [],
          "start_line": 1294,
          "end_line": 1310,
          "is_async": true
        },
        {
          "name": "calculate_file_defaults_based_on_context_window",
          "signature": "def calculate_file_defaults_based_on_context_window(context_window: Optional[int]) -> tuple[int, int]",
          "parameters": "(context_window: Optional[int])",
          "return_type": "tuple[int, int]",
          "docstring": "Calculate reasonable defaults for max_files_open and per_file_view_window_char_limit\n    based on the model's context window size.\n\n    Args:\n        context_window: The context window size of the model. If None, returns conservative defaults.\n\n    Returns:\n        A tuple of (max_files_open, per_file_view_window_char_limit)",
          "decorators": [],
          "start_line": 1313,
          "end_line": 1341,
          "is_async": false
        },
        {
          "name": "truncate_file_visible_content",
          "signature": "def truncate_file_visible_content(visible_content: str, is_open: bool, per_file_view_window_char_limit: int)",
          "parameters": "(visible_content: str, is_open: bool, per_file_view_window_char_limit: int)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1344,
          "end_line": 1353,
          "is_async": false
        },
        {
          "name": "fire_and_forget",
          "signature": "def fire_and_forget(coro, task_name: Optional[str] = None, error_callback: Optional[Callable[[Exception], None]] = None) -> asyncio.Task",
          "parameters": "(coro, task_name: Optional[str] = None, error_callback: Optional[Callable[[Exception], None]] = None)",
          "return_type": "asyncio.Task",
          "docstring": "Execute an async coroutine in the background without waiting for completion.\n\n    Args:\n        coro: The coroutine to execute\n        task_name: Optional name for logging purposes\n        error_callback: Optional callback to execute if the task fails\n\n    Returns:\n        The created asyncio Task object",
          "decorators": [],
          "start_line": 1356,
          "end_line": 1392,
          "is_async": false
        },
        {
          "name": "is_1_0_sdk_version",
          "signature": "def is_1_0_sdk_version(headers: HeaderParams)",
          "parameters": "(headers: HeaderParams)",
          "return_type": null,
          "docstring": "Check if the SDK version is 1.0.0 or above.\n    1. If sdk_version is provided from stainless (all stainless versions are 1.0.0+)\n    2. If user_agent is provided and in the format\n        @letta-ai/letta-client/version (node) or\n        letta-client/version (python)",
          "decorators": [],
          "start_line": 1395,
          "end_line": 1450,
          "is_async": false
        },
        {
          "name": "bounded_gather",
          "signature": "def bounded_gather(coros: list[Coroutine], max_concurrency: int = 10) -> list",
          "parameters": "(coros: list[Coroutine], max_concurrency: int = 10)",
          "return_type": "list",
          "docstring": "Execute coroutines with bounded concurrency to prevent event loop saturation.\n\n    Unlike asyncio.gather() which runs all coroutines concurrently, this limits\n    the number of concurrent tasks to prevent overwhelming the event loop.\n\n    Note: This is a stopgap measure. Prefer fixing the root cause by:\n    - Limiting items fetched from DB (e.g., pagination)\n    - Using explicit relationship loading instead of eager-loading all\n    - Adding concurrency limits at the API/business logic layer\n\n    Args:\n        coros: List of coroutines to execute\n        max_concurrency: Maximum number of concurrent tasks (default: 10)\n\n    Returns:\n        List of results in the same order as input coroutines",
          "decorators": [],
          "start_line": 1453,
          "end_line": 1503,
          "is_async": true
        },
        {
          "name": "decrypt_agent_secrets",
          "signature": "def decrypt_agent_secrets(agents: list) -> list",
          "parameters": "(agents: list)",
          "return_type": "list",
          "docstring": "Decrypt secrets for all agents outside DB session.\n\n    This allows DB connections to be released before expensive PBKDF2 operations,\n    preventing connection pool exhaustion during high load.\n\n    Uses bounded concurrency to limit thread pool pressure while allowing some\n    parallelism in the dedicated crypto executor.\n\n    Args:\n        agents: List of PydanticAgentState objects with encrypted secrets\n\n    Returns:\n        Same list with secrets decrypted",
          "decorators": [],
          "start_line": 1506,
          "end_line": 1540,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900559
    },
    "letta/validators.py": {
      "path": "letta/validators.py",
      "contentHash": "8139d274b502bdb7afe6503e1734c85d",
      "mtime": 1768610518538.2002,
      "functions": [
        {
          "name": "raise_on_invalid_id",
          "signature": "def raise_on_invalid_id(param_name: str, expected_prefix: PrimitiveType)",
          "parameters": "(param_name: str, expected_prefix: PrimitiveType)",
          "return_type": null,
          "docstring": "Decorator that validates an ID parameter has the expected prefix format.\n    Can be stacked multiple times on the same function to validate different IDs.\n\n    Args:\n        param_name: The name of the function parameter to validate (e.g., \"agent_id\")\n        expected_prefix: The expected primitive type (e.g., PrimitiveType.AGENT)\n\n    Example:\n        @raise_on_invalid_id(param_name=\"agent_id\", expected_prefix=PrimitiveType.AGENT)\n        @raise_on_invalid_id(param_name=\"folder_id\", expected_prefix=PrimitiveType.FOLDER)\n        def my_function(agent_id: str, folder_id: str):\n            pass",
          "decorators": [],
          "start_line": 89,
          "end_line": 127,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900559
    },
    "patch_letta_graphiti.py": {
      "path": "patch_letta_graphiti.py",
      "contentHash": "57e8f6d325ee5169955bf548f6a0c2dc",
      "mtime": 1751863426983.937,
      "functions": [
        {
          "name": "test_graphiti",
          "signature": "def test_graphiti()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test Graphiti connection",
          "decorators": [],
          "start_line": 24,
          "end_line": 34,
          "is_async": true
        },
        {
          "name": "graphiti_insert",
          "signature": "def graphiti_insert(content: str, agent_id: str) -> Optional[str]",
          "parameters": "(content: str, agent_id: str)",
          "return_type": "Optional[str]",
          "docstring": "Insert content into Graphiti",
          "decorators": [],
          "start_line": 37,
          "end_line": 68,
          "is_async": true
        },
        {
          "name": "graphiti_search",
          "signature": "def graphiti_search(query: str, agent_id: str, limit: int = 10) -> List[str]",
          "parameters": "(query: str, agent_id: str, limit: int = 10)",
          "return_type": "List[str]",
          "docstring": "Search Graphiti for memories",
          "decorators": [],
          "start_line": 71,
          "end_line": 107,
          "is_async": true
        },
        {
          "name": "patch_archival_memory",
          "signature": "def patch_archival_memory()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Patch the archival memory functions in Letta",
          "decorators": [],
          "start_line": 110,
          "end_line": 175,
          "is_async": false
        },
        {
          "name": "in()",
          "signature": "def in():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Main function\"\"\"",
          "decorators": [],
          "start_line": 178,
          "end_line": 200,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900559
    },
    "sandbox/modal_executor.py": {
      "path": "sandbox/modal_executor.py",
      "contentHash": "8383f4e6f53e74cc7152179df52de755",
      "mtime": 1767315072092.5464,
      "functions": [
        {
          "name": "setup_signal_handlers",
          "signature": "def setup_signal_handlers()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Setup signal handlers for better debugging.",
          "decorators": [],
          "start_line": 167,
          "end_line": 260,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900560
    },
    "sandbox/resources/server/entrypoint.ts": {
      "path": "sandbox/resources/server/entrypoint.ts",
      "contentHash": "fde76cdac8e304cdd509f8178f5b9bb8",
      "mtime": 1767315072092.5464,
      "functions": [
        {
          "name": "runUserFunction",
          "signature": "function runUserFunction(encoded_input: string): { result: any; error?: string }",
          "parameters": "(encoded_input: string)",
          "return_type": "{ result: any; error?: string }",
          "docstring": "/**\n * Entrypoint for the user function.\n * Dynamically finds and executes the exported TypeScript function.\n * \n * @param encoded_input - JSON encoded input\n */",
          "decorators": [],
          "start_line": 9,
          "end_line": 42,
          "is_async": false,
          "is_generator": false
        }
      ],
      "parsedAt": 1769608900560
    },
    "sandbox/resources/server/user-function.ts": {
      "path": "sandbox/resources/server/user-function.ts",
      "contentHash": "8a220164f3ed89c19a8530b214705265",
      "mtime": 1767315072092.5464,
      "functions": [
        {
          "name": "repeatString",
          "signature": "function repeatString(str: string, multiplier: number): string",
          "parameters": "(str: string, multiplier: number)",
          "return_type": "string",
          "docstring": null,
          "decorators": [],
          "start_line": 2,
          "end_line": 2,
          "is_async": false,
          "is_generator": false
        }
      ],
      "parsedAt": 1769608900560
    },
    "test_graphiti_archival.py": {
      "path": "test_graphiti_archival.py",
      "contentHash": "7465d07912404a46892ddb9c488c1a3d",
      "mtime": 1751863523978.3533,
      "functions": [
        {
          "name": "create_test_agent",
          "signature": "def create_test_agent()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Create a test agent",
          "decorators": [],
          "start_line": 17,
          "end_line": 47,
          "is_async": true
        },
        {
          "name": "raphiti_integration():\n  ",
          "signature": "def raphiti_integration():\n    ",
          "parameters": "  ",
          "return_type": null,
          "docstring": "t the Graphiti archival memory integration\"\"\"\n    p",
          "decorators": [],
          "start_line": 77,
          "end_line": 153,
          "is_async": true
        },
        {
          "name": "ion\"",
          "signature": "def ion\"\"\"",
          "parameters": "\"\"",
          "return_type": null,
          "docstring": "uccess = await test_grap",
          "decorators": [],
          "start_line": 156,
          "end_line": 159,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900560
    },
    "test_watchdog_hang.py": {
      "path": "test_watchdog_hang.py",
      "contentHash": "e93ff385f4d21d9fc0642daad9f13fec",
      "mtime": 1767315072092.5464,
      "functions": [
        {
          "name": "blocking_operation",
          "signature": "def blocking_operation(seconds: float)",
          "parameters": "(seconds: float)",
          "return_type": null,
          "docstring": "Simulate a blocking operation that hangs the event loop.",
          "decorators": [],
          "start_line": 22,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "atchdog_detection():\n  ",
          "signature": "def atchdog_detection():\n    ",
          "parameters": "  ",
          "return_type": null,
          "docstring": "t that watchdog detects event loop hangs.\"\"\"\n    p",
          "decorators": [],
          "start_line": 29,
          "end_line": 81,
          "is_async": true
        },
        {
          "name": "test",
          "signature": "def test.\"",
          "parameters": ".\"",
          "return_type": null,
          "docstring": "try:\n        await",
          "decorators": [],
          "start_line": 84,
          "end_line": 93,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900560
    },
    "tests/adapters/test_letta_llm_stream_adapter_error_handling.py": {
      "path": "tests/adapters/test_letta_llm_stream_adapter_error_handling.py",
      "contentHash": "ae0924d4a76b69ecd09621010b70b1a5",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "test_letta_llm_stream_adapter_converts_anthropic_streaming_api_status_error",
          "signature": "def test_letta_llm_stream_adapter_converts_anthropic_streaming_api_status_error(monkeypatch)",
          "parameters": "(monkeypatch)",
          "return_type": null,
          "docstring": "Regression: provider APIStatusError raised *during* streaming iteration should be converted via handle_llm_error.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 12,
          "end_line": 50,
          "is_async": true
        },
        {
          "name": "test_letta_llm_stream_adapter_converts_anthropic_413_request_too_large",
          "signature": "def test_letta_llm_stream_adapter_converts_anthropic_413_request_too_large(monkeypatch)",
          "parameters": "(monkeypatch)",
          "return_type": null,
          "docstring": "Regression: 413 request_too_large errors should be converted to ContextWindowExceededError.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 54,
          "end_line": 91,
          "is_async": true
        },
        {
          "name": "test_letta_llm_stream_adapter_converts_httpx_read_error",
          "signature": "def test_letta_llm_stream_adapter_converts_httpx_read_error(monkeypatch)",
          "parameters": "(monkeypatch)",
          "return_type": null,
          "docstring": "Regression: httpx.ReadError raised during streaming should be converted to LLMConnectionError.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 95,
          "end_line": 125,
          "is_async": true
        },
        {
          "name": "test_letta_llm_stream_adapter_converts_httpx_write_error",
          "signature": "def test_letta_llm_stream_adapter_converts_httpx_write_error(monkeypatch)",
          "parameters": "(monkeypatch)",
          "return_type": null,
          "docstring": "Regression: httpx.WriteError raised during streaming should be converted to LLMConnectionError.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 129,
          "end_line": 159,
          "is_async": true
        },
        {
          "name": "test_anthropic_client_handle_llm_error_413_status_code",
          "signature": "def test_anthropic_client_handle_llm_error_413_status_code()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that handle_llm_error correctly converts 413 status code to ContextWindowExceededError.",
          "decorators": [],
          "start_line": 162,
          "end_line": 177,
          "is_async": false
        },
        {
          "name": "test_anthropic_client_handle_llm_error_request_too_large_string",
          "signature": "def test_anthropic_client_handle_llm_error_request_too_large_string()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that handle_llm_error correctly converts request_too_large string match to ContextWindowExceededError.",
          "decorators": [],
          "start_line": 180,
          "end_line": 189,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900560
    },
    "tests/clear_postgres_db.py": {
      "path": "tests/clear_postgres_db.py",
      "contentHash": "12f25d96e6fb7a7be0b4e7340dc998e9",
      "mtime": 1767315072092.5464,
      "functions": [
        {
          "name": "main",
          "signature": "def main()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 6,
          "end_line": 15,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900560
    },
    "tests/conftest.py": {
      "path": "tests/conftest.py",
      "contentHash": "3af00b399c20aa03de40eaa83faa41d4",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "pytest_configure",
          "signature": "def pytest_configure(config)",
          "parameters": "(config)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 20,
          "end_line": 21,
          "is_async": false
        },
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until it's accepting connections.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 25,
          "end_line": 58,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> Letta",
          "parameters": "(server_url: str)",
          "return_type": "Letta",
          "docstring": "Creates and returns a synchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 62,
          "end_line": 67,
          "is_async": false
        },
        {
          "name": "disable_db_pooling_for_tests",
          "signature": "def disable_db_pooling_for_tests()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Disable database connection pooling for the entire test session.",
          "decorators": [
            "@pytest.fixture(scope=\"session\", autouse=True)"
          ],
          "start_line": 71,
          "end_line": 76,
          "is_async": false
        },
        {
          "name": "cleanup_db_connections",
          "signature": "def cleanup_db_connections()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Cleanup database connections after each test.",
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 80,
          "end_line": 97,
          "is_async": true
        },
        {
          "name": "disable_e2b_api_key",
          "signature": "def disable_e2b_api_key() -> Generator[None, None, None]",
          "parameters": "()",
          "return_type": "Generator[None, None, None]",
          "docstring": "Temporarily disables the E2B API key by setting `tool_settings.e2b_api_key` to None\n    for the duration of the test. Restores the original value afterward.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 101,
          "end_line": 111,
          "is_async": false
        },
        {
          "name": "e2b_sandbox_mode",
          "signature": "def e2b_sandbox_mode(request) -> Generator[None, None, None]",
          "parameters": "(request)",
          "return_type": "Generator[None, None, None]",
          "docstring": "Parametrizable fixture to enable/disable E2B sandbox mode.\n\n    Usage:\n        @pytest.mark.parametrize(\"e2b_sandbox_mode\", [True, False], indirect=True)\n        def test_function(e2b_sandbox_mode, ...):\n            # Test runs twice - once with E2B enabled, once disabled",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 115,
          "end_line": 137,
          "is_async": false
        },
        {
          "name": "disable_pinecone",
          "signature": "def disable_pinecone() -> Generator[None, None, None]",
          "parameters": "()",
          "return_type": "Generator[None, None, None]",
          "docstring": "Temporarily disables Pinecone by setting `settings.enable_pinecone` to False\n    and `settings.pinecone_api_key` to None for the duration of the test.\n    Restores the original values afterward.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 141,
          "end_line": 155,
          "is_async": false
        },
        {
          "name": "disable_turbopuffer",
          "signature": "def disable_turbopuffer() -> Generator[None, None, None]",
          "parameters": "()",
          "return_type": "Generator[None, None, None]",
          "docstring": "Temporarily disables Turbopuffer by setting `settings.use_tpuf` to False\n    and `settings.tpuf_api_key` to None for the duration of the test.\n    Also sets environment to DEV for testing.\n    Restores the original values afterward.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 159,
          "end_line": 177,
          "is_async": false
        },
        {
          "name": "turbopuffer_mode",
          "signature": "def turbopuffer_mode(request) -> Generator[None, None, None]",
          "parameters": "(request)",
          "return_type": "Generator[None, None, None]",
          "docstring": "Parametrizable fixture to enable/disable Turbopuffer mode.\n\n    Usage:\n        @pytest.mark.parametrize(\"turbopuffer_mode\", [True, False], indirect=True)\n        def test_function(turbopuffer_mode, ...):\n            # Test runs twice - once with Turbopuffer enabled, once disabled",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 181,
          "end_line": 211,
          "is_async": false
        },
        {
          "name": "check_e2b_key_is_set",
          "signature": "def check_e2b_key_is_set()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 215,
          "end_line": 220,
          "is_async": false
        },
        {
          "name": "check_modal_key_is_set",
          "signature": "def check_modal_key_is_set()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 224,
          "end_line": 229,
          "is_async": false
        },
        {
          "name": "default_organization",
          "signature": "def default_organization()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 233,
          "end_line": 237,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(default_organization)",
          "parameters": "(default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 241,
          "end_line": 245,
          "is_async": true
        },
        {
          "name": "weather_tool_func",
          "signature": "def weather_tool_func()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 250,
          "end_line": 275,
          "is_async": false
        },
        {
          "name": "print_tool_func",
          "signature": "def print_tool_func()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to create a tool with default settings and clean up after the test.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 279,
          "end_line": 293,
          "is_async": false
        },
        {
          "name": "roll_dice_tool_func",
          "signature": "def roll_dice_tool_func()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 297,
          "end_line": 310,
          "is_async": false
        },
        {
          "name": "dummy_beta_message_batch",
          "signature": "def dummy_beta_message_batch() -> BetaMessageBatch",
          "parameters": "()",
          "return_type": "BetaMessageBatch",
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 314,
          "end_line": 332,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900560
    },
    "tests/data/data_analysis.py": {
      "path": "tests/data/data_analysis.py",
      "contentHash": "a3315c0273b3f08eeed9c589aca0667b",
      "mtime": 1767315072108.5469,
      "functions": [
        {
          "name": "generate_sample_data",
          "signature": "def generate_sample_data(n_samples: int = 1000) -> pd.DataFrame",
          "parameters": "(n_samples: int = 1000)",
          "return_type": "pd.DataFrame",
          "docstring": "Generate sample dataset for testing analysis functions.\n\n    Args:\n        n_samples: Number of samples to generate\n\n    Returns:\n        Sample DataFrame",
          "decorators": [],
          "start_line": 326,
          "end_line": 355,
          "is_async": false
        },
        {
          "name": "main",
          "signature": "def main()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Demonstration of the data analysis pipeline.",
          "decorators": [],
          "start_line": 358,
          "end_line": 398,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900560
    },
    "tests/data/functions/dump_json.py": {
      "path": "tests/data/functions/dump_json.py",
      "contentHash": "6d422515019a06fc524e59db39d2c4a4",
      "mtime": 1767315072108.5469,
      "functions": [
        {
          "name": "dump_json",
          "signature": "def dump_json(self: Agent, input: str) -> str",
          "parameters": "(self: Agent, input: str)",
          "return_type": "str",
          "docstring": "Dumps the content to JSON.\n\n    Args:\n        input (dict): dictionary object to convert to a string\n\n    Returns:\n        str: returns string version of the input",
          "decorators": [],
          "start_line": 6,
          "end_line": 16,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900561
    },
    "tests/data/react_component.jsx": {
      "path": "tests/data/react_component.jsx",
      "contentHash": "61abc189e07c7a1330d4c00fdf0611e6",
      "mtime": 1767315072120.5474,
      "functions": [
        {
          "name": "UserProfile",
          "signature": "const UserProfile = ({ user, onEdit }) =>",
          "parameters": "({ user, onEdit })",
          "return_type": null,
          "docstring": "/**\n * UserProfile component for displaying user information\n * @param {Object} props - Component props\n * @param {Object} props.user - User object\n * @param {Function} props.onEdit - Edit callback function\n */",
          "decorators": [],
          "start_line": 10,
          "end_line": 110,
          "is_async": false,
          "is_generator": false
        }
      ],
      "parsedAt": 1769608900561
    },
    "tests/helpers/client_helper.py": {
      "path": "tests/helpers/client_helper.py",
      "contentHash": "97d7c876f2e06263168691bef54eebc9",
      "mtime": 1767315072120.5474,
      "functions": [
        {
          "name": "upload_file_using_client",
          "signature": "def upload_file_using_client(client: RESTClient, source: Source, filename: str) -> Job",
          "parameters": "(client: RESTClient, source: Source, filename: str)",
          "return_type": "Job",
          "docstring": null,
          "decorators": [],
          "start_line": 9,
          "end_line": 33,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900561
    },
    "tests/helpers/endpoints_helper.py": {
      "path": "tests/helpers/endpoints_helper.py",
      "contentHash": "79cf942f4275ae5853a6e603f8b22d50",
      "mtime": 1767315072120.5474,
      "functions": [
        {
          "name": "setup_agent",
          "signature": "def setup_agent(\n    server: SyncServer,\n    filename: str,\n    memory_human_str: str = get_human_text(DEFAULT_HUMAN),\n    memory_persona_str: str = get_persona_text(DEFAULT_PERSONA),\n    tool_ids: Optional[List[str]] = None,\n    tool_rules: Optional[List[BaseToolRule]] = None,\n    agent_uuid: str = agent_uuid,\n    include_base_tools: bool = True,\n    include_base_tool_rules: bool = True,\n) -> AgentState",
          "parameters": "(\n    server: SyncServer,\n    filename: str,\n    memory_human_str: str = get_human_text(DEFAULT_HUMAN),\n    memory_persona_str: str = get_persona_text(DEFAULT_PERSONA),\n    tool_ids: Optional[List[str]] = None,\n    tool_rules: Optional[List[BaseToolRule]] = None,\n    agent_uuid: str = agent_uuid,\n    include_base_tools: bool = True,\n    include_base_tool_rules: bool = True,\n)",
          "return_type": "AgentState",
          "docstring": null,
          "decorators": [],
          "start_line": 43,
          "end_line": 89,
          "is_async": true
        },
        {
          "name": "run_embedding_endpoint",
          "signature": "def run_embedding_endpoint(filename, actor=None)",
          "parameters": "(filename, actor=None)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 98,
          "end_line": 115,
          "is_async": true
        },
        {
          "name": "assert_sanity_checks",
          "signature": "def assert_sanity_checks(response: LettaResponse)",
          "parameters": "(response: LettaResponse)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 124,
          "end_line": 127,
          "is_async": false
        },
        {
          "name": "assert_invoked_send_message_with_keyword",
          "signature": "def assert_invoked_send_message_with_keyword(messages: Sequence[LettaMessage], keyword: str, case_sensitive: bool = False) -> None",
          "parameters": "(messages: Sequence[LettaMessage], keyword: str, case_sensitive: bool = False)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 130,
          "end_line": 160,
          "is_async": false
        },
        {
          "name": "assert_invoked_function_call",
          "signature": "def assert_invoked_function_call(messages: Sequence[LettaMessage], function_name: str) -> None",
          "parameters": "(messages: Sequence[LettaMessage], function_name: str)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 163,
          "end_line": 169,
          "is_async": false
        },
        {
          "name": "assert_inner_monologue_is_present_and_valid",
          "signature": "def assert_inner_monologue_is_present_and_valid(messages: List[LettaMessage]) -> None",
          "parameters": "(messages: List[LettaMessage])",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 172,
          "end_line": 178,
          "is_async": false
        },
        {
          "name": "assert_contains_valid_function_call",
          "signature": "def assert_contains_valid_function_call(\n    message: Message,\n    function_call_validator: Optional[Callable[[FunctionCall], bool]] = None,\n    validation_failure_summary: Optional[str] = None,\n) -> None",
          "parameters": "(\n    message: Message,\n    function_call_validator: Optional[Callable[[FunctionCall], bool]] = None,\n    validation_failure_summary: Optional[str] = None,\n)",
          "return_type": "None",
          "docstring": "Helper function to check that a message contains a valid function call.\n\n    There is an Optional parameter `function_call_validator` that specifies a validator function.\n    This function gets called on the resulting function_call to validate the function is what we expect.",
          "decorators": [],
          "start_line": 187,
          "end_line": 213,
          "is_async": false
        },
        {
          "name": "assert_inner_monologue_is_valid",
          "signature": "def assert_inner_monologue_is_valid(message: Message) -> None",
          "parameters": "(message: Message)",
          "return_type": "None",
          "docstring": "Helper function to check that the inner monologue is valid.",
          "decorators": [],
          "start_line": 216,
          "end_line": 226,
          "is_async": false
        },
        {
          "name": "assert_contains_correct_inner_monologue",
          "signature": "def assert_contains_correct_inner_monologue(\n    choice: Choice,\n    inner_thoughts_in_kwargs: bool,\n    validate_inner_monologue_contents: bool = True,\n) -> None",
          "parameters": "(\n    choice: Choice,\n    inner_thoughts_in_kwargs: bool,\n    validate_inner_monologue_contents: bool = True,\n)",
          "return_type": "None",
          "docstring": "Helper function to check that the inner monologue exists and is valid.",
          "decorators": [],
          "start_line": 229,
          "end_line": 247,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900561
    },
    "tests/helpers/plugins_helper.py": {
      "path": "tests/helpers/plugins_helper.py",
      "contentHash": "6ead3f2d068edc3353b7c3dca092a511",
      "mtime": 1767315072120.5474,
      "functions": [
        {
          "name": "is_experimental_okay",
          "signature": "def is_experimental_okay(feature_name: str, **kwargs) -> bool",
          "parameters": "(feature_name: str, **kwargs)",
          "return_type": "bool",
          "docstring": null,
          "decorators": [],
          "start_line": 5,
          "end_line": 20,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900561
    },
    "tests/helpers/utils.py": {
      "path": "tests/helpers/utils.py",
      "contentHash": "2d98bf3c64d00b39c5aad31e17b5eff1",
      "mtime": 1767315072120.5474,
      "functions": [
        {
          "name": "retry_until_threshold",
          "signature": "def retry_until_threshold(threshold=0.5, max_attempts=10, sleep_time_seconds=4)",
          "parameters": "(threshold=0.5, max_attempts=10, sleep_time_seconds=4)",
          "return_type": null,
          "docstring": "Decorator to retry a test until a failure threshold is crossed.\n\n    :param threshold: Expected passing rate (e.g., 0.5 means 50% success rate expected).\n    :param max_attempts: Maximum number of attempts to retry the test.",
          "decorators": [],
          "start_line": 20,
          "end_line": 54,
          "is_async": false
        },
        {
          "name": "retry_until_success",
          "signature": "def retry_until_success(max_attempts=10, sleep_time_seconds=4)",
          "parameters": "(max_attempts=10, sleep_time_seconds=4)",
          "return_type": null,
          "docstring": "Decorator to retry a function until it succeeds or the maximum number of attempts is reached.\n\n    :param max_attempts: Maximum number of attempts to retry the function.\n    :param sleep_time_seconds: Time to wait between attempts, in seconds.",
          "decorators": [],
          "start_line": 57,
          "end_line": 81,
          "is_async": false
        },
        {
          "name": "cleanup_async",
          "signature": "def cleanup_async(server: SyncServer, agent_uuid: str, actor: User)",
          "parameters": "(server: SyncServer, agent_uuid: str, actor: User)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 84,
          "end_line": 89,
          "is_async": true
        },
        {
          "name": "create_tool_from_func",
          "signature": "def create_tool_from_func(func: callable)",
          "parameters": "(func: callable)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 93,
          "end_line": 101,
          "is_async": false
        },
        {
          "name": "comprehensive_agent_checks",
          "signature": "def comprehensive_agent_checks(agent: AgentState, request: Union[CreateAgent, UpdateAgent], actor: PydanticUser)",
          "parameters": "(agent: AgentState, request: Union[CreateAgent, UpdateAgent], actor: PydanticUser)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 104,
          "end_line": 173,
          "is_async": false
        },
        {
          "name": "validate_context_window_overview",
          "signature": "def validate_context_window_overview(\n    agent_state: AgentState, overview: ContextWindowOverview, attached_file: Optional[FileAgent] = None\n) -> None",
          "parameters": "(\n    agent_state: AgentState, overview: ContextWindowOverview, attached_file: Optional[FileAgent] = None\n)",
          "return_type": "None",
          "docstring": "Validate common sense assertions for ContextWindowOverview",
          "decorators": [],
          "start_line": 176,
          "end_line": 257,
          "is_async": false
        },
        {
          "name": "upload_test_agentfile_from_disk",
          "signature": "def upload_test_agentfile_from_disk(client: Letta, filename: str) -> ImportedAgentsResponse",
          "parameters": "(client: Letta, filename: str)",
          "return_type": "ImportedAgentsResponse",
          "docstring": "Upload a given .af file to live FastAPI server.",
          "decorators": [],
          "start_line": 261,
          "end_line": 270,
          "is_async": false
        },
        {
          "name": "upload_test_agentfile_from_disk_async",
          "signature": "def upload_test_agentfile_from_disk_async(client: AsyncLetta, filename: str) -> ImportedAgentsResponse",
          "parameters": "(client: AsyncLetta, filename: str)",
          "return_type": "ImportedAgentsResponse",
          "docstring": "Upload a given .af file to live FastAPI server.",
          "decorators": [],
          "start_line": 273,
          "end_line": 283,
          "is_async": true
        },
        {
          "name": "upload_file_and_wait",
          "signature": "def upload_file_and_wait(\n    client: Letta,\n    source_id: str,\n    file_path: str,\n    name: Optional[str] = None,\n    max_wait: int = 60,\n    duplicate_handling: Optional[str] = None,\n)",
          "parameters": "(\n    client: Letta,\n    source_id: str,\n    file_path: str,\n    name: Optional[str] = None,\n    max_wait: int = 60,\n    duplicate_handling: Optional[str] = None,\n)",
          "return_type": null,
          "docstring": "Helper function to upload a file and wait for processing to complete",
          "decorators": [],
          "start_line": 286,
          "end_line": 323,
          "is_async": false
        },
        {
          "name": "upload_file_and_wait_list_files",
          "signature": "def upload_file_and_wait_list_files(\n    client: Letta,\n    source_id: str,\n    file_path: str,\n    name: Optional[str] = None,\n    max_wait: int = 60,\n    duplicate_handling: Optional[str] = None,\n)",
          "parameters": "(\n    client: Letta,\n    source_id: str,\n    file_path: str,\n    name: Optional[str] = None,\n    max_wait: int = 60,\n    duplicate_handling: Optional[str] = None,\n)",
          "return_type": null,
          "docstring": "Helper function to upload a file and wait for processing using list_files instead of get_file_metadata",
          "decorators": [],
          "start_line": 326,
          "end_line": 363,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900561
    },
    "tests/integration_test_agent_tool_graph.py": {
      "path": "tests/integration_test_agent_tool_graph.py",
      "contentHash": "26460662b06af9d3120b6db079870f25",
      "mtime": 1767315072120.5474,
      "functions": [
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture()"
          ],
          "start_line": 42,
          "end_line": 48,
          "is_async": true
        },
        {
          "name": "default_config_file",
          "signature": "def default_config_file()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Provides the default config file path for tests.",
          "decorators": [
            "@pytest.fixture()"
          ],
          "start_line": 52,
          "end_line": 54,
          "is_async": false
        },
        {
          "name": "first_secret_tool",
          "signature": "def first_secret_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 58,
          "end_line": 70,
          "is_async": true
        },
        {
          "name": "second_secret_tool",
          "signature": "def second_secret_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 74,
          "end_line": 91,
          "is_async": true
        },
        {
          "name": "third_secret_tool",
          "signature": "def third_secret_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 95,
          "end_line": 112,
          "is_async": true
        },
        {
          "name": "fourth_secret_tool",
          "signature": "def fourth_secret_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 116,
          "end_line": 133,
          "is_async": true
        },
        {
          "name": "flip_coin_tool",
          "signature": "def flip_coin_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 137,
          "end_line": 151,
          "is_async": true
        },
        {
          "name": "can_play_game_tool",
          "signature": "def can_play_game_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 155,
          "end_line": 169,
          "is_async": true
        },
        {
          "name": "return_none_tool",
          "signature": "def return_none_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 173,
          "end_line": 185,
          "is_async": true
        },
        {
          "name": "auto_error_tool",
          "signature": "def auto_error_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 189,
          "end_line": 201,
          "is_async": true
        },
        {
          "name": "save_data_tool",
          "signature": "def save_data_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 205,
          "end_line": 217,
          "is_async": true
        },
        {
          "name": "cleanup_temp_files_tool",
          "signature": "def cleanup_temp_files_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 221,
          "end_line": 233,
          "is_async": true
        },
        {
          "name": "validate_api_key_tool",
          "signature": "def validate_api_key_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 237,
          "end_line": 256,
          "is_async": true
        },
        {
          "name": "noop_tool",
          "signature": "def noop_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 260,
          "end_line": 267,
          "is_async": true
        },
        {
          "name": "complex_child_tool",
          "signature": "def complex_child_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 271,
          "end_line": 289,
          "is_async": true
        },
        {
          "name": "validate_work_tool",
          "signature": "def validate_work_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 293,
          "end_line": 305,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 309,
          "end_line": 311,
          "is_async": true
        },
        {
          "name": "run_agent_step",
          "signature": "def run_agent_step(agent_state, input_messages, actor)",
          "parameters": "(agent_state, input_messages, actor)",
          "return_type": null,
          "docstring": "Helper function to run agent step using LettaAgent directly instead of server.send_messages.",
          "decorators": [],
          "start_line": 314,
          "end_line": 334,
          "is_async": true
        },
        {
          "name": "test_single_path_agent_tool_call_graph",
          "signature": "def test_single_path_agent_tool_call_graph(\n    server, disable_e2b_api_key, first_secret_tool, second_secret_tool, third_secret_tool, fourth_secret_tool, auto_error_tool, default_user\n)",
          "parameters": "(\n    server, disable_e2b_api_key, first_secret_tool, second_secret_tool, third_secret_tool, fourth_secret_tool, auto_error_tool, default_user\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.timeout(60)  # Sets a 60-second timeout for the test since this could loop infinitely",
            "@pytest.mark.asyncio"
          ],
          "start_line": 339,
          "end_line": 389,
          "is_async": true
        },
        {
          "name": "test_check_tool_rules_with_different_models_parametrized",
          "signature": "def test_check_tool_rules_with_different_models_parametrized(\n    server, disable_e2b_api_key, first_secret_tool, second_secret_tool, third_secret_tool, default_user, config_file, init_tools_case\n)",
          "parameters": "(\n    server, disable_e2b_api_key, first_secret_tool, second_secret_tool, third_secret_tool, default_user, config_file, init_tools_case\n)",
          "return_type": null,
          "docstring": "Test that tool rules are properly validated across model configurations and init tool scenarios.",
          "decorators": [
            "@pytest.mark.timeout(60)",
            "@pytest.mark.parametrize(\n    \"config_file\",\n    [\n        CLAUDE_SONNET_CONFIG,\n        OPENAI_CONFIG,\n    ],\n)",
            "@pytest.mark.parametrize(\"init_tools_case\", [\"single\", \"multiple\"])"
          ],
          "start_line": 401,
          "end_line": 438,
          "is_async": true
        },
        {
          "name": "test_claude_initial_tool_rule_enforced",
          "signature": "def test_claude_initial_tool_rule_enforced(\n    server,\n    disable_e2b_api_key,\n    first_secret_tool,\n    second_secret_tool,\n    default_user,\n)",
          "parameters": "(\n    server,\n    disable_e2b_api_key,\n    first_secret_tool,\n    second_secret_tool,\n    default_user,\n)",
          "return_type": null,
          "docstring": "Test that the initial tool rule is enforced for the first message using Claude model.",
          "decorators": [
            "@pytest.mark.timeout(180)",
            "@pytest.mark.asyncio"
          ],
          "start_line": 443,
          "end_line": 492,
          "is_async": true
        },
        {
          "name": "test_agent_no_structured_output_with_one_child_tool_parametrized",
          "signature": "def test_agent_no_structured_output_with_one_child_tool_parametrized(\n    server,\n    disable_e2b_api_key,\n    default_user,\n    config_file,\n)",
          "parameters": "(\n    server,\n    disable_e2b_api_key,\n    default_user,\n    config_file,\n)",
          "return_type": null,
          "docstring": "Test that agent correctly calls tool chains with unstructured output under various model configs.",
          "decorators": [
            "@pytest.mark.timeout(60)",
            "@pytest.mark.parametrize(\n    \"config_file\",\n    [\n        OPENAI_CONFIG,\n    ],\n)",
            "@pytest.mark.asyncio"
          ],
          "start_line": 503,
          "end_line": 566,
          "is_async": true
        },
        {
          "name": "test_init_tool_rule_always_fails",
          "signature": "def test_init_tool_rule_always_fails(\n    server,\n    disable_e2b_api_key,\n    auto_error_tool,\n    default_user,\n    include_base_tools,\n)",
          "parameters": "(\n    server,\n    disable_e2b_api_key,\n    auto_error_tool,\n    default_user,\n    include_base_tools,\n)",
          "return_type": null,
          "docstring": "Test behavior when InitToolRule invokes a tool that always fails.",
          "decorators": [
            "@pytest.mark.timeout(30)",
            "@pytest.mark.parametrize(\"include_base_tools\", [False, True])",
            "@pytest.mark.asyncio"
          ],
          "start_line": 572,
          "end_line": 600,
          "is_async": true
        },
        {
          "name": "test_init_tool_rule_args_override_llm_payload",
          "signature": "def test_init_tool_rule_args_override_llm_payload(server, disable_e2b_api_key, validate_api_key_tool, default_user)",
          "parameters": "(server, disable_e2b_api_key, validate_api_key_tool, default_user)",
          "return_type": null,
          "docstring": "InitToolRule args should override LLM-provided args for the initial tool call.",
          "decorators": [
            "@pytest.mark.timeout(60)",
            "@pytest.mark.asyncio"
          ],
          "start_line": 605,
          "end_line": 648,
          "is_async": true
        },
        {
          "name": "test_init_tool_rule_invalid_prefilled_type_blocks_flow",
          "signature": "def test_init_tool_rule_invalid_prefilled_type_blocks_flow(server, disable_e2b_api_key, validate_api_key_tool, default_user)",
          "parameters": "(server, disable_e2b_api_key, validate_api_key_tool, default_user)",
          "return_type": null,
          "docstring": "Invalid prefilled args should produce an error and prevent further flow (no send_message).",
          "decorators": [
            "@pytest.mark.timeout(60)",
            "@pytest.mark.asyncio"
          ],
          "start_line": 653,
          "end_line": 683,
          "is_async": true
        },
        {
          "name": "test_init_tool_rule_unknown_prefilled_key_blocks_flow",
          "signature": "def test_init_tool_rule_unknown_prefilled_key_blocks_flow(server, disable_e2b_api_key, validate_api_key_tool, default_user)",
          "parameters": "(server, disable_e2b_api_key, validate_api_key_tool, default_user)",
          "return_type": null,
          "docstring": "Unknown prefilled arg key should error and block flow.",
          "decorators": [
            "@pytest.mark.timeout(60)",
            "@pytest.mark.asyncio"
          ],
          "start_line": 688,
          "end_line": 716,
          "is_async": true
        },
        {
          "name": "test_child_tool_rule_args_override_llm_payload",
          "signature": "def test_child_tool_rule_args_override_llm_payload(server, disable_e2b_api_key, noop_tool, validate_api_key_tool, default_user)",
          "parameters": "(server, disable_e2b_api_key, noop_tool, validate_api_key_tool, default_user)",
          "return_type": null,
          "docstring": "ChildToolRule ToolCallNode args should override LLM-provided args for the child when the parent is the last tool.",
          "decorators": [
            "@pytest.mark.timeout(60)",
            "@pytest.mark.asyncio"
          ],
          "start_line": 721,
          "end_line": 766,
          "is_async": true
        },
        {
          "name": "test_child_tool_rule_complex_args_override",
          "signature": "def test_child_tool_rule_complex_args_override(server, disable_e2b_api_key, noop_tool, complex_child_tool, default_user)",
          "parameters": "(server, disable_e2b_api_key, noop_tool, complex_child_tool, default_user)",
          "return_type": null,
          "docstring": "ChildToolRule ToolCallNode args with complex types should override LLM-supplied args.",
          "decorators": [
            "@pytest.mark.timeout(60)",
            "@pytest.mark.asyncio"
          ],
          "start_line": 771,
          "end_line": 823,
          "is_async": true
        },
        {
          "name": "test_continue_tool_rule",
          "signature": "def test_continue_tool_rule(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": "Test the continue tool rule by forcing send_message to loop before ending with core_memory_append.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 827,
          "end_line": 870,
          "is_async": true
        },
        {
          "name": "test_single_required_before_exit_tool",
          "signature": "def test_single_required_before_exit_tool(server, disable_e2b_api_key, save_data_tool, default_user)",
          "parameters": "(server, disable_e2b_api_key, save_data_tool, default_user)",
          "return_type": null,
          "docstring": "Test that agent is forced to call a single required-before-exit tool before ending.",
          "decorators": [
            "@pytest.mark.timeout(60)",
            "@pytest.mark.asyncio"
          ],
          "start_line": 1114,
          "end_line": 1150,
          "is_async": true
        },
        {
          "name": "st_multiple_required_before_exit_tools(s",
          "signature": "def st_multiple_required_before_exit_tools(server, disable_e2b_api_key, save_data_tool, cleanup_temp_files_tool, default_user):\n",
          "parameters": "erver, disable_e2b_api_key, save_data_tool, cleanup_temp_files_tool, default_user):\n",
          "return_type": null,
          "docstring": "\"Test that agent calls all required-before-exit tools before ending.\"\"\"",
          "decorators": [
            "ytest.mark.timeout(60)\n@",
            "ytest.mark.asyncio\na"
          ],
          "start_line": 1155,
          "end_line": 1194,
          "is_async": true
        },
        {
          "name": "equired_tools_called_during_normal_flow(serve",
          "signature": "def equired_tools_called_during_normal_flow(server, disable_e2b_api_key, save_data_tool, default_user):\n    ",
          "parameters": "r, disable_e2b_api_key, save_data_tool, default_user):\n    ",
          "return_type": null,
          "docstring": "t that agent can exit normally when required tools are called during regular operation.\"\"\"\n    a",
          "decorators": [
            "t.mark.timeout(60)\n@pyte",
            "t.mark.asyncio\nasync"
          ],
          "start_line": 1243,
          "end_line": 1278,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900562
    },
    "tests/integration_test_async_tool_sandbox.py": {
      "path": "tests/integration_test_async_tool_sandbox.py",
      "contentHash": "feff3ba157d98ea3265458f884655e38",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "disable_db_pooling_for_tests",
          "signature": "def disable_db_pooling_for_tests()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Disable database connection pooling for the entire test session.",
          "decorators": [
            "@pytest.fixture(scope=\"session\", autouse=True)"
          ],
          "start_line": 46,
          "end_line": 52,
          "is_async": false
        },
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until it's accepting connections.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 70,
          "end_line": 103,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> Letta",
          "parameters": "(server_url: str)",
          "return_type": "Letta",
          "docstring": "Creates and returns a synchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 107,
          "end_line": 112,
          "is_async": false
        },
        {
          "name": "clear_tables",
          "signature": "def clear_tables()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to clear the organization table before each test.",
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 116,
          "end_line": 124,
          "is_async": true
        },
        {
          "name": "test_organization",
          "signature": "def test_organization()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 128,
          "end_line": 131,
          "is_async": true
        },
        {
          "name": "test_user",
          "signature": "def test_user(test_organization)",
          "parameters": "(test_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 135,
          "end_line": 138,
          "is_async": true
        },
        {
          "name": "add_integers_tool",
          "signature": "def add_integers_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 142,
          "end_line": 158,
          "is_async": true
        },
        {
          "name": "cowsay_tool",
          "signature": "def cowsay_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 162,
          "end_line": 180,
          "is_async": true
        },
        {
          "name": "get_env_tool",
          "signature": "def get_env_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 184,
          "end_line": 200,
          "is_async": true
        },
        {
          "name": "get_warning_tool",
          "signature": "def get_warning_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 204,
          "end_line": 220,
          "is_async": true
        },
        {
          "name": "always_err_tool",
          "signature": "def always_err_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 224,
          "end_line": 238,
          "is_async": true
        },
        {
          "name": "list_tool",
          "signature": "def list_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 242,
          "end_line": 250,
          "is_async": true
        },
        {
          "name": "clear_core_memory_tool",
          "signature": "def clear_core_memory_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 254,
          "end_line": 262,
          "is_async": true
        },
        {
          "name": "external_codebase_tool",
          "signature": "def external_codebase_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 266,
          "end_line": 271,
          "is_async": true
        },
        {
          "name": "agent_state",
          "signature": "def agent_state(server_url: str)",
          "parameters": "(server_url: str)",
          "return_type": null,
          "docstring": "Creates and returns an agent state for testing with a pre-configured agent.\n\n    Note: This fixture uses the server's internal async API instead of the client API\n    because the sandbox tests need the full server-side AgentState object with all\n    its methods (like get_agent_env_vars_as_dict()), not the simplified DTO returned\n    by the REST API.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 275,
          "end_line": 309,
          "is_async": true
        },
        {
          "name": "custom_test_sandbox_config",
          "signature": "def custom_test_sandbox_config(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": "Fixture to create a consistent local sandbox configuration for tests.\n\n    Args:\n        test_user: The test user to be used for creating the sandbox configuration.\n\n    Returns:\n        A tuple containing the SandboxConfigManager and the created sandbox configuration.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 313,
          "end_line": 339,
          "is_async": true
        },
        {
          "name": "tool_with_pip_requirements",
          "signature": "def tool_with_pip_requirements(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 344,
          "end_line": 372,
          "is_async": true
        },
        {
          "name": "tool_with_broken_pip_requirements",
          "signature": "def tool_with_broken_pip_requirements(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 376,
          "end_line": 398,
          "is_async": true
        },
        {
          "name": "core_memory_tools",
          "signature": "def core_memory_tools(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": "Create all base tools for testing.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 402,
          "end_line": 412,
          "is_async": true
        },
        {
          "name": "async_add_integers_tool",
          "signature": "def async_add_integers_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 416,
          "end_line": 436,
          "is_async": true
        },
        {
          "name": "async_get_env_tool",
          "signature": "def async_get_env_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 440,
          "end_line": 459,
          "is_async": true
        },
        {
          "name": "async_stateful_tool",
          "signature": "def async_stateful_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 463,
          "end_line": 475,
          "is_async": true
        },
        {
          "name": "async_error_tool",
          "signature": "def async_error_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 479,
          "end_line": 496,
          "is_async": true
        },
        {
          "name": "async_list_tool",
          "signature": "def async_list_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 500,
          "end_line": 510,
          "is_async": true
        },
        {
          "name": "async_complex_tool",
          "signature": "def async_complex_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 514,
          "end_line": 547,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_default",
          "signature": "def test_local_sandbox_default(disable_e2b_api_key, add_integers_tool, test_user)",
          "parameters": "(disable_e2b_api_key, add_integers_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 558,
          "end_line": 570,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_stateful_tool",
          "signature": "def test_local_sandbox_stateful_tool(disable_e2b_api_key, clear_core_memory_tool, test_user, agent_state)",
          "parameters": "(disable_e2b_api_key, clear_core_memory_tool, test_user, agent_state)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 575,
          "end_line": 582,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_with_list_rv",
          "signature": "def test_local_sandbox_with_list_rv(disable_e2b_api_key, list_tool, test_user)",
          "parameters": "(disable_e2b_api_key, list_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 587,
          "end_line": 590,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_env",
          "signature": "def test_local_sandbox_env(disable_e2b_api_key, get_env_tool, test_user)",
          "parameters": "(disable_e2b_api_key, get_env_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 595,
          "end_line": 609,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_per_agent_env",
          "signature": "def test_local_sandbox_per_agent_env(disable_e2b_api_key, get_env_tool, agent_state, test_user)",
          "parameters": "(disable_e2b_api_key, get_env_tool, agent_state, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 614,
          "end_line": 632,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_external_codebase_with_venv",
          "signature": "def test_local_sandbox_external_codebase_with_venv(\n    disable_e2b_api_key, custom_test_sandbox_config, external_codebase_tool, test_user\n)",
          "parameters": "(\n    disable_e2b_api_key, custom_test_sandbox_config, external_codebase_tool, test_user\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 637,
          "end_line": 644,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_with_venv_and_warnings_does_not_error",
          "signature": "def test_local_sandbox_with_venv_and_warnings_does_not_error(\n    disable_e2b_api_key, custom_test_sandbox_config, get_warning_tool, test_user\n)",
          "parameters": "(\n    disable_e2b_api_key, custom_test_sandbox_config, get_warning_tool, test_user\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 649,
          "end_line": 654,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_with_venv_errors",
          "signature": "def test_local_sandbox_with_venv_errors(disable_e2b_api_key, custom_test_sandbox_config, always_err_tool, test_user)",
          "parameters": "(disable_e2b_api_key, custom_test_sandbox_config, always_err_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 659,
          "end_line": 665,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_with_venv_pip_installs_basic",
          "signature": "def test_local_sandbox_with_venv_pip_installs_basic(disable_e2b_api_key, cowsay_tool, test_user)",
          "parameters": "(disable_e2b_api_key, cowsay_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 670,
          "end_line": 685,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_with_tool_pip_requirements",
          "signature": "def test_local_sandbox_with_tool_pip_requirements(disable_e2b_api_key, tool_with_pip_requirements, test_user)",
          "parameters": "(disable_e2b_api_key, tool_with_pip_requirements, test_user)",
          "return_type": null,
          "docstring": "Test that local sandbox installs tool-specific pip requirements.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 690,
          "end_line": 710,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_with_mixed_pip_requirements",
          "signature": "def test_local_sandbox_with_mixed_pip_requirements(disable_e2b_api_key, tool_with_pip_requirements, test_user)",
          "parameters": "(disable_e2b_api_key, tool_with_pip_requirements, test_user)",
          "return_type": null,
          "docstring": "Test that local sandbox installs both sandbox and tool pip requirements.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 715,
          "end_line": 739,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_with_venv_pip_installs_with_update",
          "signature": "def test_local_sandbox_with_venv_pip_installs_with_update(disable_e2b_api_key, cowsay_tool, test_user)",
          "parameters": "(disable_e2b_api_key, cowsay_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 744,
          "end_line": 767,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_default",
          "signature": "def test_e2b_sandbox_default(check_e2b_key_is_set, add_integers_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, add_integers_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 775,
          "end_line": 787,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_pip_installs",
          "signature": "def test_e2b_sandbox_pip_installs(check_e2b_key_is_set, cowsay_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, cowsay_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 792,
          "end_line": 807,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_stateful_tool",
          "signature": "def test_e2b_sandbox_stateful_tool(check_e2b_key_is_set, clear_core_memory_tool, test_user, agent_state)",
          "parameters": "(check_e2b_key_is_set, clear_core_memory_tool, test_user, agent_state)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 812,
          "end_line": 817,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_inject_env_var_existing_sandbox",
          "signature": "def test_e2b_sandbox_inject_env_var_existing_sandbox(check_e2b_key_is_set, get_env_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, get_env_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 822,
          "end_line": 841,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_per_agent_env",
          "signature": "def test_e2b_sandbox_per_agent_env(check_e2b_key_is_set, get_env_tool, agent_state, test_user)",
          "parameters": "(check_e2b_key_is_set, get_env_tool, agent_state, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 846,
          "end_line": 865,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_with_list_rv",
          "signature": "def test_e2b_sandbox_with_list_rv(check_e2b_key_is_set, list_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, list_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 870,
          "end_line": 873,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_with_tool_pip_requirements",
          "signature": "def test_e2b_sandbox_with_tool_pip_requirements(check_e2b_key_is_set, tool_with_pip_requirements, test_user)",
          "parameters": "(check_e2b_key_is_set, tool_with_pip_requirements, test_user)",
          "return_type": null,
          "docstring": "Test that E2B sandbox installs tool-specific pip requirements.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 878,
          "end_line": 892,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_with_mixed_pip_requirements",
          "signature": "def test_e2b_sandbox_with_mixed_pip_requirements(check_e2b_key_is_set, tool_with_pip_requirements, test_user)",
          "parameters": "(check_e2b_key_is_set, tool_with_pip_requirements, test_user)",
          "return_type": null,
          "docstring": "Test that E2B sandbox installs both sandbox and tool pip requirements.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 897,
          "end_line": 912,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_with_broken_tool_pip_requirements_error_handling",
          "signature": "def test_e2b_sandbox_with_broken_tool_pip_requirements_error_handling(\n    check_e2b_key_is_set, tool_with_broken_pip_requirements, test_user\n)",
          "parameters": "(\n    check_e2b_key_is_set, tool_with_broken_pip_requirements, test_user\n)",
          "return_type": null,
          "docstring": "Test that E2B sandbox provides informative error messages for broken tool pip requirements.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 917,
          "end_line": 948,
          "is_async": true
        },
        {
          "name": "test_async_function_detection",
          "signature": "def test_async_function_detection(add_integers_tool, async_add_integers_tool, test_user)",
          "parameters": "(add_integers_tool, async_add_integers_tool, test_user)",
          "return_type": null,
          "docstring": "Test that async function detection works correctly",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 955,
          "end_line": 967,
          "is_async": true
        },
        {
          "name": "test_async_template_selection",
          "signature": "def test_async_template_selection(add_integers_tool, async_add_integers_tool, test_user)",
          "parameters": "(add_integers_tool, async_add_integers_tool, test_user)",
          "return_type": null,
          "docstring": "Test that correct templates are selected for sync vs async functions",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 971,
          "end_line": 992,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_async_function_execution",
          "signature": "def test_local_sandbox_async_function_execution(disable_e2b_api_key, async_add_integers_tool, test_user)",
          "parameters": "(disable_e2b_api_key, async_add_integers_tool, test_user)",
          "return_type": null,
          "docstring": "Test that async functions execute correctly in local sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 997,
          "end_line": 1003,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_async_function_execution",
          "signature": "def test_e2b_sandbox_async_function_execution(check_e2b_key_is_set, async_add_integers_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, async_add_integers_tool, test_user)",
          "return_type": null,
          "docstring": "Test that async functions execute correctly in E2B sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 1008,
          "end_line": 1014,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_async_complex_computation",
          "signature": "def test_local_sandbox_async_complex_computation(disable_e2b_api_key, async_complex_tool, test_user)",
          "parameters": "(disable_e2b_api_key, async_complex_tool, test_user)",
          "return_type": null,
          "docstring": "Test complex async computation with multiple awaits in local sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 1019,
          "end_line": 1030,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_async_complex_computation",
          "signature": "def test_e2b_sandbox_async_complex_computation(check_e2b_key_is_set, async_complex_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, async_complex_tool, test_user)",
          "return_type": null,
          "docstring": "Test complex async computation with multiple awaits in E2B sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 1035,
          "end_line": 1047,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_async_list_return",
          "signature": "def test_local_sandbox_async_list_return(disable_e2b_api_key, async_list_tool, test_user)",
          "parameters": "(disable_e2b_api_key, async_list_tool, test_user)",
          "return_type": null,
          "docstring": "Test async function returning list in local sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 1052,
          "end_line": 1056,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_async_list_return",
          "signature": "def test_e2b_sandbox_async_list_return(check_e2b_key_is_set, async_list_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, async_list_tool, test_user)",
          "return_type": null,
          "docstring": "Test async function returning list in E2B sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 1061,
          "end_line": 1065,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_async_with_env_vars",
          "signature": "def test_local_sandbox_async_with_env_vars(disable_e2b_api_key, async_get_env_tool, test_user)",
          "parameters": "(disable_e2b_api_key, async_get_env_tool, test_user)",
          "return_type": null,
          "docstring": "Test async function with environment variables in local sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 1070,
          "end_line": 1089,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_async_with_env_vars",
          "signature": "def test_e2b_sandbox_async_with_env_vars(check_e2b_key_is_set, async_get_env_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, async_get_env_tool, test_user)",
          "return_type": null,
          "docstring": "Test async function with environment variables in E2B sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 1094,
          "end_line": 1110,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_async_with_agent_state",
          "signature": "def test_local_sandbox_async_with_agent_state(disable_e2b_api_key, async_stateful_tool, test_user, agent_state)",
          "parameters": "(disable_e2b_api_key, async_stateful_tool, test_user, agent_state)",
          "return_type": null,
          "docstring": "Test async function with agent state in local sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 1115,
          "end_line": 1123,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_async_with_agent_state",
          "signature": "def test_e2b_sandbox_async_with_agent_state(check_e2b_key_is_set, async_stateful_tool, test_user, agent_state)",
          "parameters": "(check_e2b_key_is_set, async_stateful_tool, test_user, agent_state)",
          "return_type": null,
          "docstring": "Test async function with agent state in E2B sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 1128,
          "end_line": 1135,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_async_error_handling",
          "signature": "def test_local_sandbox_async_error_handling(disable_e2b_api_key, async_error_tool, test_user)",
          "parameters": "(disable_e2b_api_key, async_error_tool, test_user)",
          "return_type": null,
          "docstring": "Test async function error handling in local sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 1140,
          "end_line": 1149,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_async_error_handling",
          "signature": "def test_e2b_sandbox_async_error_handling(check_e2b_key_is_set, async_error_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, async_error_tool, test_user)",
          "return_type": null,
          "docstring": "Test async function error handling in E2B sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 1154,
          "end_line": 1163,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_async_per_agent_env",
          "signature": "def test_local_sandbox_async_per_agent_env(disable_e2b_api_key, async_get_env_tool, agent_state, test_user)",
          "parameters": "(disable_e2b_api_key, async_get_env_tool, agent_state, test_user)",
          "return_type": null,
          "docstring": "Test async function with per-agent environment variables in local sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 1168,
          "end_line": 1187,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_async_per_agent_env",
          "signature": "def test_e2b_sandbox_async_per_agent_env(check_e2b_key_is_set, async_get_env_tool, agent_state, test_user)",
          "parameters": "(check_e2b_key_is_set, async_get_env_tool, agent_state, test_user)",
          "return_type": null,
          "docstring": "Test async function with per-agent environment variables in E2B sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 1192,
          "end_line": 1212,
          "is_async": true
        },
        {
          "name": "list_tools_with_client_tool",
          "signature": "def list_tools_with_client_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": "Tool that uses the client (available in sandbox scope) to list tools.\n\n    Note: The `client` variable is always available in the sandbox scope,\n    so tools can access it directly without declaring it as a parameter.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 1219,
          "end_line": 1266,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_with_client_injection",
          "signature": "def test_local_sandbox_with_client_injection(disable_e2b_api_key, list_tools_with_client_tool, test_user, server_url)",
          "parameters": "(disable_e2b_api_key, list_tools_with_client_tool, test_user, server_url)",
          "return_type": null,
          "docstring": "Test that local sandbox can inject Letta client for tools that need it.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 1271,
          "end_line": 1327,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_with_client_injection",
          "signature": "def test_e2b_sandbox_with_client_injection(check_e2b_key_is_set, list_tools_with_client_tool, test_user, server_url)",
          "parameters": "(check_e2b_key_is_set, list_tools_with_client_tool, test_user, server_url)",
          "return_type": null,
          "docstring": "Test that E2B sandbox can inject Letta client for tools that need it.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 1332,
          "end_line": 1375,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900562
    },
    "tests/integration_test_batch_api_cron_jobs.py": {
      "path": "tests/integration_test_batch_api_cron_jobs.py",
      "contentHash": "2760c525c61563c4a9afefd454217d51",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensures a server is running and returns its base URL.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 59,
          "end_line": 68,
          "is_async": false
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 72,
          "end_line": 76,
          "is_async": false
        },
        {
          "name": "create_batch_response",
          "signature": "def create_batch_response(batch_id: str, processing_status: str = \"in_progress\") -> BetaMessageBatch",
          "parameters": "(batch_id: str, processing_status: str = \"in_progress\")",
          "return_type": "BetaMessageBatch",
          "docstring": "Create a dummy BetaMessageBatch with the specified ID and status.",
          "decorators": [],
          "start_line": 82,
          "end_line": 102,
          "is_async": false
        },
        {
          "name": "create_successful_response",
          "signature": "def create_successful_response(custom_id: str) -> BetaMessageBatchIndividualResponse",
          "parameters": "(custom_id: str)",
          "return_type": "BetaMessageBatchIndividualResponse",
          "docstring": "Create a dummy successful batch response.",
          "decorators": [],
          "start_line": 105,
          "end_line": 121,
          "is_async": false
        },
        {
          "name": "create_failed_response",
          "signature": "def create_failed_response(custom_id: str) -> BetaMessageBatchIndividualResponse",
          "parameters": "(custom_id: str)",
          "return_type": "BetaMessageBatchIndividualResponse",
          "docstring": "Create a dummy failed batch response with a rate limit error.",
          "decorators": [],
          "start_line": 124,
          "end_line": 132,
          "is_async": false
        },
        {
          "name": "create_test_agent",
          "signature": "def create_test_agent(name, actor, test_id: Optional[str] = None, model=\"anthropic/claude-sonnet-4-20250514\")",
          "parameters": "(name, actor, test_id: Optional[str] = None, model=\"anthropic/claude-sonnet-4-20250514\")",
          "return_type": null,
          "docstring": "Create a test agent with standardized configuration.",
          "decorators": [],
          "start_line": 138,
          "end_line": 169,
          "is_async": true
        },
        {
          "name": "create_test_letta_batch_job_async",
          "signature": "def create_test_letta_batch_job_async(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": "Create a test batch job with the given batch response.",
          "decorators": [],
          "start_line": 172,
          "end_line": 174,
          "is_async": true
        },
        {
          "name": "create_test_llm_batch_job_async",
          "signature": "def create_test_llm_batch_job_async(server, batch_response, default_user)",
          "parameters": "(server, batch_response, default_user)",
          "return_type": null,
          "docstring": "Create a test batch job with the given batch response.",
          "decorators": [],
          "start_line": 177,
          "end_line": 187,
          "is_async": true
        },
        {
          "name": "create_test_batch_item",
          "signature": "def create_test_batch_item(server, batch_id, agent_id, default_user)",
          "parameters": "(server, batch_id, agent_id, default_user)",
          "return_type": null,
          "docstring": "Create a test batch item for the given batch and agent.",
          "decorators": [],
          "start_line": 190,
          "end_line": 212,
          "is_async": true
        },
        {
          "name": "mock_anthropic_client",
          "signature": "def mock_anthropic_client(server, batch_a_resp, batch_b_resp, agent_b_id, agent_c_id)",
          "parameters": "(server, batch_a_resp, batch_b_resp, agent_b_id, agent_c_id)",
          "return_type": null,
          "docstring": "Set up mocks for the Anthropic client's retrieve and results methods.",
          "decorators": [],
          "start_line": 215,
          "end_line": 254,
          "is_async": false
        },
        {
          "name": "test_polling_mixed_batch_jobs",
          "signature": "def test_polling_mixed_batch_jobs(default_user, server)",
          "parameters": "(default_user, server)",
          "return_type": null,
          "docstring": "End-to-end test for polling batch jobs with mixed statuses and idempotency.\n\n    Test scenario:\n      - Create two batch jobs:\n          - Job A: Single agent that remains \"in_progress\"\n          - Job B: Two agents that complete (one succeeds, one fails)\n      - Poll jobs and verify:\n          - Job A remains in \"running\" state\n          - Job B moves to \"completed\" state\n          - Job B's items reflect appropriate individual success/failure statuses\n      - Test idempotency:\n          - Run additional polls and verify:\n              - Completed job B remains unchanged (no status changes or re-polling)\n              - In-progress job A continues to be polled\n              - All batch items maintain their final states",
          "decorators": [
            "@pytest.mark.asyncio(loop_scope=\"module\")"
          ],
          "start_line": 261,
          "end_line": 376,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900562
    },
    "tests/integration_test_batch_sdk.py": {
      "path": "tests/integration_test_batch_sdk.py",
      "contentHash": "934c359411f18999ff6511675f596925",
      "mtime": 1767315072120.5474,
      "functions": [
        {
          "name": "clear_batch_tables",
          "signature": "def clear_batch_tables()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Clear batch-related tables before each test.",
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 18,
          "end_line": 24,
          "is_async": false
        },
        {
          "name": "run_server",
          "signature": "def run_server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Starts the Letta server in a background thread.",
          "decorators": [],
          "start_line": 27,
          "end_line": 32,
          "is_async": false
        },
        {
          "name": "server_url",
          "signature": "def server_url()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensures a server is running and returns its base URL.\n\n    Uses environment variable if available, otherwise starts a server\n    in a background thread.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 36,
          "end_line": 50,
          "is_async": false
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Creates a SyncServer instance for testing.\n\n    Loads and saves config to ensure proper initialization.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 54,
          "end_line": 62,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url)",
          "parameters": "(server_url)",
          "return_type": null,
          "docstring": "Creates a REST client connected to the test server.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 66,
          "end_line": 68,
          "is_async": false
        },
        {
          "name": "test_create_batch",
          "signature": "def test_create_batch(client: Letta, server: SyncServer)",
          "parameters": "(client: Letta, server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 72,
          "end_line": 139,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900562
    },
    "tests/integration_test_builtin_tools.py": {
      "path": "tests/integration_test_builtin_tools.py",
      "contentHash": "3c7890f4801a1714ca94f238f1646311",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "\"\"\"\n    Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until its accepting connections.\n    \"\"\"",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 24,
          "end_line": 57,
          "is_async": false
        },
        {
          "name": "ient(s",
          "signature": "def ient(server_url: str) - -> tta:\n",
          "parameters": "erver_url: str) -",
          "return_type": "tta:\n",
          "docstring": "\"\n    Creates and returns a synchronous Letta REST client for testing.\n    \"\"\"",
          "decorators": [
            "ytest.fixture(scope=\"module\")\nd"
          ],
          "start_line": 61,
          "end_line": 66,
          "is_async": false
        },
        {
          "name": "ent_state(c",
          "signature": "def ent_state(client: Letta) - -> entState:\n",
          "parameters": "lient: Letta) -",
          "return_type": "entState:\n",
          "docstring": "\"\n    Creates and returns an agent state for testing with a pre-configured agent.\n    Uses system-level EXA_API_KEY setting.\n    \"\"\"",
          "decorators": [
            "ytest.fixture(scope=\"function\")\nd"
          ],
          "start_line": 70,
          "end_line": 86,
          "is_async": false
        },
        {
          "name": "ference_partition(n",
          "signature": "def ference_partition(n: int) - -> t:\n",
          "parameters": ": int) -",
          "return_type": "t:\n",
          "docstring": null,
          "decorators": [],
          "start_line": 109,
          "end_line": 115,
          "is_async": false
        },
        {
          "name": "st_run_code(\n",
          "signature": "def st_run_code(\n    client: Letta,\n    agent_state: AgentState,\n    language: str,\n) - -> ne:\n",
          "parameters": "    client: Letta,\n    agent_state: AgentState,\n    language: str,\n) -",
          "return_type": "ne:\n",
          "docstring": "\"\n    Sends a reference Python implementation, asks the model to translate & run it\n    in different languages, and verifies the exact partition(100) result.\n    \"\"\"",
          "decorators": [
            "ytest.mark.parametrize(\"language\", TEST_LANGUAGES, ids=TEST_LANGUAGES)\nd"
          ],
          "start_line": 124,
          "end_line": 157,
          "is_async": false
        },
        {
          "name": "st_web_search()",
          "signature": "def st_web_search() - -> ne:\n",
          "parameters": " -",
          "return_type": "ne:\n",
          "docstring": "\"Test web search tool with mocked Exa API.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio(scope=\"function\")\na"
          ],
          "start_line": 161,
          "end_line": 254,
          "is_async": true
        },
        {
          "name": "st_web_search_uses_exa()",
          "signature": "def st_web_search_uses_exa():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that web search uses Exa API correctly.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio(scope=\"function\")\na"
          ],
          "start_line": 258,
          "end_line": 313,
          "is_async": true
        },
        {
          "name": "ent_with_custom_tools(c",
          "signature": "def ent_with_custom_tools(client: Letta) - -> entState:\n",
          "parameters": "lient: Letta) -",
          "return_type": "entState:\n",
          "docstring": "\"\n    Creates an agent with custom add/multiply tools and run_code tool\n    to test programmatic tool calling.\n    \"\"\"",
          "decorators": [
            "ytest.fixture(scope=\"function\")\nd"
          ],
          "start_line": 351,
          "end_line": 377,
          "is_async": false
        },
        {
          "name": "st_programmatic_tool_calling_compose_tools(\n",
          "signature": "def st_programmatic_tool_calling_compose_tools(\n    client: Letta,\n    agent_with_custom_tools: AgentState,\n) - -> ne:\n",
          "parameters": "    client: Letta,\n    agent_with_custom_tools: AgentState,\n) -",
          "return_type": "ne:\n",
          "docstring": "\"\n    Tests that run_code can compose agent tools programmatically in a SINGLE call.\n    This validates that:\n    1. Tool source code is injected into the sandbox\n    2. Claude composes tools in one run_code call, not multiple separate tool calls\n    3. The result is computed correctly: add(multiply(4, 5), 6) = 26\n    \"\"\"",
          "decorators": [],
          "start_line": 380,
          "end_line": 432,
          "is_async": false
        },
        {
          "name": "st_run_code_injects_tool_source_code()",
          "signature": "def st_run_code_injects_tool_source_code() - -> ne:\n",
          "parameters": " -",
          "return_type": "ne:\n",
          "docstring": "\"\n    Unit test that verifies run_code injects agent tool source code into the sandbox.\n    This test directly calls run_code with a mocked agent_state containing tools.\n    \"\"\"",
          "decorators": [
            "ytest.mark.asyncio(scope=\"function\")\na"
          ],
          "start_line": 436,
          "end_line": 486,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900563
    },
    "tests/integration_test_cancellation.py": {
      "path": "tests/integration_test_cancellation.py",
      "contentHash": "b8b2c525fefc7a031c4613bf8d1a6652",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "get_llm_config",
          "signature": "def get_llm_config(filename: str, llm_config_dir: str = \"tests/configs/llm_model_configs\") -> LLMConfig",
          "parameters": "(filename: str, llm_config_dir: str = \"tests/configs/llm_model_configs\")",
          "return_type": "LLMConfig",
          "docstring": null,
          "decorators": [],
          "start_line": 20,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "roll_dice",
          "signature": "def roll_dice(num_sides: int) -> int",
          "parameters": "(num_sides: int)",
          "return_type": "int",
          "docstring": "Returns a random number between 1 and num_sides.\n    Args:\n        num_sides (int): The number of sides on the die.\n    Returns:\n        int: A random integer between 1 and num_sides, representing the die roll.",
          "decorators": [],
          "start_line": 42,
          "end_line": 52,
          "is_async": false
        },
        {
          "name": "accumulate_chunks",
          "signature": "def accumulate_chunks(chunks: Any) -> List[Any]",
          "parameters": "(chunks: Any)",
          "return_type": "List[Any]",
          "docstring": "Accumulates chunks into a list of messages.",
          "decorators": [],
          "start_line": 63,
          "end_line": 79,
          "is_async": true
        },
        {
          "name": "cancel_run_after_delay",
          "signature": "def cancel_run_after_delay(client: AsyncLetta, agent_id: str, delay: float = 0.5)",
          "parameters": "(client: AsyncLetta, agent_id: str, delay: float = 0.5)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 82,
          "end_line": 84,
          "is_async": true
        },
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until it's accepting connections.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 88,
          "end_line": 127,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> AsyncLetta",
          "parameters": "(server_url: str)",
          "return_type": "AsyncLetta",
          "docstring": "Creates and returns an asynchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 131,
          "end_line": 136,
          "is_async": true
        },
        {
          "name": "agent_state",
          "signature": "def agent_state(client: AsyncLetta) -> AgentState",
          "parameters": "(client: AsyncLetta)",
          "return_type": "AgentState",
          "docstring": "Creates and returns an agent state for testing with a pre-configured agent.\n    The agent is configured with the roll_dice tool.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 140,
          "end_line": 158,
          "is_async": true
        },
        {
          "name": "test_background_streaming_cancellation",
          "signature": "def test_background_streaming_cancellation(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    agent_state: AgentState,\n    llm_config: LLMConfig,\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    agent_state: AgentState,\n    llm_config: LLMConfig,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [
            "@pytest.mark.skipif(not os.getenv(\"LETTA_REDIS_HOST\"), reason=\"Redis is required for background streaming (set LETTA_REDIS_HOST to enable)\")",
            "@pytest.mark.parametrize(\n    \"llm_config\",\n    TESTED_LLM_CONFIGS,\n    ids=[c.model for c in TESTED_LLM_CONFIGS],\n)",
            "@pytest.mark.asyncio(loop_scope=\"function\")"
          ],
          "start_line": 168,
          "end_line": 200,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900563
    },
    "tests/integration_test_chat_completions.py": {
      "path": "tests/integration_test_chat_completions.py",
      "contentHash": "9171f82dbf1745d0e073e0e51c5097e7",
      "mtime": 1767315072124.5476,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensures a server is running and returns its base URL.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 32,
          "end_line": 41,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url)",
          "parameters": "(server_url)",
          "return_type": null,
          "docstring": "Creates a REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 48,
          "end_line": 51,
          "is_async": false
        },
        {
          "name": "roll_dice_tool",
          "signature": "def roll_dice_tool(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 55,
          "end_line": 67,
          "is_async": false
        },
        {
          "name": "weather_tool",
          "signature": "def weather_tool(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 71,
          "end_line": 98,
          "is_async": false
        },
        {
          "name": "agent",
          "signature": "def agent(client, roll_dice_tool, weather_tool)",
          "parameters": "(client, roll_dice_tool, weather_tool)",
          "return_type": null,
          "docstring": "Creates an agent and ensures cleanup after tests.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 102,
          "end_line": 116,
          "is_async": false
        },
        {
          "name": "test_chat_completions_streaming_openai_client",
          "signature": "def test_chat_completions_streaming_openai_client(disable_e2b_api_key, client, agent, roll_dice_tool, message)",
          "parameters": "(disable_e2b_api_key, client, agent, roll_dice_tool, message)",
          "return_type": null,
          "docstring": "Tests Letta's OpenAI-compatible chat completions streaming endpoint.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"message\", [\"Tell me a short joke\"])"
          ],
          "start_line": 155,
          "end_line": 196,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900563
    },
    "tests/integration_test_client_side_tools.py": {
      "path": "tests/integration_test_client_side_tools.py",
      "contentHash": "f8ce5af87ba5c5253e4aa34b725f50f7",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "get_client_tool_schema",
          "signature": "def get_client_tool_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Returns a client-side tool schema for testing.",
          "decorators": [],
          "start_line": 29,
          "end_line": 44,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> Letta",
          "parameters": "(server_url: str)",
          "return_type": "Letta",
          "docstring": "Create a Letta client.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 53,
          "end_line": 55,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900563
    },
    "tests/integration_test_composio.py": {
      "path": "tests/integration_test_composio.py",
      "contentHash": "5c53755ae63c05ebf78205b79e834a09",
      "mtime": 1767315072124.5476,
      "functions": [
        {
          "name": "fastapi_client",
          "signature": "def fastapi_client()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 18,
          "end_line": 19,
          "is_async": false
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 23,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "composio_get_emojis",
          "signature": "def composio_get_emojis(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 34,
          "end_line": 37,
          "is_async": false
        },
        {
          "name": "test_list_composio_apps",
          "signature": "def test_list_composio_apps(fastapi_client)",
          "parameters": "(fastapi_client)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 40,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "test_list_composio_actions_by_app",
          "signature": "def test_list_composio_actions_by_app(fastapi_client)",
          "parameters": "(fastapi_client)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 46,
          "end_line": 49,
          "is_async": false
        },
        {
          "name": "test_add_composio_tool",
          "signature": "def test_add_composio_tool(fastapi_client)",
          "parameters": "(fastapi_client)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 52,
          "end_line": 56,
          "is_async": false
        },
        {
          "name": "test_composio_tool_execution_e2e",
          "signature": "def test_composio_tool_execution_e2e(check_composio_key_set, composio_get_emojis, server: SyncServer, default_user)",
          "parameters": "(check_composio_key_set, composio_get_emojis, server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 59,
          "end_line": 84,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900563
    },
    "tests/integration_test_conversations_sdk.py": {
      "path": "tests/integration_test_conversations_sdk.py",
      "contentHash": "3cd06b97f19f41332b8eabedb1cb9e78",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "client",
          "signature": "def client(server_url: str) -> Letta",
          "parameters": "(server_url: str)",
          "return_type": "Letta",
          "docstring": "Create a Letta client.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 13,
          "end_line": 15,
          "is_async": false
        },
        {
          "name": "agent",
          "signature": "def agent(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Create a test agent.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 19,
          "end_line": 32,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900563
    },
    "tests/integration_test_human_in_the_loop.py": {
      "path": "tests/integration_test_human_in_the_loop.py",
      "contentHash": "20a893c06a3260a369d9ccbf9a7a1756",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "get_secret_code_tool",
          "signature": "def get_secret_code_tool(input_text: str) -> str",
          "parameters": "(input_text: str)",
          "return_type": "str",
          "docstring": "A tool that returns the secret code based on the input. This tool requires approval before execution.\n    Args:\n        input_text (str): The input text to process.\n    Returns:\n        str: The secret code based on the input text.",
          "decorators": [],
          "start_line": 49,
          "end_line": 57,
          "is_async": false
        },
        {
          "name": "roll_dice_tool",
          "signature": "def roll_dice_tool(num_sides: int) -> str",
          "parameters": "(num_sides: int)",
          "return_type": "str",
          "docstring": "A tool that returns a random number between 1 and num_sides.\n    Args:\n        num_sides (int): The number of sides on the die.\n    Returns:\n        str: The random number between 1 and num_sides.",
          "decorators": [],
          "start_line": 60,
          "end_line": 70,
          "is_async": false
        },
        {
          "name": "accumulate_chunks",
          "signature": "def accumulate_chunks(stream)",
          "parameters": "(stream)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 73,
          "end_line": 102,
          "is_async": false
        },
        {
          "name": "approve_tool_call",
          "signature": "def approve_tool_call(client: Letta, agent_id: str, tool_call_id: str)",
          "parameters": "(client: Letta, agent_id: str, tool_call_id: str)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 105,
          "end_line": 120,
          "is_async": false
        },
        {
          "name": "approval_tool_fixture",
          "signature": "def approval_tool_fixture(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Creates and returns a tool that requires approval for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 130,
          "end_line": 140,
          "is_async": false
        },
        {
          "name": "dice_tool_fixture",
          "signature": "def dice_tool_fixture(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 144,
          "end_line": 150,
          "is_async": false
        },
        {
          "name": "agent",
          "signature": "def agent(client: Letta, approval_tool_fixture, dice_tool_fixture) -> AgentState",
          "parameters": "(client: Letta, approval_tool_fixture, dice_tool_fixture)",
          "return_type": "AgentState",
          "docstring": "Creates and returns an agent state for testing with a pre-configured agent.\n    The agent is configured with the requires_approval_tool.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 154,
          "end_line": 174,
          "is_async": false
        },
        {
          "name": "test_send_approval_without_pending_request",
          "signature": "def test_send_approval_without_pending_request(client, agent)",
          "parameters": "(client, agent)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 182,
          "end_line": 198,
          "is_async": false
        },
        {
          "name": "test_send_user_message_with_pending_request",
          "signature": "def test_send_user_message_with_pending_request(client, agent)",
          "parameters": "(client, agent)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 201,
          "end_line": 216,
          "is_async": false
        },
        {
          "name": "test_send_approval_message_with_incorrect_request_id",
          "signature": "def test_send_approval_message_with_incorrect_request_id(client, agent)",
          "parameters": "(client, agent)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 219,
          "end_line": 242,
          "is_async": false
        },
        {
          "name": "test_invoke_approval_request",
          "signature": "def test_invoke_approval_request(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 250,
          "end_line": 290,
          "is_async": false
        },
        {
          "name": "test_invoke_approval_request_stream",
          "signature": "def test_invoke_approval_request_stream(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 293,
          "end_line": 314,
          "is_async": false
        },
        {
          "name": "test_invoke_tool_after_turning_off_requires_approval",
          "signature": "def test_invoke_tool_after_turning_off_requires_approval(\n    client: Letta,\n    agent: AgentState,\n    approval_tool_fixture: Tool,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n    approval_tool_fixture: Tool,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 317,
          "end_line": 383,
          "is_async": false
        },
        {
          "name": "test_approve_tool_call_request",
          "signature": "def test_approve_tool_call_request(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 391,
          "end_line": 425,
          "is_async": false
        },
        {
          "name": "test_approve_cursor_fetch",
          "signature": "def test_approve_cursor_fetch(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 428,
          "end_line": 472,
          "is_async": false
        },
        {
          "name": "test_approve_with_context_check",
          "signature": "def test_approve_with_context_check(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 475,
          "end_line": 509,
          "is_async": false
        },
        {
          "name": "test_approve_and_follow_up",
          "signature": "def test_approve_and_follow_up(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 512,
          "end_line": 549,
          "is_async": false
        },
        {
          "name": "test_approve_and_follow_up_with_error",
          "signature": "def test_approve_and_follow_up_with_error(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 552,
          "end_line": 599,
          "is_async": false
        },
        {
          "name": "test_approve_with_user_message",
          "signature": "def test_approve_with_user_message(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 602,
          "end_line": 644,
          "is_async": false
        },
        {
          "name": "test_deny_tool_call_request",
          "signature": "def test_deny_tool_call_request(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 652,
          "end_line": 685,
          "is_async": false
        },
        {
          "name": "test_deny_cursor_fetch",
          "signature": "def test_deny_cursor_fetch(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 688,
          "end_line": 733,
          "is_async": false
        },
        {
          "name": "test_deny_with_context_check",
          "signature": "def test_deny_with_context_check(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 736,
          "end_line": 771,
          "is_async": false
        },
        {
          "name": "test_deny_and_follow_up",
          "signature": "def test_deny_and_follow_up(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 774,
          "end_line": 812,
          "is_async": false
        },
        {
          "name": "test_deny_and_follow_up_with_error",
          "signature": "def test_deny_and_follow_up_with_error(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 815,
          "end_line": 859,
          "is_async": false
        },
        {
          "name": "test_deny_with_user_message",
          "signature": "def test_deny_with_user_message(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 862,
          "end_line": 904,
          "is_async": false
        },
        {
          "name": "test_client_side_tool_call_request",
          "signature": "def test_client_side_tool_call_request(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 912,
          "end_line": 947,
          "is_async": false
        },
        {
          "name": "test_client_side_tool_call_cursor_fetch",
          "signature": "def test_client_side_tool_call_cursor_fetch(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 950,
          "end_line": 998,
          "is_async": false
        },
        {
          "name": "test_client_side_tool_call_with_context_check",
          "signature": "def test_client_side_tool_call_with_context_check(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 1001,
          "end_line": 1036,
          "is_async": false
        },
        {
          "name": "test_client_side_tool_call_and_follow_up",
          "signature": "def test_client_side_tool_call_and_follow_up(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 1039,
          "end_line": 1077,
          "is_async": false
        },
        {
          "name": "test_client_side_tool_call_and_follow_up_with_error",
          "signature": "def test_client_side_tool_call_and_follow_up_with_error(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 1080,
          "end_line": 1124,
          "is_async": false
        },
        {
          "name": "test_client_side_tool_call_with_user_message",
          "signature": "def test_client_side_tool_call_with_user_message(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 1127,
          "end_line": 1170,
          "is_async": false
        },
        {
          "name": "test_parallel_tool_calling",
          "signature": "def test_parallel_tool_calling(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [],
          "start_line": 1173,
          "end_line": 1288,
          "is_async": false
        },
        {
          "name": "test_agent_records_last_stop_reason_after_approval_flow",
          "signature": "def test_agent_records_last_stop_reason_after_approval_flow(\n    client: Letta,\n    agent: AgentState,\n) -> None",
          "parameters": "(\n    client: Letta,\n    agent: AgentState,\n)",
          "return_type": "None",
          "docstring": "Test that the agent's last_stop_reason is properly updated after a human-in-the-loop flow.\n    This verifies the integration between run completion and agent state updates.",
          "decorators": [],
          "start_line": 1291,
          "end_line": 1335,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900564
    },
    "tests/integration_test_mcp.py": {
      "path": "tests/integration_test_mcp.py",
      "contentHash": "df8fb16cc9f0dba509190942d130f4e2",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until it's accepting connections.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 28,
          "end_line": 61,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> Letta",
          "parameters": "(server_url: str)",
          "return_type": "Letta",
          "docstring": "Creates and returns a synchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 65,
          "end_line": 70,
          "is_async": false
        },
        {
          "name": "mcp_server_name",
          "signature": "def mcp_server_name() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Generate a unique MCP server name for each test.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 74,
          "end_line": 76,
          "is_async": false
        },
        {
          "name": "mock_mcp_server_config",
          "signature": "def mock_mcp_server_config(mcp_server_name: str) -> StdioServerConfig",
          "parameters": "(mcp_server_name: str)",
          "return_type": "StdioServerConfig",
          "docstring": "Creates a stdio configuration for the mock MCP server.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 80,
          "end_line": 95,
          "is_async": false
        },
        {
          "name": "agent_state",
          "signature": "def agent_state(client: Letta, mcp_server_name: str, mock_mcp_server_config: StdioServerConfig) -> AgentState",
          "parameters": "(client: Letta, mcp_server_name: str, mock_mcp_server_config: StdioServerConfig)",
          "return_type": "AgentState",
          "docstring": "Creates an agent with MCP tools attached for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 99,
          "end_line": 156,
          "is_async": false
        },
        {
          "name": "test_mcp_echo_tool",
          "signature": "def test_mcp_echo_tool(client: Letta, agent_state: AgentState)",
          "parameters": "(client: Letta, agent_state: AgentState)",
          "return_type": null,
          "docstring": "Test that an agent can successfully call the echo tool from the MCP server.",
          "decorators": [],
          "start_line": 164,
          "end_line": 198,
          "is_async": false
        },
        {
          "name": "test_mcp_add_tool",
          "signature": "def test_mcp_add_tool(client: Letta, agent_state: AgentState)",
          "parameters": "(client: Letta, agent_state: AgentState)",
          "return_type": null,
          "docstring": "Test that an agent can successfully call the add tool from the MCP server.",
          "decorators": [],
          "start_line": 201,
          "end_line": 236,
          "is_async": false
        },
        {
          "name": "test_mcp_multiple_tools_in_sequence",
          "signature": "def test_mcp_multiple_tools_in_sequence(client: Letta, agent_state: AgentState)",
          "parameters": "(client: Letta, agent_state: AgentState)",
          "return_type": null,
          "docstring": "Test that an agent can call multiple MCP tools in sequence.",
          "decorators": [],
          "start_line": 239,
          "end_line": 268,
          "is_async": false
        },
        {
          "name": "test_mcp_server_listing",
          "signature": "def test_mcp_server_listing(client: Letta, mcp_server_name: str, mock_mcp_server_config: StdioServerConfig)",
          "parameters": "(client: Letta, mcp_server_name: str, mock_mcp_server_config: StdioServerConfig)",
          "return_type": null,
          "docstring": "Test that MCP server registration and tool listing works correctly.",
          "decorators": [],
          "start_line": 271,
          "end_line": 307,
          "is_async": false
        },
        {
          "name": "test_mcp_complex_schema_tool",
          "signature": "def test_mcp_complex_schema_tool(client: Letta, mcp_server_name: str, mock_mcp_server_config: StdioServerConfig)",
          "parameters": "(client: Letta, mcp_server_name: str, mock_mcp_server_config: StdioServerConfig)",
          "return_type": null,
          "docstring": "Test that an agent can successfully call a tool with complex nested schema.\n    This tests the get_parameter_type_description tool which has:\n    - Enum-like preset parameter\n    - Optional string field\n    - Optional nested object with arrays of objects",
          "decorators": [],
          "start_line": 310,
          "end_line": 415,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900564
    },
    "tests/integration_test_modal.py": {
      "path": "tests/integration_test_modal.py",
      "contentHash": "c30bf5c89106b094444703a91bb0e106",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "disable_db_pooling_for_tests",
          "signature": "def disable_db_pooling_for_tests()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Disable database connection pooling for the entire test session.",
          "decorators": [
            "@pytest.fixture(scope=\"session\", autouse=True)"
          ],
          "start_line": 41,
          "end_line": 47,
          "is_async": false
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Creates a SyncServer instance for testing.\n\n    Loads and saves config to ensure proper initialization.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 65,
          "end_line": 77,
          "is_async": false
        },
        {
          "name": "clear_tables",
          "signature": "def clear_tables()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to clear the organization table before each test.",
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 81,
          "end_line": 89,
          "is_async": true
        },
        {
          "name": "test_organization",
          "signature": "def test_organization()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 93,
          "end_line": 96,
          "is_async": true
        },
        {
          "name": "test_user",
          "signature": "def test_user(test_organization)",
          "parameters": "(test_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 100,
          "end_line": 103,
          "is_async": true
        },
        {
          "name": "add_integers_tool",
          "signature": "def add_integers_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 107,
          "end_line": 123,
          "is_async": true
        },
        {
          "name": "cowsay_tool",
          "signature": "def cowsay_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 127,
          "end_line": 147,
          "is_async": true
        },
        {
          "name": "get_env_tool",
          "signature": "def get_env_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 151,
          "end_line": 167,
          "is_async": true
        },
        {
          "name": "get_warning_tool",
          "signature": "def get_warning_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 171,
          "end_line": 187,
          "is_async": true
        },
        {
          "name": "always_err_tool",
          "signature": "def always_err_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 191,
          "end_line": 205,
          "is_async": true
        },
        {
          "name": "list_tool",
          "signature": "def list_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 209,
          "end_line": 217,
          "is_async": true
        },
        {
          "name": "clear_core_memory_tool",
          "signature": "def clear_core_memory_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 221,
          "end_line": 229,
          "is_async": true
        },
        {
          "name": "external_codebase_tool",
          "signature": "def external_codebase_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 233,
          "end_line": 238,
          "is_async": true
        },
        {
          "name": "agent_state",
          "signature": "def agent_state(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 242,
          "end_line": 265,
          "is_async": true
        },
        {
          "name": "custom_test_sandbox_config",
          "signature": "def custom_test_sandbox_config(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": "Fixture to create a consistent local sandbox configuration for tests.\n\n    Args:\n        test_user: The test user to be used for creating the sandbox configuration.\n\n    Returns:\n        A tuple containing the SandboxConfigManager and the created sandbox configuration.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 269,
          "end_line": 295,
          "is_async": true
        },
        {
          "name": "core_memory_tools",
          "signature": "def core_memory_tools(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": "Create all base tools for testing.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 299,
          "end_line": 309,
          "is_async": true
        },
        {
          "name": "async_add_integers_tool",
          "signature": "def async_add_integers_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 313,
          "end_line": 333,
          "is_async": true
        },
        {
          "name": "async_get_env_tool",
          "signature": "def async_get_env_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 337,
          "end_line": 356,
          "is_async": true
        },
        {
          "name": "async_stateful_tool",
          "signature": "def async_stateful_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 360,
          "end_line": 372,
          "is_async": true
        },
        {
          "name": "async_error_tool",
          "signature": "def async_error_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 376,
          "end_line": 393,
          "is_async": true
        },
        {
          "name": "async_list_tool",
          "signature": "def async_list_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 397,
          "end_line": 407,
          "is_async": true
        },
        {
          "name": "tool_with_pip_requirements",
          "signature": "def tool_with_pip_requirements(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 411,
          "end_line": 439,
          "is_async": true
        },
        {
          "name": "async_complex_tool",
          "signature": "def async_complex_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 443,
          "end_line": 476,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_default",
          "signature": "def test_modal_sandbox_default(check_modal_key_is_set, add_integers_tool, test_user)",
          "parameters": "(check_modal_key_is_set, add_integers_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 484,
          "end_line": 496,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_pip_installs",
          "signature": "def test_modal_sandbox_pip_installs(check_modal_key_is_set, cowsay_tool, test_user)",
          "parameters": "(check_modal_key_is_set, cowsay_tool, test_user)",
          "return_type": null,
          "docstring": "Test that Modal sandbox installs tool-level pip requirements.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 501,
          "end_line": 517,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_stateful_tool",
          "signature": "def test_modal_sandbox_stateful_tool(check_modal_key_is_set, clear_core_memory_tool, test_user, agent_state)",
          "parameters": "(check_modal_key_is_set, clear_core_memory_tool, test_user, agent_state)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 522,
          "end_line": 527,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_inject_env_var_existing_sandbox",
          "signature": "def test_modal_sandbox_inject_env_var_existing_sandbox(check_modal_key_is_set, get_env_tool, test_user)",
          "parameters": "(check_modal_key_is_set, get_env_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 532,
          "end_line": 551,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_per_agent_env",
          "signature": "def test_modal_sandbox_per_agent_env(check_modal_key_is_set, get_env_tool, agent_state, test_user)",
          "parameters": "(check_modal_key_is_set, get_env_tool, agent_state, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 556,
          "end_line": 575,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_with_list_rv",
          "signature": "def test_modal_sandbox_with_list_rv(check_modal_key_is_set, list_tool, test_user)",
          "parameters": "(check_modal_key_is_set, list_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 580,
          "end_line": 583,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_with_tool_pip_requirements",
          "signature": "def test_modal_sandbox_with_tool_pip_requirements(check_modal_key_is_set, tool_with_pip_requirements, test_user)",
          "parameters": "(check_modal_key_is_set, tool_with_pip_requirements, test_user)",
          "return_type": null,
          "docstring": "Test that Modal sandbox installs tool-specific pip requirements.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 588,
          "end_line": 602,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_with_mixed_pip_requirements",
          "signature": "def test_modal_sandbox_with_mixed_pip_requirements(check_modal_key_is_set, tool_with_pip_requirements, test_user)",
          "parameters": "(check_modal_key_is_set, tool_with_pip_requirements, test_user)",
          "return_type": null,
          "docstring": "Test that Modal sandbox installs tool pip requirements.\n\n    Note: Modal does not support sandbox-level pip requirements - all pip requirements\n    must be specified at the tool level since the Modal app is deployed with a fixed image.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 607,
          "end_line": 625,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_with_broken_tool_pip_requirements_error_handling",
          "signature": "def test_modal_sandbox_with_broken_tool_pip_requirements_error_handling(check_modal_key_is_set, test_user)",
          "parameters": "(check_modal_key_is_set, test_user)",
          "return_type": null,
          "docstring": "Test that Modal sandbox provides informative error messages for broken tool pip requirements.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 630,
          "end_line": 652,
          "is_async": true
        },
        {
          "name": "test_async_function_detection",
          "signature": "def test_async_function_detection(add_integers_tool, async_add_integers_tool, test_user)",
          "parameters": "(add_integers_tool, async_add_integers_tool, test_user)",
          "return_type": null,
          "docstring": "Test that async function detection works correctly",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 656,
          "end_line": 668,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_async_function_execution",
          "signature": "def test_modal_sandbox_async_function_execution(check_modal_key_is_set, async_add_integers_tool, test_user)",
          "parameters": "(check_modal_key_is_set, async_add_integers_tool, test_user)",
          "return_type": null,
          "docstring": "Test that async functions execute correctly in Modal sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 673,
          "end_line": 679,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_async_complex_computation",
          "signature": "def test_modal_sandbox_async_complex_computation(check_modal_key_is_set, async_complex_tool, test_user)",
          "parameters": "(check_modal_key_is_set, async_complex_tool, test_user)",
          "return_type": null,
          "docstring": "Test complex async computation with multiple awaits in Modal sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 684,
          "end_line": 696,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_async_list_return",
          "signature": "def test_modal_sandbox_async_list_return(check_modal_key_is_set, async_list_tool, test_user)",
          "parameters": "(check_modal_key_is_set, async_list_tool, test_user)",
          "return_type": null,
          "docstring": "Test async function returning list in Modal sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 701,
          "end_line": 705,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_async_with_env_vars",
          "signature": "def test_modal_sandbox_async_with_env_vars(check_modal_key_is_set, async_get_env_tool, test_user)",
          "parameters": "(check_modal_key_is_set, async_get_env_tool, test_user)",
          "return_type": null,
          "docstring": "Test async function with environment variables in Modal sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 710,
          "end_line": 726,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_async_with_agent_state",
          "signature": "def test_modal_sandbox_async_with_agent_state(check_modal_key_is_set, async_stateful_tool, test_user, agent_state)",
          "parameters": "(check_modal_key_is_set, async_stateful_tool, test_user, agent_state)",
          "return_type": null,
          "docstring": "Test async function with agent state in Modal sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 731,
          "end_line": 738,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_async_error_handling",
          "signature": "def test_modal_sandbox_async_error_handling(check_modal_key_is_set, async_error_tool, test_user)",
          "parameters": "(check_modal_key_is_set, async_error_tool, test_user)",
          "return_type": null,
          "docstring": "Test async function error handling in Modal sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 743,
          "end_line": 752,
          "is_async": true
        },
        {
          "name": "test_modal_sandbox_async_per_agent_env",
          "signature": "def test_modal_sandbox_async_per_agent_env(check_modal_key_is_set, async_get_env_tool, agent_state, test_user)",
          "parameters": "(check_modal_key_is_set, async_get_env_tool, agent_state, test_user)",
          "return_type": null,
          "docstring": "Test async function with per-agent environment variables in Modal sandbox",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.modal_sandbox"
          ],
          "start_line": 757,
          "end_line": 777,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900564
    },
    "tests/integration_test_modal_sandbox_v2.py": {
      "path": "tests/integration_test_modal_sandbox_v2.py",
      "contentHash": "9a2bf4c26596da12b5358a6c0e585447",
      "mtime": 1767315072124.5476,
      "functions": [
        {
          "name": "test_organization",
          "signature": "def test_organization()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Create a test organization in the database.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 41,
          "end_line": 46,
          "is_async": false
        },
        {
          "name": "test_user",
          "signature": "def test_user(test_organization)",
          "parameters": "(test_organization)",
          "return_type": null,
          "docstring": "Create a test user in the database.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 50,
          "end_line": 55,
          "is_async": false
        },
        {
          "name": "mock_user",
          "signature": "def mock_user()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Create a mock user for tests that don't need database persistence.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 59,
          "end_line": 64,
          "is_async": false
        },
        {
          "name": "basic_tool",
          "signature": "def basic_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": "Create a basic tool for testing.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 68,
          "end_line": 117,
          "is_async": false
        },
        {
          "name": "async_tool",
          "signature": "def async_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": "Create an async tool for testing.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 121,
          "end_line": 165,
          "is_async": false
        },
        {
          "name": "tool_with_dependencies",
          "signature": "def tool_with_dependencies(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": "Create a tool that requires external dependencies.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 169,
          "end_line": 223,
          "is_async": false
        },
        {
          "name": "sandbox_config",
          "signature": "def sandbox_config(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": "Create a test sandbox configuration in the database.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 227,
          "end_line": 237,
          "is_async": false
        },
        {
          "name": "mock_sandbox_config",
          "signature": "def mock_sandbox_config()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Create a mock sandbox configuration for tests that don't need database persistence.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 241,
          "end_line": 251,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900564
    },
    "tests/integration_test_multi_agent.py": {
      "path": "tests/integration_test_multi_agent.py",
      "contentHash": "78ce6662a8ff01a4b08298ebe566ca75",
      "mtime": 1768610518542.2004,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until it's accepting connections.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 18,
          "end_line": 51,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> Letta",
          "parameters": "(server_url: str)",
          "return_type": "Letta",
          "docstring": "Creates and returns a synchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 55,
          "end_line": 60,
          "is_async": false
        },
        {
          "name": "remove_stale_agents",
          "signature": "def remove_stale_agents(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": "Clean up ALL stale agents before each test to ensure fresh state.\n    This is critical because @retry_until_success decorator will retry tests\n    and accumulate agents if not cleaned up.\n\n    Note: agent_id in llm_batch_items has ondelete=\"CASCADE\" set in the migration,\n    so batch items should be automatically deleted. However, we catch errors\n    in case the migration hasn't been run yet or there are orphaned records.",
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 64,
          "end_line": 83,
          "is_async": false
        },
        {
          "name": "agent_obj",
          "signature": "def agent_obj(client: Letta) -> AgentState",
          "parameters": "(client: Letta)",
          "return_type": "AgentState",
          "docstring": "Create a test agent that we can call functions on",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 87,
          "end_line": 98,
          "is_async": false
        },
        {
          "name": "other_agent_obj",
          "signature": "def other_agent_obj(client: Letta) -> AgentState",
          "parameters": "(client: Letta)",
          "return_type": "AgentState",
          "docstring": "Create another test agent that we can call functions on",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 102,
          "end_line": 113,
          "is_async": false
        },
        {
          "name": "roll_dice_tool",
          "signature": "def roll_dice_tool(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 117,
          "end_line": 131,
          "is_async": false
        },
        {
          "name": "test_send_message_to_agent",
          "signature": "def test_send_message_to_agent(client: Letta, agent_obj: AgentState, other_agent_obj: AgentState)",
          "parameters": "(client: Letta, agent_obj: AgentState, other_agent_obj: AgentState)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@retry_until_success(max_attempts=5, sleep_time_seconds=2)"
          ],
          "start_line": 135,
          "end_line": 214,
          "is_async": false
        },
        {
          "name": "test_send_message_to_agents_with_tags_simple",
          "signature": "def test_send_message_to_agents_with_tags_simple(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@retry_until_success(max_attempts=5, sleep_time_seconds=2)"
          ],
          "start_line": 218,
          "end_line": 329,
          "is_async": false
        },
        {
          "name": "test_send_message_to_agents_with_tags_complex_tool_use",
          "signature": "def test_send_message_to_agents_with_tags_complex_tool_use(client: Letta, roll_dice_tool)",
          "parameters": "(client: Letta, roll_dice_tool)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@retry_until_success(max_attempts=5, sleep_time_seconds=2)"
          ],
          "start_line": 333,
          "end_line": 407,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900564
    },
    "tests/integration_test_send_message.py": {
      "path": "tests/integration_test_send_message.py",
      "contentHash": "323d7a8621cb6c77a51dcb1461756537",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "get_model_config",
          "signature": "def get_model_config(filename: str, model_settings_dir: str = \"tests/model_settings\") -> Tuple[str, dict]",
          "parameters": "(filename: str, model_settings_dir: str = \"tests/model_settings\")",
          "return_type": "Tuple[str, dict]",
          "docstring": "Load a model_settings file and return the handle and settings dict.",
          "decorators": [],
          "start_line": 42,
          "end_line": 47,
          "is_async": false
        },
        {
          "name": "roll_dice",
          "signature": "def roll_dice(num_sides: int) -> int",
          "parameters": "(num_sides: int)",
          "return_type": "int",
          "docstring": "Returns a random number between 1 and num_sides.\n    Args:\n        num_sides (int): The number of sides on the die.\n    Returns:\n        int: A random integer between 1 and num_sides, representing the die roll.",
          "decorators": [],
          "start_line": 50,
          "end_line": 60,
          "is_async": false
        },
        {
          "name": "is_reasoner_model",
          "signature": "def is_reasoner_model(model_handle: str, model_settings: dict) -> bool",
          "parameters": "(model_handle: str, model_settings: dict)",
          "return_type": "bool",
          "docstring": "Check if the model is a native reasoning model.\n\n    This matches the server-side implementations from:\n    - letta/llm_api/openai_client.py:is_openai_reasoning_model\n    - letta/llm_api/anthropic_client.py:is_reasoning_model\n    - letta/llm_api/google_vertex_client.py:is_reasoning_model",
          "decorators": [],
          "start_line": 214,
          "end_line": 245,
          "is_async": false
        },
        {
          "name": "is_hidden_reasoning_model",
          "signature": "def is_hidden_reasoning_model(model_handle: str, model_settings: dict) -> bool",
          "parameters": "(model_handle: str, model_settings: dict)",
          "return_type": "bool",
          "docstring": "Check if the model returns HiddenReasoningMessage instead of regular ReasoningMessage.\n\n    Currently only gpt-5 returns hidden reasoning messages.",
          "decorators": [],
          "start_line": 248,
          "end_line": 260,
          "is_async": false
        },
        {
          "name": "get_expected_message_count_range",
          "signature": "def get_expected_message_count_range(\n    model_handle: str,\n    model_settings: dict,\n    tool_call: bool = False,\n    streaming: bool = False,\n    from_db: bool = False,\n    use_assistant_message: bool = True,\n) -> Tuple[int, int]",
          "parameters": "(\n    model_handle: str,\n    model_settings: dict,\n    tool_call: bool = False,\n    streaming: bool = False,\n    from_db: bool = False,\n    use_assistant_message: bool = True,\n)",
          "return_type": "Tuple[int, int]",
          "docstring": "Returns the expected range of number of messages for a given LLM configuration.\n    Uses range to account for possible variations in the number of reasoning messages.",
          "decorators": [],
          "start_line": 263,
          "end_line": 313,
          "is_async": false
        },
        {
          "name": "assert_first_message_is_user_message",
          "signature": "def assert_first_message_is_user_message(messages: List[Any]) -> None",
          "parameters": "(messages: List[Any])",
          "return_type": "None",
          "docstring": "Asserts that the first message is a user message.",
          "decorators": [],
          "start_line": 316,
          "end_line": 320,
          "is_async": false
        },
        {
          "name": "assert_greeting_with_assistant_message_response",
          "signature": "def assert_greeting_with_assistant_message_response(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    token_streaming: bool = False,\n    from_db: bool = False,\n    input: bool = False,\n) -> None",
          "parameters": "(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    token_streaming: bool = False,\n    from_db: bool = False,\n    input: bool = False,\n)",
          "return_type": "None",
          "docstring": "Asserts that the messages list follows the expected sequence:\n    ReasoningMessage -> AssistantMessage.",
          "decorators": [],
          "start_line": 323,
          "end_line": 401,
          "is_async": false
        },
        {
          "name": "assert_contains_run_id",
          "signature": "def assert_contains_run_id(messages: List[Any]) -> None",
          "parameters": "(messages: List[Any])",
          "return_type": "None",
          "docstring": "Asserts that the messages list contains a run_id.",
          "decorators": [],
          "start_line": 404,
          "end_line": 410,
          "is_async": false
        },
        {
          "name": "assert_contains_step_id",
          "signature": "def assert_contains_step_id(messages: List[Any]) -> None",
          "parameters": "(messages: List[Any])",
          "return_type": "None",
          "docstring": "Asserts that the messages list contains a step_id.",
          "decorators": [],
          "start_line": 413,
          "end_line": 422,
          "is_async": false
        },
        {
          "name": "assert_greeting_no_reasoning_response",
          "signature": "def assert_greeting_no_reasoning_response(\n    messages: List[Any],\n    streaming: bool = False,\n    token_streaming: bool = False,\n    from_db: bool = False,\n) -> None",
          "parameters": "(\n    messages: List[Any],\n    streaming: bool = False,\n    token_streaming: bool = False,\n    from_db: bool = False,\n)",
          "return_type": "None",
          "docstring": "Asserts that the messages list follows the expected sequence without reasoning:\n    AssistantMessage (no ReasoningMessage when put_inner_thoughts_in_kwargs is False).",
          "decorators": [],
          "start_line": 425,
          "end_line": 463,
          "is_async": false
        },
        {
          "name": "assert_greeting_without_assistant_message_response",
          "signature": "def assert_greeting_without_assistant_message_response(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    token_streaming: bool = False,\n    from_db: bool = False,\n) -> None",
          "parameters": "(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    token_streaming: bool = False,\n    from_db: bool = False,\n)",
          "return_type": "None",
          "docstring": "Asserts that the messages list follows the expected sequence:\n    ReasoningMessage -> ToolCallMessage -> ToolReturnMessage.",
          "decorators": [],
          "start_line": 466,
          "end_line": 542,
          "is_async": false
        },
        {
          "name": "assert_tool_call_response",
          "signature": "def assert_tool_call_response(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    from_db: bool = False,\n) -> None",
          "parameters": "(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    from_db: bool = False,\n)",
          "return_type": "None",
          "docstring": "Asserts that the messages list follows the expected sequence:\n    ReasoningMessage -> ToolCallMessage -> ToolReturnMessage ->\n    ReasoningMessage -> AssistantMessage.",
          "decorators": [],
          "start_line": 545,
          "end_line": 713,
          "is_async": false
        },
        {
          "name": "validate_openai_format_scrubbing",
          "signature": "def validate_openai_format_scrubbing(messages: List[Dict[str, Any]]) -> None",
          "parameters": "(messages: List[Dict[str, Any]])",
          "return_type": "None",
          "docstring": "Validate that OpenAI format assistant messages with tool calls have no inner thoughts content.\n    Args:\n        messages: List of message dictionaries in OpenAI format",
          "decorators": [],
          "start_line": 716,
          "end_line": 735,
          "is_async": false
        },
        {
          "name": "validate_anthropic_format_scrubbing",
          "signature": "def validate_anthropic_format_scrubbing(messages: List[Dict[str, Any]], reasoning_enabled: bool) -> None",
          "parameters": "(messages: List[Dict[str, Any]], reasoning_enabled: bool)",
          "return_type": "None",
          "docstring": "Validate that Anthropic/Claude format assistant messages with tool_use have no <thinking> tags.\n    Args:\n        messages: List of message dictionaries in Anthropic format",
          "decorators": [],
          "start_line": 738,
          "end_line": 777,
          "is_async": false
        },
        {
          "name": "validate_google_format_scrubbing",
          "signature": "def validate_google_format_scrubbing(contents: List[Dict[str, Any]]) -> None",
          "parameters": "(contents: List[Dict[str, Any]])",
          "return_type": "None",
          "docstring": "Validate that Google/Gemini format model messages with functionCall have no thinking field.\n    Args:\n        contents: List of content dictionaries in Google format (uses 'contents' instead of 'messages')",
          "decorators": [],
          "start_line": 780,
          "end_line": 805,
          "is_async": false
        },
        {
          "name": "assert_image_input_response",
          "signature": "def assert_image_input_response(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    token_streaming: bool = False,\n    from_db: bool = False,\n) -> None",
          "parameters": "(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    token_streaming: bool = False,\n    from_db: bool = False,\n)",
          "return_type": "None",
          "docstring": "Asserts that the messages list follows the expected sequence:\n    ReasoningMessage -> AssistantMessage or ToolCallMessage -> ToolReturnMessage.",
          "decorators": [],
          "start_line": 808,
          "end_line": 886,
          "is_async": false
        },
        {
          "name": "accumulate_chunks",
          "signature": "def accumulate_chunks(chunks: List[Any], verify_token_streaming: bool = False) -> List[Any]",
          "parameters": "(chunks: List[Any], verify_token_streaming: bool = False)",
          "return_type": "List[Any]",
          "docstring": "Accumulates chunks into a list of messages.\n    Handles both message objects and raw SSE strings.",
          "decorators": [],
          "start_line": 889,
          "end_line": 971,
          "is_async": false
        },
        {
          "name": "cast_message_dict_to_messages",
          "signature": "def cast_message_dict_to_messages(messages: List[Dict[str, Any]]) -> List[Message]",
          "parameters": "(messages: List[Dict[str, Any]])",
          "return_type": "List[Message]",
          "docstring": null,
          "decorators": [],
          "start_line": 974,
          "end_line": 991,
          "is_async": false
        },
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until it's accepting connections.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 1000,
          "end_line": 1033,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> Letta",
          "parameters": "(server_url: str)",
          "return_type": "Letta",
          "docstring": "Creates and returns a synchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 1037,
          "end_line": 1042,
          "is_async": false
        },
        {
          "name": "async_client",
          "signature": "def async_client(server_url: str) -> AsyncLetta",
          "parameters": "(server_url: str)",
          "return_type": "AsyncLetta",
          "docstring": "Creates and returns an asynchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 1046,
          "end_line": 1051,
          "is_async": false
        },
        {
          "name": "agent_state",
          "signature": "def agent_state(client: Letta) -> AgentState",
          "parameters": "(client: Letta)",
          "return_type": "AgentState",
          "docstring": "Creates and returns an agent state for testing with a pre-configured agent.\n    The agent is named 'supervisor' and is configured with base tools and the roll_dice tool.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 1055,
          "end_line": 1077,
          "is_async": false
        },
        {
          "name": "test_greeting_with_assistant_message",
          "signature": "def test_greeting_with_assistant_message(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a message with a synchronous client.\n    Verifies that the response messages follow the expected order.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1090,
          "end_line": 1116,
          "is_async": false
        },
        {
          "name": "test_greeting_without_assistant_message",
          "signature": "def test_greeting_without_assistant_message(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a message with a synchronous client.\n    Verifies that the response messages follow the expected order.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1124,
          "end_line": 1151,
          "is_async": false
        },
        {
          "name": "test_tool_call",
          "signature": "def test_tool_call(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a message with a synchronous client.\n    Verifies that the response messages follow the expected order.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1159,
          "end_line": 1203,
          "is_async": false
        },
        {
          "name": "test_base64_image_input",
          "signature": "def test_base64_image_input(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a message with a synchronous client.\n    Verifies that the response messages follow the expected order.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    [\n        (\n            pytest.param(config, marks=pytest.mark.xfail(reason=\"Qwen image processing unstable - needs investigation\"))\n            if \"Qwen/Qwen2.5-72B-Instruct-Turbo\" in config[0]\n            else config\n        )\n        for config in TESTED_MODEL_CONFIGS\n    ],\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1218,
          "end_line": 1251,
          "is_async": false
        },
        {
          "name": "test_agent_loop_error",
          "signature": "def test_agent_loop_error(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a message with a synchronous client.\n    Verifies that no new messages are persisted on error.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1259,
          "end_line": 1286,
          "is_async": false
        },
        {
          "name": "test_step_streaming_greeting_with_assistant_message",
          "signature": "def test_step_streaming_greeting_with_assistant_message(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a streaming message with a synchronous client.\n    Checks that each chunk in the stream has the correct message types.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1294,
          "end_line": 1320,
          "is_async": false
        },
        {
          "name": "test_step_streaming_greeting_without_assistant_message",
          "signature": "def test_step_streaming_greeting_without_assistant_message(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a streaming message with a synchronous client.\n    Checks that each chunk in the stream has the correct message types.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1328,
          "end_line": 1353,
          "is_async": false
        },
        {
          "name": "test_step_streaming_tool_call",
          "signature": "def test_step_streaming_tool_call(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a streaming message with a synchronous client.\n    Checks that each chunk in the stream has the correct message types.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1361,
          "end_line": 1418,
          "is_async": false
        },
        {
          "name": "test_step_stream_agent_loop_error",
          "signature": "def test_step_stream_agent_loop_error(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a message with a synchronous client.\n    Verifies that no new messages are persisted on error.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1426,
          "end_line": 1453,
          "is_async": false
        },
        {
          "name": "test_token_streaming_greeting_with_assistant_message",
          "signature": "def test_token_streaming_greeting_with_assistant_message(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a streaming message with a synchronous client.\n    Checks that each chunk in the stream has the correct message types.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1461,
          "end_line": 1497,
          "is_async": false
        },
        {
          "name": "test_token_streaming_greeting_without_assistant_message",
          "signature": "def test_token_streaming_greeting_without_assistant_message(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a streaming message with a synchronous client.\n    Checks that each chunk in the stream has the correct message types.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1505,
          "end_line": 1544,
          "is_async": false
        },
        {
          "name": "test_token_streaming_tool_call",
          "signature": "def test_token_streaming_tool_call(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a streaming message with a synchronous client.\n    Checks that each chunk in the stream has the correct message types.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1552,
          "end_line": 1618,
          "is_async": false
        },
        {
          "name": "test_token_streaming_agent_loop_error",
          "signature": "def test_token_streaming_agent_loop_error(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a streaming message with a synchronous client.\n    Verifies that no new messages are persisted on error.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1626,
          "end_line": 1659,
          "is_async": false
        },
        {
          "name": "test_background_token_streaming_greeting_with_assistant_message",
          "signature": "def test_background_token_streaming_greeting_with_assistant_message(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a streaming message with a synchronous client.\n    Checks that each chunk in the stream has the correct message types.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)",
            "@pytest.mark.skip(reason=\"Skipping until token streaming is fixed for non-reasoner models\")"
          ],
          "start_line": 1668,
          "end_line": 1729,
          "is_async": false
        },
        {
          "name": "test_background_token_streaming_greeting_without_assistant_message",
          "signature": "def test_background_token_streaming_greeting_without_assistant_message(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a streaming message with a synchronous client.\n    Checks that each chunk in the stream has the correct message types.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1737,
          "end_line": 1777,
          "is_async": false
        },
        {
          "name": "test_background_token_streaming_tool_call",
          "signature": "def test_background_token_streaming_tool_call(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a streaming message with a synchronous client.\n    Checks that each chunk in the stream has the correct message types.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1785,
          "end_line": 1841,
          "is_async": false
        },
        {
          "name": "wait_for_run_completion",
          "signature": "def wait_for_run_completion(client: Letta, run_id: str, timeout: float = 30.0, interval: float = 0.5) -> Run",
          "parameters": "(client: Letta, run_id: str, timeout: float = 30.0, interval: float = 0.5)",
          "return_type": "Run",
          "docstring": null,
          "decorators": [],
          "start_line": 1844,
          "end_line": 1855,
          "is_async": false
        },
        {
          "name": "test_async_greeting_with_assistant_message",
          "signature": "def test_async_greeting_with_assistant_message(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a message as an asynchronous job using the synchronous client.\n    Waits for job completion and asserts that the result messages are as expected.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1863,
          "end_line": 1929,
          "is_async": false
        },
        {
          "name": "test_async_tool_call",
          "signature": "def test_async_tool_call(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a message as an asynchronous job using the synchronous client.\n    Waits for job completion and asserts that the result messages are as expected.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 1940,
          "end_line": 1984,
          "is_async": false
        },
        {
          "name": "callback_server",
          "signature": "def callback_server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Context manager for callback server.",
          "decorators": [
            "@contextmanager"
          ],
          "start_line": 2061,
          "end_line": 2068,
          "is_async": false
        },
        {
          "name": "test_async_greeting_with_callback_url",
          "signature": "def test_async_greeting_with_callback_url(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a message as an asynchronous job with callback URL functionality.\n    Validates that callbacks are properly sent with correct payload structure.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 2076,
          "end_line": 2144,
          "is_async": false
        },
        {
          "name": "test_auto_summarize",
          "signature": "def test_auto_summarize(disable_e2b_api_key: Any, client: Letta, model_config: Tuple[str, dict])",
          "parameters": "(disable_e2b_api_key: Any, client: Letta, model_config: Tuple[str, dict])",
          "return_type": null,
          "docstring": "Test that summarization is automatically triggered.",
          "decorators": [
            "@pytest.mark.flaky(max_runs=2)",
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 2153,
          "end_line": 2211,
          "is_async": false
        },
        {
          "name": "wait_for_run_status",
          "signature": "def wait_for_run_status(client: Letta, run_id: str, target_status: str, timeout: float = 30.0, interval: float = 0.1) -> Run",
          "parameters": "(client: Letta, run_id: str, target_status: str, timeout: float = 30.0, interval: float = 0.1)",
          "return_type": "Run",
          "docstring": "Wait for a run to reach a specific status",
          "decorators": [],
          "start_line": 2219,
          "end_line": 2228,
          "is_async": false
        },
        {
          "name": "test_job_creation_for_send_message",
          "signature": "def test_job_creation_for_send_message(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Test that send_message endpoint creates a job and the job completes successfully.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 2236,
          "end_line": 2265,
          "is_async": false
        },
        {
          "name": "test_inner_thoughts_false_non_reasoner_models",
          "signature": "def test_inner_thoughts_false_non_reasoner_models(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 2424,
          "end_line": 2459,
          "is_async": false
        },
        {
          "name": "test_inner_thoughts_false_non_reasoner_models_streaming",
          "signature": "def test_inner_thoughts_false_non_reasoner_models_streaming(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 2467,
          "end_line": 2503,
          "is_async": false
        },
        {
          "name": "test_inner_thoughts_toggle_interleaved",
          "signature": "def test_inner_thoughts_toggle_interleaved(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 2511,
          "end_line": 2567,
          "is_async": false
        },
        {
          "name": "test_input_parameter_basic",
          "signature": "def test_input_parameter_basic(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a message using the input parameter instead of messages.\n    Verifies that input is properly converted to a user message.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 2580,
          "end_line": 2606,
          "is_async": false
        },
        {
          "name": "test_input_parameter_streaming",
          "signature": "def test_input_parameter_streaming(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending a streaming message using the input parameter.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 2614,
          "end_line": 2641,
          "is_async": false
        },
        {
          "name": "test_input_parameter_async",
          "signature": "def test_input_parameter_async(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Tests sending an async message using the input parameter.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)"
          ],
          "start_line": 2649,
          "end_line": 2674,
          "is_async": false
        },
        {
          "name": "test_input_and_messages_both_provided_error",
          "signature": "def test_input_and_messages_both_provided_error(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n)",
          "return_type": "None",
          "docstring": "Tests that providing both input and messages raises a validation error.",
          "decorators": [],
          "start_line": 2677,
          "end_line": 2692,
          "is_async": false
        },
        {
          "name": "test_input_and_messages_neither_provided_error",
          "signature": "def test_input_and_messages_neither_provided_error(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: Letta,\n    agent_state: AgentState,\n)",
          "return_type": "None",
          "docstring": "Tests that providing neither input nor messages raises a validation error.",
          "decorators": [],
          "start_line": 2695,
          "end_line": 2708,
          "is_async": false
        }
      ],
      "parsedAt": 1769608900565
    },
    "tests/integration_test_send_message_v2.py": {
      "path": "tests/integration_test_send_message_v2.py",
      "contentHash": "03374d43811bd07b47087de319e32c4f",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "get_model_config",
          "signature": "def get_model_config(filename: str, model_settings_dir: str = \"tests/model_settings\") -> Tuple[str, dict]",
          "parameters": "(filename: str, model_settings_dir: str = \"tests/model_settings\")",
          "return_type": "Tuple[str, dict]",
          "docstring": "Load a model_settings file and return the handle and settings dict.",
          "decorators": [],
          "start_line": 44,
          "end_line": 49,
          "is_async": false
        },
        {
          "name": "roll_dice",
          "signature": "def roll_dice(num_sides: int) -> int",
          "parameters": "(num_sides: int)",
          "return_type": "int",
          "docstring": "Returns a random number between 1 and num_sides.\n    Args:\n        num_sides (int): The number of sides on the die.\n    Returns:\n        int: A random integer between 1 and num_sides, representing the die roll.",
          "decorators": [],
          "start_line": 57,
          "end_line": 67,
          "is_async": false
        },
        {
          "name": "assert_greeting_response",
          "signature": "def assert_greeting_response(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    token_streaming: bool = False,\n    from_db: bool = False,\n) -> None",
          "parameters": "(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    token_streaming: bool = False,\n    from_db: bool = False,\n)",
          "return_type": "None",
          "docstring": "Asserts that the messages list follows the expected sequence:\n    ReasoningMessage -> AssistantMessage.",
          "decorators": [],
          "start_line": 98,
          "end_line": 156,
          "is_async": false
        },
        {
          "name": "assert_tool_call_response",
          "signature": "def assert_tool_call_response(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    from_db: bool = False,\n    with_cancellation: bool = False,\n) -> None",
          "parameters": "(\n    messages: List[Any],\n    model_handle: str,\n    model_settings: dict,\n    streaming: bool = False,\n    from_db: bool = False,\n    with_cancellation: bool = False,\n)",
          "return_type": "None",
          "docstring": "Asserts that the messages list follows the expected sequence:\n    ReasoningMessage -> ToolCallMessage -> ToolReturnMessage ->\n    ReasoningMessage -> AssistantMessage.",
          "decorators": [],
          "start_line": 159,
          "end_line": 274,
          "is_async": false
        },
        {
          "name": "accumulate_chunks",
          "signature": "def accumulate_chunks(chunks, verify_token_streaming: bool = False) -> List[Any]",
          "parameters": "(chunks, verify_token_streaming: bool = False)",
          "return_type": "List[Any]",
          "docstring": "Accumulates chunks into a list of messages.\n    Handles both async iterators and raw SSE strings.",
          "decorators": [],
          "start_line": 277,
          "end_line": 364,
          "is_async": true
        },
        {
          "name": "cancel_run_after_delay",
          "signature": "def cancel_run_after_delay(client: AsyncLetta, agent_id: str, delay: float = 0.5)",
          "parameters": "(client: AsyncLetta, agent_id: str, delay: float = 0.5)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 367,
          "end_line": 369,
          "is_async": true
        },
        {
          "name": "wait_for_run_completion",
          "signature": "def wait_for_run_completion(client: AsyncLetta, run_id: str, timeout: float = 30.0, interval: float = 0.5) -> Run",
          "parameters": "(client: AsyncLetta, run_id: str, timeout: float = 30.0, interval: float = 0.5)",
          "return_type": "Run",
          "docstring": null,
          "decorators": [],
          "start_line": 372,
          "end_line": 385,
          "is_async": true
        },
        {
          "name": "get_expected_message_count_range",
          "signature": "def get_expected_message_count_range(\n    model_handle: str, model_settings: dict, tool_call: bool = False, streaming: bool = False, from_db: bool = False\n) -> Tuple[int, int]",
          "parameters": "(\n    model_handle: str, model_settings: dict, tool_call: bool = False, streaming: bool = False, from_db: bool = False\n)",
          "return_type": "Tuple[int, int]",
          "docstring": "Returns the expected range of number of messages for a given LLM configuration. Uses range to account for possible variations in the number of reasoning messages.\n\n    Greeting:\n    ------------------------------------------------------------------------------------------------------------------------------------------------------------------\n    | gpt-4o                   |  gpt-o3 (med effort)     |  gpt-5 (high effort)     |  sonnet-3-5              |  sonnet-3.7-thinking     |  flash-2.5-thinking      |\n    | ------------------------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ |\n    | AssistantMessage         |  AssistantMessage        |  ReasoningMessage        |  AssistantMessage        |  ReasoningMessage        |  ReasoningMessage        |\n    |                          |                          |  AssistantMessage        |                          |  AssistantMessage        |  AssistantMessage        |\n\n\n    Tool Call:\n    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n    | gpt-4o                   |  gpt-o3 (med effort)     |  gpt-5 (high effort)     |  sonnet-3-5              |  sonnet-3.7-thinking     |  sonnet-4.5/opus-4.1     |  flash-2.5-thinking      |\n    | ------------------------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ |\n    | ToolCallMessage          |  ToolCallMessage         |  ReasoningMessage        |  AssistantMessage        |  ReasoningMessage        |  ReasoningMessage        |  ReasoningMessage        |\n    | ToolReturnMessage        |  ToolReturnMessage       |  ToolCallMessage         |  ToolCallMessage         |  AssistantMessage        |  AssistantMessage        |  ToolCallMessage         |\n    | AssistantMessage         |  AssistantMessage        |  ToolReturnMessage       |  ToolReturnMessage       |  ToolCallMessage         |  ToolCallMessage         |  ToolReturnMessage       |\n    |                          |                          |  ReasoningMessage        |  AssistantMessage        |  ToolReturnMessage       |  ToolReturnMessage       |  ReasoningMessage        |\n    |                          |                          |  AssistantMessage        |                          |  AssistantMessage        |  ReasoningMessage        |  AssistantMessage        |\n    |                          |                          |                          |                          |                          |  AssistantMessage        |                          |",
          "decorators": [],
          "start_line": 388,
          "end_line": 456,
          "is_async": false
        },
        {
          "name": "is_reasoner_model",
          "signature": "def is_reasoner_model(model_handle: str, model_settings: dict) -> bool",
          "parameters": "(model_handle: str, model_settings: dict)",
          "return_type": "bool",
          "docstring": "Check if the model is a reasoning model based on its handle and settings.",
          "decorators": [],
          "start_line": 459,
          "end_line": 488,
          "is_async": false
        },
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until it's accepting connections.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 497,
          "end_line": 530,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> AsyncLetta",
          "parameters": "(server_url: str)",
          "return_type": "AsyncLetta",
          "docstring": "Creates and returns an asynchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 534,
          "end_line": 539,
          "is_async": true
        },
        {
          "name": "agent_state",
          "signature": "def agent_state(client: AsyncLetta) -> AgentState",
          "parameters": "(client: AsyncLetta)",
          "return_type": "AgentState",
          "docstring": "Creates and returns an agent state for testing with a pre-configured agent.\n    The agent is named 'supervisor' and is configured with base tools and the roll_dice tool.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 543,
          "end_line": 561,
          "is_async": true
        },
        {
          "name": "test_greeting",
          "signature": "def test_greeting(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n    send_type: str,\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n    send_type: str,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)",
            "@pytest.mark.parametrize(\"send_type\", [\"step\", \"stream_steps\", \"stream_tokens\", \"stream_tokens_background\", \"async\"])",
            "@pytest.mark.asyncio(loop_scope=\"function\")"
          ],
          "start_line": 576,
          "end_line": 636,
          "is_async": true
        },
        {
          "name": "test_parallel_tool_calls",
          "signature": "def test_parallel_tool_calls(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n    send_type: str,\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n    send_type: str,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)",
            "@pytest.mark.parametrize(\"send_type\", [\"step\", \"stream_steps\", \"stream_tokens\", \"stream_tokens_background\", \"async\"])",
            "@pytest.mark.asyncio(loop_scope=\"function\")"
          ],
          "start_line": 646,
          "end_line": 818,
          "is_async": true
        },
        {
          "name": "test_tool_call",
          "signature": "def test_tool_call(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n    send_type: str,\n    cancellation: str,\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n    send_type: str,\n    cancellation: str,\n)",
          "return_type": "None",
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)",
            "@pytest.mark.parametrize(\n    [\"send_type\", \"cancellation\"],\n    list(\n        itertools.product(\n            [\"step\", \"stream_steps\", \"stream_tokens\", \"stream_tokens_background\", \"async\"], [\"with_cancellation\", \"no_cancellation\"]\n        )\n    ),\n    ids=[\n        f\"{s}-{c}\"\n        for s, c in itertools.product(\n            [\"step\", \"stream_steps\", \"stream_tokens\", \"stream_tokens_background\", \"async\"], [\"with_cancellation\", \"no_cancellation\"]\n        )\n    ],\n)",
            "@pytest.mark.asyncio(loop_scope=\"function\")"
          ],
          "start_line": 841,
          "end_line": 917,
          "is_async": true
        },
        {
          "name": "test_conversation_streaming_raw_http",
          "signature": "def test_conversation_streaming_raw_http(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    server_url: str,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    server_url: str,\n    agent_state: AgentState,\n    model_config: Tuple[str, dict],\n)",
          "return_type": "None",
          "docstring": "Test conversation-based streaming functionality using raw HTTP requests.\n\n    This test verifies that:\n    1. A conversation can be created for an agent\n    2. Messages can be sent to the conversation via streaming\n    3. The streaming response contains the expected message types\n    4. Messages are properly persisted in the conversation\n\n    Uses raw HTTP requests instead of SDK until SDK is regenerated with conversations support.",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_config\",\n    TESTED_MODEL_CONFIGS,\n    ids=[handle for handle, _ in TESTED_MODEL_CONFIGS],\n)",
            "@pytest.mark.asyncio(loop_scope=\"function\")"
          ],
          "start_line": 926,
          "end_line": 1003,
          "is_async": true
        },
        {
          "name": "test_json_schema_response_format",
          "signature": "def test_json_schema_response_format(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    model_handle: str,\n    provider_type: str,\n) -> None",
          "parameters": "(\n    disable_e2b_api_key: Any,\n    client: AsyncLetta,\n    model_handle: str,\n    provider_type: str,\n)",
          "return_type": "None",
          "docstring": "Test JsonSchemaResponseFormat with OpenAI and Anthropic models.\n\n    This test verifies that:\n    1. Agents can be created with json_schema response_format via model_settings\n    2. The schema is properly stored in the agent's model_settings\n    3. Messages sent to the agent produce responses conforming to the schema\n    4. Both OpenAI and Anthropic handle structured outputs correctly",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model_handle,provider_type\",\n    [\n        (\"openai/gpt-4o\", \"openai\"),\n        (\"openai/gpt-5\", \"openai\"),\n        # (\"anthropic/claude-sonnet-4-5-20250929\", \"anthropic\"),\n    ],\n)",
            "@pytest.mark.asyncio(loop_scope=\"function\")"
          ],
          "start_line": 1015,
          "end_line": 1095,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900565
    },
    "tests/integration_test_sleeptime_agent.py": {
      "path": "tests/integration_test_sleeptime_agent.py",
      "contentHash": "d60a706efa6ad095483c1a4f36da9923",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until it's accepting connections.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 16,
          "end_line": 49,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> Letta",
          "parameters": "(server_url: str)",
          "return_type": "Letta",
          "docstring": "Creates and returns a synchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 53,
          "end_line": 58,
          "is_async": false
        },
        {
          "name": "test_sleeptime_group_chat",
          "signature": "def test_sleeptime_group_chat(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.flaky(max_runs=3)",
            "@pytest.mark.asyncio(loop_scope=\"module\")"
          ],
          "start_line": 63,
          "end_line": 177,
          "is_async": true
        },
        {
          "name": "test_sleeptime_removes_redundant_information",
          "signature": "def test_sleeptime_removes_redundant_information(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.skip",
            "@pytest.mark.asyncio(loop_scope=\"module\")"
          ],
          "start_line": 182,
          "end_line": 238,
          "is_async": true
        },
        {
          "name": "test_sleeptime_edit",
          "signature": "def test_sleeptime_edit(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio(loop_scope=\"module\")"
          ],
          "start_line": 242,
          "end_line": 284,
          "is_async": true
        },
        {
          "name": "test_sleeptime_agent_new_block_attachment",
          "signature": "def test_sleeptime_agent_new_block_attachment(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": "Test that a new block created after agent creation is properly attached to both main and sleeptime agents.",
          "decorators": [
            "@pytest.mark.asyncio(loop_scope=\"module\")"
          ],
          "start_line": 288,
          "end_line": 362,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900565
    },
    "tests/integration_test_summarizer.py": {
      "path": "tests/integration_test_summarizer.py",
      "contentHash": "95761c37100525e36722195aca12b5fa",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "get_llm_config",
          "signature": "def get_llm_config(filename: str, llm_config_dir: str = \"tests/configs/llm_model_configs\") -> LLMConfig",
          "parameters": "(filename: str, llm_config_dir: str = \"tests/configs/llm_model_configs\")",
          "return_type": "LLMConfig",
          "docstring": "Load LLM configuration from JSON file.",
          "decorators": [],
          "start_line": 37,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 78,
          "end_line": 85,
          "is_async": true
        },
        {
          "name": "default_organization",
          "signature": "def default_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 89,
          "end_line": 92,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(server: SyncServer, default_organization)",
          "parameters": "(server: SyncServer, default_organization)",
          "return_type": null,
          "docstring": "Create and return the default user.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 96,
          "end_line": 99,
          "is_async": true
        },
        {
          "name": "actor",
          "signature": "def actor(default_user)",
          "parameters": "(default_user)",
          "return_type": null,
          "docstring": "Return actor for authorization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 103,
          "end_line": 105,
          "is_async": true
        },
        {
          "name": "create_large_tool_return",
          "signature": "def create_large_tool_return(size_chars: int = 50000) -> str",
          "parameters": "(size_chars: int = 50000)",
          "return_type": "str",
          "docstring": "Create a large tool return string for testing.",
          "decorators": [],
          "start_line": 113,
          "end_line": 135,
          "is_async": false
        },
        {
          "name": "create_agent_with_messages",
          "signature": "def create_agent_with_messages(server: SyncServer, actor, llm_config: LLMConfig, messages: List[PydanticMessage]) -> tuple",
          "parameters": "(server: SyncServer, actor, llm_config: LLMConfig, messages: List[PydanticMessage])",
          "return_type": "tuple",
          "docstring": "Create an agent and add messages to it.\n    Returns (agent_state, in_context_messages).",
          "decorators": [],
          "start_line": 138,
          "end_line": 172,
          "is_async": true
        },
        {
          "name": "run_summarization",
          "signature": "def run_summarization(server: SyncServer, agent_state, in_context_messages, actor, force=True)",
          "parameters": "(server: SyncServer, agent_state, in_context_messages, actor, force=True)",
          "return_type": null,
          "docstring": "Execute the summarization code path that needs to be tested.\n\n    This follows the exact code path specified:\n    1. Create LettaAgentV2 instance\n    2. Fetch messages via message_manager.get_messages_by_ids_async\n    3. Call agent_loop.summarize_conversation_history with force=True",
          "decorators": [],
          "start_line": 175,
          "end_line": 189,
          "is_async": true
        },
        {
          "name": "test_summarize_empty_message_buffer",
          "signature": "def test_summarize_empty_message_buffer(server: SyncServer, actor, llm_config: LLMConfig)",
          "parameters": "(server: SyncServer, actor, llm_config: LLMConfig)",
          "return_type": null,
          "docstring": "Test summarization when there are no messages in the buffer.\n    Should handle gracefully - either return empty list or raise a clear error.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\n    \"llm_config\",\n    TESTED_LLM_CONFIGS,\n    ids=[c.model for c in TESTED_LLM_CONFIGS],\n)"
          ],
          "start_line": 203,
          "end_line": 242,
          "is_async": true
        },
        {
          "name": "test_simple_summary_anthropic_uses_streaming_and_returns_summary",
          "signature": "def test_simple_summary_anthropic_uses_streaming_and_returns_summary(actor, monkeypatch)",
          "parameters": "(actor, monkeypatch)",
          "return_type": null,
          "docstring": "Regression test: Anthropic summarization must use streaming and return real text.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(\n    not model_settings.anthropic_api_key,\n    reason=\"Missing LETTA_ANTHROPIC_API_KEY (or equivalent settings) for Anthropic integration test\",\n)"
          ],
          "start_line": 250,
          "end_line": 285,
          "is_async": true
        },
        {
          "name": "st_summarize_initialization_messages_only(s",
          "signature": "def st_summarize_initialization_messages_only(server: SyncServer, actor, llm_config: LLMConfig):\n",
          "parameters": "erver: SyncServer, actor, llm_config: LLMConfig):\n",
          "return_type": null,
          "docstring": "\"\n    Test summarization when only initialization/system messages are in the buffer.\n    Should handle gracefully and likely not summarize.\n    \"\"\"",
          "decorators": [
            "ytest.mark.asyncio\n@",
            "ytest.mark.parametrize(\n    \"llm_config\",\n    TESTED_LLM_CONFIGS,\n    ids=[c.model for c in TESTED_LLM_CONFIGS],\n)\na"
          ],
          "start_line": 294,
          "end_line": 323,
          "is_async": true
        },
        {
          "name": "st_summarize_small_conversation(s",
          "signature": "def st_summarize_small_conversation(server: SyncServer, actor, llm_config: LLMConfig):\n",
          "parameters": "erver: SyncServer, actor, llm_config: LLMConfig):\n",
          "return_type": null,
          "docstring": "\"\n    Test summarization with approximately 5 messages in the buffer.\n    This represents a typical small conversation.\n    \"\"\"",
          "decorators": [
            "ytest.mark.asyncio\n@",
            "ytest.mark.parametrize(\n    \"llm_config\",\n    TESTED_LLM_CONFIGS,\n    ids=[c.model for c in TESTED_LLM_CONFIGS],\n)\na"
          ],
          "start_line": 332,
          "end_line": 386,
          "is_async": true
        },
        {
          "name": "st_summarize_large_tool_calls(s",
          "signature": "def st_summarize_large_tool_calls(server: SyncServer, actor, llm_config: LLMConfig):\n",
          "parameters": "erver: SyncServer, actor, llm_config: LLMConfig):\n",
          "return_type": null,
          "docstring": "\"\n    Test summarization with large tool calls and returns (~50k character tool returns).\n    This tests the system's ability to handle and summarize very large context windows.\n    \"\"\"",
          "decorators": [
            "ytest.mark.asyncio\n@",
            "ytest.mark.parametrize(\n    \"llm_config\",\n    TESTED_LLM_CONFIGS,\n    ids=[c.model for c in TESTED_LLM_CONFIGS],\n)\na"
          ],
          "start_line": 395,
          "end_line": 480,
          "is_async": true
        },
        {
          "name": "st_summarize_multiple_large_tool_calls(s",
          "signature": "def st_summarize_multiple_large_tool_calls(server: SyncServer, actor, llm_config: LLMConfig):\n",
          "parameters": "erver: SyncServer, actor, llm_config: LLMConfig):\n",
          "return_type": null,
          "docstring": "\"\n    Test summarization with multiple large tool calls in sequence.\n    This stress-tests the summarization with multiple large context items.\n    \"\"\"",
          "decorators": [
            "ytest.mark.asyncio\n@",
            "ytest.mark.parametrize(\n    \"llm_config\",\n    TESTED_LLM_CONFIGS,\n    ids=[c.model for c in TESTED_LLM_CONFIGS],\n)\na"
          ],
          "start_line": 489,
          "end_line": 579,
          "is_async": true
        },
        {
          "name": "st_summarize_with_mode(s",
          "signature": "def st_summarize_with_mode(server: SyncServer, actor, llm_config: LLMConfig, mode: Literal[\"all\", \"sliding_window\"]):\n",
          "parameters": "erver: SyncServer, actor, llm_config: LLMConfig, mode: Literal[\"all\", \"sliding_window\"]):\n",
          "return_type": null,
          "docstring": "\"\n    Test summarization with different CompactionSettings modes using LettaAgentV3.\n\n    This test verifies that both summarization modes work correctly:\n    - \"all\": Summarizes the entire conversation history into a single summary\n    - \"sliding_window\": Keeps recent messages and summarizes older ones\n    \"\"\"",
          "decorators": [
            "ytest.mark.asyncio\n@",
            "ytest.mark.parametrize(\"mode\", SUMMARIZER_CONFIG_MODES, ids=SUMMARIZER_CONFIG_MODES)\n@",
            "ytest.mark.parametrize(\"llm_config\", TESTED_LLM_CONFIGS, ids=[c.model for c in TESTED_LLM_CONFIGS])\na"
          ],
          "start_line": 680,
          "end_line": 759,
          "is_async": true
        },
        {
          "name": "st_v3_compact_uses_compaction_settings_model_and_model_settings(s",
          "signature": "def st_v3_compact_uses_compaction_settings_model_and_model_settings(server: SyncServer, actor):\n",
          "parameters": "erver: SyncServer, actor):\n",
          "return_type": null,
          "docstring": "\"Integration test: LettaAgentV3.compact uses the LLMConfig implied by CompactionSettings.\n\n    We set a different summarizer model handle + model_settings and verify that\n    the LLMConfig passed into simple_summary reflects both the handle and\n    the model_settings overrides.\n    \"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 763,
          "end_line": 839,
          "is_async": true
        },
        {
          "name": "st_v3_summarize_hard_eviction_when_still_over_threshold(\n",
          "signature": "def st_v3_summarize_hard_eviction_when_still_over_threshold(\n    server: SyncServer,\n    actor,\n    llm_config: LLMConfig,\n    caplog,\n):\n",
          "parameters": "    server: SyncServer,\n    actor,\n    llm_config: LLMConfig,\n    caplog,\n):\n",
          "return_type": null,
          "docstring": "\"Regression test: ensure V3 summarizer does a hard eviction when\n    summarization fails to bring the context size below the proactive\n    summarization threshold.\n\n    This test simulates the edge case that previously led to summarization\n    loops:\n\n    1. A large pre-summarization token count triggers summarization.\n    2. Even after summarization, the (mocked) post-summarization token count\n       is still above the trigger threshold.\n    3. We verify that LettaAgentV3:\n       - Logs an error about summarization failing to reduce context size.\n       - Evicts all prior messages, keeping only the system message plus a\n         single synthetic user summary message (system_alert).\n       - Updates `context_token_estimate` to the token count of the minimal\n         context so future steps don't keep re-triggering summarization based\n         on a stale, oversized value.\n    \"\"\"",
          "decorators": [
            "ytest.mark.asyncio\n@",
            "ytest.mark.parametrize(\"llm_config\", TESTED_LLM_CONFIGS, ids=[c.model for c in TESTED_LLM_CONFIGS])\na"
          ],
          "start_line": 844,
          "end_line": 933,
          "is_async": true
        },
        {
          "name": "st_sliding_window_cutoff_index_does_not_exceed_message_count(s",
          "signature": "def st_sliding_window_cutoff_index_does_not_exceed_message_count(server: SyncServer, actor, llm_config: LLMConfig):\n",
          "parameters": "erver: SyncServer, actor, llm_config: LLMConfig):\n",
          "return_type": null,
          "docstring": "\"\n    Test that the sliding window summarizer correctly calculates cutoff indices.\n\n    This test verifies the fix for a bug where the cutoff percentage was treated as\n    a whole number (10) instead of a decimal (0.10), causing:\n      message_cutoff_index = round(10 * 65) = 650\n    when there were only 65 messages, resulting in an empty range loop and the error:\n      \"No assistant message found from indices 650 to 65\"\n\n    The fix changed:\n      - max(..., 10) -> max(..., 0.10)\n      - += 10 -> += 0.10\n      - >= 100 -> >= 1.0\n\n    This test uses the real token counter (via create_token_counter) to verify\n    the sliding window logic works with actual token counting.\n    \"\"\"",
          "decorators": [
            "ytest.mark.asyncio\n@",
            "ytest.mark.parametrize(\n    \"llm_config\",\n    TESTED_LLM_CONFIGS,\n    ids=[c.model for c in TESTED_LLM_CONFIGS],\n)\na"
          ],
          "start_line": 947,
          "end_line": 1036,
          "is_async": true
        },
        {
          "name": "st_large_system_prompt_summarization(s",
          "signature": "def st_large_system_prompt_summarization(server: SyncServer, actor, llm_config: LLMConfig):\n",
          "parameters": "erver: SyncServer, actor, llm_config: LLMConfig):\n",
          "return_type": null,
          "docstring": "\"\n    Test edge case of large system prompt / memory blocks.\n\n    This test verifies that summarization handles the case where the system prompt\n    and memory blocks are very large, potentially consuming most of the context window.\n    The summarizer should gracefully handle this scenario without errors.\n    \"\"\"",
          "decorators": [
            "ytest.mark.asyncio\n@",
            "ytest.mark.parametrize(\n    \"llm_config\",\n    TESTED_LLM_CONFIGS,\n    ids=[c.model for c in TESTED_LLM_CONFIGS],\n)\na"
          ],
          "start_line": 1045,
          "end_line": 1135,
          "is_async": true
        },
        {
          "name": "st_summarize_all(s",
          "signature": "def st_summarize_all(server: SyncServer, actor, llm_config: LLMConfig):\n",
          "parameters": "erver: SyncServer, actor, llm_config: LLMConfig):\n",
          "return_type": null,
          "docstring": "\"\n    Test the summarize_all function with real LLM calls.\n\n    This test verifies that the 'all' summarization mode works correctly,\n    summarizing the entire conversation into a single summary string.\n    \"\"\"",
          "decorators": [
            "ytest.mark.asyncio\n@",
            "ytest.mark.parametrize(\n    \"llm_config\",\n    TESTED_LLM_CONFIGS,\n    ids=[c.model for c in TESTED_LLM_CONFIGS],\n)\na"
          ],
          "start_line": 1509,
          "end_line": 1565,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900566
    },
    "tests/integration_test_token_counters.py": {
      "path": "tests/integration_test_token_counters.py",
      "contentHash": "c637afb07e21883a0b68e132f7f5b8d5",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "get_llm_config",
          "signature": "def get_llm_config(filename: str, llm_config_dir: str = \"tests/configs/llm_model_configs\") -> LLMConfig",
          "parameters": "(filename: str, llm_config_dir: str = \"tests/configs/llm_model_configs\")",
          "return_type": "LLMConfig",
          "docstring": "Load LLM configuration from JSON file.",
          "decorators": [],
          "start_line": 28,
          "end_line": 33,
          "is_async": false
        },
        {
          "name": "clear_tables",
          "signature": "def clear_tables()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 61,
          "end_line": 62,
          "is_async": true
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 66,
          "end_line": 72,
          "is_async": true
        },
        {
          "name": "default_organization",
          "signature": "def default_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 76,
          "end_line": 79,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(server: SyncServer, default_organization)",
          "parameters": "(server: SyncServer, default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 83,
          "end_line": 86,
          "is_async": true
        },
        {
          "name": "other_organization",
          "signature": "def other_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Fixture to create and return another organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 90,
          "end_line": 93,
          "is_async": true
        },
        {
          "name": "other_user",
          "signature": "def other_user(server: SyncServer, other_organization)",
          "parameters": "(server: SyncServer, other_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return another user within the other organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 97,
          "end_line": 100,
          "is_async": true
        },
        {
          "name": "imported_agent_id",
          "signature": "def imported_agent_id(server: SyncServer, other_user)",
          "parameters": "(server: SyncServer, other_user)",
          "return_type": null,
          "docstring": "Import the test agent from the .af file and return the agent ID.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 104,
          "end_line": 124,
          "is_async": true
        },
        {
          "name": "test_get_context_window",
          "signature": "def test_get_context_window(server: SyncServer, imported_agent_id: str, other_user, llm_config: LLMConfig)",
          "parameters": "(server: SyncServer, imported_agent_id: str, other_user, llm_config: LLMConfig)",
          "return_type": null,
          "docstring": "Test get_context_window with different LLM providers.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"llm_config\", LLM_CONFIGS)"
          ],
          "start_line": 134,
          "end_line": 156,
          "is_async": true
        },
        {
          "name": "test_count_empty_text_tokens",
          "signature": "def test_count_empty_text_tokens(llm_config: LLMConfig)",
          "parameters": "(llm_config: LLMConfig)",
          "return_type": null,
          "docstring": "Test that empty text returns 0 tokens for all providers.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"llm_config\", LLM_CONFIGS)"
          ],
          "start_line": 166,
          "end_line": 186,
          "is_async": true
        },
        {
          "name": "test_count_empty_messages_tokens",
          "signature": "def test_count_empty_messages_tokens(llm_config: LLMConfig)",
          "parameters": "(llm_config: LLMConfig)",
          "return_type": null,
          "docstring": "Test that empty message list returns 0 tokens for all providers.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"llm_config\", LLM_CONFIGS)"
          ],
          "start_line": 191,
          "end_line": 211,
          "is_async": true
        },
        {
          "name": "test_count_empty_tools_tokens",
          "signature": "def test_count_empty_tools_tokens(llm_config: LLMConfig)",
          "parameters": "(llm_config: LLMConfig)",
          "return_type": null,
          "docstring": "Test that empty tools list returns 0 tokens for all providers.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"llm_config\", LLM_CONFIGS)"
          ],
          "start_line": 216,
          "end_line": 236,
          "is_async": true
        }
      ],
      "parsedAt": 1769608900566
    },
    "tests/integration_test_tool_execution_sandbox.py": {
      "path": "tests/integration_test_tool_execution_sandbox.py",
      "contentHash": "a2e5d01aaf292af4835a46a15664ddbb",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Creates a SyncServer instance for testing.\n\n    Loads and saves config to ensure proper initialization.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 41,
          "end_line": 52,
          "is_async": false
        },
        {
          "name": "clear_tables",
          "signature": "def clear_tables()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to clear the organization table before each test.",
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 56,
          "end_line": 64,
          "is_async": true
        },
        {
          "name": "test_organization",
          "signature": "def test_organization()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 68,
          "end_line": 71,
          "is_async": false
        },
        {
          "name": "test_user",
          "signature": "def test_user(test_organization)",
          "parameters": "(test_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 75,
          "end_line": 78,
          "is_async": false
        },
        {
          "name": "add_integers_tool",
          "signature": "def add_integers_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 82,
          "end_line": 98,
          "is_async": false
        },
        {
          "name": "cowsay_tool",
          "signature": "def cowsay_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 102,
          "end_line": 120,
          "is_async": false
        },
        {
          "name": "get_env_tool",
          "signature": "def get_env_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 124,
          "end_line": 140,
          "is_async": false
        },
        {
          "name": "get_warning_tool",
          "signature": "def get_warning_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 144,
          "end_line": 160,
          "is_async": false
        },
        {
          "name": "always_err_tool",
          "signature": "def always_err_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 164,
          "end_line": 178,
          "is_async": false
        },
        {
          "name": "list_tool",
          "signature": "def list_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 182,
          "end_line": 190,
          "is_async": false
        },
        {
          "name": "clear_core_memory_tool",
          "signature": "def clear_core_memory_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 194,
          "end_line": 202,
          "is_async": false
        },
        {
          "name": "external_codebase_tool",
          "signature": "def external_codebase_tool(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 206,
          "end_line": 211,
          "is_async": false
        },
        {
          "name": "agent_state",
          "signature": "def agent_state(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 215,
          "end_line": 237,
          "is_async": false
        },
        {
          "name": "custom_test_sandbox_config",
          "signature": "def custom_test_sandbox_config(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": "Fixture to create a consistent local sandbox configuration for tests.\n\n    Args:\n        test_user: The test user to be used for creating the sandbox configuration.\n\n    Returns:\n        A tuple containing the SandboxConfigManager and the created sandbox configuration.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 241,
          "end_line": 267,
          "is_async": true
        },
        {
          "name": "core_memory_tools",
          "signature": "def core_memory_tools(test_user)",
          "parameters": "(test_user)",
          "return_type": null,
          "docstring": "Create all base tools for testing.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 272,
          "end_line": 282,
          "is_async": false
        },
        {
          "name": "test_local_sandbox_default",
          "signature": "def test_local_sandbox_default(disable_e2b_api_key, add_integers_tool, test_user)",
          "parameters": "(disable_e2b_api_key, add_integers_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 289,
          "end_line": 301,
          "is_async": false
        },
        {
          "name": "test_local_sandbox_stateful_tool",
          "signature": "def test_local_sandbox_stateful_tool(disable_e2b_api_key, clear_core_memory_tool, test_user, agent_state)",
          "parameters": "(disable_e2b_api_key, clear_core_memory_tool, test_user, agent_state)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 305,
          "end_line": 312,
          "is_async": false
        },
        {
          "name": "test_local_sandbox_with_list_rv",
          "signature": "def test_local_sandbox_with_list_rv(disable_e2b_api_key, list_tool, test_user)",
          "parameters": "(disable_e2b_api_key, list_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 316,
          "end_line": 319,
          "is_async": false
        },
        {
          "name": "test_local_sandbox_env",
          "signature": "def test_local_sandbox_env(disable_e2b_api_key, get_env_tool, test_user)",
          "parameters": "(disable_e2b_api_key, get_env_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.local_sandbox",
            "@pytest.mark.asyncio"
          ],
          "start_line": 324,
          "end_line": 346,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_per_agent_env",
          "signature": "def test_local_sandbox_per_agent_env(disable_e2b_api_key, get_env_tool, agent_state, test_user)",
          "parameters": "(disable_e2b_api_key, get_env_tool, agent_state, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.local_sandbox",
            "@pytest.mark.asyncio"
          ],
          "start_line": 351,
          "end_line": 380,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_external_codebase_with_venv",
          "signature": "def test_local_sandbox_external_codebase_with_venv(disable_e2b_api_key, custom_test_sandbox_config, external_codebase_tool, test_user)",
          "parameters": "(disable_e2b_api_key, custom_test_sandbox_config, external_codebase_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 384,
          "end_line": 394,
          "is_async": false
        },
        {
          "name": "test_local_sandbox_with_venv_and_warnings_does_not_error",
          "signature": "def test_local_sandbox_with_venv_and_warnings_does_not_error(disable_e2b_api_key, custom_test_sandbox_config, get_warning_tool, test_user)",
          "parameters": "(disable_e2b_api_key, custom_test_sandbox_config, get_warning_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.local_sandbox"
          ],
          "start_line": 398,
          "end_line": 401,
          "is_async": false
        },
        {
          "name": "test_tool_with_client_injection",
          "signature": "def test_tool_with_client_injection(disable_e2b_api_key, server: SyncServer, test_user)",
          "parameters": "(disable_e2b_api_key, server: SyncServer, test_user)",
          "return_type": null,
          "docstring": "Test that tools can access injected letta_client and agent_id to modify agent blocks.",
          "decorators": [
            "@pytest.mark.local_sandbox",
            "@pytest.mark.asyncio"
          ],
          "start_line": 406,
          "end_line": 533,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_with_venv_errors",
          "signature": "def test_local_sandbox_with_venv_errors(disable_e2b_api_key, custom_test_sandbox_config, always_err_tool, test_user)",
          "parameters": "(disable_e2b_api_key, custom_test_sandbox_config, always_err_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 537,
          "end_line": 545,
          "is_async": false
        },
        {
          "name": "test_local_sandbox_with_venv_pip_installs_basic",
          "signature": "def test_local_sandbox_with_venv_pip_installs_basic(disable_e2b_api_key, cowsay_tool, test_user)",
          "parameters": "(disable_e2b_api_key, cowsay_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.e2b_sandbox",
            "@pytest.mark.asyncio"
          ],
          "start_line": 550,
          "end_line": 566,
          "is_async": true
        },
        {
          "name": "test_local_sandbox_with_venv_pip_installs_with_update",
          "signature": "def test_local_sandbox_with_venv_pip_installs_with_update(disable_e2b_api_key, cowsay_tool, test_user)",
          "parameters": "(disable_e2b_api_key, cowsay_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.e2b_sandbox",
            "@pytest.mark.asyncio"
          ],
          "start_line": 571,
          "end_line": 600,
          "is_async": true
        },
        {
          "name": "test_e2b_sandbox_default",
          "signature": "def test_e2b_sandbox_default(check_e2b_key_is_set, add_integers_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, add_integers_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 607,
          "end_line": 619,
          "is_async": false
        },
        {
          "name": "test_e2b_sandbox_pip_installs",
          "signature": "def test_e2b_sandbox_pip_installs(check_e2b_key_is_set, cowsay_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, cowsay_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 623,
          "end_line": 637,
          "is_async": false
        },
        {
          "name": "test_e2b_sandbox_reuses_same_sandbox",
          "signature": "def test_e2b_sandbox_reuses_same_sandbox(check_e2b_key_is_set, list_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, list_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 641,
          "end_line": 652,
          "is_async": false
        },
        {
          "name": "test_e2b_sandbox_stateful_tool",
          "signature": "def test_e2b_sandbox_stateful_tool(check_e2b_key_is_set, clear_core_memory_tool, test_user, agent_state)",
          "parameters": "(check_e2b_key_is_set, clear_core_memory_tool, test_user, agent_state)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 656,
          "end_line": 663,
          "is_async": false
        },
        {
          "name": "test_e2b_sandbox_inject_env_var_existing_sandbox",
          "signature": "def test_e2b_sandbox_inject_env_var_existing_sandbox(check_e2b_key_is_set, get_env_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, get_env_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 667,
          "end_line": 688,
          "is_async": false
        },
        {
          "name": "test_e2b_sandbox_per_agent_env",
          "signature": "def test_e2b_sandbox_per_agent_env(check_e2b_key_is_set, get_env_tool, agent_state, test_user)",
          "parameters": "(check_e2b_key_is_set, get_env_tool, agent_state, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 693,
          "end_line": 722,
          "is_async": false
        },
        {
          "name": "test_e2b_sandbox_config_change_force_recreates_sandbox",
          "signature": "def test_e2b_sandbox_config_change_force_recreates_sandbox(check_e2b_key_is_set, list_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, list_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 726,
          "end_line": 751,
          "is_async": false
        },
        {
          "name": "test_e2b_sandbox_with_list_rv",
          "signature": "def test_e2b_sandbox_with_list_rv(check_e2b_key_is_set, list_tool, test_user)",
          "parameters": "(check_e2b_key_is_set, list_tool, test_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.e2b_sandbox"
          ],
          "start_line": 755,
          "end_line": 758,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406663
    },
    "tests/integration_test_turbopuffer.py": {
      "path": "tests/integration_test_turbopuffer.py",
      "contentHash": "dccfed90e442b5781f4adb3897914048",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Server fixture for testing",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 19,
          "end_line": 24,
          "is_async": false
        },
        {
          "name": "sarah_agent",
          "signature": "def sarah_agent(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": "Create a test agent named Sarah",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 28,
          "end_line": 49,
          "is_async": true
        },
        {
          "name": "enable_turbopuffer",
          "signature": "def enable_turbopuffer()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Temporarily enable Turbopuffer for testing with a test API key",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 53,
          "end_line": 72,
          "is_async": false
        },
        {
          "name": "enable_message_embedding",
          "signature": "def enable_message_embedding()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Enable both Turbopuffer and message embedding",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 76,
          "end_line": 93,
          "is_async": false
        },
        {
          "name": "disable_turbopuffer",
          "signature": "def disable_turbopuffer()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensure Turbopuffer is disabled for testing",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 97,
          "end_line": 108,
          "is_async": false
        },
        {
          "name": "sample_embedding_config",
          "signature": "def sample_embedding_config()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Provide a sample embedding configuration",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 112,
          "end_line": 114,
          "is_async": false
        },
        {
          "name": "wait_for_embedding",
          "signature": "def wait_for_embedding(\n    agent_id: str, message_id: str, organization_id: str, actor, max_wait: float = 10.0, poll_interval: float = 0.5\n) -> bool",
          "parameters": "(\n    agent_id: str, message_id: str, organization_id: str, actor, max_wait: float = 10.0, poll_interval: float = 0.5\n)",
          "return_type": "bool",
          "docstring": "Poll Turbopuffer directly to check if a message has been embedded.\n\n    Args:\n        agent_id: Agent ID for the message\n        message_id: ID of the message to find\n        organization_id: Organization ID\n        max_wait: Maximum time to wait in seconds\n        poll_interval: Time between polls in seconds\n\n    Returns:\n        True if message was found in Turbopuffer within timeout, False otherwise",
          "decorators": [],
          "start_line": 117,
          "end_line": 160,
          "is_async": true
        },
        {
          "name": "test_should_use_tpuf_with_settings",
          "signature": "def test_should_use_tpuf_with_settings()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that should_use_tpuf correctly reads settings",
          "decorators": [],
          "start_line": 163,
          "end_line": 186,
          "is_async": false
        },
        {
          "name": "test_archive_creation_with_tpuf_enabled",
          "signature": "def test_archive_creation_with_tpuf_enabled(server, default_user, enable_turbopuffer)",
          "parameters": "(server, default_user, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test that archives are created with correct vector_db_provider when TPUF is enabled",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 190,
          "end_line": 196,
          "is_async": true
        },
        {
          "name": "test_archive_creation_with_tpuf_disabled",
          "signature": "def test_archive_creation_with_tpuf_disabled(server, default_user, disable_turbopuffer)",
          "parameters": "(server, default_user, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test that archives default to NATIVE when TPUF is disabled",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 200,
          "end_line": 206,
          "is_async": true
        },
        {
          "name": "test_dual_write_and_query_with_real_tpuf",
          "signature": "def test_dual_write_and_query_with_real_tpuf(server, default_user, sarah_agent, enable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test that passages are written to both SQL and Turbopuffer with real connection and can be queried",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured for testing\")"
          ],
          "start_line": 211,
          "end_line": 283,
          "is_async": true
        },
        {
          "name": "test_turbopuffer_metadata_attributes",
          "signature": "def test_turbopuffer_metadata_attributes(default_user, enable_turbopuffer)",
          "parameters": "(default_user, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test that Turbopuffer properly stores and retrieves metadata attributes",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 287,
          "end_line": 352,
          "is_async": true
        },
        {
          "name": "test_native_only_operations",
          "signature": "def test_native_only_operations(server, default_user, sarah_agent, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test that operations work correctly when using only native PostgreSQL",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 356,
          "end_line": 385,
          "is_async": true
        },
        {
          "name": "test_hybrid_search_with_real_tpuf",
          "signature": "def test_hybrid_search_with_real_tpuf(default_user, enable_turbopuffer)",
          "parameters": "(default_user, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test hybrid search functionality combining vector and full-text search",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured for testing\")"
          ],
          "start_line": 390,
          "end_line": 491,
          "is_async": true
        },
        {
          "name": "test_tag_filtering_with_real_tpuf",
          "signature": "def test_tag_filtering_with_real_tpuf(default_user, enable_turbopuffer)",
          "parameters": "(default_user, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test tag filtering functionality with AND and OR logic",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured for testing\")"
          ],
          "start_line": 496,
          "end_line": 619,
          "is_async": true
        },
        {
          "name": "test_temporal_filtering_with_real_tpuf",
          "signature": "def test_temporal_filtering_with_real_tpuf(default_user, enable_turbopuffer)",
          "parameters": "(default_user, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test temporal filtering with date ranges",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 623,
          "end_line": 758,
          "is_async": true
        },
        {
          "name": "test_should_use_tpuf_for_messages_settings",
          "signature": "def test_should_use_tpuf_for_messages_settings()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that should_use_tpuf_for_messages correctly checks both use_tpuf AND embed_all_messages",
          "decorators": [],
          "start_line": 761,
          "end_line": 800,
          "is_async": false
        },
        {
          "name": "test_message_text_extraction",
          "signature": "def test_message_text_extraction(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": "Test extraction of text from various message content structures including ReasoningContent",
          "decorators": [],
          "start_line": 803,
          "end_line": 947,
          "is_async": false
        },
        {
          "name": "test_message_embedding_without_config",
          "signature": "def test_message_embedding_without_config(server, default_user, sarah_agent, enable_message_embedding)",
          "parameters": "(server, default_user, sarah_agent, enable_message_embedding)",
          "return_type": null,
          "docstring": "Test that messages are NOT embedded without embedding_config even when tpuf is enabled",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 952,
          "end_line": 986,
          "is_async": true
        },
        {
          "name": "test_generic_reciprocal_rank_fusion",
          "signature": "def test_generic_reciprocal_rank_fusion()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test the generic RRF function with different object types",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 990,
          "end_line": 1086,
          "is_async": true
        },
        {
          "name": "test_message_dual_write_with_real_tpuf",
          "signature": "def test_message_dual_write_with_real_tpuf(enable_message_embedding, default_user)",
          "parameters": "(enable_message_embedding, default_user)",
          "return_type": null,
          "docstring": "Test actual message embedding and storage in Turbopuffer",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 1091,
          "end_line": 1148,
          "is_async": true
        },
        {
          "name": "test_message_vector_search_with_real_tpuf",
          "signature": "def test_message_vector_search_with_real_tpuf(enable_message_embedding, default_user)",
          "parameters": "(enable_message_embedding, default_user)",
          "return_type": null,
          "docstring": "Test vector search on messages in Turbopuffer",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 1153,
          "end_line": 1209,
          "is_async": true
        },
        {
          "name": "test_message_hybrid_search_with_real_tpuf",
          "signature": "def test_message_hybrid_search_with_real_tpuf(enable_message_embedding, default_user)",
          "parameters": "(enable_message_embedding, default_user)",
          "return_type": null,
          "docstring": "Test hybrid search combining vector and FTS for messages",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 1214,
          "end_line": 1272,
          "is_async": true
        },
        {
          "name": "test_message_role_filtering_with_real_tpuf",
          "signature": "def test_message_role_filtering_with_real_tpuf(enable_message_embedding, default_user)",
          "parameters": "(enable_message_embedding, default_user)",
          "return_type": null,
          "docstring": "Test filtering messages by role",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 1277,
          "end_line": 1344,
          "is_async": true
        },
        {
          "name": "test_message_search_fallback_to_sql",
          "signature": "def test_message_search_fallback_to_sql(server, default_user, sarah_agent)",
          "parameters": "(server, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test that message search falls back to SQL when Turbopuffer is disabled",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1348,
          "end_line": 1392,
          "is_async": true
        },
        {
          "name": "test_message_update_reindexes_in_turbopuffer",
          "signature": "def test_message_update_reindexes_in_turbopuffer(server, default_user, sarah_agent, enable_message_embedding)",
          "parameters": "(server, default_user, sarah_agent, enable_message_embedding)",
          "return_type": null,
          "docstring": "Test that updating a message properly deletes and re-inserts with new embedding in Turbopuffer",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 1397,
          "end_line": 1463,
          "is_async": true
        },
        {
          "name": "test_message_deletion_syncs_with_turbopuffer",
          "signature": "def test_message_deletion_syncs_with_turbopuffer(server, default_user, enable_message_embedding)",
          "parameters": "(server, default_user, enable_message_embedding)",
          "return_type": null,
          "docstring": "Test that all deletion methods properly sync with Turbopuffer",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 1468,
          "end_line": 1589,
          "is_async": true
        },
        {
          "name": "test_turbopuffer_failure_does_not_break_postgres",
          "signature": "def test_turbopuffer_failure_does_not_break_postgres(server, default_user, sarah_agent, enable_message_embedding)",
          "parameters": "(server, default_user, sarah_agent, enable_message_embedding)",
          "return_type": null,
          "docstring": "Test that postgres operations succeed even if turbopuffer fails",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 1594,
          "end_line": 1664,
          "is_async": true
        },
        {
          "name": "test_message_creation_background_mode",
          "signature": "def test_message_creation_background_mode(server, default_user, sarah_agent, enable_message_embedding)",
          "parameters": "(server, default_user, sarah_agent, enable_message_embedding)",
          "return_type": null,
          "docstring": "Test that messages are embedded in background when strict_mode=False",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 1669,
          "end_line": 1717,
          "is_async": true
        },
        {
          "name": "test_message_update_background_mode",
          "signature": "def test_message_update_background_mode(server, default_user, sarah_agent, enable_message_embedding)",
          "parameters": "(server, default_user, sarah_agent, enable_message_embedding)",
          "return_type": null,
          "docstring": "Test that message updates work in background mode",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 1722,
          "end_line": 1812,
          "is_async": true
        },
        {
          "name": "test_message_date_filtering_with_real_tpuf",
          "signature": "def test_message_date_filtering_with_real_tpuf(enable_message_embedding, default_user)",
          "parameters": "(enable_message_embedding, default_user)",
          "return_type": null,
          "docstring": "Test filtering messages by date range",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 1817,
          "end_line": 1903,
          "is_async": true
        },
        {
          "name": "test_archive_namespace_tracking",
          "signature": "def test_archive_namespace_tracking(server, default_user, enable_turbopuffer)",
          "parameters": "(server, default_user, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test that archive namespaces are properly tracked in database",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1907,
          "end_line": 1926,
          "is_async": true
        },
        {
          "name": "test_namespace_consistency_with_tpuf_client",
          "signature": "def test_namespace_consistency_with_tpuf_client(server, default_user, enable_turbopuffer)",
          "parameters": "(server, default_user, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test that the namespace from managers matches what tpuf_client would generate",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1930,
          "end_line": 1945,
          "is_async": true
        },
        {
          "name": "test_environment_namespace_variation",
          "signature": "def test_environment_namespace_variation(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": "Test namespace generation with different environment settings",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1949,
          "end_line": 1972,
          "is_async": true
        },
        {
          "name": "test_message_project_id_filtering",
          "signature": "def test_message_project_id_filtering(server, sarah_agent, default_user, enable_turbopuffer, enable_message_embedding)",
          "parameters": "(server, sarah_agent, default_user, enable_turbopuffer, enable_message_embedding)",
          "return_type": null,
          "docstring": "Test that project_id filtering works correctly in query_messages_by_agent_id",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 1977,
          "end_line": 2082,
          "is_async": true
        },
        {
          "name": "test_message_template_id_filtering",
          "signature": "def test_message_template_id_filtering(server, sarah_agent, default_user, enable_turbopuffer, enable_message_embedding)",
          "parameters": "(server, sarah_agent, default_user, enable_turbopuffer, enable_message_embedding)",
          "return_type": null,
          "docstring": "Test that template_id filtering works correctly in message queries",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 2087,
          "end_line": 2167,
          "is_async": true
        },
        {
          "name": "test_message_conversation_id_filtering",
          "signature": "def test_message_conversation_id_filtering(server, sarah_agent, default_user, enable_turbopuffer, enable_message_embedding)",
          "parameters": "(server, sarah_agent, default_user, enable_turbopuffer, enable_message_embedding)",
          "return_type": null,
          "docstring": "Test that conversation_id filtering works correctly in message queries, including 'default' sentinel",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 2172,
          "end_line": 2283,
          "is_async": true
        },
        {
          "name": "test_query_messages_with_mixed_conversation_id_presence",
          "signature": "def test_query_messages_with_mixed_conversation_id_presence(enable_message_embedding, default_user)",
          "parameters": "(enable_message_embedding, default_user)",
          "return_type": null,
          "docstring": "Test that querying works when the namespace schema doesn't have conversation_id.\n\n    This test validates the fix for the error:\n    'attribute \"conversation_id\" not found in schema, cannot be part of include_attributes'\n\n    The fix changed from explicitly listing attributes (which fails when the namespace\n    schema doesn't have conversation_id) to using include_attributes=True which gracefully\n    returns all available attributes.\n\n    IMPORTANT: This test uses raw Turbopuffer API to insert messages WITHOUT\n    the conversation_id schema, then queries BEFORE any new messages are added.\n    This reproduces the exact production scenario where old namespaces don't have\n    conversation_id in their schema.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 2288,
          "end_line": 2407,
          "is_async": true
        },
        {
          "name": "test_query_messages_by_org_id_with_missing_conversation_id_schema",
          "signature": "def test_query_messages_by_org_id_with_missing_conversation_id_schema(enable_message_embedding, default_user)",
          "parameters": "(enable_message_embedding, default_user)",
          "return_type": null,
          "docstring": "Test that query_messages_by_org_id works when the namespace doesn't have conversation_id in schema.\n\n    This is the companion test to test_query_messages_with_mixed_conversation_id_presence,\n    validating the same fix for the query_messages_by_org_id method.\n\n    IMPORTANT: This test queries BEFORE any messages with conversation_id are inserted,\n    to reproduce the exact production scenario.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 2412,
          "end_line": 2489,
          "is_async": true
        },
        {
          "name": "test_system_messages_not_embedded_during_agent_creation",
          "signature": "def test_system_messages_not_embedded_during_agent_creation(server, default_user, enable_message_embedding)",
          "parameters": "(server, default_user, enable_message_embedding)",
          "return_type": null,
          "docstring": "Test that system messages are filtered out before being passed to the embedding pipeline during agent creation",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2493,
          "end_line": 2545,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406663
    },
    "tests/integration_test_usage_tracking.py": {
      "path": "tests/integration_test_usage_tracking.py",
      "contentHash": "48d660bedc3a60e791cc0a267c5f5f48",
      "mtime": 1767315072128.5476,
      "functions": [
        {
          "name": "get_model_config",
          "signature": "def get_model_config(filename: str, model_settings_dir: str = \"tests/model_settings\") -> Tuple[str, dict]",
          "parameters": "(filename: str, model_settings_dir: str = \"tests/model_settings\")",
          "return_type": "Tuple[str, dict]",
          "docstring": "Load a model_settings file and return the handle and settings dict.",
          "decorators": [],
          "start_line": 75,
          "end_line": 80,
          "is_async": false
        },
        {
          "name": "base_url",
          "signature": "def base_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Get the Letta server URL from environment or use default.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 89,
          "end_line": 91,
          "is_async": false
        },
        {
          "name": "async_client",
          "signature": "def async_client(base_url: str) -> AsyncLetta",
          "parameters": "(base_url: str)",
          "return_type": "AsyncLetta",
          "docstring": "Create an async Letta client.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 95,
          "end_line": 98,
          "is_async": true
        },
        {
          "name": "create_test_agent",
          "signature": "def create_test_agent(\n    client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n    name_suffix: str = \"\",\n) -> AgentState",
          "parameters": "(\n    client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n    name_suffix: str = \"\",\n)",
          "return_type": "AgentState",
          "docstring": "Create a test agent with the specified model configuration.",
          "decorators": [],
          "start_line": 106,
          "end_line": 119,
          "is_async": true
        },
        {
          "name": "cleanup_agent",
          "signature": "def cleanup_agent(client: AsyncLetta, agent_id: str) -> None",
          "parameters": "(client: AsyncLetta, agent_id: str)",
          "return_type": "None",
          "docstring": "Delete a test agent.",
          "decorators": [],
          "start_line": 122,
          "end_line": 127,
          "is_async": true
        },
        {
          "name": "extract_usage_from_stream",
          "signature": "def extract_usage_from_stream(messages: List[Any]) -> Optional[LettaUsageStatistics]",
          "parameters": "(messages: List[Any])",
          "return_type": "Optional[LettaUsageStatistics]",
          "docstring": "Extract LettaUsageStatistics from a stream response.",
          "decorators": [],
          "start_line": 130,
          "end_line": 135,
          "is_async": false
        },
        {
          "name": "test_cache_tokens_streaming",
          "signature": "def test_cache_tokens_streaming(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n) -> None",
          "parameters": "(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n)",
          "return_type": "None",
          "docstring": "Test that cache token data is captured in streaming mode.\n\n    Cache hits typically occur on the second+ request with the same context,\n    so we send multiple messages to trigger caching.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"model_handle,model_settings\", CACHE_TEST_CONFIGS)"
          ],
          "start_line": 145,
          "end_line": 204,
          "is_async": true
        },
        {
          "name": "test_cache_tokens_non_streaming",
          "signature": "def test_cache_tokens_non_streaming(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n) -> None",
          "parameters": "(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n)",
          "return_type": "None",
          "docstring": "Test that cache token data is captured in non-streaming (blocking) mode.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"model_handle,model_settings\", CACHE_TEST_CONFIGS)"
          ],
          "start_line": 209,
          "end_line": 249,
          "is_async": true
        },
        {
          "name": "test_reasoning_tokens_streaming",
          "signature": "def test_reasoning_tokens_streaming(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n) -> None",
          "parameters": "(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n)",
          "return_type": "None",
          "docstring": "Test that reasoning token data is captured from reasoning models in streaming mode.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"model_handle,model_settings\", REASONING_TEST_CONFIGS)"
          ],
          "start_line": 259,
          "end_line": 295,
          "is_async": true
        },
        {
          "name": "test_reasoning_tokens_non_streaming",
          "signature": "def test_reasoning_tokens_non_streaming(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n) -> None",
          "parameters": "(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n)",
          "return_type": "None",
          "docstring": "Test that reasoning token data is captured from reasoning models in non-streaming mode.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"model_handle,model_settings\", REASONING_TEST_CONFIGS)"
          ],
          "start_line": 300,
          "end_line": 331,
          "is_async": true
        },
        {
          "name": "test_step_level_usage_details",
          "signature": "def test_step_level_usage_details(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n) -> None",
          "parameters": "(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n)",
          "return_type": "None",
          "docstring": "Test that step-level usage details (prompt_tokens_details, completion_tokens_details)\n    are properly persisted and retrievable.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"model_handle,model_settings\", CACHE_TEST_CONFIGS[:1])  # Test with one config"
          ],
          "start_line": 341,
          "end_line": 381,
          "is_async": true
        },
        {
          "name": "test_run_level_usage_aggregation",
          "signature": "def test_run_level_usage_aggregation(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n) -> None",
          "parameters": "(\n    async_client: AsyncLetta,\n    model_handle: str,\n    model_settings: dict,\n)",
          "return_type": "None",
          "docstring": "Test that run-level usage correctly aggregates cache/reasoning tokens from steps.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"model_handle,model_settings\", CACHE_TEST_CONFIGS[:1])  # Test with one config"
          ],
          "start_line": 391,
          "end_line": 432,
          "is_async": true
        },
        {
          "name": "test_usage_tracking_end_to_end",
          "signature": "def test_usage_tracking_end_to_end(async_client: AsyncLetta) -> None",
          "parameters": "(async_client: AsyncLetta)",
          "return_type": "None",
          "docstring": "End-to-end test that verifies the complete usage tracking flow:\n    1. Create agent with a model that supports caching\n    2. Send messages to trigger cache writes and reads\n    3. Verify step-level details are persisted\n    4. Verify run-level aggregation is correct",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 441,
          "end_line": 497,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406663
    },
    "tests/integration_test_voice_agent.py": {
      "path": "tests/integration_test_voice_agent.py",
      "contentHash": "d5852f62194b29585b5986c6c5e9a02d",
      "mtime": 1767315072128.5476,
      "functions": [
        {
          "name": " returns i",
          "signature": "def  returns its",
          "parameters": "ts",
          "return_type": null,
          "docstring": "URL.\"\"\"\n    url = os.getenv(\"LETTA_SERVER_URL\", \"http://loc",
          "decorators": [
            "  \"\"\"Ensures a server is runnin"
          ],
          "start_line": 94,
          "end_line": 113,
          "is_async": false
        },
        {
          "name": "\"CONFI",
          "signature": "def \"CONFIG ",
          "parameters": "G ",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "nfig = LettaConfig.load()\n    p"
          ],
          "start_line": 117,
          "end_line": 126,
          "is_async": false
        },
        {
          "name": "        \"\"\"\n  ",
          "signature": "def         \"\"\"\n        Rolls a 6",
          "parameters": "      Rolls a 6",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "erver, actor):\n    def roll_dic"
          ],
          "start_line": 133,
          "end_line": 144,
          "is_async": false
        },
        {
          "name": "code_tool =",
          "signature": "def code_tool = server.tool_manager.get_tool_b",
          "parameters": " server.tool_manager.get_tool_b",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "dice_tool):\n   "
          ],
          "start_line": 148,
          "end_line": 172,
          "is_async": false
        },
        {
          "name": "agent_gr",
          "signature": "def agent_group.id\n\n\n@pyt",
          "parameters": "oup.id\n\n\n@pyt",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "n voice_agent.m"
          ],
          "start_line": 176,
          "end_line": 177,
          "is_async": false
        },
        {
          "name": "r.crea",
          "signature": "def r.create_defau",
          "parameters": "te_defau",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "    org = server.organization_m"
          ],
          "start_line": 181,
          "end_line": 184,
          "is_async": false
        },
        {
          "name": "r.cre",
          "signature": "def r.create_default_user",
          "parameters": "ate_default_user",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "g_id):\n    user = server.user_m"
          ],
          "start_line": 188,
          "end_line": 190,
          "is_async": false
        },
        {
          "name": "rns a chat comple",
          "signature": "def rns a chat completion request with stre",
          "parameters": "tion request with stre",
          "return_type": null,
          "docstring": "enabled.\"\"\"\n    return ChatCompletionRequest(\n        model=\"gp",
          "decorators": [],
          "start_line": 196,
          "end_line": 202,
          "is_async": false
        },
        {
          "name": "dates the structure",
          "signature": "def dates the structure of each streaming c",
          "parameters": " of each streaming c",
          "return_type": null,
          "docstring": "\"\"\n    if isinstance(chunk, ChatCompletionChunk):",
          "decorators": [],
          "start_line": 205,
          "end_line": 221,
          "is_async": false
        },
        {
          "name": "ver_url, actor, roll_dic",
          "signature": "def ver_url, actor, roll_dice_tool):\n    request = _get_chat_request(message)\n    serve",
          "parameters": "e_tool):\n    request = _get_chat_request(message)\n    serve",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "rk.parametrize(\"model\", [\"openai/gpt-4o-m",
            "ni\", \"anthropic/claude-sonnet-4-20250514\"])\n@pytest.mark.parametrize(\n    \"message\", [\"How are ",
            "ou?\", \"Use the roll_dice tool to roll a die for me\", \"Use the run_code tool to calculate 2+2\"]\n)\nasync def test_model_compatibility(model, message, "
          ],
          "start_line": 232,
          "end_line": 302,
          "is_async": true
        },
        {
          "name": "agent, message, endpoint",
          "signature": "def agent, message, endpoint, server_url):\n    \"\"\"Tests chat completion streaming using the A",
          "parameters": ", server_url):\n    \"\"\"Tests chat completion streaming using the A",
          "return_type": null,
          "docstring": "penAI client.\"\"\"\n    request = _get_chat_request(message)\n\n    async",
          "decorators": [
            "rk.parametrize(\"message\", [\"Use search me",
            "ory tool to recall what my name is.\"])\n@pytest.mark.parametrize(\"endpoint\", [\"v1/voice-bet",
            "\"])\nasync def test_voice_recall_memory(disable_e2b_api_"
          ],
          "start_line": 308,
          "end_line": 317,
          "is_async": true
        },
        {
          "name": "er, voice_agent, group_id,",
          "signature": "def er, voice_agent, group_id, endpoint, actor, server_url):\n    await server.group_manager.modify_group_async(",
          "parameters": " endpoint, actor, server_url):\n    await server.group_manager.modify_group_async(",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "rk.parametrize(\"endpoint\", [\"v1/voice-bet",
            "\"])\nasync def test_trigger_summarization(disable_e2b_ap"
          ],
          "start_line": 322,
          "end_line": 349,
          "is_async": true
        },
        {
          "name": " server_url):\n    ",
          "signature": "def  server_url):\n    agent_manager = AgentManager()\n    user_manage",
          "parameters": "agent_manager = AgentManager()\n    user_manage",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "test_summarization(disable_e2b_api_key, v"
          ],
          "start_line": 353,
          "end_line": 422,
          "is_async": true
        },
        {
          "name": "agent):\n    \"\"\"Tests chat ",
          "signature": "def agent):\n    \"\"\"Tests chat completion streaming using the Asy",
          "parameters": "completion streaming using the Asy",
          "return_type": null,
          "docstring": "nAI client.\"\"\"\n    agent_manager = AgentManager()\n    tool_manager =",
          "decorators": [
            "st_voice_sleeptime_agent(disable_e2b_api_"
          ],
          "start_line": 426,
          "end_line": 489,
          "is_async": true
        },
        {
          "name": " assert voice_agent.enable_",
          "signature": "def  assert voice_agent.enable_sleeptime == True\n    main_a",
          "parameters": "sleeptime == True\n    main_a",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "t_voice_convo_agent(voice_agent, server, "
          ],
          "start_line": 493,
          "end_line": 550,
          "is_async": true
        },
        {
          "name": "elper t",
          "signature": "def elper to invoke modify_group with voice_sleeptime ",
          "parameters": "o invoke modify_group with voice_sleeptime ",
          "return_type": null,
          "docstring": ".\"\"\"\n    return await server.group_manager.modify_group_async(",
          "decorators": [],
          "start_line": 553,
          "end_line": 565,
          "is_async": true
        },
        {
          "name": "):\n    # both > 4 and max > min\n    ",
          "signature": "def ):\n    # both > 4 and max > min\n    updated = await _modify(g",
          "parameters": "updated = await _modify(g",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "id_buffer_lengths_above_four(group_id, se"
          ],
          "start_line": 569,
          "end_line": 573,
          "is_async": true
        },
        {
          "name": "\n    # both > 4 and max > min\n    ",
          "signature": "def \n    # both > 4 and max > min\n    updated = await _modify(g",
          "parameters": "updated = await _modify(g",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "id_buffer_lengths_only_max(group_id, serv"
          ],
          "start_line": 577,
          "end_line": 581,
          "is_async": true
        },
        {
          "name": "\n    # both > 4 and max > min\n    ",
          "signature": "def \n    # both > 4 and max > min\n    updated = await _modify(g",
          "parameters": "updated = await _modify(g",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "id_buffer_lengths_only_min(group_id, serv"
          ],
          "start_line": 585,
          "end_line": 589,
          "is_async": true
        },
        {
          "name": "min_val, err_part):\n    wit",
          "signature": "def min_val, err_part):\n    with pytest.raises(ValueError) as exc:\n        await _mo",
          "parameters": "h pytest.raises(ValueError) as exc:\n        await _mo",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "etrize(\n    \"max_val,min_val,err_part\",\n ",
            "  [\n        # only one set  both-or-none\n        (None, DEFAULT_MAX_MESSAGE_BUFFER_LENGTH, \"must be greater than\"),\n        (DEFAULT_MIN_MESSAGE_BUFFER_LENGTH, None, \"must be greater than\"),\n        # ordering violations\n        (5, 5, \"must be greater than\"),\n        (6, 7, \"must be greater than\"),\n        # lower-bound (must both be > 4)\n        (4, 5, \"greater than 4\"),\n        (5, 4, \"greater than 4\"),\n        (1, 10, \"greater than 4\"),\n        (10, 1, \"greater than 4\"),\n    ],\n)\nasync def test_invalid_buffer_lengths(group_id, server, actor"
          ],
          "start_line": 609,
          "end_line": 612,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406664
    },
    "tests/managers/conftest.py": {
      "path": "tests/managers/conftest.py",
      "contentHash": "a909902f41ec0f8e9529147aae887f6c",
      "mtime": 1767315072128.5476,
      "functions": [
        {
          "name": "async_session",
          "signature": "def async_session()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Provide an async database session.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 57,
          "end_line": 60,
          "is_async": true
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Create a server instance for the test module.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 84,
          "end_line": 89,
          "is_async": false
        },
        {
          "name": "default_organization",
          "signature": "def default_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 98,
          "end_line": 101,
          "is_async": true
        },
        {
          "name": "other_organization",
          "signature": "def other_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Create and return another organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 105,
          "end_line": 108,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(server: SyncServer, default_organization)",
          "parameters": "(server: SyncServer, default_organization)",
          "return_type": null,
          "docstring": "Create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 112,
          "end_line": 115,
          "is_async": true
        },
        {
          "name": "other_user",
          "signature": "def other_user(server: SyncServer, default_organization)",
          "parameters": "(server: SyncServer, default_organization)",
          "return_type": null,
          "docstring": "Create and return another user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 119,
          "end_line": 122,
          "is_async": true
        },
        {
          "name": "other_user_different_org",
          "signature": "def other_user_different_org(server: SyncServer, other_organization)",
          "parameters": "(server: SyncServer, other_organization)",
          "return_type": null,
          "docstring": "Create and return a user in a different organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 126,
          "end_line": 129,
          "is_async": true
        },
        {
          "name": "default_source",
          "signature": "def default_source(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Create and return the default source.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 138,
          "end_line": 147,
          "is_async": true
        },
        {
          "name": "other_source",
          "signature": "def other_source(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Create and return another source.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 151,
          "end_line": 160,
          "is_async": true
        },
        {
          "name": "default_file",
          "signature": "def default_file(server: SyncServer, default_source, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_source, default_user, default_organization)",
          "return_type": null,
          "docstring": "Create and return the default file.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 164,
          "end_line": 170,
          "is_async": true
        },
        {
          "name": "another_file",
          "signature": "def another_file(server: SyncServer, default_source, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_source, default_user, default_organization)",
          "return_type": null,
          "docstring": "Create and return another file.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 174,
          "end_line": 182,
          "is_async": true
        },
        {
          "name": "print_tool",
          "signature": "def print_tool(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Create and return a print tool.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 191,
          "end_line": 220,
          "is_async": true
        },
        {
          "name": "bash_tool",
          "signature": "def bash_tool(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Create and return a bash tool with requires_approval.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 224,
          "end_line": 254,
          "is_async": true
        },
        {
          "name": "other_tool",
          "signature": "def other_tool(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Create and return another tool.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 258,
          "end_line": 286,
          "is_async": true
        },
        {
          "name": "default_block",
          "signature": "def default_block(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Create and return a default block.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 295,
          "end_line": 306,
          "is_async": true
        },
        {
          "name": "other_block",
          "signature": "def other_block(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Create and return another block.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 310,
          "end_line": 321,
          "is_async": true
        },
        {
          "name": "sarah_agent",
          "signature": "def sarah_agent(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Create and return a sample agent named 'sarah_agent'.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 330,
          "end_line": 343,
          "is_async": true
        },
        {
          "name": "charles_agent",
          "signature": "def charles_agent(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Create and return a sample agent named 'charles_agent'.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 347,
          "end_line": 360,
          "is_async": true
        },
        {
          "name": "comprehensive_test_agent_fixture",
          "signature": "def comprehensive_test_agent_fixture(server: SyncServer, default_user, print_tool, default_source, default_block) -> Tuple",
          "parameters": "(server: SyncServer, default_user, print_tool, default_source, default_block)",
          "return_type": "Tuple",
          "docstring": "Create a comprehensive test agent with all features.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 364,
          "end_line": 390,
          "is_async": true
        },
        {
          "name": "default_archive",
          "signature": "def default_archive(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Create and return a default archive.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 399,
          "end_line": 404,
          "is_async": true
        },
        {
          "name": "agent_passage_fixture",
          "signature": "def agent_passage_fixture(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Create an agent passage.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 408,
          "end_line": 424,
          "is_async": true
        },
        {
          "name": "source_passage_fixture",
          "signature": "def source_passage_fixture(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Create a source passage.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 428,
          "end_line": 443,
          "is_async": true
        },
        {
          "name": "hello_world_message_fixture",
          "signature": "def hello_world_message_fixture(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Create a hello world message.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 452,
          "end_line": 461,
          "is_async": true
        },
        {
          "name": "sandbox_config_fixture",
          "signature": "def sandbox_config_fixture(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Create a sandbox configuration.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 470,
          "end_line": 476,
          "is_async": true
        },
        {
          "name": "sandbox_env_var_fixture",
          "signature": "def sandbox_env_var_fixture(server: SyncServer, sandbox_config_fixture, default_user)",
          "parameters": "(server: SyncServer, sandbox_config_fixture, default_user)",
          "return_type": null,
          "docstring": "Create a sandbox environment variable.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 480,
          "end_line": 490,
          "is_async": true
        },
        {
          "name": "file_attachment",
          "signature": "def file_attachment(server: SyncServer, default_user, sarah_agent, default_file)",
          "parameters": "(server: SyncServer, default_user, sarah_agent, default_file)",
          "return_type": null,
          "docstring": "Create a file attachment to an agent.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 499,
          "end_line": 510,
          "is_async": true
        },
        {
          "name": "default_job",
          "signature": "def default_job(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Create and return a default job.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 519,
          "end_line": 526,
          "is_async": true
        },
        {
          "name": "default_run",
          "signature": "def default_run(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Create and return a default run.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 530,
          "end_line": 537,
          "is_async": true
        },
        {
          "name": "letta_batch_job",
          "signature": "def letta_batch_job(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Create a batch job.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 541,
          "end_line": 543,
          "is_async": true
        },
        {
          "name": "mcp_tool",
          "signature": "def mcp_tool(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Create an MCP tool.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 552,
          "end_line": 576,
          "is_async": true
        },
        {
          "name": "create_test_passages",
          "signature": "def create_test_passages(server: SyncServer, default_file, default_user, sarah_agent, default_source)",
          "parameters": "(server: SyncServer, default_file, default_user, sarah_agent, default_source)",
          "return_type": null,
          "docstring": "Helper function to create test passages for all tests.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 585,
          "end_line": 629,
          "is_async": true
        },
        {
          "name": "agent_passages_setup",
          "signature": "def agent_passages_setup(server: SyncServer, default_archive, default_source, default_file, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_archive, default_source, default_file, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Setup fixture for agent passages tests.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 633,
          "end_line": 680,
          "is_async": true
        },
        {
          "name": "agent_with_tags",
          "signature": "def agent_with_tags(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Create agents with specific tags.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 684,
          "end_line": 725,
          "is_async": true
        },
        {
          "name": "dummy_llm_config",
          "signature": "def dummy_llm_config() -> LLMConfig",
          "parameters": "()",
          "return_type": "LLMConfig",
          "docstring": "Create a dummy LLM config.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 734,
          "end_line": 736,
          "is_async": false
        },
        {
          "name": "dummy_tool_rules_solver",
          "signature": "def dummy_tool_rules_solver() -> ToolRulesSolver",
          "parameters": "()",
          "return_type": "ToolRulesSolver",
          "docstring": "Create a dummy tool rules solver.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 740,
          "end_line": 742,
          "is_async": false
        },
        {
          "name": "dummy_step_state",
          "signature": "def dummy_step_state(dummy_tool_rules_solver: ToolRulesSolver) -> AgentStepState",
          "parameters": "(dummy_tool_rules_solver: ToolRulesSolver)",
          "return_type": "AgentStepState",
          "docstring": "Create a dummy step state.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 746,
          "end_line": 748,
          "is_async": false
        },
        {
          "name": "dummy_successful_response",
          "signature": "def dummy_successful_response() -> BetaMessageBatchIndividualResponse",
          "parameters": "()",
          "return_type": "BetaMessageBatchIndividualResponse",
          "docstring": "Create a dummy successful Anthropic message batch response.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 752,
          "end_line": 768,
          "is_async": false
        },
        {
          "name": "set_letta_environment",
          "signature": "def set_letta_environment(request, monkeypatch)",
          "parameters": "(request, monkeypatch)",
          "return_type": null,
          "docstring": "Parametrized fixture to test with different environment settings.",
          "decorators": [
            "@pytest.fixture(params=[None, \"prod\"])"
          ],
          "start_line": 777,
          "end_line": 786,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406664
    },
    "tests/managers/test_agent_manager.py": {
      "path": "tests/managers/test_agent_manager.py",
      "contentHash": "480f5231985a750fb938078bd49c7c60",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "test_validate_agent_exists_async",
          "signature": "def test_validate_agent_exists_async(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": "Test the validate_agent_exists_async helper function",
          "decorators": [],
          "start_line": 120,
          "end_line": 132,
          "is_async": true
        },
        {
          "name": "test_create_get_list_agent",
          "signature": "def test_create_get_list_agent(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 136,
          "end_line": 158,
          "is_async": true
        },
        {
          "name": "test_create_agent_include_base_tools",
          "signature": "def test_create_agent_include_base_tools(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test agent creation with include_default_source=True",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 162,
          "end_line": 188,
          "is_async": true
        },
        {
          "name": "test_create_agent_base_tool_rules_excluded_providers",
          "signature": "def test_create_agent_base_tool_rules_excluded_providers(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that include_base_tool_rules is overridden to False for excluded providers",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 192,
          "end_line": 218,
          "is_async": true
        },
        {
          "name": "test_create_agent_base_tool_rules_non_excluded_providers",
          "signature": "def test_create_agent_base_tool_rules_non_excluded_providers(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that include_base_tool_rules is NOT overridden for non-excluded providers",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 222,
          "end_line": 253,
          "is_async": true
        },
        {
          "name": "test_create_agent_with_model_handle_uses_correct_llm_config",
          "signature": "def test_create_agent_with_model_handle_uses_correct_llm_config(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "When CreateAgent.model is provided, ensure the correct handle is used to resolve llm_config.\n\n    This verifies that the model handle passed by the client is forwarded into\n    SyncServer.get_llm_config_from_handle_async and that the resulting AgentState\n    carries an llm_config with the same handle.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 257,
          "end_line": 305,
          "is_async": true
        },
        {
          "name": "test_compaction_settings_model_uses_separate_llm_config_for_summarization",
          "signature": "def test_compaction_settings_model_uses_separate_llm_config_for_summarization(default_user)",
          "parameters": "(default_user)",
          "return_type": null,
          "docstring": "When compaction_settings.model differs from the agent model, use a separate llm_config.\n\n    This test exercises the summarization helpers directly to avoid external\n    provider dependencies. It verifies that CompactionSettings.model controls\n    the LLMConfig used for the summarizer request.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 309,
          "end_line": 423,
          "is_async": true
        },
        {
          "name": "test_calculate_multi_agent_tools",
          "signature": "def test_calculate_multi_agent_tools(set_letta_environment)",
          "parameters": "(set_letta_environment)",
          "return_type": null,
          "docstring": "Test that calculate_multi_agent_tools excludes local-only tools in production.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 427,
          "end_line": 449,
          "is_async": true
        },
        {
          "name": "test_upsert_base_tools_excludes_local_only_in_production",
          "signature": "def test_upsert_base_tools_excludes_local_only_in_production(server: SyncServer, default_user, set_letta_environment)",
          "parameters": "(server: SyncServer, default_user, set_letta_environment)",
          "return_type": null,
          "docstring": "Test that upsert_base_tools excludes local-only multi-agent tools in production.",
          "decorators": [],
          "start_line": 452,
          "end_line": 470,
          "is_async": true
        },
        {
          "name": "test_upsert_multi_agent_tools_only",
          "signature": "def test_upsert_multi_agent_tools_only(server: SyncServer, default_user, set_letta_environment)",
          "parameters": "(server: SyncServer, default_user, set_letta_environment)",
          "return_type": null,
          "docstring": "Test that upserting only multi-agent tools respects production filtering.",
          "decorators": [],
          "start_line": 473,
          "end_line": 489,
          "is_async": true
        },
        {
          "name": "test_create_agent_with_default_source",
          "signature": "def test_create_agent_with_default_source(server: SyncServer, default_user, print_tool, default_block)",
          "parameters": "(server: SyncServer, default_user, print_tool, default_block)",
          "return_type": null,
          "docstring": "Test agent creation with include_default_source=True",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 493,
          "end_line": 559,
          "is_async": true
        },
        {
          "name": "test_get_context_window_basic",
          "signature": "def test_get_context_window_basic(\n    server: SyncServer, comprehensive_test_agent_fixture, default_user, default_file, set_letta_environment\n)",
          "parameters": "(\n    server: SyncServer, comprehensive_test_agent_fixture, default_user, default_file, set_letta_environment\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 562,
          "end_line": 586,
          "is_async": true
        },
        {
          "name": "test_create_agent_passed_in_initial_messages",
          "signature": "def test_create_agent_passed_in_initial_messages(server: SyncServer, default_user, default_block)",
          "parameters": "(server: SyncServer, default_user, default_block)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 590,
          "end_line": 616,
          "is_async": true
        },
        {
          "name": "test_create_agent_default_initial_message",
          "signature": "def test_create_agent_default_initial_message(server: SyncServer, default_user, default_block)",
          "parameters": "(server: SyncServer, default_user, default_block)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 620,
          "end_line": 641,
          "is_async": true
        },
        {
          "name": "test_create_agent_with_json_in_system_message",
          "signature": "def test_create_agent_with_json_in_system_message(server: SyncServer, default_user, default_block)",
          "parameters": "(server: SyncServer, default_user, default_block)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 645,
          "end_line": 672,
          "is_async": true
        },
        {
          "name": "test_update_agent",
          "signature": "def test_update_agent(server: SyncServer, comprehensive_test_agent_fixture, other_tool, other_source, other_block, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, other_tool, other_source, other_block, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 675,
          "end_line": 698,
          "is_async": true
        },
        {
          "name": "test_create_agent_with_compaction_settings",
          "signature": "def test_create_agent_with_compaction_settings(server: SyncServer, default_user, default_block)",
          "parameters": "(server: SyncServer, default_user, default_block)",
          "return_type": null,
          "docstring": "Test that agents can be created with custom compaction_settings",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 702,
          "end_line": 745,
          "is_async": true
        },
        {
          "name": "test_update_agent_compaction_settings",
          "signature": "def test_update_agent_compaction_settings(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": "Test that an agent's compaction_settings can be updated",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 749,
          "end_line": 783,
          "is_async": true
        },
        {
          "name": "test_agent_file_defaults_based_on_context_window",
          "signature": "def test_agent_file_defaults_based_on_context_window(server: SyncServer, default_user, default_block)",
          "parameters": "(server: SyncServer, default_user, default_block)",
          "return_type": null,
          "docstring": "Test that file-related defaults are set based on the model's context window size",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 787,
          "end_line": 851,
          "is_async": true
        },
        {
          "name": "test_agent_file_defaults_explicit_values",
          "signature": "def test_agent_file_defaults_explicit_values(server: SyncServer, default_user, default_block)",
          "parameters": "(server: SyncServer, default_user, default_block)",
          "return_type": null,
          "docstring": "Test that explicitly set file-related values are respected",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 855,
          "end_line": 877,
          "is_async": true
        },
        {
          "name": "test_update_agent_file_fields",
          "signature": "def test_update_agent_file_fields(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": "Test updating file-related fields on an existing agent",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 881,
          "end_line": 894,
          "is_async": true
        },
        {
          "name": "test_update_agent_last_stop_reason",
          "signature": "def test_update_agent_last_stop_reason(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": "Test updating last_stop_reason field on an existing agent",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 898,
          "end_line": 934,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_empty",
          "signature": "def test_list_agents_select_fields_empty(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 943,
          "end_line": 957,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_none",
          "signature": "def test_list_agents_select_fields_none(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 961,
          "end_line": 975,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_specific",
          "signature": "def test_list_agents_select_fields_specific(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 979,
          "end_line": 992,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_invalid",
          "signature": "def test_list_agents_select_fields_invalid(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 996,
          "end_line": 1007,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_duplicates",
          "signature": "def test_list_agents_select_fields_duplicates(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1011,
          "end_line": 1022,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_mixed",
          "signature": "def test_list_agents_select_fields_mixed(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1026,
          "end_line": 1038,
          "is_async": true
        },
        {
          "name": "test_list_agents_ascending",
          "signature": "def test_list_agents_ascending(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1042,
          "end_line": 1073,
          "is_async": true
        },
        {
          "name": "test_list_agents_descending",
          "signature": "def test_list_agents_descending(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1077,
          "end_line": 1108,
          "is_async": true
        },
        {
          "name": "test_list_agents_by_last_stop_reason",
          "signature": "def test_list_agents_by_last_stop_reason(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1112,
          "end_line": 1177,
          "is_async": true
        },
        {
          "name": "test_count_agents_with_filters",
          "signature": "def test_count_agents_with_filters(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test count_agents_async with various filters",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1181,
          "end_line": 1289,
          "is_async": true
        },
        {
          "name": "test_list_agents_ordering_and_pagination",
          "signature": "def test_list_agents_ordering_and_pagination(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1293,
          "end_line": 1350,
          "is_async": true
        },
        {
          "name": "encryption_key",
          "signature": "def encryption_key()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to ensure encryption key is set for tests.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 1359,
          "end_line": 1367,
          "is_async": false
        },
        {
          "name": "test_agent_environment_variables_encrypt_on_create",
          "signature": "def test_agent_environment_variables_encrypt_on_create(server: SyncServer, default_user, encryption_key)",
          "parameters": "(server: SyncServer, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that creating an agent with secrets encrypts the values in the database.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1371,
          "end_line": 1419,
          "is_async": true
        },
        {
          "name": "test_agent_environment_variables_decrypt_on_read",
          "signature": "def test_agent_environment_variables_decrypt_on_read(server: SyncServer, default_user, encryption_key)",
          "parameters": "(server: SyncServer, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that reading an agent deserializes secrets correctly to AgentEnvironmentVariable objects.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1423,
          "end_line": 1465,
          "is_async": true
        },
        {
          "name": "test_agent_environment_variables_update_encryption",
          "signature": "def test_agent_environment_variables_update_encryption(server: SyncServer, default_user, encryption_key)",
          "parameters": "(server: SyncServer, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that updating agent secrets encrypts new values.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1469,
          "end_line": 1519,
          "is_async": true
        },
        {
          "name": "test_agent_secrets_clear_with_empty_dict",
          "signature": "def test_agent_secrets_clear_with_empty_dict(server: SyncServer, default_user, encryption_key)",
          "parameters": "(server: SyncServer, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that updating agent secrets with empty dict clears all secrets.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1523,
          "end_line": 1559,
          "is_async": true
        },
        {
          "name": "test_agent_state_schema_unchanged",
          "signature": "def test_agent_state_schema_unchanged(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Test that the AgentState pydantic schema structure has not changed.\n    This test validates all fields including nested pydantic objects to ensure\n    the schema remains stable across changes.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1563,
          "end_line": 1932,
          "is_async": true
        },
        {
          "name": "test_agent_state_relationship_loads",
          "signature": "def test_agent_state_relationship_loads(server: SyncServer, default_user, print_tool, default_block)",
          "parameters": "(server: SyncServer, default_user, print_tool, default_block)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1935,
          "end_line": 2000,
          "is_async": true
        },
        {
          "name": "test_create_template_agent_with_files_from_sources",
          "signature": "def test_create_template_agent_with_files_from_sources(server: SyncServer, default_user, print_tool, default_block)",
          "parameters": "(server: SyncServer, default_user, print_tool, default_block)",
          "return_type": null,
          "docstring": "Test that agents created from templates properly attach files from their sources",
          "decorators": [],
          "start_line": 2003,
          "end_line": 2083,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406664
    },
    "tests/managers/test_agent_manager_block_update.py": {
      "path": "tests/managers/test_agent_manager_block_update.py",
      "contentHash": "e8ac6c9e2b34095a37ce5bdeecf34a57",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "test_modify_nonexistent_block_raises_error",
          "signature": "def test_modify_nonexistent_block_raises_error(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that modifying a non-existent block raises NoResultFound instead of\n    silently updating the wrong block.\n\n    Regression test for bug where `block = block` was a no-op, causing the loop\n    variable to end as the last block in core_memory, which then got incorrectly updated.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 15,
          "end_line": 73,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406664
    },
    "tests/managers/test_agent_tag_manager.py": {
      "path": "tests/managers/test_agent_tag_manager.py",
      "contentHash": "fdd41e2f8dcfaad68feda49550efc9a2",
      "mtime": 1767315072128.5476,
      "functions": [
        {
          "name": "test_list_agents_matching_all_tags",
          "signature": "def test_list_agents_matching_all_tags(server: SyncServer, default_user, agent_with_tags)",
          "parameters": "(server: SyncServer, default_user, agent_with_tags)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 111,
          "end_line": 118,
          "is_async": true
        },
        {
          "name": "test_list_agents_matching_some_tags",
          "signature": "def test_list_agents_matching_some_tags(server: SyncServer, default_user, agent_with_tags)",
          "parameters": "(server: SyncServer, default_user, agent_with_tags)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 122,
          "end_line": 129,
          "is_async": true
        },
        {
          "name": "test_list_agents_matching_all_and_some_tags",
          "signature": "def test_list_agents_matching_all_and_some_tags(server: SyncServer, default_user, agent_with_tags)",
          "parameters": "(server: SyncServer, default_user, agent_with_tags)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 133,
          "end_line": 140,
          "is_async": true
        },
        {
          "name": "test_list_agents_matching_no_tags",
          "signature": "def test_list_agents_matching_no_tags(server: SyncServer, default_user, agent_with_tags)",
          "parameters": "(server: SyncServer, default_user, agent_with_tags)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 144,
          "end_line": 150,
          "is_async": true
        },
        {
          "name": "test_list_agents_by_tags_match_all",
          "signature": "def test_list_agents_by_tags_match_all(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing agents that have ALL specified tags.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 154,
          "end_line": 170,
          "is_async": true
        },
        {
          "name": "test_list_agents_by_tags_match_any",
          "signature": "def test_list_agents_by_tags_match_any(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing agents that have ANY of the specified tags.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 174,
          "end_line": 190,
          "is_async": true
        },
        {
          "name": "test_list_agents_by_tags_no_matches",
          "signature": "def test_list_agents_by_tags_no_matches(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing agents when no tags match.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 194,
          "end_line": 205,
          "is_async": true
        },
        {
          "name": "test_list_agents_by_tags_with_other_filters",
          "signature": "def test_list_agents_by_tags_with_other_filters(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": "Test combining tag search with other filters.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 209,
          "end_line": 224,
          "is_async": true
        },
        {
          "name": "test_list_agents_by_tags_pagination",
          "signature": "def test_list_agents_by_tags_pagination(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test pagination when listing agents by tags.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 228,
          "end_line": 284,
          "is_async": true
        },
        {
          "name": "test_list_agents_query_text_pagination",
          "signature": "def test_list_agents_query_text_pagination(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test listing agents with query text filtering and pagination.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 288,
          "end_line": 371,
          "is_async": true
        },
        {
          "name": "test_list_tags",
          "signature": "def test_list_tags(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test listing tags functionality.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 375,
          "end_line": 427,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406665
    },
    "tests/managers/test_archive_manager.py": {
      "path": "tests/managers/test_archive_manager.py",
      "contentHash": "08e51eb0bf96720bed5523707c5baa69",
      "mtime": 1767315072128.5476,
      "functions": [
        {
          "name": "test_archive_manager_delete_archive_async",
          "signature": "def test_archive_manager_delete_archive_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test the delete_archive_async function.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 109,
          "end_line": 124,
          "is_async": true
        },
        {
          "name": "test_archive_manager_get_agents_for_archive_async",
          "signature": "def test_archive_manager_get_agents_for_archive_async(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test getting all agents that have access to an archive.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 128,
          "end_line": 166,
          "is_async": true
        },
        {
          "name": "test_archive_manager_race_condition_handling",
          "signature": "def test_archive_manager_race_condition_handling(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test that the race condition fix in get_or_create_default_archive_for_agent_async works.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 170,
          "end_line": 236,
          "is_async": true
        },
        {
          "name": "test_archive_manager_get_agent_from_passage_async",
          "signature": "def test_archive_manager_get_agent_from_passage_async(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test getting the agent ID that owns a passage through its archive.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 240,
          "end_line": 280,
          "is_async": true
        },
        {
          "name": "test_archive_manager_create_archive_async",
          "signature": "def test_archive_manager_create_archive_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test creating a new archive with various parameters.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 284,
          "end_line": 307,
          "is_async": true
        },
        {
          "name": "test_archive_manager_get_archive_by_id_async",
          "signature": "def test_archive_manager_get_archive_by_id_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test retrieving an archive by its ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 311,
          "end_line": 331,
          "is_async": true
        },
        {
          "name": "test_archive_manager_update_archive_async",
          "signature": "def test_archive_manager_update_archive_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test updating archive name and description.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 335,
          "end_line": 372,
          "is_async": true
        },
        {
          "name": "test_archive_manager_list_archives_async",
          "signature": "def test_archive_manager_list_archives_async(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test listing archives with various filters and pagination.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 376,
          "end_line": 418,
          "is_async": true
        },
        {
          "name": "test_archive_manager_attach_agent_to_archive_async",
          "signature": "def test_archive_manager_attach_agent_to_archive_async(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test attaching agents to archives with ownership settings.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 422,
          "end_line": 475,
          "is_async": true
        },
        {
          "name": "test_archive_manager_detach_agent_from_archive_async",
          "signature": "def test_archive_manager_detach_agent_from_archive_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test detaching agents from archives.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 479,
          "end_line": 554,
          "is_async": true
        },
        {
          "name": "test_archive_manager_attach_detach_idempotency",
          "signature": "def test_archive_manager_attach_detach_idempotency(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that attach and detach operations are idempotent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 558,
          "end_line": 617,
          "is_async": true
        },
        {
          "name": "test_archive_manager_detach_with_multiple_archives",
          "signature": "def test_archive_manager_detach_with_multiple_archives(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test detaching an agent from one archive doesn't affect others.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 621,
          "end_line": 688,
          "is_async": true
        },
        {
          "name": "test_archive_manager_detach_deleted_agent",
          "signature": "def test_archive_manager_detach_deleted_agent(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test behavior when detaching a deleted agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 692,
          "end_line": 730,
          "is_async": true
        },
        {
          "name": "test_archive_manager_cascade_delete_on_archive_deletion",
          "signature": "def test_archive_manager_cascade_delete_on_archive_deletion(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that deleting an archive cascades to delete relationships in archives_agents table.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 734,
          "end_line": 811,
          "is_async": true
        },
        {
          "name": "test_archive_manager_list_agents_with_pagination",
          "signature": "def test_archive_manager_list_agents_with_pagination(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test listing agents for an archive with pagination support.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 815,
          "end_line": 878,
          "is_async": true
        },
        {
          "name": "test_archive_manager_get_default_archive_for_agent_async",
          "signature": "def test_archive_manager_get_default_archive_for_agent_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test getting default archive for an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 882,
          "end_line": 917,
          "is_async": true
        },
        {
          "name": "test_archive_manager_get_or_set_vector_db_namespace_async",
          "signature": "def test_archive_manager_get_or_set_vector_db_namespace_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test getting or setting vector database namespace for an archive.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 921,
          "end_line": 940,
          "is_async": true
        },
        {
          "name": "test_archive_manager_get_agents_with_include_parameter",
          "signature": "def test_archive_manager_get_agents_with_include_parameter(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test getting agents for an archive with include parameter to load relationships.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 944,
          "end_line": 1008,
          "is_async": true
        },
        {
          "name": "test_archive_manager_delete_passage_from_archive_async",
          "signature": "def test_archive_manager_delete_passage_from_archive_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test deleting a passage from an archive.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1012,
          "end_line": 1066,
          "is_async": true
        },
        {
          "name": "test_archive_manager_delete_passage_from_wrong_archive",
          "signature": "def test_archive_manager_delete_passage_from_wrong_archive(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that deleting a passage from the wrong archive raises an error.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1070,
          "end_line": 1103,
          "is_async": true
        },
        {
          "name": "test_archive_manager_delete_nonexistent_passage",
          "signature": "def test_archive_manager_delete_nonexistent_passage(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that deleting a non-existent passage raises an error.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1107,
          "end_line": 1122,
          "is_async": true
        },
        {
          "name": "test_archive_manager_delete_passage_from_nonexistent_archive",
          "signature": "def test_archive_manager_delete_passage_from_nonexistent_archive(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that deleting a passage from a non-existent archive raises an error.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1126,
          "end_line": 1157,
          "is_async": true
        },
        {
          "name": "test_archive_manager_create_passage_in_archive_async",
          "signature": "def test_archive_manager_create_passage_in_archive_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test creating a passage in an archive.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1161,
          "end_line": 1192,
          "is_async": true
        },
        {
          "name": "test_archive_manager_create_passage_with_metadata_and_tags",
          "signature": "def test_archive_manager_create_passage_with_metadata_and_tags(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test creating a passage with metadata and tags.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1196,
          "end_line": 1228,
          "is_async": true
        },
        {
          "name": "test_archive_manager_create_passage_in_nonexistent_archive",
          "signature": "def test_archive_manager_create_passage_in_nonexistent_archive(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that creating a passage in a non-existent archive raises an error.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1232,
          "end_line": 1242,
          "is_async": true
        },
        {
          "name": "test_archive_manager_create_passage_inherits_embedding_config",
          "signature": "def test_archive_manager_create_passage_inherits_embedding_config(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that created passages inherit the archive's embedding configuration.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1246,
          "end_line": 1272,
          "is_async": true
        },
        {
          "name": "test_archive_manager_create_multiple_passages_in_archive",
          "signature": "def test_archive_manager_create_multiple_passages_in_archive(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test creating multiple passages in the same archive.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1276,
          "end_line": 1307,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406665
    },
    "tests/managers/test_block_manager.py": {
      "path": "tests/managers/test_block_manager.py",
      "contentHash": "b1d1e49c264914e0fd0649b40dd8a388",
      "mtime": 1767315072128.5476,
      "functions": [
        {
          "name": "test_attach_block",
          "signature": "def test_attach_block(server: SyncServer, sarah_agent, default_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_block, default_user)",
          "return_type": null,
          "docstring": "Test attaching a block to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 110,
          "end_line": 119,
          "is_async": true
        },
        {
          "name": "test_attach_block_duplicate_label",
          "signature": "def test_attach_block_duplicate_label(server: SyncServer, sarah_agent, default_block, other_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_block, other_block, default_user)",
          "return_type": null,
          "docstring": "Test attempting to attach a block with a duplicate label.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 124,
          "end_line": 135,
          "is_async": true
        },
        {
          "name": "test_detach_block",
          "signature": "def test_detach_block(server: SyncServer, sarah_agent, default_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_block, default_user)",
          "return_type": null,
          "docstring": "Test detaching a block by ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 139,
          "end_line": 153,
          "is_async": true
        },
        {
          "name": "test_detach_nonexistent_block",
          "signature": "def test_detach_nonexistent_block(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test detaching a block that isn't attached.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 157,
          "end_line": 160,
          "is_async": true
        },
        {
          "name": "test_update_block_label",
          "signature": "def test_update_block_label(server: SyncServer, sarah_agent, default_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_block, default_user)",
          "return_type": null,
          "docstring": "Test updating a block's label updates the relationship.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 164,
          "end_line": 177,
          "is_async": true
        },
        {
          "name": "test_update_block_label_multiple_agents",
          "signature": "def test_update_block_label_multiple_agents(server: SyncServer, sarah_agent, charles_agent, default_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_block, default_user)",
          "return_type": null,
          "docstring": "Test updating a block's label updates relationships for all agents.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 181,
          "end_line": 196,
          "is_async": true
        },
        {
          "name": "test_get_block_with_label",
          "signature": "def test_get_block_with_label(server: SyncServer, sarah_agent, default_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_block, default_user)",
          "return_type": null,
          "docstring": "Test retrieving a block by its label.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 200,
          "end_line": 211,
          "is_async": true
        },
        {
          "name": "test_refresh_memory_async",
          "signature": "def test_refresh_memory_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 215,
          "end_line": 253,
          "is_async": true
        },
        {
          "name": "test_create_block",
          "signature": "def test_create_block(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 262,
          "end_line": 285,
          "is_async": true
        },
        {
          "name": "test_batch_create_blocks_async",
          "signature": "def test_batch_create_blocks_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test batch creating multiple blocks at once",
          "decorators": [],
          "start_line": 288,
          "end_line": 349,
          "is_async": true
        },
        {
          "name": "test_get_blocks",
          "signature": "def test_get_blocks(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 353,
          "end_line": 370,
          "is_async": true
        },
        {
          "name": "test_get_blocks_comprehensive",
          "signature": "def test_get_blocks_comprehensive(server, default_user, other_user_different_org)",
          "parameters": "(server, default_user, other_user_different_org)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 374,
          "end_line": 426,
          "is_async": true
        },
        {
          "name": "test_update_block",
          "signature": "def test_update_block(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 430,
          "end_line": 443,
          "is_async": true
        },
        {
          "name": "test_update_block_limit",
          "signature": "def test_update_block_limit(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 447,
          "end_line": 466,
          "is_async": true
        },
        {
          "name": "test_update_block_limit_does_not_reset",
          "signature": "def test_update_block_limit_does_not_reset(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 470,
          "end_line": 484,
          "is_async": true
        },
        {
          "name": "test_update_nonexistent_block",
          "signature": "def test_update_nonexistent_block(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that updating a non-existent block raises NoResultFound (which maps to 404).",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 488,
          "end_line": 497,
          "is_async": true
        },
        {
          "name": "test_delete_block",
          "signature": "def test_delete_block(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 501,
          "end_line": 510,
          "is_async": true
        },
        {
          "name": "test_delete_block_detaches_from_agent",
          "signature": "def test_delete_block_detaches_from_agent(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 514,
          "end_line": 533,
          "is_async": true
        },
        {
          "name": "test_get_agents_for_block",
          "signature": "def test_get_agents_for_block(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 537,
          "end_line": 556,
          "is_async": true
        },
        {
          "name": "test_batch_create_multiple_blocks",
          "signature": "def test_batch_create_multiple_blocks(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 560,
          "end_line": 586,
          "is_async": true
        },
        {
          "name": "test_bulk_update_skips_missing_and_truncates_then_returns_none",
          "signature": "def test_bulk_update_skips_missing_and_truncates_then_returns_none(server: SyncServer, default_user: PydanticUser, caplog)",
          "parameters": "(server: SyncServer, default_user: PydanticUser, caplog)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 589,
          "end_line": 617,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406665
    },
    "tests/managers/test_cancellation.py": {
      "path": "tests/managers/test_cancellation.py",
      "contentHash": "909e7e31db34780843064c9e9ff90975",
      "mtime": 1767315072132.5479,
      "functions": [
        {
          "name": "test_agent_with_tool",
          "signature": "def test_agent_with_tool(server: SyncServer, default_user, print_tool)",
          "parameters": "(server: SyncServer, default_user, print_tool)",
          "return_type": null,
          "docstring": "Create a test agent with letta_v1_agent type (uses LettaAgentV3).",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 29,
          "end_line": 43,
          "is_async": true
        },
        {
          "name": "test_run",
          "signature": "def test_run(server: SyncServer, default_user, test_agent_with_tool)",
          "parameters": "(server: SyncServer, default_user, test_agent_with_tool)",
          "return_type": null,
          "docstring": "Create a test run for cancellation testing.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 47,
          "end_line": 56,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406666
    },
    "tests/managers/test_conversation_manager.py": {
      "path": "tests/managers/test_conversation_manager.py",
      "contentHash": "db8d265d88ccabc83f6021d5c5f7f16a",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "conversation_manager",
          "signature": "def conversation_manager()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Create a ConversationManager instance.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 18,
          "end_line": 20,
          "is_async": false
        },
        {
          "name": "test_create_conversation",
          "signature": "def test_create_conversation(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test creating a conversation.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 24,
          "end_line": 35,
          "is_async": true
        },
        {
          "name": "test_create_conversation_no_summary",
          "signature": "def test_create_conversation_no_summary(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test creating a conversation without summary.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 39,
          "end_line": 49,
          "is_async": true
        },
        {
          "name": "test_get_conversation_by_id",
          "signature": "def test_get_conversation_by_id(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test retrieving a conversation by ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 53,
          "end_line": 70,
          "is_async": true
        },
        {
          "name": "test_get_conversation_not_found",
          "signature": "def test_get_conversation_not_found(conversation_manager, server: SyncServer, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test retrieving a non-existent conversation raises error.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 74,
          "end_line": 80,
          "is_async": true
        },
        {
          "name": "test_list_conversations",
          "signature": "def test_list_conversations(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing conversations for an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 84,
          "end_line": 100,
          "is_async": true
        },
        {
          "name": "test_list_conversations_with_limit",
          "signature": "def test_list_conversations_with_limit(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing conversations with a limit.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 104,
          "end_line": 121,
          "is_async": true
        },
        {
          "name": "test_update_conversation",
          "signature": "def test_update_conversation(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test updating a conversation.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 125,
          "end_line": 142,
          "is_async": true
        },
        {
          "name": "test_delete_conversation",
          "signature": "def test_delete_conversation(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test soft deleting a conversation.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 146,
          "end_line": 166,
          "is_async": true
        },
        {
          "name": "test_conversation_isolation_by_agent",
          "signature": "def test_conversation_isolation_by_agent(conversation_manager, server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": "Test that conversations are isolated by agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 170,
          "end_line": 200,
          "is_async": true
        },
        {
          "name": "test_conversation_isolation_by_organization",
          "signature": "def test_conversation_isolation_by_organization(\n    conversation_manager, server: SyncServer, sarah_agent, default_user, other_user_different_org\n)",
          "parameters": "(\n    conversation_manager, server: SyncServer, sarah_agent, default_user, other_user_different_org\n)",
          "return_type": null,
          "docstring": "Test that conversations are isolated by organization.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 204,
          "end_line": 220,
          "is_async": true
        },
        {
          "name": "test_add_messages_to_conversation",
          "signature": "def test_add_messages_to_conversation(\n    conversation_manager, server: SyncServer, sarah_agent, default_user, hello_world_message_fixture\n)",
          "parameters": "(\n    conversation_manager, server: SyncServer, sarah_agent, default_user, hello_world_message_fixture\n)",
          "return_type": null,
          "docstring": "Test adding messages to a conversation.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 229,
          "end_line": 255,
          "is_async": true
        },
        {
          "name": "test_get_messages_for_conversation",
          "signature": "def test_get_messages_for_conversation(\n    conversation_manager, server: SyncServer, sarah_agent, default_user, hello_world_message_fixture\n)",
          "parameters": "(\n    conversation_manager, server: SyncServer, sarah_agent, default_user, hello_world_message_fixture\n)",
          "return_type": null,
          "docstring": "Test getting full message objects from a conversation.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 259,
          "end_line": 285,
          "is_async": true
        },
        {
          "name": "test_message_ordering_in_conversation",
          "signature": "def test_message_ordering_in_conversation(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that messages maintain their order in a conversation.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 289,
          "end_line": 329,
          "is_async": true
        },
        {
          "name": "test_update_in_context_messages",
          "signature": "def test_update_in_context_messages(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test updating which messages are in context.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 333,
          "end_line": 383,
          "is_async": true
        },
        {
          "name": "test_empty_conversation_message_ids",
          "signature": "def test_empty_conversation_message_ids(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test getting message IDs from an empty conversation.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 387,
          "end_line": 402,
          "is_async": true
        },
        {
          "name": "test_list_conversation_messages",
          "signature": "def test_list_conversation_messages(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing messages from a conversation as LettaMessages.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 406,
          "end_line": 454,
          "is_async": true
        },
        {
          "name": "test_list_conversation_messages_pagination",
          "signature": "def test_list_conversation_messages_pagination(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(conversation_manager, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test pagination when listing conversation messages.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 458,
          "end_line": 506,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406666
    },
    "tests/managers/test_file_manager.py": {
      "path": "tests/managers/test_file_manager.py",
      "contentHash": "d57d36d95815984d21bc25f83d1e196b",
      "mtime": 1767315072132.5479,
      "functions": [
        {
          "name": "test_attach_creates_association",
          "signature": "def test_attach_creates_association(server, default_user, sarah_agent, default_file)",
          "parameters": "(server, default_user, sarah_agent, default_file)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 111,
          "end_line": 130,
          "is_async": true
        },
        {
          "name": "test_attach_is_idempotent",
          "signature": "def test_attach_is_idempotent(server, default_user, sarah_agent, default_file)",
          "parameters": "(server, default_user, sarah_agent, default_file)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 133,
          "end_line": 164,
          "is_async": true
        },
        {
          "name": "test_update_file_agent",
          "signature": "def test_update_file_agent(server, file_attachment, default_user)",
          "parameters": "(server, file_attachment, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 167,
          "end_line": 176,
          "is_async": true
        },
        {
          "name": "test_update_file_agent_by_file_name",
          "signature": "def test_update_file_agent_by_file_name(server, file_attachment, default_user)",
          "parameters": "(server, file_attachment, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 179,
          "end_line": 190,
          "is_async": true
        },
        {
          "name": "test_file_agent_line_tracking",
          "signature": "def test_file_agent_line_tracking(server, default_user, sarah_agent, default_source)",
          "parameters": "(server, default_user, sarah_agent, default_source)",
          "return_type": null,
          "docstring": "Test that line information is captured when opening files with line ranges",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 194,
          "end_line": 253,
          "is_async": true
        },
        {
          "name": "test_mark_access",
          "signature": "def test_mark_access(server, file_attachment, default_user)",
          "parameters": "(server, file_attachment, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 256,
          "end_line": 273,
          "is_async": true
        },
        {
          "name": "test_list_files_and_agents",
          "signature": "def test_list_files_and_agents(\n    server,\n    default_user,\n    sarah_agent,\n    charles_agent,\n    default_file,\n    another_file,\n)",
          "parameters": "(\n    server,\n    default_user,\n    sarah_agent,\n    charles_agent,\n    default_file,\n    another_file,\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 276,
          "end_line": 333,
          "is_async": true
        },
        {
          "name": "ist_files_for_agent_paginated_basic(\n    ",
          "signature": "def ist_files_for_agent_paginated_basic(\n    server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    ",
          "parameters": "server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    ",
          "return_type": null,
          "docstring": "t basic pagination functionality.\"\"\"\n    #",
          "decorators": [
            "t.mark.asyncio\nasync"
          ],
          "start_line": 337,
          "end_line": 385,
          "is_async": true
        },
        {
          "name": "ist_files_for_agent_paginated_filter_open(\n    ",
          "signature": "def ist_files_for_agent_paginated_filter_open(\n    server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    ",
          "parameters": "server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    ",
          "return_type": null,
          "docstring": "t pagination with is_open=True filter.\"\"\"\n    #",
          "decorators": [
            "t.mark.asyncio\nasync"
          ],
          "start_line": 389,
          "end_line": 423,
          "is_async": true
        },
        {
          "name": "ist_files_for_agent_paginated_filter_closed(\n    ",
          "signature": "def ist_files_for_agent_paginated_filter_closed(\n    server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    ",
          "parameters": "server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    ",
          "return_type": null,
          "docstring": "t pagination with is_open=False filter.\"\"\"\n    #",
          "decorators": [
            "t.mark.asyncio\nasync"
          ],
          "start_line": 427,
          "end_line": 473,
          "is_async": true
        },
        {
          "name": "ist_files_for_agent_paginated_empty(\n    ",
          "signature": "def ist_files_for_agent_paginated_empty(\n    server,\n    default_user,\n    charles_agent,\n):\n    ",
          "parameters": "server,\n    default_user,\n    charles_agent,\n):\n    ",
          "return_type": null,
          "docstring": "t pagination with agent that has no files.\"\"\"\n    #",
          "decorators": [
            "t.mark.asyncio\nasync"
          ],
          "start_line": 477,
          "end_line": 491,
          "is_async": true
        },
        {
          "name": "ist_files_for_agent_paginated_large_limit(\n    ",
          "signature": "def ist_files_for_agent_paginated_large_limit(\n    server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    ",
          "parameters": "server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    ",
          "return_type": null,
          "docstring": "t that large limit returns all files without pagination.\"\"\"\n    #",
          "decorators": [
            "t.mark.asyncio\nasync"
          ],
          "start_line": 495,
          "end_line": 527,
          "is_async": true
        },
        {
          "name": "etach_file(serve",
          "signature": "def etach_file(server, file_attachment, default_user):\n    ",
          "parameters": "r, file_attachment, default_user):\n    ",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "t.mark.asyncio\nasync"
          ],
          "start_line": 531,
          "end_line": 542,
          "is_async": true
        },
        {
          "name": "etach_file_bulk(\n    ",
          "signature": "def etach_file_bulk(\n    server,\n    default_user,\n    sarah_agent,\n    charles_agent,\n    default_source,\n):\n    ",
          "parameters": "server,\n    default_user,\n    sarah_agent,\n    charles_agent,\n    default_source,\n):\n    ",
          "return_type": null,
          "docstring": "t bulk deletion of multiple agent-file associations.\"\"\"\n    #",
          "decorators": [],
          "start_line": 545,
          "end_line": 630,
          "is_async": true
        },
        {
          "name": "rg_scoping(\n    ",
          "signature": "def rg_scoping(\n    server,\n    default_user,\n    other_user_different_org,\n    sarah_agent,\n    default_file,\n):\n    ",
          "parameters": "server,\n    default_user,\n    other_user_different_org,\n    sarah_agent,\n    default_file,\n):\n    ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 633,
          "end_line": 654,
          "is_async": true
        },
        {
          "name": "ark_access_bulk(serve",
          "signature": "def ark_access_bulk(server, default_user, sarah_agent, default_source):\n    ",
          "parameters": "r, default_user, sarah_agent, default_source):\n    ",
          "return_type": null,
          "docstring": "t that mark_access_bulk updates last_accessed_at for multiple files.\"\"\"\n    i",
          "decorators": [],
          "start_line": 662,
          "end_line": 711,
          "is_async": true
        },
        {
          "name": "ru_eviction_on_attach(serve",
          "signature": "def ru_eviction_on_attach(server, default_user, sarah_agent, default_source):\n    ",
          "parameters": "r, default_user, sarah_agent, default_source):\n    ",
          "return_type": null,
          "docstring": "t that attaching files beyond max_files_open triggers LRU eviction.\"\"\"\n    i",
          "decorators": [],
          "start_line": 714,
          "end_line": 780,
          "is_async": true
        },
        {
          "name": "ru_eviction_on_open_file(serve",
          "signature": "def ru_eviction_on_open_file(server, default_user, sarah_agent, default_source):\n    ",
          "parameters": "r, default_user, sarah_agent, default_source):\n    ",
          "return_type": null,
          "docstring": "t that opening a file beyond max_files_open triggers LRU eviction.\"\"\"\n    i",
          "decorators": [],
          "start_line": 783,
          "end_line": 868,
          "is_async": true
        },
        {
          "name": "ru_no_eviction_when_reopening_same_file(serve",
          "signature": "def ru_no_eviction_when_reopening_same_file(server, default_user, sarah_agent, default_source):\n    ",
          "parameters": "r, default_user, sarah_agent, default_source):\n    ",
          "return_type": null,
          "docstring": "t that reopening an already open file doesn't trigger unnecessary eviction.\"\"\"\n    i",
          "decorators": [],
          "start_line": 871,
          "end_line": 932,
          "is_async": true
        },
        {
          "name": "ast_accessed_at_updates_correctly(serve",
          "signature": "def ast_accessed_at_updates_correctly(server, default_user, sarah_agent, default_source):\n    ",
          "parameters": "r, default_user, sarah_agent, default_source):\n    ",
          "return_type": null,
          "docstring": "t that last_accessed_at is updated in the correct scenarios.\"\"\"\n    i",
          "decorators": [],
          "start_line": 935,
          "end_line": 982,
          "is_async": true
        },
        {
          "name": "ttach_files_bulk_basic(serve",
          "signature": "def ttach_files_bulk_basic(server, default_user, sarah_agent, default_source):\n    ",
          "parameters": "r, default_user, sarah_agent, default_source):\n    ",
          "return_type": null,
          "docstring": "t basic functionality of attach_files_bulk method.\"\"\"\n    #",
          "decorators": [],
          "start_line": 985,
          "end_line": 1026,
          "is_async": true
        },
        {
          "name": "ttach_files_bulk_deduplication(serve",
          "signature": "def ttach_files_bulk_deduplication(server, default_user, sarah_agent, default_source):\n    ",
          "parameters": "r, default_user, sarah_agent, default_source):\n    ",
          "return_type": null,
          "docstring": "t that attach_files_bulk properly deduplicates files with same names.\"\"\"\n    #",
          "decorators": [],
          "start_line": 1029,
          "end_line": 1064,
          "is_async": true
        },
        {
          "name": "ttach_files_bulk_lru_eviction(serve",
          "signature": "def ttach_files_bulk_lru_eviction(server, default_user, sarah_agent, default_source):\n    ",
          "parameters": "r, default_user, sarah_agent, default_source):\n    ",
          "return_type": null,
          "docstring": "t that attach_files_bulk properly handles LRU eviction without duplicates.\"\"\"\n    i",
          "decorators": [],
          "start_line": 1067,
          "end_line": 1143,
          "is_async": true
        },
        {
          "name": "ttach_files_bulk_mixed_existing_new(serve",
          "signature": "def ttach_files_bulk_mixed_existing_new(server, default_user, sarah_agent, default_source):\n    ",
          "parameters": "r, default_user, sarah_agent, default_source):\n    ",
          "return_type": null,
          "docstring": "t bulk attach with mix of existing and new files.\"\"\"\n    #",
          "decorators": [],
          "start_line": 1146,
          "end_line": 1208,
          "is_async": true
        },
        {
          "name": "ttach_files_bulk_empty_list(serve",
          "signature": "def ttach_files_bulk_empty_list(server, default_user, sarah_agent):\n    ",
          "parameters": "r, default_user, sarah_agent):\n    ",
          "return_type": null,
          "docstring": "t attach_files_bulk with empty file list.\"\"\"\n    c",
          "decorators": [],
          "start_line": 1211,
          "end_line": 1223,
          "is_async": true
        },
        {
          "name": "ttach_files_bulk_oversized_bulk(serve",
          "signature": "def ttach_files_bulk_oversized_bulk(server, default_user, sarah_agent, default_source):\n    ",
          "parameters": "r, default_user, sarah_agent, default_source):\n    ",
          "return_type": null,
          "docstring": "t bulk attach when trying to attach more files than max_files_open allows.\"\"\"\n    m",
          "decorators": [],
          "start_line": 1226,
          "end_line": 1268,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406667
    },
    "tests/managers/test_group_manager.py": {
      "path": "tests/managers/test_group_manager.py",
      "contentHash": "d8f00ae73e625f575c0f425c8ec4cc18",
      "mtime": 1767315072132.5479,
      "functions": [
        {
          "name": "test_create_internal_template_objects",
          "signature": "def test_create_internal_template_objects(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test creating agents, groups, and blocks with template-related fields.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 106,
          "end_line": 176,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406667
    },
    "tests/managers/test_identity_manager.py": {
      "path": "tests/managers/test_identity_manager.py",
      "contentHash": "22274e1e5c1834e52e156c785212f8c0",
      "mtime": 1767315072132.5479,
      "functions": [
        {
          "name": "test_create_and_upsert_identity",
          "signature": "def test_create_and_upsert_identity(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 110,
          "end_line": 148,
          "is_async": true
        },
        {
          "name": "test_get_identities",
          "signature": "def test_get_identities(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 151,
          "end_line": 173,
          "is_async": true
        },
        {
          "name": "test_update_identity",
          "signature": "def test_update_identity(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 177,
          "end_line": 201,
          "is_async": true
        },
        {
          "name": "test_attach_detach_identity_from_agent",
          "signature": "def test_attach_detach_identity_from_agent(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 205,
          "end_line": 226,
          "is_async": true
        },
        {
          "name": "test_get_set_agents_for_identities",
          "signature": "def test_get_set_agents_for_identities(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 230,
          "end_line": 293,
          "is_async": true
        },
        {
          "name": "test_upsert_properties",
          "signature": "def test_upsert_properties(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 297,
          "end_line": 322,
          "is_async": true
        },
        {
          "name": "test_attach_detach_identity_from_block",
          "signature": "def test_attach_detach_identity_from_block(server: SyncServer, default_block, default_user)",
          "parameters": "(server: SyncServer, default_block, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 326,
          "end_line": 346,
          "is_async": true
        },
        {
          "name": "test_get_set_blocks_for_identities",
          "signature": "def test_get_set_blocks_for_identities(server: SyncServer, default_block, default_user)",
          "parameters": "(server: SyncServer, default_block, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 350,
          "end_line": 399,
          "is_async": true
        },
        {
          "name": "test_upsert_properties",
          "signature": "def test_upsert_properties(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 402,
          "end_line": 427,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406667
    },
    "tests/managers/test_job_manager.py": {
      "path": "tests/managers/test_job_manager.py",
      "contentHash": "5712c7676022130d09c9064b28829c7a",
      "mtime": 1767315072132.5479,
      "functions": [
        {
          "name": "test_create_job",
          "signature": "def test_create_job(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test creating a job.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 110,
          "end_line": 122,
          "is_async": true
        },
        {
          "name": "test_get_job_by_id",
          "signature": "def test_get_job_by_id(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test fetching a job by ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 126,
          "end_line": 141,
          "is_async": true
        },
        {
          "name": "test_list_jobs",
          "signature": "def test_list_jobs(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test listing jobs.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 145,
          "end_line": 161,
          "is_async": true
        },
        {
          "name": "test_list_jobs_with_metadata",
          "signature": "def test_list_jobs_with_metadata(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 165,
          "end_line": 171,
          "is_async": true
        },
        {
          "name": "test_update_job_by_id",
          "signature": "def test_update_job_by_id(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test updating a job by its ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 175,
          "end_line": 192,
          "is_async": true
        },
        {
          "name": "test_delete_job_by_id",
          "signature": "def test_delete_job_by_id(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test deleting a job by its ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 196,
          "end_line": 210,
          "is_async": true
        },
        {
          "name": "test_update_job_auto_complete",
          "signature": "def test_update_job_auto_complete(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that updating a job's status to 'completed' automatically sets completed_at.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 214,
          "end_line": 229,
          "is_async": true
        },
        {
          "name": "test_get_job_not_found",
          "signature": "def test_get_job_not_found(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test fetching a non-existent job.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 233,
          "end_line": 237,
          "is_async": true
        },
        {
          "name": "test_delete_job_not_found",
          "signature": "def test_delete_job_not_found(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test deleting a non-existent job.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 241,
          "end_line": 245,
          "is_async": true
        },
        {
          "name": "test_list_jobs_pagination",
          "signature": "def test_list_jobs_pagination(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test listing jobs with pagination.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 249,
          "end_line": 299,
          "is_async": true
        },
        {
          "name": "test_list_jobs_by_status",
          "signature": "def test_list_jobs_by_status(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test listing jobs filtered by status.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 303,
          "end_line": 336,
          "is_async": true
        },
        {
          "name": "test_list_jobs_filter_by_type",
          "signature": "def test_list_jobs_filter_by_type(server: SyncServer, default_user, default_job)",
          "parameters": "(server: SyncServer, default_user, default_job)",
          "return_type": null,
          "docstring": "Test that list_jobs correctly filters by job_type.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 340,
          "end_line": 358,
          "is_async": true
        },
        {
          "name": "test_e2e_job_callback",
          "signature": "def test_e2e_job_callback(monkeypatch, server: SyncServer, default_user)",
          "parameters": "(monkeypatch, server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that job callbacks are properly dispatched when a job is completed.",
          "decorators": [],
          "start_line": 361,
          "end_line": 407,
          "is_async": true
        },
        {
          "name": "test_record_ttft",
          "signature": "def test_record_ttft(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test recording time to first token for a job.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 416,
          "end_line": 431,
          "is_async": true
        },
        {
          "name": "test_record_response_duration",
          "signature": "def test_record_response_duration(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test recording total response duration for a job.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 435,
          "end_line": 450,
          "is_async": true
        },
        {
          "name": "test_record_timing_metrics_together",
          "signature": "def test_record_timing_metrics_together(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test recording both TTFT and response duration for a job.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 454,
          "end_line": 473,
          "is_async": true
        },
        {
          "name": "test_record_timing_invalid_job",
          "signature": "def test_record_timing_invalid_job(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test recording timing metrics for non-existent job raises LettaInvalidArgumentError.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 477,
          "end_line": 485,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406667
    },
    "tests/managers/test_mcp_manager.py": {
      "path": "tests/managers/test_mcp_manager.py",
      "contentHash": "7020e16f95d0d51534eb38beccd6a22b",
      "mtime": 1767315072132.5479,
      "functions": [
        {
          "name": "test_create_mcp_server",
          "signature": "def test_create_mcp_server(mock_get_client, server, default_user)",
          "parameters": "(mock_get_client, server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@patch(\"letta.services.mcp_manager.MCPManager.get_mcp_client\")"
          ],
          "start_line": 111,
          "end_line": 196,
          "is_async": true
        },
        {
          "name": "test_create_mcp_server_with_tools",
          "signature": "def test_create_mcp_server_with_tools(mock_get_client, server, default_user)",
          "parameters": "(mock_get_client, server, default_user)",
          "return_type": null,
          "docstring": "Test that creating an MCP server automatically syncs and persists its tools.",
          "decorators": [
            "@patch(\"letta.services.mcp_manager.MCPManager.get_mcp_client\")"
          ],
          "start_line": 200,
          "end_line": 320,
          "is_async": true
        },
        {
          "name": "test_complex_schema_normalization",
          "signature": "def test_complex_schema_normalization(mock_get_client, server, default_user)",
          "parameters": "(mock_get_client, server, default_user)",
          "return_type": null,
          "docstring": "Test that complex MCP schemas with nested objects are normalized and accepted.",
          "decorators": [
            "@pytest.mark.asyncio",
            "@patch(\"letta.services.mcp_manager.MCPManager.get_mcp_client\")"
          ],
          "start_line": 325,
          "end_line": 503,
          "is_async": true
        },
        {
          "name": "test_create_mcp_server_with_tools_connection_failure",
          "signature": "def test_create_mcp_server_with_tools_connection_failure(mock_get_client, server, default_user)",
          "parameters": "(mock_get_client, server, default_user)",
          "return_type": null,
          "docstring": "Test that MCP server creation succeeds even when tool sync fails (optimistic approach).",
          "decorators": [
            "@patch(\"letta.services.mcp_manager.MCPManager.get_mcp_client\")"
          ],
          "start_line": 507,
          "end_line": 552,
          "is_async": true
        },
        {
          "name": "test_get_mcp_servers_by_ids",
          "signature": "def test_get_mcp_servers_by_ids(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 555,
          "end_line": 629,
          "is_async": true
        },
        {
          "name": "test_mcp_server_deletion_cascades_oauth_sessions",
          "signature": "def test_mcp_server_deletion_cascades_oauth_sessions(server, default_organization, default_user)",
          "parameters": "(server, default_organization, default_user)",
          "return_type": null,
          "docstring": "Deleting an MCP server deletes associated OAuth sessions (same user + URL).",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 634,
          "end_line": 672,
          "is_async": true
        },
        {
          "name": "test_oauth_sessions_with_different_url_persist",
          "signature": "def test_oauth_sessions_with_different_url_persist(server, default_organization, default_user)",
          "parameters": "(server, default_organization, default_user)",
          "return_type": null,
          "docstring": "Sessions with different URL should not be deleted when deleting the server for another URL.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 676,
          "end_line": 711,
          "is_async": true
        },
        {
          "name": "test_mcp_server_creation_links_orphaned_sessions",
          "signature": "def test_mcp_server_creation_links_orphaned_sessions(server, default_organization, default_user)",
          "parameters": "(server, default_organization, default_user)",
          "return_type": null,
          "docstring": "Creating a server should link any existing orphaned sessions (same user + URL).",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 715,
          "end_line": 755,
          "is_async": true
        },
        {
          "name": "test_mcp_server_delete_removes_all_sessions_for_url_and_user",
          "signature": "def test_mcp_server_delete_removes_all_sessions_for_url_and_user(server, default_organization, default_user)",
          "parameters": "(server, default_organization, default_user)",
          "return_type": null,
          "docstring": "Deleting a server removes both linked and orphaned sessions for same user+URL.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 759,
          "end_line": 792,
          "is_async": true
        },
        {
          "name": "test_mcp_server_resync_tools",
          "signature": "def test_mcp_server_resync_tools(server, default_user, default_organization)",
          "parameters": "(server, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test that resyncing MCP server tools correctly handles added, deleted, and updated tools.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 796,
          "end_line": 903,
          "is_async": true
        },
        {
          "name": "encryption_key",
          "signature": "def encryption_key()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to ensure encryption key is set for tests.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 912,
          "end_line": 920,
          "is_async": false
        },
        {
          "name": "test_mcp_server_token_encryption_on_create",
          "signature": "def test_mcp_server_token_encryption_on_create(server, default_user, encryption_key)",
          "parameters": "(server, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that creating an MCP server encrypts the token in the database.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 924,
          "end_line": 970,
          "is_async": true
        },
        {
          "name": "test_mcp_server_token_decryption_on_read",
          "signature": "def test_mcp_server_token_decryption_on_read(server, default_user, encryption_key)",
          "parameters": "(server, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that reading an MCP server decrypts the token correctly.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 974,
          "end_line": 1010,
          "is_async": true
        },
        {
          "name": "test_mcp_server_custom_headers_encryption",
          "signature": "def test_mcp_server_custom_headers_encryption(server, default_user, encryption_key)",
          "parameters": "(server, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that custom headers are encrypted as JSON strings.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1014,
          "end_line": 1076,
          "is_async": true
        },
        {
          "name": "test_oauth_session_tokens_encryption",
          "signature": "def test_oauth_session_tokens_encryption(server, default_user, encryption_key)",
          "parameters": "(server, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that OAuth session tokens are encrypted in the database.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1080,
          "end_line": 1142,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406667
    },
    "tests/managers/test_message_manager.py": {
      "path": "tests/managers/test_message_manager.py",
      "contentHash": "e7dafabb124a06ac5a1c26b83a524ab4",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "test_reset_messages_no_messages",
          "signature": "def test_reset_messages_no_messages(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that resetting messages on an agent clears message_ids to only system message,\n    but messages remain in the database.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 110,
          "end_line": 123,
          "is_async": true
        },
        {
          "name": "test_reset_messages_default_messages",
          "signature": "def test_reset_messages_default_messages(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that resetting messages with add_default_initial_messages=True\n    clears context and adds new default messages, while old messages remain in database.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 127,
          "end_line": 146,
          "is_async": true
        },
        {
          "name": "test_reset_messages_with_existing_messages",
          "signature": "def test_reset_messages_with_existing_messages(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that resetting messages on an agent with actual messages\n    clears message_ids but keeps messages in the database.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 150,
          "end_line": 193,
          "is_async": true
        },
        {
          "name": "test_reset_messages_idempotency",
          "signature": "def test_reset_messages_idempotency(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that calling reset_messages multiple times has no adverse effect.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 197,
          "end_line": 224,
          "is_async": true
        },
        {
          "name": "test_reset_messages_preserves_system_message_id",
          "signature": "def test_reset_messages_preserves_system_message_id(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that resetting messages preserves the original system message ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 228,
          "end_line": 257,
          "is_async": true
        },
        {
          "name": "test_reset_messages_preserves_system_message_content",
          "signature": "def test_reset_messages_preserves_system_message_content(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that resetting messages preserves the original system message content.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 261,
          "end_line": 292,
          "is_async": true
        },
        {
          "name": "test_modify_letta_message",
          "signature": "def test_modify_letta_message(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test updating a message.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 296,
          "end_line": 360,
          "is_async": true
        },
        {
          "name": "test_message_create",
          "signature": "def test_message_create(server: SyncServer, hello_world_message_fixture, default_user)",
          "parameters": "(server: SyncServer, hello_world_message_fixture, default_user)",
          "return_type": null,
          "docstring": "Test creating a message using hello_world_message_fixture fixture",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 364,
          "end_line": 378,
          "is_async": true
        },
        {
          "name": "test_message_get_by_id",
          "signature": "def test_message_get_by_id(server: SyncServer, hello_world_message_fixture, default_user)",
          "parameters": "(server: SyncServer, hello_world_message_fixture, default_user)",
          "return_type": null,
          "docstring": "Test retrieving a message by ID",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 382,
          "end_line": 387,
          "is_async": true
        },
        {
          "name": "test_message_update",
          "signature": "def test_message_update(server: SyncServer, hello_world_message_fixture, default_user, other_user)",
          "parameters": "(server: SyncServer, hello_world_message_fixture, default_user, other_user)",
          "return_type": null,
          "docstring": "Test updating a message",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 391,
          "end_line": 404,
          "is_async": true
        },
        {
          "name": "test_message_delete",
          "signature": "def test_message_delete(server: SyncServer, hello_world_message_fixture, default_user)",
          "parameters": "(server: SyncServer, hello_world_message_fixture, default_user)",
          "return_type": null,
          "docstring": "Test deleting a message",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 408,
          "end_line": 412,
          "is_async": true
        },
        {
          "name": "test_message_conversation_id_persistence",
          "signature": "def test_message_conversation_id_persistence(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that conversation_id is properly persisted and retrieved from DB to Pydantic object",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 416,
          "end_line": 465,
          "is_async": true
        },
        {
          "name": "test_message_size",
          "signature": "def test_message_size(server: SyncServer, hello_world_message_fixture, default_user)",
          "parameters": "(server: SyncServer, hello_world_message_fixture, default_user)",
          "return_type": null,
          "docstring": "Test counting messages with filters",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 469,
          "end_line": 499,
          "is_async": true
        },
        {
          "name": "create_test_messages",
          "signature": "def create_test_messages(server: SyncServer, base_message: PydanticMessage, default_user) -> list[PydanticMessage]",
          "parameters": "(server: SyncServer, base_message: PydanticMessage, default_user)",
          "return_type": "list[PydanticMessage]",
          "docstring": "Helper function to create test messages for all tests",
          "decorators": [],
          "start_line": 502,
          "end_line": 513,
          "is_async": true
        },
        {
          "name": "test_get_messages_by_ids",
          "signature": "def test_get_messages_by_ids(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test basic message listing with limit",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 517,
          "end_line": 523,
          "is_async": true
        },
        {
          "name": "test_message_listing_basic",
          "signature": "def test_message_listing_basic(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test basic message listing with limit",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 527,
          "end_line": 532,
          "is_async": true
        },
        {
          "name": "test_message_listing_cursor",
          "signature": "def test_message_listing_cursor(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test cursor-based pagination functionality",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 536,
          "end_line": 571,
          "is_async": true
        },
        {
          "name": "test_message_listing_filtering",
          "signature": "def test_message_listing_filtering(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test filtering messages by agent ID",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 575,
          "end_line": 581,
          "is_async": true
        },
        {
          "name": "test_message_listing_text_search",
          "signature": "def test_message_listing_text_search(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test searching messages by text content",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 585,
          "end_line": 599,
          "is_async": true
        },
        {
          "name": "test_create_many_messages_async_basic",
          "signature": "def test_create_many_messages_async_basic(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test basic batch creation of messages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 603,
          "end_line": 625,
          "is_async": true
        },
        {
          "name": "test_create_many_messages_async_allow_partial_false",
          "signature": "def test_create_many_messages_async_allow_partial_false(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that allow_partial=False (default) fails on duplicate IDs",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 629,
          "end_line": 651,
          "is_async": true
        },
        {
          "name": "test_create_many_messages_async_allow_partial_true_some_duplicates",
          "signature": "def test_create_many_messages_async_allow_partial_true_some_duplicates(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that allow_partial=True handles partial duplicates correctly",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 655,
          "end_line": 695,
          "is_async": true
        },
        {
          "name": "test_create_many_messages_async_allow_partial_true_all_duplicates",
          "signature": "def test_create_many_messages_async_allow_partial_true_all_duplicates(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that allow_partial=True handles all duplicates correctly",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 699,
          "end_line": 730,
          "is_async": true
        },
        {
          "name": "test_create_many_messages_async_empty_list",
          "signature": "def test_create_many_messages_async_empty_list(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that empty list returns empty list",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 734,
          "end_line": 740,
          "is_async": true
        },
        {
          "name": "test_check_existing_message_ids",
          "signature": "def test_check_existing_message_ids(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test the check_existing_message_ids convenience function",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 744,
          "end_line": 767,
          "is_async": true
        },
        {
          "name": "test_filter_existing_messages",
          "signature": "def test_filter_existing_messages(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test the filter_existing_messages helper function",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 771,
          "end_line": 817,
          "is_async": true
        },
        {
          "name": "test_create_many_messages_async_with_turbopuffer",
          "signature": "def test_create_many_messages_async_with_turbopuffer(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test batch creation with turbopuffer embedding (if enabled)",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 821,
          "end_line": 841,
          "is_async": true
        },
        {
          "name": "test_convert_tool_call_messages_no_assistant_mode",
          "signature": "def test_convert_tool_call_messages_no_assistant_mode(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that when assistant mode is off, all tool calls go into a single ToolCallMessage",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 850,
          "end_line": 894,
          "is_async": true
        },
        {
          "name": "test_convert_tool_call_messages_with_assistant_mode",
          "signature": "def test_convert_tool_call_messages_with_assistant_mode(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that with assistant mode, send_message becomes AssistantMessage and others are grouped",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 898,
          "end_line": 944,
          "is_async": true
        },
        {
          "name": "test_convert_tool_call_messages_multiple_non_assistant_tools",
          "signature": "def test_convert_tool_call_messages_multiple_non_assistant_tools(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that multiple non-assistant tools are batched together until assistant tool is reached",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 948,
          "end_line": 994,
          "is_async": true
        },
        {
          "name": "test_convert_single_tool_call_both_fields",
          "signature": "def test_convert_single_tool_call_both_fields(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that a single tool call is written to both tool_call and tool_calls fields",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 998,
          "end_line": 1040,
          "is_async": true
        },
        {
          "name": "test_convert_tool_calls_only_assistant_tools",
          "signature": "def test_convert_tool_calls_only_assistant_tools(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that only send_message tools are converted to AssistantMessages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1044,
          "end_line": 1074,
          "is_async": true
        },
        {
          "name": "test_convert_assistant_message_with_dict_content",
          "signature": "def test_convert_assistant_message_with_dict_content(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that send_message with dict content is properly serialized to JSON string\n\n    Regression test for bug where dict content like {'tofu': 1, 'mofu': 1, 'bofu': 1}\n    caused pydantic validation error because AssistantMessage.content expects a string.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1078,
          "end_line": 1141,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406667
    },
    "tests/managers/test_organization_manager.py": {
      "path": "tests/managers/test_organization_manager.py",
      "contentHash": "caf5d60c133af6e76dc871bfb1666964",
      "mtime": 1767315072136.548,
      "functions": [
        {
          "name": "test_list_organizations",
          "signature": "def test_list_organizations(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 109,
          "end_line": 121,
          "is_async": true
        },
        {
          "name": "test_create_default_organization",
          "signature": "def test_create_default_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 125,
          "end_line": 128,
          "is_async": true
        },
        {
          "name": "test_update_organization_name",
          "signature": "def test_update_organization_name(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 132,
          "end_line": 138,
          "is_async": true
        },
        {
          "name": "test_update_organization_privileged_tools",
          "signature": "def test_update_organization_privileged_tools(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 142,
          "end_line": 147,
          "is_async": true
        },
        {
          "name": "test_list_organizations_pagination",
          "signature": "def test_list_organizations_pagination(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 151,
          "end_line": 163,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406668
    },
    "tests/managers/test_passage_manager.py": {
      "path": "tests/managers/test_passage_manager.py",
      "contentHash": "b1dc301aebb0edc85aa783a4c29fc8a7",
      "mtime": 1767315072136.548,
      "functions": [
        {
          "name": "test_agent_list_passages_basic",
          "signature": "def test_agent_list_passages_basic(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test basic listing functionality of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 110,
          "end_line": 117,
          "is_async": true
        },
        {
          "name": "test_agent_list_passages_ordering",
          "signature": "def test_agent_list_passages_ordering(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test ordering of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 121,
          "end_line": 134,
          "is_async": true
        },
        {
          "name": "test_agent_list_passages_pagination",
          "signature": "def test_agent_list_passages_pagination(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test pagination of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 138,
          "end_line": 175,
          "is_async": true
        },
        {
          "name": "test_agent_list_passages_text_search",
          "signature": "def test_agent_list_passages_text_search(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test text search functionality of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 179,
          "end_line": 192,
          "is_async": true
        },
        {
          "name": "test_agent_list_passages_agent_only",
          "signature": "def test_agent_list_passages_agent_only(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test text search functionality of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 196,
          "end_line": 201,
          "is_async": true
        },
        {
          "name": "test_agent_list_passages_filtering",
          "signature": "def test_agent_list_passages_filtering(server, default_user, sarah_agent, default_source, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, default_source, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test filtering functionality of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 205,
          "end_line": 222,
          "is_async": true
        },
        {
          "name": "mock_embeddings",
          "signature": "def mock_embeddings()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Load mock embeddings from JSON file",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 226,
          "end_line": 230,
          "is_async": false
        },
        {
          "name": "mock_embed_model",
          "signature": "def mock_embed_model(mock_embeddings)",
          "parameters": "(mock_embeddings)",
          "return_type": null,
          "docstring": "Mock embedding model that returns predefined embeddings",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 234,
          "end_line": 238,
          "is_async": false
        },
        {
          "name": "test_agent_list_passages_vector_search",
          "signature": "def test_agent_list_passages_vector_search(\n    server, default_user, sarah_agent, default_source, default_file, mock_embed_model, disable_turbopuffer\n)",
          "parameters": "(\n    server, default_user, sarah_agent, default_source, default_file, mock_embed_model, disable_turbopuffer\n)",
          "return_type": null,
          "docstring": "Test vector search functionality of agent passages",
          "decorators": [],
          "start_line": 241,
          "end_line": 318,
          "is_async": true
        },
        {
          "name": "test_list_source_passages_only",
          "signature": "def test_list_source_passages_only(server: SyncServer, default_user, default_source, agent_passages_setup)",
          "parameters": "(server: SyncServer, default_user, default_source, agent_passages_setup)",
          "return_type": null,
          "docstring": "Test listing passages from a source without specifying an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 322,
          "end_line": 334,
          "is_async": true
        },
        {
          "name": "test_passage_create_agentic",
          "signature": "def test_passage_create_agentic(server: SyncServer, agent_passage_fixture, default_user)",
          "parameters": "(server: SyncServer, agent_passage_fixture, default_user)",
          "return_type": null,
          "docstring": "Test creating a passage using agent_passage_fixture fixture",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 343,
          "end_line": 355,
          "is_async": true
        },
        {
          "name": "test_passage_create_source",
          "signature": "def test_passage_create_source(server: SyncServer, source_passage_fixture, default_user)",
          "parameters": "(server: SyncServer, source_passage_fixture, default_user)",
          "return_type": null,
          "docstring": "Test creating a source passage.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 359,
          "end_line": 371,
          "is_async": true
        },
        {
          "name": "test_passage_create_invalid",
          "signature": "def test_passage_create_invalid(server: SyncServer, agent_passage_fixture, default_user)",
          "parameters": "(server: SyncServer, agent_passage_fixture, default_user)",
          "return_type": null,
          "docstring": "Test creating an agent passage.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 375,
          "end_line": 392,
          "is_async": true
        },
        {
          "name": "test_passage_get_by_id",
          "signature": "def test_passage_get_by_id(server: SyncServer, agent_passage_fixture, source_passage_fixture, default_user)",
          "parameters": "(server: SyncServer, agent_passage_fixture, source_passage_fixture, default_user)",
          "return_type": null,
          "docstring": "Test retrieving a passage by ID",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 396,
          "end_line": 406,
          "is_async": true
        },
        {
          "name": "test_passage_cascade_deletion",
          "signature": "def test_passage_cascade_deletion(\n    server: SyncServer, agent_passage_fixture, source_passage_fixture, default_user, default_source, sarah_agent\n)",
          "parameters": "(\n    server: SyncServer, agent_passage_fixture, source_passage_fixture, default_user, default_source, sarah_agent\n)",
          "return_type": null,
          "docstring": "Test that passages are deleted when their parent (agent or source) is deleted.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 410,
          "end_line": 423,
          "is_async": true
        },
        {
          "name": "test_create_agent_passage_specific",
          "signature": "def test_create_agent_passage_specific(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test creating an agent passage using the new agent-specific method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 427,
          "end_line": 449,
          "is_async": true
        },
        {
          "name": "test_create_source_passage_specific",
          "signature": "def test_create_source_passage_specific(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Test creating a source passage using the new source-specific method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 453,
          "end_line": 474,
          "is_async": true
        },
        {
          "name": "test_create_agent_passage_validation",
          "signature": "def test_create_agent_passage_validation(server: SyncServer, default_user, default_source, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, default_source, sarah_agent)",
          "return_type": null,
          "docstring": "Test that agent passage creation validates inputs correctly.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 478,
          "end_line": 507,
          "is_async": true
        },
        {
          "name": "test_create_source_passage_validation",
          "signature": "def test_create_source_passage_validation(server: SyncServer, default_user, default_file, default_source, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source, sarah_agent)",
          "return_type": null,
          "docstring": "Test that source passage creation validates inputs correctly.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 511,
          "end_line": 542,
          "is_async": true
        },
        {
          "name": "test_get_agent_passage_by_id_specific",
          "signature": "def test_get_agent_passage_by_id_specific(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test retrieving an agent passage using the new agent-specific method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 546,
          "end_line": 568,
          "is_async": true
        },
        {
          "name": "test_get_source_passage_by_id_specific",
          "signature": "def test_get_source_passage_by_id_specific(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Test retrieving a source passage using the new source-specific method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 572,
          "end_line": 593,
          "is_async": true
        },
        {
          "name": "test_get_wrong_passage_type_fails",
          "signature": "def test_get_wrong_passage_type_fails(server: SyncServer, default_user, sarah_agent, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, sarah_agent, default_file, default_source)",
          "return_type": null,
          "docstring": "Test that trying to get the wrong passage type with specific methods fails.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 597,
          "end_line": 634,
          "is_async": true
        },
        {
          "name": "test_update_agent_passage_specific",
          "signature": "def test_update_agent_passage_specific(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test updating an agent passage using the new agent-specific method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 638,
          "end_line": 670,
          "is_async": true
        },
        {
          "name": "test_update_source_passage_specific",
          "signature": "def test_update_source_passage_specific(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Test updating a source passage using the new source-specific method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 674,
          "end_line": 706,
          "is_async": true
        },
        {
          "name": "test_delete_agent_passage_specific",
          "signature": "def test_delete_agent_passage_specific(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test deleting an agent passage using the new agent-specific method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 710,
          "end_line": 737,
          "is_async": true
        },
        {
          "name": "test_delete_source_passage_specific",
          "signature": "def test_delete_source_passage_specific(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Test deleting a source passage using the new source-specific method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 741,
          "end_line": 767,
          "is_async": true
        },
        {
          "name": "test_create_many_agent_passages_async",
          "signature": "def test_create_many_agent_passages_async(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test creating multiple agent passages using the new batch method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 771,
          "end_line": 796,
          "is_async": true
        },
        {
          "name": "test_create_many_source_passages_async",
          "signature": "def test_create_many_source_passages_async(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Test creating multiple source passages using the new batch method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 800,
          "end_line": 822,
          "is_async": true
        },
        {
          "name": "test_agent_passage_size",
          "signature": "def test_agent_passage_size(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test counting agent passages using the new agent-specific size method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 826,
          "end_line": 847,
          "is_async": true
        },
        {
          "name": "test_passage_tags_functionality",
          "signature": "def test_passage_tags_functionality(disable_turbopuffer, server: SyncServer, default_user, sarah_agent)",
          "parameters": "(disable_turbopuffer, server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test comprehensive tag functionality for passages.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 851,
          "end_line": 913,
          "is_async": true
        },
        {
          "name": "test_comprehensive_tag_functionality",
          "signature": "def test_comprehensive_tag_functionality(disable_turbopuffer, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(disable_turbopuffer, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Comprehensive test for tag functionality including dual storage and junction table.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 917,
          "end_line": 1129,
          "is_async": true
        },
        {
          "name": "test_tag_edge_cases",
          "signature": "def test_tag_edge_cases(disable_turbopuffer, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(disable_turbopuffer, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test edge cases for tag functionality.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1133,
          "end_line": 1211,
          "is_async": true
        },
        {
          "name": "rch_agent_archival_memory_async(disable",
          "signature": "def rch_agent_archival_memory_async(disable_turbopuffer, server: SyncServer, default_user, sarah_agent):\n    \"\"",
          "parameters": "_turbopuffer, server: SyncServer, default_user, sarah_agent):\n    \"\"",
          "return_type": null,
          "docstring": "the search_agent_archival_memory_async method that powers both the agent tool and API endpoint.\"\"\"\n    # G",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 1215,
          "end_line": 1365,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406668
    },
    "tests/managers/test_provider_manager.py": {
      "path": "tests/managers/test_provider_manager.py",
      "contentHash": "372ab9fc2834c3fd3f4bc09bdfc9cafd",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "default_organization",
          "signature": "def default_organization()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 19,
          "end_line": 23,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(default_organization)",
          "parameters": "(default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 27,
          "end_line": 31,
          "is_async": true
        },
        {
          "name": "provider_manager",
          "signature": "def provider_manager()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to create and return a ProviderManager instance.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 35,
          "end_line": 37,
          "is_async": true
        },
        {
          "name": "encryption_key",
          "signature": "def encryption_key()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to ensure encryption key is set for tests.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 41,
          "end_line": 49,
          "is_async": false
        },
        {
          "name": "test_provider_create_encrypts_api_key",
          "signature": "def test_provider_create_encrypts_api_key(provider_manager, default_user, encryption_key)",
          "parameters": "(provider_manager, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that creating a provider encrypts the api_key and stores it in api_key_enc.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 58,
          "end_line": 90,
          "is_async": true
        },
        {
          "name": "test_provider_read_decrypts_api_key",
          "signature": "def test_provider_read_decrypts_api_key(provider_manager, default_user, encryption_key)",
          "parameters": "(provider_manager, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that reading a provider decrypts the api_key from api_key_enc.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 94,
          "end_line": 111,
          "is_async": true
        },
        {
          "name": "test_provider_update_encrypts_new_api_key",
          "signature": "def test_provider_update_encrypts_new_api_key(provider_manager, default_user, encryption_key)",
          "parameters": "(provider_manager, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that updating a provider's api_key encrypts the new value.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 115,
          "end_line": 147,
          "is_async": true
        },
        {
          "name": "test_bedrock_credentials_encryption",
          "signature": "def test_bedrock_credentials_encryption(provider_manager, default_user, encryption_key)",
          "parameters": "(provider_manager, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that Bedrock provider encrypts both access_key and api_key (secret_key).",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 151,
          "end_line": 189,
          "is_async": true
        },
        {
          "name": "test_provider_secret_not_exposed_in_logs",
          "signature": "def test_provider_secret_not_exposed_in_logs(provider_manager, default_user, encryption_key)",
          "parameters": "(provider_manager, default_user, encryption_key)",
          "return_type": null,
          "docstring": "Test that Secret objects don't expose plaintext in string representations.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 193,
          "end_line": 214,
          "is_async": true
        },
        {
          "name": "test_provider_pydantic_to_orm_serialization",
          "signature": "def test_provider_pydantic_to_orm_serialization(provider_manager, default_user, encryption_key)",
          "parameters": "(provider_manager, default_user, encryption_key)",
          "return_type": null,
          "docstring": "\"\"\"Test the full Pydantic  ORM  Pydantic round-trip maintains data integrity.\"\"\"",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 218,
          "end_line": 251,
          "is_async": true
        },
        {
          "name": "vider_with_none_api_key(provide",
          "signature": "def vider_with_none_api_key(provider_manager, default_user, encryption_key):\n    \"\"",
          "parameters": "r_manager, default_user, encryption_key):\n    \"\"",
          "return_type": null,
          "docstring": "that providers can be created with None api_key (some providers may not need it).\"\"\"\n    # C",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 255,
          "end_line": 281,
          "is_async": true
        },
        {
          "name": "t_providers_decrypts_all(provide",
          "signature": "def t_providers_decrypts_all(provider_manager, default_user, encryption_key):\n    \"\"",
          "parameters": "r_manager, default_user, encryption_key):\n    \"\"",
          "return_type": null,
          "docstring": "that listing multiple providers decrypts all their api_keys correctly.\"\"\"\n    # C",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 285,
          "end_line": 307,
          "is_async": true
        },
        {
          "name": "dle_to_llm_config_conversion(provide",
          "signature": "def dle_to_llm_config_conversion(provider_manager, default_user):\n    \"\"",
          "parameters": "r_manager, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "that handle to LLMConfig conversion works correctly with database lookup.\"\"\"\n    fro",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 316,
          "end_line": 392,
          "is_async": true
        },
        {
          "name": "k_provider_auto_syncs_models(provide",
          "signature": "def k_provider_auto_syncs_models(provider_manager, default_user, monkeypatch):\n    \"\"",
          "parameters": "r_manager, default_user, monkeypatch):\n    \"\"",
          "return_type": null,
          "docstring": "that creating a BYOK provider attempts to sync its models.\"\"\"\n    fro",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 396,
          "end_line": 486,
          "is_async": true
        },
        {
          "name": "ver_startup_syncs_base_providers(default",
          "signature": "def ver_startup_syncs_base_providers(default_user, default_organization, monkeypatch):\n    \"\"",
          "parameters": "_user, default_organization, monkeypatch):\n    \"\"",
          "return_type": null,
          "docstring": "that server startup properly syncs base provider models from environment.\n\n    This test simulates the server startup process and verifies that:\n    1. Base providers from environment variables are synced to database\n    2. Provider models are fetched from mocked API endpoints\n    3. Models are properly persisted to the database with correct metadata\n    4. Models can be retrieved using handles\n    \"\"\"\n    fro",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 495,
          "end_line": 734,
          "is_async": true
        },
        {
          "name": "ver_startup_handles_disabled_providers(default",
          "signature": "def ver_startup_handles_disabled_providers(default_user, default_organization, monkeypatch):\n    \"\"",
          "parameters": "_user, default_organization, monkeypatch):\n    \"\"",
          "return_type": null,
          "docstring": "that server startup properly handles providers that are no longer enabled.\n\n    This test verifies that:\n    1. Base providers that are no longer enabled (env vars removed) are deleted\n    2. BYOK providers that are no longer enabled are NOT deleted (user-created)\n    3. The sync process handles providers gracefully when API calls fail\n    \"\"\"\n    fro",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 738,
          "end_line": 822,
          "is_async": true
        },
        {
          "name": "ver_startup_handles_api_errors_gracefully(default",
          "signature": "def ver_startup_handles_api_errors_gracefully(default_user, default_organization, monkeypatch):\n    \"\"",
          "parameters": "_user, default_organization, monkeypatch):\n    \"\"",
          "return_type": null,
          "docstring": "that server startup handles API errors gracefully without crashing.\n\n    This test verifies that:\n    1. If a provider's API call fails during sync, it logs an error but continues\n    2. Other providers can still sync successfully\n    3. The server startup completes without crashing\n    \"\"\"\n    fro",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 826,
          "end_line": 921,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406668
    },
    "tests/managers/test_run_manager.py": {
      "path": "tests/managers/test_run_manager.py",
      "contentHash": "a310e830cf26a052ae4f13f2a4d3a551",
      "mtime": 1768610518546.2004,
      "functions": [
        {
          "name": "test_create_run",
          "signature": "def test_create_run(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test creating a run.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 110,
          "end_line": 123,
          "is_async": true
        },
        {
          "name": "test_get_run_by_id",
          "signature": "def test_get_run_by_id(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test fetching a run by ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 127,
          "end_line": 142,
          "is_async": true
        },
        {
          "name": "test_list_runs",
          "signature": "def test_list_runs(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing runs.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 146,
          "end_line": 162,
          "is_async": true
        },
        {
          "name": "test_list_runs_with_metadata",
          "signature": "def test_list_runs_with_metadata(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 166,
          "end_line": 178,
          "is_async": true
        },
        {
          "name": "test_update_run_by_id",
          "signature": "def test_update_run_by_id(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test updating a run by its ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 182,
          "end_line": 195,
          "is_async": true
        },
        {
          "name": "test_update_run_metadata_persistence",
          "signature": "def test_update_run_metadata_persistence(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that metadata is properly persisted when updating a run.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 199,
          "end_line": 234,
          "is_async": true
        },
        {
          "name": "test_update_run_updates_agent_last_stop_reason",
          "signature": "def test_update_run_updates_agent_last_stop_reason(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that completing a run updates the agent's last_stop_reason.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 238,
          "end_line": 269,
          "is_async": true
        },
        {
          "name": "test_delete_run_by_id",
          "signature": "def test_delete_run_by_id(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test deleting a run by its ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 273,
          "end_line": 292,
          "is_async": true
        },
        {
          "name": "test_update_run_auto_complete",
          "signature": "def test_update_run_auto_complete(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test that updating a run's status to 'completed' automatically sets completed_at.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 296,
          "end_line": 311,
          "is_async": true
        },
        {
          "name": "test_get_run_not_found",
          "signature": "def test_get_run_not_found(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test fetching a non-existent run.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 315,
          "end_line": 319,
          "is_async": true
        },
        {
          "name": "test_delete_run_not_found",
          "signature": "def test_delete_run_not_found(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test deleting a non-existent run.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 323,
          "end_line": 327,
          "is_async": true
        },
        {
          "name": "test_list_runs_pagination",
          "signature": "def test_list_runs_pagination(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing runs with pagination.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 331,
          "end_line": 370,
          "is_async": true
        },
        {
          "name": "test_list_runs_by_status",
          "signature": "def test_list_runs_by_status(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test listing runs filtered by status.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 374,
          "end_line": 410,
          "is_async": true
        },
        {
          "name": "test_list_runs_by_stop_reason",
          "signature": "def test_list_runs_by_stop_reason(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing runs by stop reason.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 414,
          "end_line": 440,
          "is_async": true
        },
        {
          "name": "test_list_runs_by_tools_used",
          "signature": "def test_list_runs_by_tools_used(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing runs filtered by tools used.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 444,
          "end_line": 530,
          "is_async": true
        },
        {
          "name": "test_list_runs_by_step_count",
          "signature": "def test_list_runs_by_step_count(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing runs filtered by step count.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 534,
          "end_line": 664,
          "is_async": true
        },
        {
          "name": "test_list_runs_by_base_template_id",
          "signature": "def test_list_runs_by_base_template_id(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing runs by template family.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 668,
          "end_line": 677,
          "is_async": true
        },
        {
          "name": "test_e2e_run_callback",
          "signature": "def test_e2e_run_callback(monkeypatch, server: SyncServer, default_user, sarah_agent)",
          "parameters": "(monkeypatch, server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test that run callbacks are properly dispatched when a run is completed.",
          "decorators": [],
          "start_line": 680,
          "end_line": 730,
          "is_async": true
        },
        {
          "name": "test_run_callback_only_on_terminal_status",
          "signature": "def test_run_callback_only_on_terminal_status(server: SyncServer, sarah_agent, default_user, monkeypatch)",
          "parameters": "(server: SyncServer, sarah_agent, default_user, monkeypatch)",
          "return_type": null,
          "docstring": "Regression: ensure a non-terminal update (running) does NOT set completed_at or trigger callback,\n    and that a subsequent terminal update (completed) does trigger the callback exactly once.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 734,
          "end_line": 801,
          "is_async": true
        },
        {
          "name": "test_run_messages_pagination",
          "signature": "def test_run_messages_pagination(server: SyncServer, default_run, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_run, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test pagination of run messages.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 810,
          "end_line": 919,
          "is_async": true
        },
        {
          "name": "test_run_messages_ordering",
          "signature": "def test_run_messages_ordering(server: SyncServer, default_run, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_run, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test that messages are ordered by created_at.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 923,
          "end_line": 969,
          "is_async": true
        },
        {
          "name": "test_job_messages_empty",
          "signature": "def test_job_messages_empty(server: SyncServer, default_run, default_user)",
          "parameters": "(server: SyncServer, default_run, default_user)",
          "return_type": null,
          "docstring": "Test getting messages for a job with no messages.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 973,
          "end_line": 979,
          "is_async": true
        },
        {
          "name": "test_job_messages_filter",
          "signature": "def test_job_messages_filter(server: SyncServer, default_run, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_run, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test getting messages associated with a job.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 983,
          "end_line": 1039,
          "is_async": true
        },
        {
          "name": "test_get_run_messages",
          "signature": "def test_get_run_messages(server: SyncServer, default_user: PydanticUser, sarah_agent)",
          "parameters": "(server: SyncServer, default_user: PydanticUser, sarah_agent)",
          "return_type": null,
          "docstring": "Test getting messages for a run with request config.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1043,
          "end_line": 1112,
          "is_async": true
        },
        {
          "name": "test_get_run_messages_with_assistant_message",
          "signature": "def test_get_run_messages_with_assistant_message(server: SyncServer, default_user: PydanticUser, sarah_agent)",
          "parameters": "(server: SyncServer, default_user: PydanticUser, sarah_agent)",
          "return_type": null,
          "docstring": "Test getting messages for a run with request config.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1116,
          "end_line": 1188,
          "is_async": true
        },
        {
          "name": "test_run_usage_stats_add_and_get",
          "signature": "def test_run_usage_stats_add_and_get(server: SyncServer, sarah_agent, default_run, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_run, default_user)",
          "return_type": null,
          "docstring": "Test adding and retrieving run usage statistics.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1197,
          "end_line": 1230,
          "is_async": true
        },
        {
          "name": "test_run_usage_stats_get_no_stats",
          "signature": "def test_run_usage_stats_get_no_stats(server: SyncServer, default_run, default_user)",
          "parameters": "(server: SyncServer, default_run, default_user)",
          "return_type": null,
          "docstring": "Test getting usage statistics for a job with no stats.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1234,
          "end_line": 1248,
          "is_async": true
        },
        {
          "name": "test_run_usage_stats_add_multiple",
          "signature": "def test_run_usage_stats_add_multiple(server: SyncServer, sarah_agent, default_run, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_run, default_user)",
          "return_type": null,
          "docstring": "Test adding multiple usage statistics entries for a job.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1252,
          "end_line": 1321,
          "is_async": true
        },
        {
          "name": "test_run_usage_stats_get_nonexistent_run",
          "signature": "def test_run_usage_stats_get_nonexistent_run(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test getting usage statistics for a nonexistent run.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1325,
          "end_line": 1330,
          "is_async": true
        },
        {
          "name": "test_get_run_request_config",
          "signature": "def test_get_run_request_config(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test getting request config from a run.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1334,
          "end_line": 1351,
          "is_async": true
        },
        {
          "name": "test_get_run_request_config_none",
          "signature": "def test_get_run_request_config_none(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test getting request config from a run with no config.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1355,
          "end_line": 1362,
          "is_async": true
        },
        {
          "name": "test_get_run_request_config_nonexistent_run",
          "signature": "def test_get_run_request_config_nonexistent_run(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test getting request config for a nonexistent run.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1366,
          "end_line": 1369,
          "is_async": true
        },
        {
          "name": "test_run_metrics_creation",
          "signature": "def test_run_metrics_creation(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that run metrics are created when a run is created.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1378,
          "end_line": 1400,
          "is_async": true
        },
        {
          "name": "test_run_metrics_timestamp_tracking",
          "signature": "def test_run_metrics_timestamp_tracking(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that run_start_ns is properly tracked.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1404,
          "end_line": 1426,
          "is_async": true
        },
        {
          "name": "test_run_metrics_duration_calculation",
          "signature": "def test_run_metrics_duration_calculation(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that run duration (run_ns) is calculated when run completes.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1430,
          "end_line": 1463,
          "is_async": true
        },
        {
          "name": "test_run_metrics_num_steps_tracking",
          "signature": "def test_run_metrics_num_steps_tracking(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that num_steps is properly tracked in run metrics.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1467,
          "end_line": 1508,
          "is_async": true
        },
        {
          "name": "test_run_metrics_not_found",
          "signature": "def test_run_metrics_not_found(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test getting metrics for non-existent run.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1512,
          "end_line": 1515,
          "is_async": true
        },
        {
          "name": "test_run_metrics_partial_update",
          "signature": "def test_run_metrics_partial_update(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that non-terminal updates don't calculate run_ns.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1519,
          "end_line": 1555,
          "is_async": true
        },
        {
          "name": "test_run_metrics_integration_with_run_steps",
          "signature": "def test_run_metrics_integration_with_run_steps(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test integration between run metrics and run steps.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1559,
          "end_line": 1606,
          "is_async": true
        },
        {
          "name": "test_convert_statuses_to_enum_with_none",
          "signature": "def test_convert_statuses_to_enum_with_none()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that convert_statuses_to_enum returns None when input is None.",
          "decorators": [],
          "start_line": 1688,
          "end_line": 1693,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_single_status",
          "signature": "def test_convert_statuses_to_enum_with_single_status()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test converting a single status string to RunStatus enum.",
          "decorators": [],
          "start_line": 1696,
          "end_line": 1702,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_multiple_statuses",
          "signature": "def test_convert_statuses_to_enum_with_multiple_statuses()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test converting multiple status strings to RunStatus enums.",
          "decorators": [],
          "start_line": 1705,
          "end_line": 1711,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_all_statuses",
          "signature": "def test_convert_statuses_to_enum_with_all_statuses()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test converting all possible status strings.",
          "decorators": [],
          "start_line": 1714,
          "end_line": 1721,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_empty_list",
          "signature": "def test_convert_statuses_to_enum_with_empty_list()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test converting an empty list.",
          "decorators": [],
          "start_line": 1724,
          "end_line": 1729,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_invalid_status",
          "signature": "def test_convert_statuses_to_enum_with_invalid_status()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that invalid status strings raise ValueError.",
          "decorators": [],
          "start_line": 1732,
          "end_line": 1737,
          "is_async": false
        },
        {
          "name": "test_list_runs_with_multiple_statuses",
          "signature": "def test_list_runs_with_multiple_statuses(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing runs with multiple status filters.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1741,
          "end_line": 1789,
          "is_async": true
        },
        {
          "name": "test_list_runs_with_no_status_filter_returns_all",
          "signature": "def test_list_runs_with_no_status_filter_returns_all(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that not providing statuses parameter returns all runs.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1793,
          "end_line": 1814,
          "is_async": true
        },
        {
          "name": "test_list_runs_by_duration_gt",
          "signature": "def test_list_runs_by_duration_gt(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing runs filtered by duration greater than a threshold.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1823,
          "end_line": 1874,
          "is_async": true
        },
        {
          "name": "test_list_runs_by_duration_lt",
          "signature": "def test_list_runs_by_duration_lt(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing runs filtered by duration less than a threshold.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1878,
          "end_line": 1921,
          "is_async": true
        },
        {
          "name": "test_list_runs_by_duration_percentile",
          "signature": "def test_list_runs_by_duration_percentile(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing runs filtered by duration percentile.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1925,
          "end_line": 1961,
          "is_async": true
        },
        {
          "name": "test_list_runs_by_duration_with_order_by",
          "signature": "def test_list_runs_by_duration_with_order_by(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing runs filtered by duration with different order_by options.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1965,
          "end_line": 2016,
          "is_async": true
        },
        {
          "name": "test_list_runs_combined_duration_filter_and_percentile",
          "signature": "def test_list_runs_combined_duration_filter_and_percentile(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test combining duration filter with percentile filter.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2020,
          "end_line": 2053,
          "is_async": true
        },
        {
          "name": "test_get_run_with_status_no_lettuce",
          "signature": "def test_get_run_with_status_no_lettuce(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test getting a run without Lettuce metadata.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2057,
          "end_line": 2072,
          "is_async": true
        },
        {
          "name": "test_get_run_with_status_lettuce_success",
          "signature": "def test_get_run_with_status_lettuce_success(server: SyncServer, sarah_agent, default_user, monkeypatch)",
          "parameters": "(server: SyncServer, sarah_agent, default_user, monkeypatch)",
          "return_type": null,
          "docstring": "Test getting a run with Lettuce metadata and successful status fetch.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2076,
          "end_line": 2101,
          "is_async": true
        },
        {
          "name": "test_get_run_with_status_lettuce_failure",
          "signature": "def test_get_run_with_status_lettuce_failure(server: SyncServer, sarah_agent, default_user, monkeypatch)",
          "parameters": "(server: SyncServer, sarah_agent, default_user, monkeypatch)",
          "return_type": null,
          "docstring": "Test getting a run when Lettuce status fetch fails.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2105,
          "end_line": 2126,
          "is_async": true
        },
        {
          "name": "test_get_run_with_status_lettuce_terminal_status",
          "signature": "def test_get_run_with_status_lettuce_terminal_status(server: SyncServer, sarah_agent, default_user, monkeypatch)",
          "parameters": "(server: SyncServer, sarah_agent, default_user, monkeypatch)",
          "return_type": null,
          "docstring": "Test that Lettuce status is not fetched for runs with terminal status.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2130,
          "end_line": 2155,
          "is_async": true
        },
        {
          "name": "test_get_run_with_status_not_found",
          "signature": "def test_get_run_with_status_not_found(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test getting a non-existent run with get_run_with_status.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2159,
          "end_line": 2164,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406669
    },
    "tests/managers/test_sandbox_manager.py": {
      "path": "tests/managers/test_sandbox_manager.py",
      "contentHash": "a217cd08864b7e40dddcd2320c9f0210",
      "mtime": 1768610518550.2007,
      "functions": [
        {
          "name": "test_create_or_update_sandbox_config",
          "signature": "def test_create_or_update_sandbox_config(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 110,
          "end_line": 119,
          "is_async": true
        },
        {
          "name": "test_create_local_sandbox_config_defaults",
          "signature": "def test_create_local_sandbox_config_defaults(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 123,
          "end_line": 133,
          "is_async": true
        },
        {
          "name": "test_default_e2b_settings_sandbox_config",
          "signature": "def test_default_e2b_settings_sandbox_config(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 137,
          "end_line": 145,
          "is_async": true
        },
        {
          "name": "test_update_existing_sandbox_config",
          "signature": "def test_update_existing_sandbox_config(server: SyncServer, sandbox_config_fixture, default_user)",
          "parameters": "(server: SyncServer, sandbox_config_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 149,
          "end_line": 157,
          "is_async": true
        },
        {
          "name": "test_delete_sandbox_config",
          "signature": "def test_delete_sandbox_config(server: SyncServer, sandbox_config_fixture, default_user)",
          "parameters": "(server: SyncServer, sandbox_config_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 161,
          "end_line": 169,
          "is_async": true
        },
        {
          "name": "test_get_sandbox_config_by_type",
          "signature": "def test_get_sandbox_config_by_type(server: SyncServer, sandbox_config_fixture, default_user)",
          "parameters": "(server: SyncServer, sandbox_config_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 173,
          "end_line": 178,
          "is_async": true
        },
        {
          "name": "test_list_sandbox_configs",
          "signature": "def test_list_sandbox_configs(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 182,
          "end_line": 214,
          "is_async": true
        },
        {
          "name": "test_create_sandbox_env_var",
          "signature": "def test_create_sandbox_env_var(server: SyncServer, sandbox_config_fixture, default_user)",
          "parameters": "(server: SyncServer, sandbox_config_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 223,
          "end_line": 232,
          "is_async": true
        },
        {
          "name": "test_update_sandbox_env_var",
          "signature": "def test_update_sandbox_env_var(server: SyncServer, sandbox_env_var_fixture, default_user)",
          "parameters": "(server: SyncServer, sandbox_env_var_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 236,
          "end_line": 244,
          "is_async": true
        },
        {
          "name": "test_delete_sandbox_env_var",
          "signature": "def test_delete_sandbox_env_var(server: SyncServer, sandbox_config_fixture, sandbox_env_var_fixture, default_user)",
          "parameters": "(server: SyncServer, sandbox_config_fixture, sandbox_env_var_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 248,
          "end_line": 258,
          "is_async": true
        },
        {
          "name": "test_list_sandbox_env_vars",
          "signature": "def test_list_sandbox_env_vars(server: SyncServer, sandbox_config_fixture, default_user)",
          "parameters": "(server: SyncServer, sandbox_config_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 262,
          "end_line": 291,
          "is_async": true
        },
        {
          "name": "test_get_sandbox_env_var_by_key",
          "signature": "def test_get_sandbox_env_var_by_key(server: SyncServer, sandbox_env_var_fixture, default_user)",
          "parameters": "(server: SyncServer, sandbox_env_var_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 295,
          "end_line": 301,
          "is_async": true
        },
        {
          "name": "test_gather_env_vars_layering",
          "signature": "def test_gather_env_vars_layering(server: SyncServer, sandbox_config_fixture, default_user)",
          "parameters": "(server: SyncServer, sandbox_config_fixture, default_user)",
          "return_type": null,
          "docstring": "Test that _gather_env_vars properly layers env vars with correct priority.\n\n    Priority order (later overrides earlier):\n    1. Global sandbox env vars from DB (always included)\n    2. Provided sandbox env vars (agent-scoped, override global on key collision)\n    3. Agent state env vars\n    4. Additional runtime env vars (highest priority)",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 305,
          "end_line": 390,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406669
    },
    "tests/managers/test_source_manager.py": {
      "path": "tests/managers/test_source_manager.py",
      "contentHash": "a9d7bf1385328ad1f5cdf26832ee98b9",
      "mtime": 1767315072136.548,
      "functions": [
        {
          "name": "test_attach_source",
          "signature": "def test_attach_source(server: SyncServer, sarah_agent, default_source, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_source, default_user)",
          "return_type": null,
          "docstring": "Test attaching a source to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 118,
          "end_line": 130,
          "is_async": true
        },
        {
          "name": "test_list_attached_source_ids",
          "signature": "def test_list_attached_source_ids(server: SyncServer, sarah_agent, default_source, other_source, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_source, other_source, default_user)",
          "return_type": null,
          "docstring": "Test listing source IDs attached to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 134,
          "end_line": 149,
          "is_async": true
        },
        {
          "name": "test_detach_source",
          "signature": "def test_detach_source(server: SyncServer, sarah_agent, default_source, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_source, default_user)",
          "return_type": null,
          "docstring": "Test detaching a source from an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 153,
          "end_line": 170,
          "is_async": true
        },
        {
          "name": "test_attach_source_nonexistent_agent",
          "signature": "def test_attach_source_nonexistent_agent(server: SyncServer, default_source, default_user)",
          "parameters": "(server: SyncServer, default_source, default_user)",
          "return_type": null,
          "docstring": "Test attaching a source to a nonexistent agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 174,
          "end_line": 177,
          "is_async": true
        },
        {
          "name": "test_attach_source_nonexistent_source",
          "signature": "def test_attach_source_nonexistent_source(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test attaching a nonexistent source to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 181,
          "end_line": 184,
          "is_async": true
        },
        {
          "name": "test_detach_source_nonexistent_agent",
          "signature": "def test_detach_source_nonexistent_agent(server: SyncServer, default_source, default_user)",
          "parameters": "(server: SyncServer, default_source, default_user)",
          "return_type": null,
          "docstring": "Test detaching a source from a nonexistent agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 188,
          "end_line": 191,
          "is_async": true
        },
        {
          "name": "test_list_attached_source_ids_nonexistent_agent",
          "signature": "def test_list_attached_source_ids_nonexistent_agent(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test listing sources for a nonexistent agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 195,
          "end_line": 198,
          "is_async": true
        },
        {
          "name": "test_list_attached_agents",
          "signature": "def test_list_attached_agents(server: SyncServer, sarah_agent, charles_agent, default_source, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_source, default_user)",
          "return_type": null,
          "docstring": "Test listing agents that have a particular source attached.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 202,
          "end_line": 232,
          "is_async": true
        },
        {
          "name": "test_list_attached_agents_nonexistent_source",
          "signature": "def test_list_attached_agents_nonexistent_source(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test listing agents for a nonexistent source.",
          "decorators": [],
          "start_line": 235,
          "end_line": 238,
          "is_async": true
        },
        {
          "name": "test_get_agents_for_source_id_pagination",
          "signature": "def test_get_agents_for_source_id_pagination(server: SyncServer, default_source, default_user)",
          "parameters": "(server: SyncServer, default_source, default_user)",
          "return_type": null,
          "docstring": "Test pagination functionality of get_agents_for_source_id.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 242,
          "end_line": 325,
          "is_async": true
        },
        {
          "name": "test_get_existing_source_names",
          "signature": "def test_get_existing_source_names(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test the fast batch check for existing source names.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 334,
          "end_line": 383,
          "is_async": true
        },
        {
          "name": "test_create_source",
          "signature": "def test_create_source(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test creating a new source.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 387,
          "end_line": 401,
          "is_async": true
        },
        {
          "name": "test_source_vector_db_provider_with_tpuf",
          "signature": "def test_source_vector_db_provider_with_tpuf(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that vector_db_provider is correctly set based on should_use_tpuf.",
          "decorators": [],
          "start_line": 404,
          "end_line": 452,
          "is_async": true
        },
        {
          "name": "test_create_sources_with_same_name_raises_error",
          "signature": "def test_create_sources_with_same_name_raises_error(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that creating sources with the same name raises an IntegrityError due to unique constraint.",
          "decorators": [],
          "start_line": 455,
          "end_line": 474,
          "is_async": true
        },
        {
          "name": "test_update_source",
          "signature": "def test_update_source(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test updating an existing source.",
          "decorators": [],
          "start_line": 477,
          "end_line": 489,
          "is_async": true
        },
        {
          "name": "test_delete_source",
          "signature": "def test_delete_source(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test deleting a source.",
          "decorators": [],
          "start_line": 492,
          "end_line": 507,
          "is_async": true
        },
        {
          "name": "test_delete_attached_source",
          "signature": "def test_delete_attached_source(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test deleting a source.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 511,
          "end_line": 532,
          "is_async": true
        },
        {
          "name": "test_list_sources",
          "signature": "def test_list_sources(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test listing sources with pagination.",
          "decorators": [],
          "start_line": 535,
          "end_line": 558,
          "is_async": true
        },
        {
          "name": "test_get_source_by_id",
          "signature": "def test_get_source_by_id(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test retrieving a source by ID.",
          "decorators": [],
          "start_line": 561,
          "end_line": 574,
          "is_async": true
        },
        {
          "name": "test_get_source_by_name",
          "signature": "def test_get_source_by_name(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test retrieving a source by name.",
          "decorators": [],
          "start_line": 577,
          "end_line": 589,
          "is_async": true
        },
        {
          "name": "test_update_source_no_changes",
          "signature": "def test_update_source_no_changes(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test update_source with no actual changes to verify logging and response.",
          "decorators": [],
          "start_line": 592,
          "end_line": 604,
          "is_async": true
        },
        {
          "name": "test_bulk_upsert_sources_async",
          "signature": "def test_bulk_upsert_sources_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test bulk upserting sources.",
          "decorators": [],
          "start_line": 607,
          "end_line": 640,
          "is_async": true
        },
        {
          "name": "test_bulk_upsert_sources_name_conflict",
          "signature": "def test_bulk_upsert_sources_name_conflict(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test bulk upserting sources with name conflicts.",
          "decorators": [],
          "start_line": 643,
          "end_line": 686,
          "is_async": true
        },
        {
          "name": "test_bulk_upsert_sources_mixed_create_update",
          "signature": "def test_bulk_upsert_sources_mixed_create_update(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test bulk upserting with a mix of creates and updates.",
          "decorators": [],
          "start_line": 689,
          "end_line": 759,
          "is_async": true
        },
        {
          "name": "test_get_file_by_id",
          "signature": "def test_get_file_by_id(server: SyncServer, default_user, default_source)",
          "parameters": "(server: SyncServer, default_user, default_source)",
          "return_type": null,
          "docstring": "Test retrieving a file by ID.",
          "decorators": [],
          "start_line": 767,
          "end_line": 785,
          "is_async": true
        },
        {
          "name": "test_create_and_retrieve_file_with_content",
          "signature": "def test_create_and_retrieve_file_with_content(server, default_user, default_source, async_session)",
          "parameters": "(server, default_user, default_source, async_session)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 788,
          "end_line": 813,
          "is_async": true
        },
        {
          "name": "test_create_file_without_content",
          "signature": "def test_create_file_without_content(server, default_user, default_source, async_session)",
          "parameters": "(server, default_user, default_source, async_session)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 816,
          "end_line": 831,
          "is_async": true
        },
        {
          "name": "test_lazy_raise_guard",
          "signature": "def test_lazy_raise_guard(server, default_user, default_source, async_session)",
          "parameters": "(server, default_user, default_source, async_session)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 834,
          "end_line": 851,
          "is_async": true
        },
        {
          "name": "st_list_files_content_none(s",
          "signature": "def st_list_files_content_none(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 854,
          "end_line": 856,
          "is_async": true
        },
        {
          "name": "st_delete_cascades_to_content(s",
          "signature": "def st_delete_cascades_to_content(server, default_user, default_source, async_session):\n",
          "parameters": "erver, default_user, default_source, async_session):\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 859,
          "end_line": 877,
          "is_async": true
        },
        {
          "name": "st_get_file_by_original_name_and_source_found(s",
          "signature": "def st_get_file_by_original_name_and_source_found(server: SyncServer, default_user, default_source):\n",
          "parameters": "erver: SyncServer, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test retrieving a file by original filename and source when it exists.\"\"\"",
          "decorators": [],
          "start_line": 880,
          "end_line": 902,
          "is_async": true
        },
        {
          "name": "st_get_file_by_original_name_and_source_not_found(s",
          "signature": "def st_get_file_by_original_name_and_source_not_found(server: SyncServer, default_user, default_source):\n",
          "parameters": "erver: SyncServer, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test retrieving a file by original filename and source when it doesn't exist.\"\"\"",
          "decorators": [],
          "start_line": 905,
          "end_line": 915,
          "is_async": true
        },
        {
          "name": "st_get_file_by_original_name_and_source_different_sources(s",
          "signature": "def st_get_file_by_original_name_and_source_different_sources(server: SyncServer, default_user, default_source):\n",
          "parameters": "erver: SyncServer, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test that files with same original name in different sources are handled correctly.\"\"\"",
          "decorators": [],
          "start_line": 918,
          "end_line": 972,
          "is_async": true
        },
        {
          "name": "st_get_file_by_original_name_and_source_ignores_deleted(s",
          "signature": "def st_get_file_by_original_name_and_source_ignores_deleted(server: SyncServer, default_user, default_source):\n",
          "parameters": "erver: SyncServer, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test that deleted files are ignored when searching by original name and source.\"\"\"",
          "decorators": [],
          "start_line": 975,
          "end_line": 1004,
          "is_async": true
        },
        {
          "name": "st_list_files(s",
          "signature": "def st_list_files(server: SyncServer, default_user, default_source):\n",
          "parameters": "erver: SyncServer, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test listing files with pagination.\"\"\"",
          "decorators": [],
          "start_line": 1007,
          "end_line": 1032,
          "is_async": true
        },
        {
          "name": "st_delete_file(s",
          "signature": "def st_delete_file(server: SyncServer, default_user, default_source):\n",
          "parameters": "erver: SyncServer, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test deleting a file.\"\"\"",
          "decorators": [],
          "start_line": 1035,
          "end_line": 1050,
          "is_async": true
        },
        {
          "name": "st_update_file_status_basic(s",
          "signature": "def st_update_file_status_basic(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Update processing status and error message for a file.\"\"\"",
          "decorators": [],
          "start_line": 1053,
          "end_line": 1081,
          "is_async": true
        },
        {
          "name": "st_update_file_status_error_only(s",
          "signature": "def st_update_file_status_error_only(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Update just the error message, leave status unchanged.\"\"\"",
          "decorators": [],
          "start_line": 1084,
          "end_line": 1101,
          "is_async": true
        },
        {
          "name": "st_update_file_status_with_chunks(s",
          "signature": "def st_update_file_status_with_chunks(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Update chunk progress fields along with status.\"\"\"",
          "decorators": [],
          "start_line": 1104,
          "end_line": 1143,
          "is_async": true
        },
        {
          "name": "st_file_status_valid_transitions(s",
          "signature": "def st_file_status_valid_transitions(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test valid state transitions follow the expected flow.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 1147,
          "end_line": 1181,
          "is_async": true
        },
        {
          "name": "st_file_status_invalid_transitions(s",
          "signature": "def st_file_status_invalid_transitions(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test that invalid state transitions are blocked.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 1185,
          "end_line": 1241,
          "is_async": true
        },
        {
          "name": "st_file_status_terminal_states(s",
          "signature": "def st_file_status_terminal_states(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test that terminal states (COMPLETED and ERROR) cannot be updated.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 1245,
          "end_line": 1301,
          "is_async": true
        },
        {
          "name": "st_file_status_error_transitions(s",
          "signature": "def st_file_status_error_transitions(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test that any non-terminal state can transition to ERROR.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 1305,
          "end_line": 1369,
          "is_async": true
        },
        {
          "name": "st_file_status_terminal_state_non_status_updates(s",
          "signature": "def st_file_status_terminal_state_non_status_updates(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test that terminal states block ALL updates, not just status changes.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 1373,
          "end_line": 1435,
          "is_async": true
        },
        {
          "name": "st_file_status_race_condition_prevention(s",
          "signature": "def st_file_status_race_condition_prevention(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test that race conditions are prevented when multiple updates happen.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 1439,
          "end_line": 1481,
          "is_async": true
        },
        {
          "name": "st_file_status_backwards_transitions(s",
          "signature": "def st_file_status_backwards_transitions(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test that backwards transitions are not allowed.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 1485,
          "end_line": 1514,
          "is_async": true
        },
        {
          "name": "st_file_status_update_with_chunks_progress(s",
          "signature": "def st_file_status_update_with_chunks_progress(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test updating chunk progress during EMBEDDING state.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 1518,
          "end_line": 1565,
          "is_async": true
        },
        {
          "name": "st_same_state_transitions_allowed(s",
          "signature": "def st_same_state_transitions_allowed(server, default_user, default_source):\n",
          "parameters": "erver, default_user, default_source):\n",
          "return_type": null,
          "docstring": "\"Test that same-state transitions are allowed to prevent race conditions.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 1569,
          "end_line": 1602,
          "is_async": true
        },
        {
          "name": "st_upsert_file_content_basic(s",
          "signature": "def st_upsert_file_content_basic(server: SyncServer, default_user, default_source, async_session):\n",
          "parameters": "erver: SyncServer, default_user, default_source, async_session):\n",
          "return_type": null,
          "docstring": "\"Test creating and updating file content with upsert_file_content().\"\"\"",
          "decorators": [],
          "start_line": 1605,
          "end_line": 1647,
          "is_async": true
        },
        {
          "name": "st_get_organization_sources_metadata(s",
          "signature": "def st_get_organization_sources_metadata(server, default_user):\n",
          "parameters": "erver, default_user):\n",
          "return_type": null,
          "docstring": "\"Test getting organization sources metadata with aggregated file information.\"\"\"",
          "decorators": [],
          "start_line": 1650,
          "end_line": 1750,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406669
    },
    "tests/managers/test_tool_manager.py": {
      "path": "tests/managers/test_tool_manager.py",
      "contentHash": "e8d0e90174f760c669fd4175ba1bc51e",
      "mtime": 1768610518550.2007,
      "functions": [
        {
          "name": "test_attach_tool",
          "signature": "def test_attach_tool(server: SyncServer, sarah_agent, print_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test attaching a tool to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 111,
          "end_line": 123,
          "is_async": true
        },
        {
          "name": "test_detach_tool",
          "signature": "def test_detach_tool(server: SyncServer, sarah_agent, print_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test detaching a tool from an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 127,
          "end_line": 144,
          "is_async": true
        },
        {
          "name": "test_bulk_detach_tools",
          "signature": "def test_bulk_detach_tools(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk detaching multiple tools from an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 148,
          "end_line": 165,
          "is_async": true
        },
        {
          "name": "test_bulk_detach_tools_partial",
          "signature": "def test_bulk_detach_tools_partial(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk detaching tools when some are not attached.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 169,
          "end_line": 181,
          "is_async": true
        },
        {
          "name": "test_bulk_detach_tools_empty_list",
          "signature": "def test_bulk_detach_tools_empty_list(server: SyncServer, sarah_agent, print_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk detaching empty list of tools.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 185,
          "end_line": 195,
          "is_async": true
        },
        {
          "name": "test_bulk_detach_tools_idempotent",
          "signature": "def test_bulk_detach_tools_idempotent(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test that bulk detach is idempotent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 199,
          "end_line": 217,
          "is_async": true
        },
        {
          "name": "test_bulk_detach_tools_nonexistent_agent",
          "signature": "def test_bulk_detach_tools_nonexistent_agent(server: SyncServer, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk detaching tools from a nonexistent agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 221,
          "end_line": 227,
          "is_async": true
        },
        {
          "name": "test_attach_tool_nonexistent_agent",
          "signature": "def test_attach_tool_nonexistent_agent(server: SyncServer, print_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test attaching a tool to a nonexistent agent.",
          "decorators": [],
          "start_line": 230,
          "end_line": 233,
          "is_async": true
        },
        {
          "name": "test_attach_tool_nonexistent_tool",
          "signature": "def test_attach_tool_nonexistent_tool(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test attaching a nonexistent tool to an agent.",
          "decorators": [],
          "start_line": 236,
          "end_line": 239,
          "is_async": true
        },
        {
          "name": "test_detach_tool_nonexistent_agent",
          "signature": "def test_detach_tool_nonexistent_agent(server: SyncServer, print_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test detaching a tool from a nonexistent agent.",
          "decorators": [],
          "start_line": 242,
          "end_line": 245,
          "is_async": true
        },
        {
          "name": "test_list_attached_tools",
          "signature": "def test_list_attached_tools(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test listing tools attached to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 249,
          "end_line": 264,
          "is_async": true
        },
        {
          "name": "test_bulk_attach_tools",
          "signature": "def test_bulk_attach_tools(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk attaching multiple tools to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 268,
          "end_line": 278,
          "is_async": true
        },
        {
          "name": "test_bulk_attach_tools_with_duplicates",
          "signature": "def test_bulk_attach_tools_with_duplicates(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk attaching tools handles duplicates correctly.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 282,
          "end_line": 298,
          "is_async": true
        },
        {
          "name": "test_bulk_attach_tools_empty_list",
          "signature": "def test_bulk_attach_tools_empty_list(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test bulk attaching empty list of tools.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 302,
          "end_line": 309,
          "is_async": true
        },
        {
          "name": "test_bulk_attach_tools_nonexistent_tool",
          "signature": "def test_bulk_attach_tools_nonexistent_tool(server: SyncServer, sarah_agent, print_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk attaching tools with a nonexistent tool ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 313,
          "end_line": 327,
          "is_async": true
        },
        {
          "name": "test_bulk_attach_tools_nonexistent_agent",
          "signature": "def test_bulk_attach_tools_nonexistent_agent(server: SyncServer, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk attaching tools to a nonexistent agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 331,
          "end_line": 337,
          "is_async": true
        },
        {
          "name": "test_attach_missing_files_tools_async",
          "signature": "def test_attach_missing_files_tools_async(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test attaching missing file tools to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 341,
          "end_line": 358,
          "is_async": true
        },
        {
          "name": "test_attach_missing_files_tools_async_partial",
          "signature": "def test_attach_missing_files_tools_async_partial(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test attaching missing file tools when some are already attached.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 362,
          "end_line": 387,
          "is_async": true
        },
        {
          "name": "test_attach_missing_files_tools_async_idempotent",
          "signature": "def test_attach_missing_files_tools_async_idempotent(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that attach_missing_files_tools is idempotent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 391,
          "end_line": 411,
          "is_async": true
        },
        {
          "name": "test_detach_all_files_tools_async",
          "signature": "def test_detach_all_files_tools_async(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test detaching all file tools from an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 415,
          "end_line": 437,
          "is_async": true
        },
        {
          "name": "test_detach_all_files_tools_async_empty",
          "signature": "def test_detach_all_files_tools_async_empty(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test detaching all file tools when no file tools are attached.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 441,
          "end_line": 456,
          "is_async": true
        },
        {
          "name": "test_detach_all_files_tools_async_with_other_tools",
          "signature": "def test_detach_all_files_tools_async_with_other_tools(server: SyncServer, sarah_agent, print_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test detaching all file tools preserves non-file tools.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 460,
          "end_line": 484,
          "is_async": true
        },
        {
          "name": "test_detach_all_files_tools_async_idempotent",
          "signature": "def test_detach_all_files_tools_async_idempotent(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that detach_all_files_tools is idempotent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 488,
          "end_line": 509,
          "is_async": true
        },
        {
          "name": "test_attach_tool_with_default_requires_approval",
          "signature": "def test_attach_tool_with_default_requires_approval(server: SyncServer, sarah_agent, bash_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, bash_tool, default_user)",
          "return_type": null,
          "docstring": "Test that attaching a tool with default requires_approval adds associated tool rule.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 513,
          "end_line": 531,
          "is_async": true
        },
        {
          "name": "test_attach_tool_with_default_requires_approval_on_creation",
          "signature": "def test_attach_tool_with_default_requires_approval_on_creation(server: SyncServer, bash_tool, default_user)",
          "parameters": "(server: SyncServer, bash_tool, default_user)",
          "return_type": null,
          "docstring": "Test that attaching a tool with default requires_approval adds associated tool rule.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 535,
          "end_line": 580,
          "is_async": true
        },
        {
          "name": "test_create_tool",
          "signature": "def test_create_tool(server: SyncServer, print_tool, default_user, default_organization)",
          "parameters": "(server: SyncServer, print_tool, default_user, default_organization)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 589,
          "end_line": 592,
          "is_async": true
        },
        {
          "name": "test_create_mcp_tool",
          "signature": "def test_create_mcp_tool(server: SyncServer, mcp_tool, default_user, default_organization)",
          "parameters": "(server: SyncServer, mcp_tool, default_user, default_organization)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 596,
          "end_line": 601,
          "is_async": true
        },
        {
          "name": "test_create_tool_duplicate_name",
          "signature": "def test_create_tool_duplicate_name(server: SyncServer, print_tool, default_user, default_organization)",
          "parameters": "(server: SyncServer, print_tool, default_user, default_organization)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 606,
          "end_line": 611,
          "is_async": true
        },
        {
          "name": "test_create_tool_requires_approval",
          "signature": "def test_create_tool_requires_approval(server: SyncServer, bash_tool, default_user, default_organization)",
          "parameters": "(server: SyncServer, bash_tool, default_user, default_organization)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 615,
          "end_line": 619,
          "is_async": true
        },
        {
          "name": "test_get_tool_by_id",
          "signature": "def test_get_tool_by_id(server: SyncServer, print_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 623,
          "end_line": 635,
          "is_async": true
        },
        {
          "name": "test_get_tool_with_actor",
          "signature": "def test_get_tool_with_actor(server: SyncServer, print_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 639,
          "end_line": 651,
          "is_async": true
        },
        {
          "name": "test_list_tools",
          "signature": "def test_list_tools(server: SyncServer, print_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 655,
          "end_line": 661,
          "is_async": true
        },
        {
          "name": "test_list_tools_with_tool_types",
          "signature": "def test_list_tools_with_tool_types(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test filtering tools by tool_types parameter.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 665,
          "end_line": 730,
          "is_async": true
        },
        {
          "name": "test_list_tools_with_exclude_tool_types",
          "signature": "def test_list_tools_with_exclude_tool_types(server: SyncServer, default_user, print_tool)",
          "parameters": "(server: SyncServer, default_user, print_tool)",
          "return_type": null,
          "docstring": "Test excluding tools by exclude_tool_types parameter.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 734,
          "end_line": 770,
          "is_async": true
        },
        {
          "name": "test_list_tools_with_names",
          "signature": "def test_list_tools_with_names(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test filtering tools by names parameter.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 774,
          "end_line": 826,
          "is_async": true
        },
        {
          "name": "test_list_tools_with_tool_ids",
          "signature": "def test_list_tools_with_tool_ids(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test filtering tools by tool_ids parameter.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 830,
          "end_line": 882,
          "is_async": true
        },
        {
          "name": "test_list_tools_with_search",
          "signature": "def test_list_tools_with_search(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test searching tools by partial name match.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 886,
          "end_line": 947,
          "is_async": true
        },
        {
          "name": "test_list_tools_return_only_letta_tools",
          "signature": "def test_list_tools_return_only_letta_tools(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test filtering for only Letta tools.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 951,
          "end_line": 987,
          "is_async": true
        },
        {
          "name": "test_list_tools_combined_filters",
          "signature": "def test_list_tools_combined_filters(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test combining multiple filters.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 991,
          "end_line": 1060,
          "is_async": true
        },
        {
          "name": "test_count_tools_async",
          "signature": "def test_count_tools_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test counting tools with various filters.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1064,
          "end_line": 1141,
          "is_async": true
        },
        {
          "name": "test_update_tool_by_id",
          "signature": "def test_update_tool_by_id(server: SyncServer, print_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1145,
          "end_line": 1168,
          "is_async": true
        },
        {
          "name": "test_update_tool_multi_user",
          "signature": "def test_update_tool_multi_user(server: SyncServer, print_tool, default_user, other_user)",
          "parameters": "(server: SyncServer, print_tool, default_user, other_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1250,
          "end_line": 1264,
          "is_async": true
        },
        {
          "name": "test_delete_tool_by_id",
          "signature": "def test_delete_tool_by_id(server: SyncServer, print_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1268,
          "end_line": 1273,
          "is_async": true
        },
        {
          "name": "test_upsert_base_tools",
          "signature": "def test_upsert_base_tools(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1277,
          "end_line": 1313,
          "is_async": true
        },
        {
          "name": "test_upsert_filtered_base_tools",
          "signature": "def test_upsert_filtered_base_tools(server: SyncServer, default_user, tool_type, expected_names)",
          "parameters": "(server: SyncServer, default_user, tool_type, expected_names)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"tool_type,expected_names\",\n    [\n        (ToolType.LETTA_CORE, BASE_TOOLS),\n        (ToolType.LETTA_MEMORY_CORE, BASE_MEMORY_TOOLS),\n        (ToolType.LETTA_MULTI_AGENT_CORE, MULTI_AGENT_TOOLS),\n        (ToolType.LETTA_SLEEPTIME_CORE, BASE_SLEEPTIME_TOOLS),\n        (ToolType.LETTA_VOICE_SLEEPTIME_CORE, sorted(set(BASE_VOICE_SLEEPTIME_TOOLS + BASE_VOICE_SLEEPTIME_CHAT_TOOLS) - {\"send_message\"})),\n        (ToolType.LETTA_BUILTIN, BUILTIN_TOOLS),\n        (ToolType.LETTA_FILES_CORE, FILES_TOOLS),\n    ],\n)"
          ],
          "start_line": 1328,
          "end_line": 1339,
          "is_async": true
        },
        {
          "name": "test_upsert_multiple_tool_types",
          "signature": "def test_upsert_multiple_tool_types(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1342,
          "end_line": 1349,
          "is_async": true
        },
        {
          "name": "test_upsert_base_tools_with_empty_type_filter",
          "signature": "def test_upsert_base_tools_with_empty_type_filter(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1352,
          "end_line": 1354,
          "is_async": true
        },
        {
          "name": "test_bulk_upsert_tools_async",
          "signature": "def test_bulk_upsert_tools_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test bulk upserting multiple tools at once",
          "decorators": [],
          "start_line": 1357,
          "end_line": 1410,
          "is_async": true
        },
        {
          "name": "test_bulk_upsert_tools_name_conflict",
          "signature": "def test_bulk_upsert_tools_name_conflict(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test bulk upserting tools handles name+org_id unique constraint correctly",
          "decorators": [],
          "start_line": 1413,
          "end_line": 1452,
          "is_async": true
        },
        {
          "name": "test_bulk_upsert_tools_mixed_create_update",
          "signature": "def test_bulk_upsert_tools_mixed_create_update(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test bulk upserting with mix of new tools and updates to existing ones",
          "decorators": [],
          "start_line": 1455,
          "end_line": 1535,
          "is_async": true
        },
        {
          "name": "test_bulk_upsert_tools_override_existing_true",
          "signature": "def test_bulk_upsert_tools_override_existing_true(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test bulk_upsert_tools_async with override_existing_tools=True (default behavior)",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1539,
          "end_line": 1573,
          "is_async": true
        },
        {
          "name": "test_bulk_upsert_tools_override_existing_false",
          "signature": "def test_bulk_upsert_tools_override_existing_false(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test bulk_upsert_tools_async with override_existing_tools=False (skip existing)",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1577,
          "end_line": 1611,
          "is_async": true
        },
        {
          "name": "test_bulk_upsert_tools_override_mixed_scenario",
          "signature": "def test_bulk_upsert_tools_override_mixed_scenario(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test bulk_upsert_tools_async with override_existing_tools=False in mixed create/update scenario",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1615,
          "end_line": 1675,
          "is_async": true
        },
        {
          "name": "test_create_tool_with_pip_requirements",
          "signature": "def test_create_tool_with_pip_requirements(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1679,
          "end_line": 1718,
          "is_async": true
        },
        {
          "name": "test_create_tool_without_pip_requirements",
          "signature": "def test_create_tool_without_pip_requirements(server: SyncServer, print_tool)",
          "parameters": "(server: SyncServer, print_tool)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1721,
          "end_line": 1723,
          "is_async": true
        },
        {
          "name": "test_update_tool_pip_requirements",
          "signature": "def test_update_tool_pip_requirements(server: SyncServer, print_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1726,
          "end_line": 1745,
          "is_async": true
        },
        {
          "name": "test_update_tool_clear_pip_requirements",
          "signature": "def test_update_tool_clear_pip_requirements(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1748,
          "end_line": 1790,
          "is_async": true
        },
        {
          "name": "test_pip_requirements_roundtrip",
          "signature": "def test_pip_requirements_roundtrip(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1793,
          "end_line": 1840,
          "is_async": true
        },
        {
          "name": "test_update_default_requires_approval",
          "signature": "def test_update_default_requires_approval(server: SyncServer, bash_tool, default_user)",
          "parameters": "(server: SyncServer, bash_tool, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1843,
          "end_line": 1862,
          "is_async": true
        },
        {
          "name": "test_create_tool_with_json_schema",
          "signature": "def test_create_tool_with_json_schema(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test that json_schema is used when provided at creation.",
          "decorators": [],
          "start_line": 1870,
          "end_line": 1896,
          "is_async": true
        },
        {
          "name": "test_create_tool_with_args_json_schema",
          "signature": "def test_create_tool_with_args_json_schema(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test that schema is generated from args_json_schema at creation.",
          "decorators": [],
          "start_line": 1899,
          "end_line": 1932,
          "is_async": true
        },
        {
          "name": "test_create_tool_with_docstring_no_schema",
          "signature": "def test_create_tool_with_docstring_no_schema(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test that schema is generated from docstring when no schema provided.",
          "decorators": [],
          "start_line": 1935,
          "end_line": 1965,
          "is_async": true
        },
        {
          "name": "test_create_tool_with_docstring_and_args_schema",
          "signature": "def test_create_tool_with_docstring_and_args_schema(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test that args_json_schema takes precedence over docstring.",
          "decorators": [],
          "start_line": 1968,
          "end_line": 1999,
          "is_async": true
        },
        {
          "name": "test_error_no_docstring_or_schema",
          "signature": "def test_error_no_docstring_or_schema(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test error when no docstring or schema provided (minimal function).",
          "decorators": [],
          "start_line": 2002,
          "end_line": 2019,
          "is_async": true
        },
        {
          "name": "test_error_on_create_tool_with_name_conflict",
          "signature": "def test_error_on_create_tool_with_name_conflict(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test error when json_schema name conflicts with function name.",
          "decorators": [],
          "start_line": 2022,
          "end_line": 2047,
          "is_async": true
        },
        {
          "name": "test_update_tool_with_json_schema",
          "signature": "def test_update_tool_with_json_schema(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test update with a new json_schema.",
          "decorators": [],
          "start_line": 2050,
          "end_line": 2080,
          "is_async": true
        },
        {
          "name": "test_update_tool_with_args_json_schema",
          "signature": "def test_update_tool_with_args_json_schema(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test update with args_json_schema.",
          "decorators": [],
          "start_line": 2083,
          "end_line": 2120,
          "is_async": true
        },
        {
          "name": "test_update_tool_with_no_schema",
          "signature": "def test_update_tool_with_no_schema(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test update with no schema changes.",
          "decorators": [],
          "start_line": 2123,
          "end_line": 2149,
          "is_async": true
        },
        {
          "name": "test_update_tool_name",
          "signature": "def test_update_tool_name(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test various name update scenarios.",
          "decorators": [],
          "start_line": 2152,
          "end_line": 2174,
          "is_async": true
        },
        {
          "name": "test_list_tools_with_project_id_filtering",
          "signature": "def test_list_tools_with_project_id_filtering(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test listing tools with project_id filtering - global vs project-scoped tools.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2178,
          "end_line": 2273,
          "is_async": true
        },
        {
          "name": "test_count_tools_with_project_id_filtering",
          "signature": "def test_count_tools_with_project_id_filtering(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test counting tools with project_id filtering - global vs project-scoped tools.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2277,
          "end_line": 2393,
          "is_async": true
        },
        {
          "name": "test_list_tools_with_corrupted_tool",
          "signature": "def test_list_tools_with_corrupted_tool(server: SyncServer, default_user, print_tool)",
          "parameters": "(server: SyncServer, default_user, print_tool)",
          "return_type": null,
          "docstring": "Test that list_tools still works even if there's a corrupted tool (missing json_schema) in the database.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2397,
          "end_line": 2440,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406670
    },
    "tests/managers/test_user_manager.py": {
      "path": "tests/managers/test_user_manager.py",
      "contentHash": "7d7aa702c5a78120e18a296345fe5655",
      "mtime": 1767315072136.548,
      "functions": [
        {
          "name": "test_list_users",
          "signature": "def test_list_users(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 108,
          "end_line": 121,
          "is_async": true
        },
        {
          "name": "test_create_default_user",
          "signature": "def test_create_default_user(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 125,
          "end_line": 129,
          "is_async": true
        },
        {
          "name": "test_update_user",
          "signature": "def test_update_user(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 133,
          "end_line": 153,
          "is_async": true
        },
        {
          "name": "test_user_caching",
          "signature": "def test_user_caching(server: SyncServer, default_user, performance_pct=0.4)",
          "parameters": "(server: SyncServer, default_user, performance_pct=0.4)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 156,
          "end_line": 189,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406670
    },
    "tests/manual_test_many_messages.py": {
      "path": "tests/manual_test_many_messages.py",
      "contentHash": "a900bf06a47b8cd88f783133633a8f03",
      "mtime": 1767315072136.548,
      "functions": [
        {
          "name": "truncate_database",
          "signature": "def truncate_database()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 19,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Creates a SyncServer instance for testing.\n\n    Loads and saves config to ensure proper initialization.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 29,
          "end_line": 40,
          "is_async": false
        },
        {
          "name": "default_user",
          "signature": "def default_user(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 44,
          "end_line": 46,
          "is_async": false
        },
        {
          "name": "generate_tool_call_id",
          "signature": "def generate_tool_call_id()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Generates a unique tool call ID.",
          "decorators": [],
          "start_line": 49,
          "end_line": 51,
          "is_async": false
        },
        {
          "name": "generate_timestamps",
          "signature": "def generate_timestamps(base_time)",
          "parameters": "(base_time)",
          "return_type": null,
          "docstring": "Creates a sequence of timestamps for user, assistant, and tool messages.",
          "decorators": [],
          "start_line": 54,
          "end_line": 61,
          "is_async": false
        },
        {
          "name": "get_conversation_pair",
          "signature": "def get_conversation_pair()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 64,
          "end_line": 66,
          "is_async": false
        },
        {
          "name": "create_user_message",
          "signature": "def create_user_message(agent_id, organization_id, message_text, timestamp)",
          "parameters": "(agent_id, organization_id, message_text, timestamp)",
          "return_type": null,
          "docstring": "Creates a user message dictionary.",
          "decorators": [],
          "start_line": 69,
          "end_line": 87,
          "is_async": false
        },
        {
          "name": "create_send_message",
          "signature": "def create_send_message(agent_id, organization_id, assistant_text, tool_call_id, timestamp)",
          "parameters": "(agent_id, organization_id, assistant_text, tool_call_id, timestamp)",
          "return_type": null,
          "docstring": "Creates an assistant message dictionary.",
          "decorators": [],
          "start_line": 90,
          "end_line": 112,
          "is_async": false
        },
        {
          "name": "create_tool_message",
          "signature": "def create_tool_message(agent_id, organization_id, tool_call_id, timestamp)",
          "parameters": "(agent_id, organization_id, tool_call_id, timestamp)",
          "return_type": null,
          "docstring": "Creates a tool response message dictionary.",
          "decorators": [],
          "start_line": 115,
          "end_line": 133,
          "is_async": false
        },
        {
          "name": "test_many_messages_performance",
          "signature": "def test_many_messages_performance(server, default_user, num_messages)",
          "parameters": "(server, default_user, num_messages)",
          "return_type": null,
          "docstring": "Performance test to insert many messages and ensure retrieval works correctly.",
          "decorators": [
            "@pytest.mark.parametrize(\"num_messages\", [1000])"
          ],
          "start_line": 137,
          "end_line": 213,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406670
    },
    "tests/manual_test_multi_agent_broadcast_large.py": {
      "path": "tests/manual_test_multi_agent_broadcast_large.py",
      "contentHash": "84a8d48bf0b6e2633bd362de687092a0",
      "mtime": 1767315072136.548,
      "functions": [
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Creates a SyncServer instance for testing.\n\n    Loads and saves config to ensure proper initialization.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 12,
          "end_line": 23,
          "is_async": false
        },
        {
          "name": "default_user",
          "signature": "def default_user(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 27,
          "end_line": 29,
          "is_async": false
        },
        {
          "name": "roll_dice_tool",
          "signature": "def roll_dice_tool(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 33,
          "end_line": 45,
          "is_async": false
        },
        {
          "name": "test_multi_agent_large",
          "signature": "def test_multi_agent_large(server, default_user, roll_dice_tool, num_workers)",
          "parameters": "(server, default_user, roll_dice_tool, num_workers)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\"num_workers\", [50])"
          ],
          "start_line": 49,
          "end_line": 98,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406670
    },
    "tests/mcp_test.py": {
      "path": "tests/mcp_test.py",
      "contentHash": "7540c8072cf56f268efac9bf4cd19e3e",
      "mtime": 1767315072136.548,
      "functions": [
        {
          "name": "ver ",
          "signature": "def ver UR",
          "parameters": "UR",
          "return_type": null,
          "docstring": "n be overridden with en",
          "decorators": [],
          "start_line": 333,
          "end_line": 347,
          "is_async": true
        },
        {
          "name": "cio",
          "signature": "def cio.r",
          "parameters": ".r",
          "return_type": null,
          "docstring": "n())\n\n\nif __name__ == \"__main__\":",
          "decorators": [],
          "start_line": 350,
          "end_line": 352,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406670
    },
    "tests/mcp_tests/test_mcp.py": {
      "path": "tests/mcp_tests/test_mcp.py",
      "contentHash": "9e634d9c9d415cb07c505c2eae8c1624",
      "mtime": 1767315072136.548,
      "functions": [
        {
          "name": "create_virtualenv_and_install_requirements",
          "signature": "def create_virtualenv_and_install_requirements(requirements_path: Path, name=\"venv\", force_recreate=True) -> Path",
          "parameters": "(requirements_path: Path, name=\"venv\", force_recreate=True)",
          "return_type": "Path",
          "docstring": null,
          "decorators": [],
          "start_line": 23,
          "end_line": 70,
          "is_async": false
        },
        {
          "name": "empty_mcp_config",
          "signature": "def empty_mcp_config()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 85,
          "end_line": 89,
          "is_async": false
        },
        {
          "name": "cleanup_test_venvs",
          "signature": "def cleanup_test_venvs()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to clean up test virtual environments before and after tests.",
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 93,
          "end_line": 107,
          "is_async": false
        },
        {
          "name": "server_url",
          "signature": "def server_url(empty_mcp_config)",
          "parameters": "(empty_mcp_config)",
          "return_type": null,
          "docstring": "Ensures a server is running and returns its base URL.",
          "decorators": [
            "@pytest.fixture()"
          ],
          "start_line": 111,
          "end_line": 120,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url)",
          "parameters": "(server_url)",
          "return_type": null,
          "docstring": "Creates a REST client for testing.",
          "decorators": [
            "@pytest.fixture()"
          ],
          "start_line": 124,
          "end_line": 127,
          "is_async": false
        },
        {
          "name": "agent_state",
          "signature": "def agent_state(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": "Creates an agent and ensures cleanup after tests.",
          "decorators": [
            "@pytest.fixture()"
          ],
          "start_line": 131,
          "end_line": 150,
          "is_async": false
        },
        {
          "name": "test_sse_mcp_server",
          "signature": "def test_sse_mcp_server(client, agent_state)",
          "parameters": "(client, agent_state)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 154,
          "end_line": 208,
          "is_async": true
        },
        {
          "name": "test_stdio_mcp_server",
          "signature": "def test_stdio_mcp_server(client, agent_state, server_url)",
          "parameters": "(client, agent_state, server_url)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 211,
          "end_line": 268,
          "is_async": false
        },
        {
          "name": "test_openai_rejects_untyped_additional_properties_and_accepts_normalized_schema",
          "signature": "def test_openai_rejects_untyped_additional_properties_and_accepts_normalized_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test written to check if our extra schema validation works.\n\n    Some MCP servers will return faulty schemas that require correction, or they will brick the LLM client calls.",
          "decorators": [
            "@pytest.mark.skipif(\n    not os.getenv(\"OPENAI_API_KEY\"),\n    reason=\"Requires OPENAI_API_KEY to call OpenAI for schema validation\",\n)"
          ],
          "start_line": 302,
          "end_line": 345,
          "is_async": false
        },
        {
          "name": "test_streamable_http_mcp_server_update_schema_no_docstring_required",
          "signature": "def test_streamable_http_mcp_server_update_schema_no_docstring_required(client, agent_state, server_url)",
          "parameters": "(client, agent_state, server_url)",
          "return_type": null,
          "docstring": "Repro for schema-derivation-on-update error with MCP tools.\n\n    Without the fix, calling add_mcp_tool a second time for the same MCP tool\n    triggers a docstring-based schema derivation on a generated wrapper that has\n    no docstring, causing a 500. With the fix in place, updates should succeed.\n\n    With 1.0 API, tools are automatically registered when server is created,\n    so this test verifies that tools can be retrieved multiple times without issues.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 349,
          "end_line": 394,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406670
    },
    "tests/mcp_tests/test_mcp_schema_validation.py": {
      "path": "tests/mcp_tests/test_mcp_schema_validation.py",
      "contentHash": "666f85e5e60914c95167274b22845637",
      "mtime": 1767315072136.548,
      "functions": [
        {
          "name": "test_mcp_tools_get_health_status",
          "signature": "def test_mcp_tools_get_health_status()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that MCP tools receive health status when listed.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 16,
          "end_line": 75,
          "is_async": true
        },
        {
          "name": "test_empty_object_in_required_marked_invalid",
          "signature": "def test_empty_object_in_required_marked_invalid()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that required properties allowing empty objects are marked INVALID.",
          "decorators": [],
          "start_line": 78,
          "end_line": 94,
          "is_async": false
        },
        {
          "name": "test_add_mcp_tool_accepts_non_strict_schemas",
          "signature": "def test_add_mcp_tool_accepts_non_strict_schemas()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that adding MCP tools with non-strict schemas is allowed.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 98,
          "end_line": 134,
          "is_async": true
        },
        {
          "name": "test_add_mcp_tool_rejects_invalid_schemas",
          "signature": "def test_add_mcp_tool_rejects_invalid_schemas()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that adding MCP tools with invalid schemas is rejected.",
          "decorators": [
            "@pytest.mark.skip(reason=\"Allowing invalid schemas to be attached\")",
            "@pytest.mark.asyncio"
          ],
          "start_line": 139,
          "end_line": 174,
          "is_async": true
        },
        {
          "name": "test_mcp_schema_healing_for_optional_fields",
          "signature": "def test_mcp_schema_healing_for_optional_fields()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that optional fields in MCP schemas are healed only in strict mode.",
          "decorators": [],
          "start_line": 177,
          "end_line": 213,
          "is_async": false
        },
        {
          "name": "test_mcp_schema_healing_with_anyof",
          "signature": "def test_mcp_schema_healing_with_anyof()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test schema healing for fields with anyOf that include optional types.",
          "decorators": [],
          "start_line": 216,
          "end_line": 249,
          "is_async": false
        },
        {
          "name": "test_mcp_schema_type_deduplication",
          "signature": "def test_mcp_schema_type_deduplication()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that anyOf duplicates are removed in schema generation.",
          "decorators": [],
          "start_line": 252,
          "end_line": 284,
          "is_async": false
        },
        {
          "name": "test_mcp_schema_healing_preserves_existing_null",
          "signature": "def test_mcp_schema_healing_preserves_existing_null()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that schema healing doesn't add duplicate null when it already exists.",
          "decorators": [],
          "start_line": 287,
          "end_line": 311,
          "is_async": false
        },
        {
          "name": "test_mcp_schema_healing_all_fields_already_required",
          "signature": "def test_mcp_schema_healing_all_fields_already_required()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that schema healing works correctly when all fields are already required.",
          "decorators": [],
          "start_line": 314,
          "end_line": 340,
          "is_async": false
        },
        {
          "name": "test_mcp_schema_with_uuid_format",
          "signature": "def test_mcp_schema_with_uuid_format()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test handling of UUID format in anyOf schemas (deduplicates but keeps format).",
          "decorators": [],
          "start_line": 343,
          "end_line": 381,
          "is_async": false
        },
        {
          "name": "test_mcp_schema_healing_only_in_strict_mode",
          "signature": "def test_mcp_schema_healing_only_in_strict_mode()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that schema healing only happens in strict mode.",
          "decorators": [],
          "start_line": 384,
          "end_line": 421,
          "is_async": false
        },
        {
          "name": "test_mcp_schema_with_uuid_format_required_field",
          "signature": "def test_mcp_schema_with_uuid_format_required_field()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that UUID format is preserved and duplicates are removed for required fields.",
          "decorators": [],
          "start_line": 424,
          "end_line": 463,
          "is_async": false
        },
        {
          "name": "test_mcp_schema_complex_nested_with_defs",
          "signature": "def test_mcp_schema_complex_nested_with_defs()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test generating exact schema with nested Pydantic-like models using $defs.",
          "decorators": [],
          "start_line": 466,
          "end_line": 821,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406671
    },
    "tests/mcp_tests/weather/weather.py": {
      "path": "tests/mcp_tests/weather/weather.py",
      "contentHash": "dc93186e6dbf575252d7d14a0118f2ff",
      "mtime": 1767315072136.548,
      "functions": [
        {
          "name": "make_nws_request",
          "signature": "def make_nws_request(url: str) -> dict[str, Any] | None",
          "parameters": "(url: str)",
          "return_type": "dict[str, Any] | None",
          "docstring": "Make a request to the NWS API with proper error handling.",
          "decorators": [],
          "start_line": 14,
          "end_line": 23,
          "is_async": true
        },
        {
          "name": "format_alert",
          "signature": "def format_alert(feature: dict) -> str",
          "parameters": "(feature: dict)",
          "return_type": "str",
          "docstring": "Format an alert feature into a readable string.",
          "decorators": [],
          "start_line": 26,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "get_alerts",
          "signature": "def get_alerts(state: str) -> str",
          "parameters": "(state: str)",
          "return_type": "str",
          "docstring": "Get weather alerts for a US state.\n\n    Args:\n        state: Two-letter US state code (e.g. CA, NY)",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 39,
          "end_line": 55,
          "is_async": true
        },
        {
          "name": "get_forecast",
          "signature": "def get_forecast(latitude: float, longitude: float) -> str",
          "parameters": "(latitude: float, longitude: float)",
          "return_type": "str",
          "docstring": "Get weather forecast for a location.\n\n    Args:\n        latitude: Latitude of the location\n        longitude: Longitude of the location",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 59,
          "end_line": 92,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406671
    },
    "tests/mock_mcp_server.py": {
      "path": "tests/mock_mcp_server.py",
      "contentHash": "94cd2950c80421c819e4ccf46207809e",
      "mtime": 1767315072136.548,
      "functions": [
        {
          "name": "echo",
          "signature": "def echo(message: str) -> str",
          "parameters": "(message: str)",
          "return_type": "str",
          "docstring": "Echo back the provided message.\n\n    Args:\n        message: The message to echo back",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 85,
          "end_line": 91,
          "is_async": true
        },
        {
          "name": "add",
          "signature": "def add(a: float, b: float) -> str",
          "parameters": "(a: float, b: float)",
          "return_type": "str",
          "docstring": "Add two numbers together.\n\n    Args:\n        a: First number\n        b: Second number",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 95,
          "end_line": 103,
          "is_async": true
        },
        {
          "name": "multiply",
          "signature": "def multiply(a: float, b: float) -> str",
          "parameters": "(a: float, b: float)",
          "return_type": "str",
          "docstring": "Multiply two numbers together.\n\n    Args:\n        a: First number\n        b: Second number",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 107,
          "end_line": 115,
          "is_async": true
        },
        {
          "name": "everse_string(",
          "signature": "def everse_string(text: str)  -> tr:",
          "parameters": "text: str) ",
          "return_type": "tr:",
          "docstring": "\"\"Reverse a string.\n\n    Args:\n        text: The string to reverse\n    \"\"\"",
          "decorators": [
            "mcp.tool()\n"
          ],
          "start_line": 119,
          "end_line": 125,
          "is_async": true
        },
        {
          "name": "reate_person(",
          "signature": "def reate_person(person: Person)  -> tr:",
          "parameters": "person: Person) ",
          "return_type": "tr:",
          "docstring": "\"\"Create a person profile with nested address information.\n\n    Args:\n        person: Person object with name, age, optional email and address\n    \"\"\"",
          "decorators": [
            "mcp.tool()\n"
          ],
          "start_line": 132,
          "end_line": 151,
          "is_async": true
        },
        {
          "name": "anage_tasks(",
          "signature": "def anage_tasks(tasks: List[TaskItem])  -> tr:",
          "parameters": "tasks: List[TaskItem]) ",
          "return_type": "tr:",
          "docstring": "\"\"Manage multiple tasks with priorities and tags.\n\n    Args:\n        tasks: List of task items to manage\n    \"\"\"",
          "decorators": [
            "mcp.tool()\n"
          ],
          "start_line": 155,
          "end_line": 179,
          "is_async": true
        },
        {
          "name": "h_with_filters(quer",
          "signature": "def h_with_filters(query: str, filters: SearchFilter) -> s ->    ",
          "parameters": "y: str, filters: SearchFilter) -> s",
          "return_type": "   ",
          "docstring": "arch with complex filter criteria including keywords and categories.\n\n    Args:\n        query: The main search query\n        filters: Complex filter object with keywords, score threshold, and categories\n    \"\"\"",
          "decorators": [
            "tool()\nasyn"
          ],
          "start_line": 183,
          "end_line": 206,
          "is_async": true
        },
        {
          "name": "ss_nested_data(data",
          "signature": "def ss_nested_data(data: dict) -> s ->    ",
          "parameters": ": dict) -> s",
          "return_type": "   ",
          "docstring": "ocess arbitrary nested dictionary data.\n\n    Args:\n        data: Nested dictionary with arbitrary structure\n    \"\"\"",
          "decorators": [
            "tool()\nasyn"
          ],
          "start_line": 210,
          "end_line": 240,
          "is_async": true
        },
        {
          "name": "arameter_type_description(\n   ",
          "signature": "def arameter_type_description(\n    preset: str,\n    instantiation_data: InstantiationData,\n    connected_service_descriptor: Optional[str] = None,\n) -> s ->    ",
          "parameters": " preset: str,\n    instantiation_data: InstantiationData,\n    connected_service_descriptor: Optional[str] = None,\n) -> s",
          "return_type": "   ",
          "docstring": "t parameter type description with complex nested structure.\n\n    This tool matches the customer-reported schema pattern with:\n    - Enum-like preset parameter\n    - Optional string field\n    - Optional nested object with arrays of objects\n\n    Args:\n        preset: The parameter preset (a, b, c, e, f, g, h, i, d, l, s, m, z, o, u, unknown)\n        connected_service_descriptor: Connected service descriptor string, if available\n        instantiation_data: Instantiation data dict with isAbstract, isMultiplicity, and instantiations list\n    \"\"\"",
          "decorators": [
            "tool()\nasyn"
          ],
          "start_line": 244,
          "end_line": 274,
          "is_async": true
        },
        {
          "name": "):\n ",
          "signature": "def ):\n   ",
          "parameters": "  ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 277,
          "end_line": 279,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406671
    },
    "tests/performance_tests/test_agent_mass_creation.py": {
      "path": "tests/performance_tests/test_agent_mass_creation.py",
      "contentHash": "69e375950414ff838ec36ccc164fc020",
      "mtime": 1767315072140.548,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensures a server is running and returns its base URL.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 36,
          "end_line": 45,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url)",
          "parameters": "(server_url)",
          "return_type": null,
          "docstring": "Creates a REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 52,
          "end_line": 55,
          "is_async": false
        },
        {
          "name": "roll_dice_tool",
          "signature": "def roll_dice_tool(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture()"
          ],
          "start_line": 59,
          "end_line": 71,
          "is_async": false
        },
        {
          "name": "rethink_tool",
          "signature": "def rethink_tool(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture()"
          ],
          "start_line": 75,
          "end_line": 92,
          "is_async": false
        },
        {
          "name": "default_block",
          "signature": "def default_block(default_user)",
          "parameters": "(default_user)",
          "return_type": null,
          "docstring": "Fixture to create and return a default block.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 96,
          "end_line": 107,
          "is_async": false
        },
        {
          "name": "agent_state",
          "signature": "def agent_state(client, roll_dice_tool, weather_tool, rethink_tool)",
          "parameters": "(client, roll_dice_tool, weather_tool, rethink_tool)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 111,
          "end_line": 130,
          "is_async": false
        },
        {
          "name": "create_agents_for_user",
          "signature": "def create_agents_for_user(client, roll_dice_tool, rethink_tool, user_index: int) -> tuple",
          "parameters": "(client, roll_dice_tool, rethink_tool, user_index: int)",
          "return_type": "tuple",
          "docstring": "Create agents and return E2E latencies in seconds along with user index.",
          "decorators": [],
          "start_line": 136,
          "end_line": 175,
          "is_async": false
        },
        {
          "name": "plot_agent_creation_latencies",
          "signature": "def plot_agent_creation_latencies(latency_data)",
          "parameters": "(latency_data)",
          "return_type": null,
          "docstring": "Plot the distribution of agent creation latencies.\n\n    Args:\n        latency_data: List of dictionaries with latency information",
          "decorators": [],
          "start_line": 178,
          "end_line": 249,
          "is_async": false
        },
        {
          "name": "test_parallel_create_many_agents",
          "signature": "def test_parallel_create_many_agents(client, roll_dice_tool, rethink_tool)",
          "parameters": "(client, roll_dice_tool, rethink_tool)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.slow"
          ],
          "start_line": 253,
          "end_line": 294,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406671
    },
    "tests/performance_tests/test_agent_mass_update.py": {
      "path": "tests/performance_tests/test_agent_mass_update.py",
      "contentHash": "bd6a9ec55971b23e720aa8ca3feacab9",
      "mtime": 1767315072140.548,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensures a server is running and returns its base URL.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 35,
          "end_line": 44,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url)",
          "parameters": "(server_url)",
          "return_type": null,
          "docstring": "Creates a REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 51,
          "end_line": 54,
          "is_async": false
        },
        {
          "name": "roll_dice_tool",
          "signature": "def roll_dice_tool(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture()"
          ],
          "start_line": 58,
          "end_line": 70,
          "is_async": false
        },
        {
          "name": "rethink_tool",
          "signature": "def rethink_tool(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture()"
          ],
          "start_line": 74,
          "end_line": 91,
          "is_async": false
        },
        {
          "name": "weather_tool",
          "signature": "def weather_tool(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 95,
          "end_line": 122,
          "is_async": false
        },
        {
          "name": "test_parallel_mass_update_agents_complex",
          "signature": "def test_parallel_mass_update_agents_complex(client, roll_dice_tool, weather_tool, rethink_tool)",
          "parameters": "(client, roll_dice_tool, weather_tool, rethink_tool)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.slow"
          ],
          "start_line": 129,
          "end_line": 220,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406671
    },
    "tests/performance_tests/test_insert_archival_memory.py": {
      "path": "tests/performance_tests/test_insert_archival_memory.py",
      "contentHash": "39068e8e98ff4f1eb07859c088680eb8",
      "mtime": 1767315072140.548,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensures a server is running and returns its base URL.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 36,
          "end_line": 45,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url)",
          "parameters": "(server_url)",
          "return_type": null,
          "docstring": "Creates a REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 52,
          "end_line": 55,
          "is_async": false
        },
        {
          "name": "test_insert_archival_memories_concurrent",
          "signature": "def test_insert_archival_memories_concurrent(client)",
          "parameters": "(client)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 64,
          "end_line": 162,
          "is_async": true
        },
        {
          "name": "st_insert_large_archival_memory(c",
          "signature": "def st_insert_large_archival_memory(client):\n",
          "parameters": "lient):\n",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 166,
          "end_line": 185,
          "is_async": true
        }
      ],
      "parsedAt": 1769609406671
    },
    "tests/sdk/conftest.py": {
      "path": "tests/sdk/conftest.py",
      "contentHash": "8746a87af2d1cc0187f784e80f733e2c",
      "mtime": 1768610518550.2007,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until it's accepting connections.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 13,
          "end_line": 46,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> Letta",
          "parameters": "(server_url: str)",
          "return_type": "Letta",
          "docstring": "Creates and returns a synchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 51,
          "end_line": 56,
          "is_async": false
        },
        {
          "name": "skip_test_if_not_implemented",
          "signature": "def skip_test_if_not_implemented(handler, resource_name, test_name)",
          "parameters": "(handler, resource_name, test_name)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 59,
          "end_line": 61,
          "is_async": false
        },
        {
          "name": "create_test_module",
          "signature": "def create_test_module(\n    resource_name: str,\n    id_param_name: str,\n    create_params: List[Tuple[str, Dict[str, Any], Dict[str, Any], Optional[Exception]]] = [],\n    upsert_params: List[Tuple[str, Dict[str, Any], Dict[str, Any], Optional[Exception]]] = [],\n    update_params: List[Tuple[str, Dict[str, Any], Dict[str, Any], Optional[Exception]]] = [],\n    list_params: List[Tuple[Dict[str, Any], int]] = [],\n) -> Dict[str, Any]",
          "parameters": "(\n    resource_name: str,\n    id_param_name: str,\n    create_params: List[Tuple[str, Dict[str, Any], Dict[str, Any], Optional[Exception]]] = [],\n    upsert_params: List[Tuple[str, Dict[str, Any], Dict[str, Any], Optional[Exception]]] = [],\n    update_params: List[Tuple[str, Dict[str, Any], Dict[str, Any], Optional[Exception]]] = [],\n    list_params: List[Tuple[Dict[str, Any], int]] = [],\n)",
          "return_type": "Dict[str, Any]",
          "docstring": "Create a test module for a resource.\n\n    This function creates all the necessary test methods and returns them in a dictionary\n    that can be added to the globals() of the module.\n\n    Args:\n        resource_name: Name of the resource (e.g., \"blocks\", \"tools\")\n        id_param_name: Name of the ID parameter (e.g., \"block_id\", \"tool_id\")\n        create_params: List of (name, params, expected_error) tuples for create tests\n        update_params: List of (name, params, expected_error) tuples for update tests\n        list_params: List of (query_params, expected_count) tuples for list tests\n\n    Returns:\n        Dict: A dictionary of all test functions that should be added to the module globals",
          "decorators": [],
          "start_line": 64,
          "end_line": 256,
          "is_async": false
        },
        {
          "name": "custom_model_dump",
          "signature": "def custom_model_dump(model)",
          "parameters": "(model)",
          "return_type": null,
          "docstring": "Dumps the given model to a form that can be easily compared.\n\n    Args:\n        model: The model to dump\n\n    Returns:\n        The dumped model",
          "decorators": [],
          "start_line": 259,
          "end_line": 276,
          "is_async": false
        },
        {
          "name": "add_fixture_params",
          "signature": "def add_fixture_params(value, caren_agent)",
          "parameters": "(value, caren_agent)",
          "return_type": null,
          "docstring": "Replaces string values containing '.id' with their mapped values.\n\n    Args:\n        value: The value to process (should be a string)\n        caren_agent: The agent object to use for ID replacement\n\n    Returns:\n        The processed value with ID strings replaced by actual values",
          "decorators": [],
          "start_line": 279,
          "end_line": 293,
          "is_async": false
        },
        {
          "name": "preprocess_params",
          "signature": "def preprocess_params(params, caren_agent)",
          "parameters": "(params, caren_agent)",
          "return_type": null,
          "docstring": "Recursively processes a nested structure of dictionaries and lists,\n    replacing string values containing '.id' with their mapped values.\n\n    Args:\n        params: The parameters to process (dict, list, or scalar value)\n        caren_agent: The agent object to use for ID replacement\n\n    Returns:\n        The processed parameters with ID strings replaced by actual values",
          "decorators": [],
          "start_line": 296,
          "end_line": 319,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406671
    },
    "tests/sdk/mcp_servers_test.py": {
      "path": "tests/sdk/mcp_servers_test.py",
      "contentHash": "afa2e3e44ec1f1a8eb882be234d88ad4",
      "mtime": 1768610518550.2007,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until it's accepting connections.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 31,
          "end_line": 64,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> Letta",
          "parameters": "(server_url: str)",
          "return_type": "Letta",
          "docstring": "Creates and returns a synchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 68,
          "end_line": 73,
          "is_async": false
        },
        {
          "name": "unique_server_id",
          "signature": "def unique_server_id() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Generate a unique MCP server ID for each test.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 77,
          "end_line": 80,
          "is_async": false
        },
        {
          "name": "mock_mcp_server_path",
          "signature": "def mock_mcp_server_path() -> Path",
          "parameters": "()",
          "return_type": "Path",
          "docstring": "Get path to mock MCP server for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 84,
          "end_line": 93,
          "is_async": false
        },
        {
          "name": "mock_mcp_server_config_for_agent",
          "signature": "def mock_mcp_server_config_for_agent() -> Dict[str, Any]",
          "parameters": "()",
          "return_type": "Dict[str, Any]",
          "docstring": "Creates a stdio configuration for the mock MCP server for agent testing.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 97,
          "end_line": 117,
          "is_async": false
        },
        {
          "name": "agent_with_mcp_tools",
          "signature": "def agent_with_mcp_tools(client: Letta, mock_mcp_server_config_for_agent: Dict[str, Any]) -> AgentState",
          "parameters": "(client: Letta, mock_mcp_server_config_for_agent: Dict[str, Any])",
          "return_type": "AgentState",
          "docstring": "Creates an agent with MCP tools attached for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 121,
          "end_line": 175,
          "is_async": false
        },
        {
          "name": "get_attr",
          "signature": "def get_attr(obj, attr)",
          "parameters": "(obj, attr)",
          "return_type": null,
          "docstring": "Helper to get attribute from dict or object.",
          "decorators": [],
          "start_line": 183,
          "end_line": 187,
          "is_async": false
        },
        {
          "name": "create_stdio_server_request",
          "signature": "def create_stdio_server_request(server_name: str, command: str = \"npx\", args: List[str] = None) -> Dict[str, Any]",
          "parameters": "(server_name: str, command: str = \"npx\", args: List[str] = None)",
          "return_type": "Dict[str, Any]",
          "docstring": "Create a stdio MCP server configuration object.\n\n    Returns a dict with server_name and config following CreateMCPServerRequest schema.",
          "decorators": [],
          "start_line": 190,
          "end_line": 203,
          "is_async": false
        },
        {
          "name": "create_sse_server_request",
          "signature": "def create_sse_server_request(server_name: str, server_url: str = None) -> Dict[str, Any]",
          "parameters": "(server_name: str, server_url: str = None)",
          "return_type": "Dict[str, Any]",
          "docstring": "Create an SSE MCP server configuration object.\n\n    Returns a dict with server_name and config following CreateMCPServerRequest schema.",
          "decorators": [],
          "start_line": 206,
          "end_line": 220,
          "is_async": false
        },
        {
          "name": "create_streamable_http_server_request",
          "signature": "def create_streamable_http_server_request(server_name: str, server_url: str = None) -> Dict[str, Any]",
          "parameters": "(server_name: str, server_url: str = None)",
          "return_type": "Dict[str, Any]",
          "docstring": "Create a streamable HTTP MCP server configuration object.\n\n    Returns a dict with server_name and config following CreateMCPServerRequest schema.",
          "decorators": [],
          "start_line": 223,
          "end_line": 237,
          "is_async": false
        },
        {
          "name": "create_exa_streamable_http_server_request",
          "signature": "def create_exa_streamable_http_server_request(server_name: str) -> Dict[str, Any]",
          "parameters": "(server_name: str)",
          "return_type": "Dict[str, Any]",
          "docstring": "Create a Streamable HTTP config for Exa MCP with no auth.\n\n    Reference: https://mcp.exa.ai/mcp\n    Returns a dict with server_name and config following CreateMCPServerRequest schema.",
          "decorators": [],
          "start_line": 240,
          "end_line": 253,
          "is_async": false
        },
        {
          "name": "test_create_stdio_mcp_server",
          "signature": "def test_create_stdio_mcp_server(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test creating a stdio MCP server.",
          "decorators": [],
          "start_line": 261,
          "end_line": 285,
          "is_async": false
        },
        {
          "name": "test_create_sse_mcp_server",
          "signature": "def test_create_sse_mcp_server(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test creating an SSE MCP server.",
          "decorators": [],
          "start_line": 288,
          "end_line": 311,
          "is_async": false
        },
        {
          "name": "test_create_streamable_http_mcp_server",
          "signature": "def test_create_streamable_http_mcp_server(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test creating a streamable HTTP MCP server.",
          "decorators": [],
          "start_line": 314,
          "end_line": 335,
          "is_async": false
        },
        {
          "name": "test_list_mcp_servers",
          "signature": "def test_list_mcp_servers(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test listing all MCP servers.",
          "decorators": [],
          "start_line": 338,
          "end_line": 376,
          "is_async": false
        },
        {
          "name": "test_get_specific_mcp_server",
          "signature": "def test_get_specific_mcp_server(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test getting a specific MCP server by ID.",
          "decorators": [],
          "start_line": 379,
          "end_line": 405,
          "is_async": false
        },
        {
          "name": "test_update_stdio_mcp_server",
          "signature": "def test_update_stdio_mcp_server(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test updating a stdio MCP server.",
          "decorators": [],
          "start_line": 408,
          "end_line": 441,
          "is_async": false
        },
        {
          "name": "test_update_sse_mcp_server",
          "signature": "def test_update_sse_mcp_server(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test updating an SSE MCP server.",
          "decorators": [],
          "start_line": 444,
          "end_line": 472,
          "is_async": false
        },
        {
          "name": "test_delete_mcp_server",
          "signature": "def test_delete_mcp_server(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test deleting an MCP server.",
          "decorators": [],
          "start_line": 475,
          "end_line": 489,
          "is_async": false
        },
        {
          "name": "test_invalid_server_type",
          "signature": "def test_invalid_server_type(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test creating server with invalid type.",
          "decorators": [],
          "start_line": 497,
          "end_line": 541,
          "is_async": false
        },
        {
          "name": "test_multiple_server_types_coexist",
          "signature": "def test_multiple_server_types_coexist(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test that multiple server types can coexist.",
          "decorators": [],
          "start_line": 549,
          "end_line": 592,
          "is_async": false
        },
        {
          "name": "test_partial_update_preserves_fields",
          "signature": "def test_partial_update_preserves_fields(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test that partial updates preserve non-updated fields.",
          "decorators": [],
          "start_line": 595,
          "end_line": 633,
          "is_async": false
        },
        {
          "name": "test_concurrent_server_operations",
          "signature": "def test_concurrent_server_operations(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test multiple servers can be operated on concurrently.",
          "decorators": [],
          "start_line": 636,
          "end_line": 670,
          "is_async": false
        },
        {
          "name": "test_full_server_lifecycle",
          "signature": "def test_full_server_lifecycle(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test complete lifecycle: create, list, get, update, tools, delete.",
          "decorators": [],
          "start_line": 673,
          "end_line": 731,
          "is_async": false
        },
        {
          "name": "test_empty_tools_list",
          "signature": "def test_empty_tools_list(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test handling of servers with no tools.",
          "decorators": [],
          "start_line": 739,
          "end_line": 765,
          "is_async": false
        },
        {
          "name": "test_mcp_echo_tool_with_agent",
          "signature": "def test_mcp_echo_tool_with_agent(client: Letta, agent_with_mcp_tools: AgentState)",
          "parameters": "(client: Letta, agent_with_mcp_tools: AgentState)",
          "return_type": null,
          "docstring": "Test that an agent can successfully call the echo tool from the MCP server.",
          "decorators": [],
          "start_line": 773,
          "end_line": 807,
          "is_async": false
        },
        {
          "name": "test_mcp_add_tool_with_agent",
          "signature": "def test_mcp_add_tool_with_agent(client: Letta, agent_with_mcp_tools: AgentState)",
          "parameters": "(client: Letta, agent_with_mcp_tools: AgentState)",
          "return_type": null,
          "docstring": "Test that an agent can successfully call the add tool from the MCP server.",
          "decorators": [],
          "start_line": 810,
          "end_line": 845,
          "is_async": false
        },
        {
          "name": "test_mcp_multiple_tools_in_sequence_with_agent",
          "signature": "def test_mcp_multiple_tools_in_sequence_with_agent(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test that an agent can call multiple MCP tools in sequence.",
          "decorators": [],
          "start_line": 848,
          "end_line": 941,
          "is_async": false
        },
        {
          "name": "test_mcp_complex_schema_tool_with_agent",
          "signature": "def test_mcp_complex_schema_tool_with_agent(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test that an agent can successfully call a tool with complex nested schema.\n    This tests the get_parameter_type_description tool which has:\n    - Enum-like preset parameter\n    - Optional string field\n    - Optional nested object with arrays of objects",
          "decorators": [],
          "start_line": 944,
          "end_line": 1096,
          "is_async": false
        },
        {
          "name": "test_comprehensive_mcp_server_tool_listing",
          "signature": "def test_comprehensive_mcp_server_tool_listing(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Comprehensive test for MCP server registration, tool listing, and management.",
          "decorators": [],
          "start_line": 1099,
          "end_line": 1173,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406672
    },
    "tests/sdk/mock_mcp_server.py": {
      "path": "tests/sdk/mock_mcp_server.py",
      "contentHash": "3029f06b0e8d17366604ae1e45f2e347",
      "mtime": 1767315072140.548,
      "functions": [
        {
          "name": "echo",
          "signature": "def echo(message: str) -> str",
          "parameters": "(message: str)",
          "return_type": "str",
          "docstring": "Echo back a message.\n\n        Args:\n            message: The message to echo",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 61,
          "end_line": 67,
          "is_async": true
        },
        {
          "name": "add",
          "signature": "def add(a: float, b: float) -> str",
          "parameters": "(a: float, b: float)",
          "return_type": "str",
          "docstring": "Add two numbers.\n\n        Args:\n            a: First number\n            b: Second number",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 70,
          "end_line": 77,
          "is_async": true
        },
        {
          "name": "multiply",
          "signature": "def multiply(a: float, b: float) -> str",
          "parameters": "(a: float, b: float)",
          "return_type": "str",
          "docstring": "Multiply two numbers.\n\n        Args:\n            a: First number\n            b: Second number",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 80,
          "end_line": 87,
          "is_async": true
        },
        {
          "name": "reverse_string",
          "signature": "def reverse_string(text: str) -> str",
          "parameters": "(text: str)",
          "return_type": "str",
          "docstring": "Reverse a string.\n\n        Args:\n            text: The text to reverse",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 90,
          "end_line": 96,
          "is_async": true
        },
        {
          "name": "create_person",
          "signature": "def create_person(name: str, age: Optional[int] = None, email: Optional[str] = None, address: Optional[Address] = None) -> str",
          "parameters": "(name: str, age: Optional[int] = None, email: Optional[str] = None, address: Optional[Address] = None)",
          "return_type": "str",
          "docstring": "Create a person object with details.\n\n        Args:\n            name: Person's name\n            age: Person's age\n            email: Person's email\n            address: Person's address",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 100,
          "end_line": 117,
          "is_async": true
        },
        {
          "name": "manage_tasks",
          "signature": "def manage_tasks(action: str, task: Optional[str] = None) -> str",
          "parameters": "(action: str, task: Optional[str] = None)",
          "return_type": "str",
          "docstring": "Manage a list of tasks.\n\n        Args:\n            action: The action to perform (add, remove, list)\n            task: The task to add or remove",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 120,
          "end_line": 132,
          "is_async": true
        },
        {
          "name": "search_with_filters",
          "signature": "def search_with_filters(query: str, filters: Optional[Dict[str, Any]] = None) -> str",
          "parameters": "(query: str, filters: Optional[Dict[str, Any]] = None)",
          "return_type": "str",
          "docstring": "Search with various filters.\n\n        Args:\n            query: Search query\n            filters: Optional filters dictionary",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 135,
          "end_line": 142,
          "is_async": true
        },
        {
          "name": "process_nested_data",
          "signature": "def process_nested_data(data: Dict[str, Any]) -> str",
          "parameters": "(data: Dict[str, Any])",
          "return_type": "str",
          "docstring": "Process deeply nested data structures.\n\n        Args:\n            data: The nested data to process",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 145,
          "end_line": 151,
          "is_async": true
        },
        {
          "name": "get_parameter_type_description",
          "signature": "def get_parameter_type_description(\n        preset: str, connected_service_descriptor: Optional[str] = None, instantiation_data: Optional[InstantiationData] = None\n    ) -> str",
          "parameters": "(\n        preset: str, connected_service_descriptor: Optional[str] = None, instantiation_data: Optional[InstantiationData] = None\n    )",
          "return_type": "str",
          "docstring": "Get parameter type description with complex schema.\n\n        Args:\n            preset: Preset configuration (a, b, c)\n            connected_service_descriptor: Service descriptor\n            instantiation_data: Instantiation data with nested structure",
          "decorators": [
            "@mcp.tool()"
          ],
          "start_line": 154,
          "end_line": 169,
          "is_async": true
        },
        {
          "name": "main",
          "signature": "def main()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Run the MCP server using stdio transport.",
          "decorators": [],
          "start_line": 172,
          "end_line": 181,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406672
    },
    "tests/sdk/search_test.py": {
      "path": "tests/sdk/search_test.py",
      "contentHash": "62f9b7040f8455fb9a6b60c56961fbce",
      "mtime": 1767315072140.548,
      "functions": [
        {
          "name": "cleanup_agent_with_messages",
          "signature": "def cleanup_agent_with_messages(client: Letta, agent_id: str)",
          "parameters": "(client: Letta, agent_id: str)",
          "return_type": null,
          "docstring": "Helper function to properly clean up an agent by first deleting all its messages\n    from Turbopuffer before deleting the agent itself.\n\n    Args:\n        client: Letta SDK client\n        agent_id: ID of the agent to clean up",
          "decorators": [],
          "start_line": 26,
          "end_line": 53,
          "is_async": false
        },
        {
          "name": "cleanup_tool",
          "signature": "def cleanup_tool(client: Letta, tool_id: str)",
          "parameters": "(client: Letta, tool_id: str)",
          "return_type": null,
          "docstring": "Helper function to properly clean up a tool by deleting it from both\n    Turbopuffer and the database.\n\n    Args:\n        client: Letta SDK client\n        tool_id: ID of the tool to clean up",
          "decorators": [],
          "start_line": 56,
          "end_line": 81,
          "is_async": false
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Server fixture for testing",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 85,
          "end_line": 90,
          "is_async": false
        },
        {
          "name": "enable_turbopuffer",
          "signature": "def enable_turbopuffer()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Temporarily enable Turbopuffer for testing",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 94,
          "end_line": 111,
          "is_async": false
        },
        {
          "name": "enable_message_embedding",
          "signature": "def enable_message_embedding()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Enable both Turbopuffer and message embedding",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 115,
          "end_line": 132,
          "is_async": false
        },
        {
          "name": "disable_turbopuffer",
          "signature": "def disable_turbopuffer()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensure Turbopuffer is disabled for testing",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 136,
          "end_line": 147,
          "is_async": false
        },
        {
          "name": "test_passage_search_basic",
          "signature": "def test_passage_search_basic(client: Letta, enable_turbopuffer)",
          "parameters": "(client: Letta, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test basic passage search functionality through the SDK",
          "decorators": [
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 151,
          "end_line": 228,
          "is_async": false
        },
        {
          "name": "test_passage_search_with_tags",
          "signature": "def test_passage_search_with_tags(client: Letta, enable_turbopuffer)",
          "parameters": "(client: Letta, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test passage search with tag filtering",
          "decorators": [
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 232,
          "end_line": 290,
          "is_async": false
        },
        {
          "name": "test_passage_search_with_date_filters",
          "signature": "def test_passage_search_with_date_filters(client: Letta, enable_turbopuffer)",
          "parameters": "(client: Letta, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test passage search with date range filtering",
          "decorators": [
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 294,
          "end_line": 358,
          "is_async": false
        },
        {
          "name": "test_message_search_basic",
          "signature": "def test_message_search_basic(client: Letta, enable_message_embedding)",
          "parameters": "(client: Letta, enable_message_embedding)",
          "return_type": null,
          "docstring": "Test basic message search functionality through the SDK",
          "decorators": [
            "@pytest.mark.skipif(\n    not (settings.use_tpuf and settings.tpuf_api_key and model_settings.openai_api_key and settings.embed_all_messages),\n    reason=\"Message search requires Turbopuffer, OpenAI, and message embedding to be enabled\",\n)"
          ],
          "start_line": 365,
          "end_line": 422,
          "is_async": false
        },
        {
          "name": "test_passage_search_pagination",
          "signature": "def test_passage_search_pagination(client: Letta, enable_turbopuffer)",
          "parameters": "(client: Letta, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test passage search pagination",
          "decorators": [
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 426,
          "end_line": 497,
          "is_async": false
        },
        {
          "name": "test_passage_search_org_wide",
          "signature": "def test_passage_search_org_wide(client: Letta, enable_turbopuffer)",
          "parameters": "(client: Letta, enable_turbopuffer)",
          "return_type": null,
          "docstring": "Test organization-wide passage search (without agent_id or archive_id)",
          "decorators": [
            "@pytest.mark.skipif(not settings.tpuf_api_key, reason=\"Turbopuffer API key not configured\")"
          ],
          "start_line": 501,
          "end_line": 567,
          "is_async": false
        },
        {
          "name": "enable_tool_embedding",
          "signature": "def enable_tool_embedding()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Enable both Turbopuffer and tool embedding",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 571,
          "end_line": 588,
          "is_async": false
        },
        {
          "name": "test_tool_search_basic",
          "signature": "def test_tool_search_basic(client: Letta, enable_tool_embedding)",
          "parameters": "(client: Letta, enable_tool_embedding)",
          "return_type": null,
          "docstring": "Test basic tool search functionality through the SDK",
          "decorators": [
            "@pytest.mark.skipif(\n    not (settings.use_tpuf and settings.tpuf_api_key and model_settings.openai_api_key and settings.embed_tools),\n    reason=\"Tool search requires Turbopuffer, OpenAI, and tool embedding to be enabled\",\n)"
          ],
          "start_line": 595,
          "end_line": 727,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406672
    },
    "tests/test_agent_serialization.py": {
      "path": "tests/test_agent_serialization.py",
      "contentHash": "22486a0546aec1ae14772595cd2806da",
      "mtime": 1768610518550.2007,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "\"\"\"\n    Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until its accepting connections.\n    \"\"\"",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 39,
          "end_line": 72,
          "is_async": false
        },
        {
          "name": "lear_tables()",
          "signature": "def lear_tables():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 75,
          "end_line": 85,
          "is_async": false
        },
        {
          "name": "ear_tables()",
          "signature": "def ear_tables():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "ytest.fixture(autouse=True)\nd"
          ],
          "start_line": 89,
          "end_line": 90,
          "is_async": false
        },
        {
          "name": "rver()",
          "signature": "def rver():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "ytest.fixture\nd"
          ],
          "start_line": 94,
          "end_line": 100,
          "is_async": false
        },
        {
          "name": "fault_organization(s",
          "signature": "def fault_organization(server: SyncServer):\n",
          "parameters": "erver: SyncServer):\n",
          "return_type": null,
          "docstring": "\"Fixture to create and return the default organization.\"\"\"",
          "decorators": [
            "ytest.fixture\nd"
          ],
          "start_line": 104,
          "end_line": 107,
          "is_async": false
        },
        {
          "name": "fault_user(s",
          "signature": "def fault_user(server: SyncServer, default_organization):\n",
          "parameters": "erver: SyncServer, default_organization):\n",
          "return_type": null,
          "docstring": "\"Fixture to create and return the default user within the default organization.\"\"\"",
          "decorators": [
            "ytest.fixture\nd"
          ],
          "start_line": 111,
          "end_line": 114,
          "is_async": false
        },
        {
          "name": "her_organization(s",
          "signature": "def her_organization(server: SyncServer):\n",
          "parameters": "erver: SyncServer):\n",
          "return_type": null,
          "docstring": "\"Fixture to create and return the default organization.\"\"\"",
          "decorators": [
            "ytest.fixture\nd"
          ],
          "start_line": 118,
          "end_line": 125,
          "is_async": false
        },
        {
          "name": "her_user(s",
          "signature": "def her_user(server: SyncServer, other_organization):\n",
          "parameters": "erver: SyncServer, other_organization):\n",
          "return_type": null,
          "docstring": "\"Fixture to create and return the default user within the default organization.\"\"\"",
          "decorators": [
            "ytest.fixture\nd"
          ],
          "start_line": 129,
          "end_line": 136,
          "is_async": false
        },
        {
          "name": "ather_tool(s",
          "signature": "def ather_tool(server, weather_tool_func, default_user):\n",
          "parameters": "erver, weather_tool_func, default_user):\n",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "ytest.fixture\nd"
          ],
          "start_line": 140,
          "end_line": 142,
          "is_async": false
        },
        {
          "name": "int_tool(s",
          "signature": "def int_tool(server, print_tool_func, default_user):\n",
          "parameters": "erver, print_tool_func, default_user):\n",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "ytest.fixture\nd"
          ],
          "start_line": 146,
          "end_line": 148,
          "is_async": false
        },
        {
          "name": "fault_block(s",
          "signature": "def fault_block(server: SyncServer, default_user):\n",
          "parameters": "erver: SyncServer, default_user):\n",
          "return_type": null,
          "docstring": "\"Fixture to create and return a default block.\"\"\"",
          "decorators": [
            "ytest.fixture\nd"
          ],
          "start_line": 152,
          "end_line": 162,
          "is_async": false
        },
        {
          "name": "rialize_test_agent(s",
          "signature": "def rialize_test_agent(server: SyncServer, default_user, default_organization, default_block, weather_tool):\n",
          "parameters": "erver: SyncServer, default_user, default_organization, default_block, weather_tool):\n",
          "return_type": null,
          "docstring": "\"Fixture to create and return a sample agent within the default organization.\"\"\"",
          "decorators": [
            "ytest.fixture\nd"
          ],
          "start_line": 166,
          "end_line": 194,
          "is_async": false
        },
        {
          "name": "ct_to_pretty_json(d",
          "signature": "def ct_to_pretty_json(d: Dict[str, Any]) - -> r:\n",
          "parameters": ": Dict[str, Any]) -",
          "return_type": "r:\n",
          "docstring": "\"Convert a dictionary to a pretty JSON string with sorted keys, handling datetime objects.\"\"\"",
          "decorators": [],
          "start_line": 200,
          "end_line": 202,
          "is_async": false
        },
        {
          "name": "son_serializable(o",
          "signature": "def son_serializable(obj: Any) - -> y:\n",
          "parameters": "bj: Any) -",
          "return_type": "y:\n",
          "docstring": "\"Convert non-serializable objects (like datetime) to a JSON-friendly format.\"\"\"",
          "decorators": [],
          "start_line": 205,
          "end_line": 209,
          "is_async": false
        },
        {
          "name": "int_dict_diff(d",
          "signature": "def int_dict_diff(dict1: Dict[str, Any], dict2: Dict[str, Any]) - -> ne:\n",
          "parameters": "ict1: Dict[str, Any], dict2: Dict[str, Any]) -",
          "return_type": "ne:\n",
          "docstring": "\"Prints a detailed colorized diff between two dictionaries.\"\"\"",
          "decorators": [],
          "start_line": 212,
          "end_line": 225,
          "is_async": false
        },
        {
          "name": "e_prefix(value1",
          "signature": "def e_prefix(value1: Any, value2: Any) -> boo ->    \"",
          "parameters": ": Any, value2: Any) -> boo",
          "return_type": "   \"",
          "docstring": "k if two string values have the same major prefix (before the second hyphen).\"\"\"\n    if",
          "decorators": [],
          "start_line": 228,
          "end_line": 236,
          "is_async": false
        },
        {
          "name": "atetime_fields(d: Dic",
          "signature": "def atetime_fields(d: Dict[str, Any]) -> Dic -> r, Any]:\n    \"",
          "parameters": "t[str, Any]) -> Dic",
          "return_type": "r, Any]:\n    \"",
          "docstring": "ve datetime fields from a dictionary before comparison.\"\"\"\n    re",
          "decorators": [],
          "start_line": 250,
          "end_line": 252,
          "is_async": false
        },
        {
          "name": "smatch(key: s",
          "signature": "def smatch(key: str, expected: Any, actual: Any, log: bool = True) -> Non ->    \"",
          "parameters": "tr, expected: Any, actual: Any, log: bool = True) -> Non",
          "return_type": "   \"",
          "docstring": "detailed information about a mismatch.\"\"\"\n    if",
          "decorators": [],
          "start_line": 255,
          "end_line": 265,
          "is_async": false
        },
        {
          "name": "t_state_model_dump(d1: Dict[str",
          "signature": "def t_state_model_dump(d1: Dict[str, Any], d2: Dict[str, Any], log: bool = True) -> bool:\n    -> \n   ",
          "parameters": ", Any], d2: Dict[str, Any], log: bool = True) -> bool:\n   ",
          "return_type": "\n   ",
          "docstring": "re two dictionaries with special handling:\n    - Keys in `ignore_prefix_fields` should match only by prefix.\n    - 'message_ids' lists should match in length only.\n    - 'tool_exec_environment_variables' ignores values since they're cleared during serialization.\n    - 'json_schema' allows extra fields in d2 (from schema normalization during deserialization).\n    - Datetime fields are ignored.\n    - Order-independent comparison for lists of dicts.\n    \"\"\"\n    ignore_p",
          "decorators": [],
          "start_line": 268,
          "end_line": 339,
          "is_async": false
        },
        {
          "name": "ntext_message_id_remapping(server, og_a",
          "signature": "def ntext_message_id_remapping(server, og_agent: AgentState, copy_agent: AgentState, og_user, copy_user):\n    \"\"\"\n   ",
          "parameters": "gent: AgentState, copy_agent: AgentState, og_user, copy_user):\n    \"\"\"\n   ",
          "return_type": null,
          "docstring": "deserializing JSON into an Agent instance results in messages with\n    remapped IDs but identical relevant content and order.\n    \"\"\"\n    # Serial",
          "decorators": [],
          "start_line": 352,
          "end_line": 397,
          "is_async": false
        },
        {
          "name": "dentical_dicts():\n    d1 = ",
          "signature": "def dentical_dicts():\n    d1 = {\"",
          "parameters": "{\"",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 403,
          "end_line": 406,
          "is_async": false
        },
        {
          "name": "ifferent_dicts():\n    d1 = ",
          "signature": "def ifferent_dicts():\n    d1 = {\"",
          "parameters": "{\"",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 409,
          "end_line": 412,
          "is_async": false
        },
        {
          "name": "gnored_id_fields():\n    d1 = ",
          "signature": "def gnored_id_fields():\n    d1 = {\"",
          "parameters": "{\"",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 415,
          "end_line": 418,
          "is_async": false
        },
        {
          "name": "ifferent_id_prefix_fails():\n    d1 = ",
          "signature": "def ifferent_id_prefix_fails():\n    d1 = {\"",
          "parameters": "{\"",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 421,
          "end_line": 424,
          "is_async": false
        },
        {
          "name": "ested_dicts():\n    d1 = ",
          "signature": "def ested_dicts():\n    d1 = {\"",
          "parameters": "{\"",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 427,
          "end_line": 430,
          "is_async": false
        },
        {
          "name": "ist_handling():\n    d1 = ",
          "signature": "def ist_handling():\n    d1 = {\"",
          "parameters": "{\"",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 433,
          "end_line": 436,
          "is_async": false
        },
        {
          "name": "ist_mismatch():\n    d1 = ",
          "signature": "def ist_mismatch():\n    d1 = {\"",
          "parameters": "{\"",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 439,
          "end_line": 442,
          "is_async": false
        },
        {
          "name": "essage_ids_length_check():\n    d1 = ",
          "signature": "def essage_ids_length_check():\n    d1 = {\"",
          "parameters": "{\"",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 445,
          "end_line": 448,
          "is_async": false
        },
        {
          "name": "essage_ids_different_length():\n    d1 = ",
          "signature": "def essage_ids_different_length():\n    d1 = {\"",
          "parameters": "{\"",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 451,
          "end_line": 454,
          "is_async": false
        },
        {
          "name": "atetime_fields():\n    d1 = ",
          "signature": "def atetime_fields():\n    d1 = {\"",
          "parameters": "{\"",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 457,
          "end_line": 460,
          "is_async": false
        },
        {
          "name": "atetime_mismatch():\n    d1 = ",
          "signature": "def atetime_mismatch():\n    d1 = {\"",
          "parameters": "{\"",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 463,
          "end_line": 466,
          "is_async": false
        },
        {
          "name": "ize_simple(server, seri",
          "signature": "def ize_simple(server, serialize_test_agent, default_user, other_user):\n    \"\"\"Test",
          "parameters": "alize_test_agent, default_user, other_user):\n    \"\"\"Test",
          "return_type": null,
          "docstring": "ializing JSON into an Agent instance.\"\"\"\n    append_c",
          "decorators": [],
          "start_line": 472,
          "end_line": 482,
          "is_async": false
        },
        {
          "name": "ize_override_existing_tools(server, seri",
          "signature": "def ize_override_existing_tools(server, serialize_test_agent, default_user, weather_tool, print_tool, override_existing_tools):\n    \"\"\"\n   ",
          "parameters": "alize_test_agent, default_user, weather_tool, print_tool, override_existing_tools):\n    \"\"\"\n   ",
          "return_type": null,
          "docstring": "deserializing an agent with tools and ensure correct behavior for overriding existing tools.\n    \"\"\"\n    append_c",
          "decorators": [
            "parametrize(\"override_existing_tools\", [True, False])\ndef test_des"
          ],
          "start_line": 486,
          "end_line": 516,
          "is_async": false
        },
        {
          "name": "rialize_with_user_messages(server, seri",
          "signature": "def rialize_with_user_messages(server, serialize_test_agent, default_user, other_user):\n    \"\"\"Test",
          "parameters": "alize_test_agent, default_user, other_user):\n    \"\"\"Test",
          "return_type": null,
          "docstring": "ializing JSON into an Agent instance.\"\"\"\n    append_c",
          "decorators": [],
          "start_line": 519,
          "end_line": 545,
          "is_async": false
        },
        {
          "name": "rialize_tool_calls(disable_e2b_",
          "signature": "def rialize_tool_calls(disable_e2b_api_key, server, serialize_test_agent, default_user, other_user):\n    \"\"\"Test",
          "parameters": "api_key, server, serialize_test_agent, default_user, other_user):\n    \"\"\"Test",
          "return_type": null,
          "docstring": "ializing JSON into an Agent instance.\"\"\"\n    append_c",
          "decorators": [],
          "start_line": 548,
          "end_line": 581,
          "is_async": false
        },
        {
          "name": "rialize_update_blocks(disable_e2b_",
          "signature": "def rialize_update_blocks(disable_e2b_api_key, server, serialize_test_agent, default_user, other_user):\n    \"\"\"Test",
          "parameters": "api_key, server, serialize_test_agent, default_user, other_user):\n    \"\"\"Test",
          "return_type": null,
          "docstring": "ializing JSON into an Agent instance.\"\"\"\n    append_c",
          "decorators": [],
          "start_line": 584,
          "end_line": 623,
          "is_async": false
        },
        {
          "name": "wnload_upload_flow(server, serv",
          "signature": "def wnload_upload_flow(server, server_url, serialize_test_agent, default_user, other_user, append_copy_suffix, project_id):\n    \"\"\"\n   ",
          "parameters": "er_url, serialize_test_agent, default_user, other_user, append_copy_suffix, project_id):\n    \"\"\"\n   ",
          "return_type": null,
          "docstring": "the full E2E serialization and deserialization flow using FastAPI endpoints.\n    \"\"\"\n    agent_id",
          "decorators": [
            "parametrize(\"append_copy_suffix\", [True, False])\n@pytest.mark",
            "parametrize(\"project_id\", [\"project-12345\", None])\ndef test_age"
          ],
          "start_line": 631,
          "end_line": 683,
          "is_async": false
        },
        {
          "name": "gentfile_from_disk(server, serv",
          "signature": "def gentfile_from_disk(server, server_url, disable_e2b_api_key, other_user, filename):\n    \"\"\"\n   ",
          "parameters": "er_url, disable_e2b_api_key, other_user, filename):\n    \"\"\"\n   ",
          "return_type": null,
          "docstring": "uploading each .af file from the test_agent_files directory via live FastAPI server.\n    \"\"\"\n    file_pat",
          "decorators": [
            "parametrize(\n    \"filename\",\n    [\n        \"outreach_workflow_agent.af\",\n        \"customer_service.af\",\n        \"deep_research_agent.af\",\n        \"memgpt_agent_with_convo.af\",\n    ],\n)\ndef test_upl"
          ],
          "start_line": 695,
          "end_line": 726,
          "is_async": false
        },
        {
          "name": "e_with_max_steps(server, serv",
          "signature": "def e_with_max_steps(server, server_url, default_user, other_user):\n    \"\"\"Test",
          "parameters": "er_url, default_user, other_user):\n    \"\"\"Test",
          "return_type": null,
          "docstring": "max_steps parameter correctly limits messages by conversation steps.\"\"\"\n    # load a",
          "decorators": [],
          "start_line": 729,
          "end_line": 774,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406672
    },
    "tests/test_agent_serialization_v2.py": {
      "path": "tests/test_agent_serialization_v2.py",
      "contentHash": "17c96598eb0f6d29a53ddd0b01203fed",
      "mtime": 1768610518550.2007,
      "functions": [
        {
          "name": "clear_tables",
          "signature": "def clear_tables()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 51,
          "end_line": 52,
          "is_async": true
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 56,
          "end_line": 63,
          "is_async": true
        },
        {
          "name": "default_organization",
          "signature": "def default_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 67,
          "end_line": 70,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(server: SyncServer, default_organization)",
          "parameters": "(server: SyncServer, default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 74,
          "end_line": 77,
          "is_async": true
        },
        {
          "name": "other_organization",
          "signature": "def other_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Fixture to create and return another organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 81,
          "end_line": 84,
          "is_async": true
        },
        {
          "name": "other_user",
          "signature": "def other_user(server: SyncServer, other_organization)",
          "parameters": "(server: SyncServer, other_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return another user within the other organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 88,
          "end_line": 91,
          "is_async": true
        },
        {
          "name": "weather_tool_func",
          "signature": "def weather_tool_func()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 95,
          "end_line": 107,
          "is_async": false
        },
        {
          "name": "print_tool_func",
          "signature": "def print_tool_func()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 111,
          "end_line": 124,
          "is_async": false
        },
        {
          "name": "weather_tool",
          "signature": "def weather_tool(server, weather_tool_func, default_user)",
          "parameters": "(server, weather_tool_func, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 128,
          "end_line": 130,
          "is_async": true
        },
        {
          "name": "print_tool",
          "signature": "def print_tool(server, print_tool_func, default_user)",
          "parameters": "(server, print_tool_func, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 134,
          "end_line": 136,
          "is_async": true
        },
        {
          "name": "test_block",
          "signature": "def test_block(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Fixture to create and return a test block.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 140,
          "end_line": 150,
          "is_async": true
        },
        {
          "name": "agent_serialization_manager",
          "signature": "def agent_serialization_manager(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": "Fixture to create AgentSerializationManager with all required services including file processing.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 154,
          "end_line": 167,
          "is_async": false
        },
        {
          "name": "send_message_to_agent",
          "signature": "def send_message_to_agent(server: SyncServer, agent_state, actor: User, messages: list[MessageCreate])",
          "parameters": "(server: SyncServer, agent_state, actor: User, messages: list[MessageCreate])",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 170,
          "end_line": 184,
          "is_async": true
        },
        {
          "name": "test_agent",
          "signature": "def test_agent(server: SyncServer, default_user, default_organization, test_block, weather_tool)",
          "parameters": "(server: SyncServer, default_user, default_organization, test_block, weather_tool)",
          "return_type": null,
          "docstring": "Fixture to create and return a test agent with messages.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 188,
          "end_line": 226,
          "is_async": true
        },
        {
          "name": "embedding_handle_override",
          "signature": "def embedding_handle_override()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 230,
          "end_line": 235,
          "is_async": false
        },
        {
          "name": "test_source",
          "signature": "def test_source(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Fixture to create and return a test source.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 239,
          "end_line": 247,
          "is_async": true
        },
        {
          "name": "test_file",
          "signature": "def test_file(server: SyncServer, default_user, test_source)",
          "parameters": "(server: SyncServer, default_user, test_source)",
          "return_type": null,
          "docstring": "Fixture to create and return a test file attached to test_source.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 251,
          "end_line": 263,
          "is_async": true
        },
        {
          "name": "agent_with_files",
          "signature": "def agent_with_files(server: SyncServer, default_user, test_block, weather_tool, test_source, test_file)",
          "parameters": "(server: SyncServer, default_user, test_block, weather_tool, test_source, test_file)",
          "return_type": null,
          "docstring": "Fixture to create and return an agent with attached files.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 267,
          "end_line": 304,
          "is_async": true
        },
        {
          "name": "test_mcp_server",
          "signature": "def test_mcp_server(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Fixture to create and return a test MCP server.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 308,
          "end_line": 320,
          "is_async": true
        },
        {
          "name": "mcp_tool",
          "signature": "def mcp_tool(server: SyncServer, default_user, test_mcp_server)",
          "parameters": "(server: SyncServer, default_user, test_mcp_server)",
          "return_type": null,
          "docstring": "Fixture to create and return an MCP tool.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 324,
          "end_line": 338,
          "is_async": true
        },
        {
          "name": "agent_with_mcp_tools",
          "signature": "def agent_with_mcp_tools(server: SyncServer, default_user, test_block, mcp_tool, test_mcp_server)",
          "parameters": "(server: SyncServer, default_user, test_block, mcp_tool, test_mcp_server)",
          "return_type": null,
          "docstring": "Fixture to create and return an agent with MCP tools.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 342,
          "end_line": 366,
          "is_async": true
        },
        {
          "name": "create_test_source",
          "signature": "def create_test_source(server: SyncServer, name: str, user: User)",
          "parameters": "(server: SyncServer, name: str, user: User)",
          "return_type": null,
          "docstring": "Helper function to create a test source using server.",
          "decorators": [],
          "start_line": 374,
          "end_line": 381,
          "is_async": true
        },
        {
          "name": "create_test_file",
          "signature": "def create_test_file(server: SyncServer, filename: str, source_id: str, user: User, content: Optional[str] = None)",
          "parameters": "(server: SyncServer, filename: str, source_id: str, user: User, content: Optional[str] = None)",
          "return_type": null,
          "docstring": "Helper function to create a test file using server.",
          "decorators": [],
          "start_line": 384,
          "end_line": 396,
          "is_async": true
        },
        {
          "name": "create_test_agent_with_files",
          "signature": "def create_test_agent_with_files(server: SyncServer, name: str, user: User, file_relationships: List[tuple])",
          "parameters": "(server: SyncServer, name: str, user: User, file_relationships: List[tuple])",
          "return_type": null,
          "docstring": "Helper function to create agent with attached files using server.\n\n    Args:\n        server: SyncServer instance\n        name: Agent name\n        user: User creating the agent\n        file_relationships: List of (source_id, file_id) tuples",
          "decorators": [],
          "start_line": 399,
          "end_line": 434,
          "is_async": true
        },
        {
          "name": "compare_agent_files",
          "signature": "def compare_agent_files(original: AgentFileSchema, imported: AgentFileSchema) -> bool",
          "parameters": "(original: AgentFileSchema, imported: AgentFileSchema)",
          "return_type": "bool",
          "docstring": "Compare two AgentFileSchema objects for logical equivalence.",
          "decorators": [],
          "start_line": 437,
          "end_line": 493,
          "is_async": false
        },
        {
          "name": "validate_id_format",
          "signature": "def validate_id_format(schema: AgentFileSchema) -> bool",
          "parameters": "(schema: AgentFileSchema)",
          "return_type": "bool",
          "docstring": "Validate that all IDs follow the expected format (entity-N).",
          "decorators": [],
          "start_line": 724,
          "end_line": 754,
          "is_async": false
        }
      ],
      "parsedAt": 1769609406673
    },
    "tests/test_cli.py": {
      "path": "tests/test_cli.py",
      "contentHash": "d3a4e92b843c7c6a83ab3563c4f2146f",
      "mtime": 1767315072148.5483,
      "functions": [
        {
          "name": "swap_letta_config",
          "signature": "def swap_letta_config()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 16,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "test_letta_run_create_new_agent",
          "signature": "def test_letta_run_create_new_agent(swap_letta_config)",
          "parameters": "(swap_letta_config)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 77,
          "is_async": false
        },
        {
          "name": "test_letta_version_prints_only_version",
          "signature": "def test_letta_version_prints_only_version(swap_letta_config)",
          "parameters": "(swap_letta_config)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 80,
          "end_line": 90,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317301
    },
    "tests/test_client.py": {
      "path": "tests/test_client.py",
      "contentHash": "7e0b5aab44c1087a859ddb99b49d7c76",
      "mtime": 1768610518550.2007,
      "functions": [
        {
          "name": "run_server",
          "signature": "def run_server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 28,
          "end_line": 34,
          "is_async": false
        },
        {
          "name": "mock_openai_server",
          "signature": "def mock_openai_server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Local mock for the OpenAI API used by tests.\n\n    These tests should not require a real OPENAI_API_KEY.\n    We still exercise the OpenAI embeddings codepath by serving a minimal subset of the API.",
          "decorators": [
            "@pytest.fixture(\n    scope=\"module\",\n)"
          ],
          "start_line": 40,
          "end_line": 141,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(request, mock_openai_server)",
          "parameters": "(request, mock_openai_server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(\n    scope=\"module\",\n)"
          ],
          "start_line": 147,
          "end_line": 161,
          "is_async": false
        },
        {
          "name": "agent",
          "signature": "def agent(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 166,
          "end_line": 177,
          "is_async": false
        },
        {
          "name": "search_agent_one",
          "signature": "def search_agent_one(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 182,
          "end_line": 193,
          "is_async": false
        },
        {
          "name": "search_agent_two",
          "signature": "def search_agent_two(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 198,
          "end_line": 209,
          "is_async": false
        },
        {
          "name": "clear_tables",
          "signature": "def clear_tables()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Clear the sandbox tables before each test.",
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 213,
          "end_line": 222,
          "is_async": true
        },
        {
          "name": "test_add_and_manage_tags_for_agent",
          "signature": "def test_add_and_manage_tags_for_agent(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Comprehensive happy path test for adding, retrieving, and managing tags on an agent.",
          "decorators": [],
          "start_line": 230,
          "end_line": 273,
          "is_async": false
        },
        {
          "name": "test_agent_tags",
          "signature": "def test_agent_tags(client: Letta, clear_tables)",
          "parameters": "(client: Letta, clear_tables)",
          "return_type": null,
          "docstring": "Test creating agents with tags and retrieving tags via the API.",
          "decorators": [],
          "start_line": 276,
          "end_line": 333,
          "is_async": false
        },
        {
          "name": "test_shared_blocks",
          "signature": "def test_shared_blocks(disable_e2b_api_key, client: Letta)",
          "parameters": "(disable_e2b_api_key, client: Letta)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 339,
          "end_line": 367,
          "is_async": false
        },
        {
          "name": "test_update_agent_memory_label",
          "signature": "def test_update_agent_memory_label(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test that we can update the label of a block in an agent's memory",
          "decorators": [],
          "start_line": 370,
          "end_line": 391,
          "is_async": false
        },
        {
          "name": "test_attach_detach_agent_memory_block",
          "signature": "def test_attach_detach_agent_memory_block(client: Letta, agent: AgentState)",
          "parameters": "(client: Letta, agent: AgentState)",
          "return_type": null,
          "docstring": "Test that we can add and remove a block from an agent's memory",
          "decorators": [],
          "start_line": 394,
          "end_line": 419,
          "is_async": false
        },
        {
          "name": "test_update_agent_memory_limit",
          "signature": "def test_update_agent_memory_limit(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test that we can update the limit of a block in an agent's memory",
          "decorators": [],
          "start_line": 422,
          "end_line": 466,
          "is_async": false
        },
        {
          "name": "test_function_always_error",
          "signature": "def test_function_always_error(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test to see if function that errors works correctly",
          "decorators": [],
          "start_line": 474,
          "end_line": 519,
          "is_async": false
        },
        {
          "name": "test_attach_detach_agent_tool",
          "signature": "def test_attach_detach_agent_tool(client: Letta, agent: AgentState)",
          "parameters": "(client: Letta, agent: AgentState)",
          "return_type": null,
          "docstring": "Test that we can attach and detach a tool from an agent",
          "decorators": [],
          "start_line": 522,
          "end_line": 564,
          "is_async": false
        },
        {
          "name": "test_messages",
          "signature": "def test_messages(client: Letta, agent: AgentState)",
          "parameters": "(client: Letta, agent: AgentState)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 570,
          "end_line": 585,
          "is_async": false
        },
        {
          "name": "test_agent_listing",
          "signature": "def test_agent_listing(client: Letta, agent, search_agent_one, search_agent_two)",
          "parameters": "(client: Letta, agent, search_agent_one, search_agent_two)",
          "return_type": null,
          "docstring": "Test listing agents with pagination and query text filtering.",
          "decorators": [],
          "start_line": 626,
          "end_line": 657,
          "is_async": false
        },
        {
          "name": "test_agent_creation",
          "signature": "def test_agent_creation(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test that block IDs are properly attached when creating an agent.",
          "decorators": [],
          "start_line": 660,
          "end_line": 716,
          "is_async": false
        },
        {
          "name": "test_initial_sequence",
          "signature": "def test_initial_sequence(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 722,
          "end_line": 751,
          "is_async": false
        },
        {
          "name": "test_attach_sleeptime_block",
          "signature": "def test_attach_sleeptime_block(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 790,
          "end_line": 820,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317301
    },
    "tests/test_embeddings.py": {
      "path": "tests/test_embeddings.py",
      "contentHash": "27e4f5894825af6e87fec85893d3f1fe",
      "mtime": 1767315072148.5483,
      "functions": [
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 28,
          "end_line": 34,
          "is_async": true
        },
        {
          "name": "default_organization",
          "signature": "def default_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 38,
          "end_line": 41,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(server: SyncServer, default_organization)",
          "parameters": "(server: SyncServer, default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 45,
          "end_line": 48,
          "is_async": true
        },
        {
          "name": "test_embeddings",
          "signature": "def test_embeddings(embedding_config: EmbeddingConfig, default_user)",
          "parameters": "(embedding_config: EmbeddingConfig, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\n    \"embedding_config\",\n    embedding_configs,\n    ids=[c.embedding_model for c in embedding_configs],\n)"
          ],
          "start_line": 57,
          "end_line": 66,
          "is_async": true
        },
        {
          "name": "test_openai_embedding_chunking",
          "signature": "def test_openai_embedding_chunking(default_user)",
          "parameters": "(default_user)",
          "return_type": null,
          "docstring": "Test that large inputs are split into 2048-sized chunks",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 70,
          "end_line": 99,
          "is_async": true
        },
        {
          "name": "test_openai_embedding_retry_logic",
          "signature": "def test_openai_embedding_retry_logic(default_user)",
          "parameters": "(default_user)",
          "return_type": null,
          "docstring": "Test that failed chunks are retried with reduced batch size",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 103,
          "end_line": 141,
          "is_async": true
        },
        {
          "name": "test_openai_embedding_order_preserved",
          "signature": "def test_openai_embedding_order_preserved(default_user)",
          "parameters": "(default_user)",
          "return_type": null,
          "docstring": "Test that order is maintained despite chunking and retries",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 145,
          "end_line": 177,
          "is_async": true
        },
        {
          "name": "test_openai_embedding_minimum_chunk_failure",
          "signature": "def test_openai_embedding_minimum_chunk_failure(default_user)",
          "parameters": "(default_user)",
          "return_type": null,
          "docstring": "Test that persistent failures at minimum chunk size raise error",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 181,
          "end_line": 205,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317301
    },
    "tests/test_exception_logging.py": {
      "path": "tests/test_exception_logging.py",
      "contentHash": "c9dcc1a4f3408a1d5f3b9da255f425fb",
      "mtime": 1767315072148.5483,
      "functions": [
        {
          "name": "app_with_exception_middleware",
          "signature": "def app_with_exception_middleware()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Create a test FastAPI app with logging middleware.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 19,
          "end_line": 42,
          "is_async": false
        },
        {
          "name": "test_exception_middleware_logs_basic_exception",
          "signature": "def test_exception_middleware_logs_basic_exception(app_with_exception_middleware)",
          "parameters": "(app_with_exception_middleware)",
          "return_type": null,
          "docstring": "Test that the middleware logs exceptions with basic context.",
          "decorators": [],
          "start_line": 45,
          "end_line": 69,
          "is_async": false
        },
        {
          "name": "test_exception_middleware_logs_custom_context",
          "signature": "def test_exception_middleware_logs_custom_context(app_with_exception_middleware)",
          "parameters": "(app_with_exception_middleware)",
          "return_type": null,
          "docstring": "Test that the middleware logs custom context attached to exceptions.",
          "decorators": [],
          "start_line": 72,
          "end_line": 90,
          "is_async": false
        },
        {
          "name": "test_exception_middleware_does_not_interfere_with_success",
          "signature": "def test_exception_middleware_does_not_interfere_with_success(app_with_exception_middleware)",
          "parameters": "(app_with_exception_middleware)",
          "return_type": null,
          "docstring": "Test that the middleware doesn't interfere with successful requests.",
          "decorators": [],
          "start_line": 93,
          "end_line": 99,
          "is_async": false
        },
        {
          "name": "test_add_exception_context",
          "signature": "def test_add_exception_context()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that add_exception_context properly attaches context to exceptions.",
          "decorators": [],
          "start_line": 102,
          "end_line": 121,
          "is_async": false
        },
        {
          "name": "test_add_exception_context_multiple_times",
          "signature": "def test_add_exception_context_multiple_times()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that add_exception_context can be called multiple times.",
          "decorators": [],
          "start_line": 124,
          "end_line": 134,
          "is_async": false
        },
        {
          "name": "test_log_and_raise",
          "signature": "def test_log_and_raise()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that log_and_raise logs and then raises the exception.",
          "decorators": [],
          "start_line": 137,
          "end_line": 161,
          "is_async": false
        },
        {
          "name": "test_log_exception",
          "signature": "def test_log_exception()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that log_exception logs without raising.",
          "decorators": [],
          "start_line": 164,
          "end_line": 187,
          "is_async": false
        },
        {
          "name": "test_log_exception_with_different_levels",
          "signature": "def test_log_exception_with_different_levels()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that log_exception respects different log levels.",
          "decorators": [],
          "start_line": 190,
          "end_line": 201,
          "is_async": false
        },
        {
          "name": "test_global_exception_handler_setup",
          "signature": "def test_global_exception_handler_setup()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that global exception handlers can be set up without errors.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 205,
          "end_line": 215,
          "is_async": true
        },
        {
          "name": "test_asyncio_exception_handler",
          "signature": "def test_asyncio_exception_handler()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that asyncio exception handler can be set up.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 219,
          "end_line": 226,
          "is_async": true
        },
        {
          "name": "test_exception_middleware_preserves_traceback",
          "signature": "def test_exception_middleware_preserves_traceback(app_with_exception_middleware)",
          "parameters": "(app_with_exception_middleware)",
          "return_type": null,
          "docstring": "Test that the middleware preserves traceback information.",
          "decorators": [],
          "start_line": 229,
          "end_line": 246,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317301
    },
    "tests/test_google_embeddings.py": {
      "path": "tests/test_google_embeddings.py",
      "contentHash": "a56cf55780707dc12241e8cd64e311a0",
      "mtime": 1767315072148.5483,
      "functions": [
        {
          "name": "run_server",
          "signature": "def run_server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 18,
          "end_line": 24,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client() -> LettaSDKClient",
          "parameters": "()",
          "return_type": "LettaSDKClient",
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 28,
          "end_line": 38,
          "is_async": false
        },
        {
          "name": "test_google_embeddings_response",
          "signature": "def test_google_embeddings_response()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 41,
          "end_line": 56,
          "is_async": false
        },
        {
          "name": "test_archival_insert_text_embedding_004",
          "signature": "def test_archival_insert_text_embedding_004(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test that an agent with model 'gemini-2.0-flash-exp' and embedding 'text_embedding_004'\n    correctly inserts a message into its archival memory.\n\n    The test works by:\n      1. Creating an agent with the desired model and embedding.\n      2. Sending a message prefixed with 'archive :' to instruct the agent to store the message in archival.\n      3. Retrieving the archival memory via the agent messaging API.\n      4. Verifying that the archival message is stored.",
          "decorators": [],
          "start_line": 59,
          "end_line": 104,
          "is_async": false
        },
        {
          "name": "test_archival_insert_embedding_001",
          "signature": "def test_archival_insert_embedding_001(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test that an agent with model 'gemini-2.0-flash-exp' and embedding 'embedding_001'\n    correctly inserts a message into its archival memory.\n\n    The test works by:\n      1. Creating an agent with the desired model and embedding.\n      2. Sending a message prefixed with 'archive :' to instruct the agent to store the message in archival.\n      3. Retrieving the archival memory via the agent messaging API.\n      4. Verifying that the archival message is stored.",
          "decorators": [],
          "start_line": 107,
          "end_line": 150,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317301
    },
    "tests/test_internal_agents_count.py": {
      "path": "tests/test_internal_agents_count.py",
      "contentHash": "ad42739eb7424d22f27670a1e3ac3f3d",
      "mtime": 1767315072148.5483,
      "functions": [
        {
          "name": "test_agents",
          "signature": "def test_agents(client: Letta) -> List[AgentState]",
          "parameters": "(client: Letta)",
          "return_type": "List[AgentState]",
          "docstring": "Creates test agents - some hidden, some not hidden.\n    Cleans them up after the test.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 12,
          "end_line": 61,
          "is_async": false
        },
        {
          "name": "test_internal_agents_count_exclude_hidden",
          "signature": "def test_internal_agents_count_exclude_hidden(client: Letta, test_agents: List[AgentState])",
          "parameters": "(client: Letta, test_agents: List[AgentState])",
          "return_type": null,
          "docstring": "Test that the internal agents count endpoint correctly excludes hidden agents\n    when exclude_hidden=True (default).",
          "decorators": [],
          "start_line": 64,
          "end_line": 98,
          "is_async": false
        },
        {
          "name": "test_internal_agents_count_include_all",
          "signature": "def test_internal_agents_count_include_all(client: Letta, test_agents: List[AgentState])",
          "parameters": "(client: Letta, test_agents: List[AgentState])",
          "return_type": null,
          "docstring": "Test that the internal agents count endpoint correctly includes all agents\n    when exclude_hidden=False.",
          "decorators": [],
          "start_line": 101,
          "end_line": 118,
          "is_async": false
        },
        {
          "name": "test_internal_agents_count_default_behavior",
          "signature": "def test_internal_agents_count_default_behavior(client: Letta, test_agents: List[AgentState])",
          "parameters": "(client: Letta, test_agents: List[AgentState])",
          "return_type": null,
          "docstring": "Test that the default behavior (exclude_hidden=True) works correctly.",
          "decorators": [],
          "start_line": 121,
          "end_line": 150,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317301
    },
    "tests/test_letta_agent_batch.py": {
      "path": "tests/test_letta_agent_batch.py",
      "contentHash": "370a567fd12c150230e3d8fadf923086",
      "mtime": 1767315072148.5483,
      "functions": [
        {
          "name": "weather_tool",
          "signature": "def weather_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 53,
          "end_line": 81,
          "is_async": true
        },
        {
          "name": "rethink_tool",
          "signature": "def rethink_tool(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 85,
          "end_line": 104,
          "is_async": true
        },
        {
          "name": "agents",
          "signature": "def agents(server, weather_tool)",
          "parameters": "(server, weather_tool)",
          "return_type": null,
          "docstring": "Create three test agents with different models.\n\n    Returns:\n        Tuple[Agent, Agent, Agent]: Three agents with sonnet, haiku, and opus models",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 108,
          "end_line": 135,
          "is_async": true
        },
        {
          "name": "batch_requests",
          "signature": "def batch_requests(agents)",
          "parameters": "(agents)",
          "return_type": null,
          "docstring": "Create batch requests for each test agent.\n\n    Args:\n        agents: The test agents fixture\n\n    Returns:\n        List[LettaBatchRequest]: Batch requests for each agent",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 139,
          "end_line": 152,
          "is_async": false
        },
        {
          "name": "step_state_map",
          "signature": "def step_state_map(agents)",
          "parameters": "(agents)",
          "return_type": null,
          "docstring": "Create a mapping of agent IDs to their step states.\n\n    Args:\n        agents: The test agents fixture\n\n    Returns:\n        Dict[str, AgentStepState]: Mapping of agent IDs to step states",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 156,
          "end_line": 167,
          "is_async": false
        },
        {
          "name": "create_batch_response",
          "signature": "def create_batch_response(batch_id: str, processing_status: str = \"in_progress\") -> BetaMessageBatch",
          "parameters": "(batch_id: str, processing_status: str = \"in_progress\")",
          "return_type": "BetaMessageBatch",
          "docstring": "Create a dummy BetaMessageBatch with the specified ID and status.",
          "decorators": [],
          "start_line": 170,
          "end_line": 190,
          "is_async": false
        },
        {
          "name": "create_get_weather_tool_response",
          "signature": "def create_get_weather_tool_response(custom_id: str, model: str, request_heartbeat: bool) -> BetaMessageBatchIndividualResponse",
          "parameters": "(custom_id: str, model: str, request_heartbeat: bool)",
          "return_type": "BetaMessageBatchIndividualResponse",
          "docstring": "Create a dummy successful batch response with a tool call after user asks about weather.",
          "decorators": [],
          "start_line": 193,
          "end_line": 221,
          "is_async": false
        },
        {
          "name": "create_rethink_tool_response",
          "signature": "def create_rethink_tool_response(\n    custom_id: str, model: str, request_heartbeat: bool, new_memory: str, target_block_label: str\n) -> BetaMessageBatchIndividualResponse",
          "parameters": "(\n    custom_id: str, model: str, request_heartbeat: bool, new_memory: str, target_block_label: str\n)",
          "return_type": "BetaMessageBatchIndividualResponse",
          "docstring": "Create a dummy successful batch response with a tool call after user asks about weather.",
          "decorators": [],
          "start_line": 224,
          "end_line": 254,
          "is_async": false
        },
        {
          "name": "create_failed_response",
          "signature": "def create_failed_response(custom_id: str) -> BetaMessageBatchIndividualResponse",
          "parameters": "(custom_id: str)",
          "return_type": "BetaMessageBatchIndividualResponse",
          "docstring": "Create a dummy failed batch response with a rate limit error.",
          "decorators": [],
          "start_line": 257,
          "end_line": 265,
          "is_async": false
        },
        {
          "name": "dummy_batch_response",
          "signature": "def dummy_batch_response()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Create a minimal dummy batch response similar to what Anthropic would return.\n\n    Returns:\n        BetaMessageBatch: A dummy batch response",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 269,
          "end_line": 278,
          "is_async": false
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Creates a SyncServer instance for testing.\n\n    Loads and saves config to ensure proper initialization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 297,
          "end_line": 309,
          "is_async": true
        },
        {
          "name": "default_organization",
          "signature": "def default_organization(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 313,
          "end_line": 316,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(server, default_organization)",
          "parameters": "(server, default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 320,
          "end_line": 323,
          "is_async": true
        },
        {
          "name": "batch_job",
          "signature": "def batch_job(default_user, server)",
          "parameters": "(default_user, server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 327,
          "end_line": 339,
          "is_async": true
        },
        {
          "name": "test_rethink_tool_modify_agent_state",
          "signature": "def test_rethink_tool_modify_agent_state(disable_e2b_api_key, server, default_user, batch_job, rethink_tool)",
          "parameters": "(disable_e2b_api_key, server, default_user, batch_job, rethink_tool)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 361,
          "end_line": 443,
          "is_async": true
        },
        {
          "name": "test_partial_error_from_anthropic_batch",
          "signature": "def test_partial_error_from_anthropic_batch(\n    disable_e2b_api_key, server, default_user, agents: Tuple[AgentState], batch_requests, step_state_map, batch_job\n)",
          "parameters": "(\n    disable_e2b_api_key, server, default_user, agents: Tuple[AgentState], batch_requests, step_state_map, batch_job\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 447,
          "end_line": 610,
          "is_async": true
        },
        {
          "name": "ep_some_stop(\n    disable_",
          "signature": "def ep_some_stop(\n    disable_e2b_api_key, server, default_user, agents: Tuple[AgentState], batch_requests, step_state_map, batch_job\n):\n    anthropi",
          "parameters": "e2b_api_key, server, default_user, agents: Tuple[AgentState], batch_requests, step_state_map, batch_job\n):\n    anthropi",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 614,
          "end_line": 764,
          "is_async": true
        },
        {
          "name": "sages):\n    \"\"\"Assert me",
          "signature": "def sages):\n    \"\"\"Assert messages are",
          "parameters": "ssages are",
          "return_type": null,
          "docstring": "notonically decreasing by created_at timestamps.\"\"\"\n    if len(messages) <= 1:",
          "decorators": [],
          "start_line": 767,
          "end_line": 776,
          "is_async": false
        },
        {
          "name": "st_all_continue(\n    disable_e2b_api_key, s",
          "signature": "def st_all_continue(\n    disable_e2b_api_key, server, default_user, agents: Tuple[AgentState], batch_requests, step_state_map, batch_job\n):\n    anthropic_batch_id = \"",
          "parameters": "erver, default_user, agents: Tuple[AgentState], batch_requests, step_state_map, batch_job\n):\n    anthropic_batch_id = \"",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "ef test_resume_step_"
          ],
          "start_line": 780,
          "end_line": 917,
          "is_async": true
        },
        {
          "name": "ts_batch_correctly(\n    disable_e2b_api_key, server, default",
          "signature": "def ts_batch_correctly(\n    disable_e2b_api_key, server, default_user, agents, batch_requests, step_state_map, dummy_batch_response, batch_job\n):\n    \"\"\"\n    Test that step_until_request",
          "parameters": "_user, agents, batch_requests, step_state_map, dummy_batch_response, batch_job\n):\n    \"\"\"\n    Test that step_until_request",
          "return_type": null,
          "docstring": "ctly:\n    1. Prepares the proper payload format for each agent\n    2. Creates the appropriate database records\n    3. Returns correct batch information\n\n    This test mocks the actual API call to Anthropic while validating\n    that the correct data would be sent.\n    \"\"\"\n    agent_sonnet, agent_haiku, agent_opus",
          "decorators": [
            "ntil_request_prepare"
          ],
          "start_line": 921,
          "end_line": 1023,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317302
    },
    "tests/test_llm_clients.py": {
      "path": "tests/test_llm_clients.py",
      "contentHash": "8c0aba76d3b5cfe1a18aaf5c21a7e9c6",
      "mtime": 1767315072148.5483,
      "functions": [
        {
          "name": "llm_config",
          "signature": "def llm_config()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 14,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "anthropic_client",
          "signature": "def anthropic_client()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 29,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "mock_agent_messages",
          "signature": "def mock_agent_messages()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 34,
          "end_line": 46,
          "is_async": false
        },
        {
          "name": "mock_agent_tools",
          "signature": "def mock_agent_tools()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 50,
          "end_line": 63,
          "is_async": false
        },
        {
          "name": "mock_agent_llm_config",
          "signature": "def mock_agent_llm_config(llm_config)",
          "parameters": "(llm_config)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 67,
          "end_line": 68,
          "is_async": false
        },
        {
          "name": "test_send_llm_batch_request_async_success",
          "signature": "def test_send_llm_batch_request_async_success(\n    anthropic_client, mock_agent_messages, mock_agent_tools, mock_agent_llm_config, dummy_beta_message_batch\n)",
          "parameters": "(\n    anthropic_client, mock_agent_messages, mock_agent_tools, mock_agent_llm_config, dummy_beta_message_batch\n)",
          "return_type": null,
          "docstring": "Test a successful batch request using mocked Anthropic client responses.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 72,
          "end_line": 94,
          "is_async": true
        },
        {
          "name": "test_send_llm_batch_request_async_mismatched_keys",
          "signature": "def test_send_llm_batch_request_async_mismatched_keys(anthropic_client, mock_agent_messages, mock_agent_llm_config)",
          "parameters": "(anthropic_client, mock_agent_messages, mock_agent_llm_config)",
          "return_type": null,
          "docstring": "This test verifies that if the keys in the messages and tools mappings do not match,\n    a ValueError is raised.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 98,
          "end_line": 107,
          "is_async": true
        },
        {
          "name": "test_count_tokens_with_empty_messages",
          "signature": "def test_count_tokens_with_empty_messages(anthropic_client, llm_config)",
          "parameters": "(anthropic_client, llm_config)",
          "return_type": null,
          "docstring": "Test that count_tokens properly handles empty messages by replacing them with placeholders,\n    while preserving the exemption for the final assistant message.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 111,
          "end_line": 200,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317302
    },
    "tests/test_log_context_middleware.py": {
      "path": "tests/test_log_context_middleware.py",
      "contentHash": "ca6f5a102770f64e5eedf380938ebb70",
      "mtime": 1767315072148.5483,
      "functions": [
        {
          "name": "app",
          "signature": "def app()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 10,
          "end_line": 29,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(app)",
          "parameters": "(app)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 33,
          "end_line": 34,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317302
    },
    "tests/test_long_running_agents.py": {
      "path": "tests/test_long_running_agents.py",
      "contentHash": "d6ba305be3d4f3749c1e85e0bdd6cb4a",
      "mtime": 1768610518550.2007,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url() -> str",
          "parameters": "()",
          "return_type": "str",
          "docstring": "Provides the URL for the Letta server.\n    If LETTA_SERVER_URL is not set, starts the server in a background thread\n    and polls until it's accepting connections.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 18,
          "end_line": 55,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url: str) -> Letta",
          "parameters": "(server_url: str)",
          "return_type": "Letta",
          "docstring": "Creates and returns a synchronous Letta REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 59,
          "end_line": 70,
          "is_async": false
        },
        {
          "name": "test_deep_research_agent",
          "signature": "def test_deep_research_agent(client: Letta, server_url, disable_e2b_api_key)",
          "parameters": "(client: Letta, server_url, disable_e2b_api_key)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 73,
          "end_line": 101,
          "is_async": true
        },
        {
          "name": "test_kylie_agent",
          "signature": "def test_kylie_agent(client: Letta, server_url, disable_e2b_api_key)",
          "parameters": "(client: Letta, server_url, disable_e2b_api_key)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 104,
          "end_line": 132,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317302
    },
    "tests/test_managers.py": {
      "path": "tests/test_managers.py",
      "contentHash": "d7092327cecfc0410d7064cbccce635f",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "async_session",
          "signature": "def async_session()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 110,
          "end_line": 112,
          "is_async": true
        },
        {
          "name": "default_organization",
          "signature": "def default_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 137,
          "end_line": 140,
          "is_async": true
        },
        {
          "name": "other_organization",
          "signature": "def other_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 144,
          "end_line": 147,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(server: SyncServer, default_organization)",
          "parameters": "(server: SyncServer, default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 151,
          "end_line": 154,
          "is_async": false
        },
        {
          "name": "other_user",
          "signature": "def other_user(server: SyncServer, default_organization)",
          "parameters": "(server: SyncServer, default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 158,
          "end_line": 161,
          "is_async": true
        },
        {
          "name": "other_user_different_org",
          "signature": "def other_user_different_org(server: SyncServer, other_organization)",
          "parameters": "(server: SyncServer, other_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 165,
          "end_line": 168,
          "is_async": true
        },
        {
          "name": "default_source",
          "signature": "def default_source(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 172,
          "end_line": 180,
          "is_async": true
        },
        {
          "name": "other_source",
          "signature": "def other_source(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 184,
          "end_line": 192,
          "is_async": true
        },
        {
          "name": "default_file",
          "signature": "def default_file(server: SyncServer, default_source, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_source, default_user, default_organization)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 196,
          "end_line": 201,
          "is_async": true
        },
        {
          "name": "print_tool",
          "signature": "def print_tool(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Fixture to create a tool with default settings and clean up after the test.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 205,
          "end_line": 236,
          "is_async": true
        },
        {
          "name": "bash_tool",
          "signature": "def bash_tool(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Fixture to create a bash tool with requires_approval and clean up after the test.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 240,
          "end_line": 272,
          "is_async": true
        },
        {
          "name": "composio_github_star_tool",
          "signature": "def composio_github_star_tool(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 276,
          "end_line": 279,
          "is_async": false
        },
        {
          "name": "mcp_tool",
          "signature": "def mcp_tool(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 283,
          "end_line": 306,
          "is_async": false
        },
        {
          "name": "default_job",
          "signature": "def default_job(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Fixture to create and return a default job.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 310,
          "end_line": 317,
          "is_async": true
        },
        {
          "name": "default_run",
          "signature": "def default_run(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Fixture to create and return a default job.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 321,
          "end_line": 328,
          "is_async": true
        },
        {
          "name": "agent_passage_fixture",
          "signature": "def agent_passage_fixture(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Fixture to create an agent passage.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 332,
          "end_line": 350,
          "is_async": false
        },
        {
          "name": "source_passage_fixture",
          "signature": "def source_passage_fixture(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Fixture to create a source passage.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 354,
          "end_line": 369,
          "is_async": false
        },
        {
          "name": "create_test_passages",
          "signature": "def create_test_passages(server: SyncServer, default_file, default_user, sarah_agent, default_source)",
          "parameters": "(server: SyncServer, default_file, default_user, sarah_agent, default_source)",
          "return_type": null,
          "docstring": "Helper function to create test passages for all tests.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 373,
          "end_line": 417,
          "is_async": false
        },
        {
          "name": "hello_world_message_fixture",
          "signature": "def hello_world_message_fixture(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Fixture to create a tool with default settings and clean up after the test.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 421,
          "end_line": 431,
          "is_async": false
        },
        {
          "name": "sandbox_config_fixture",
          "signature": "def sandbox_config_fixture(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 435,
          "end_line": 440,
          "is_async": false
        },
        {
          "name": "sandbox_env_var_fixture",
          "signature": "def sandbox_env_var_fixture(server: SyncServer, sandbox_config_fixture, default_user)",
          "parameters": "(server: SyncServer, sandbox_config_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 444,
          "end_line": 453,
          "is_async": false
        },
        {
          "name": "default_block",
          "signature": "def default_block(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Fixture to create and return a default block.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 457,
          "end_line": 468,
          "is_async": false
        },
        {
          "name": "other_block",
          "signature": "def other_block(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Fixture to create and return another block.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 472,
          "end_line": 483,
          "is_async": false
        },
        {
          "name": "other_tool",
          "signature": "def other_tool(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 487,
          "end_line": 515,
          "is_async": true
        },
        {
          "name": "sarah_agent",
          "signature": "def sarah_agent(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return a sample agent within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 519,
          "end_line": 531,
          "is_async": true
        },
        {
          "name": "charles_agent",
          "signature": "def charles_agent(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return a sample agent within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 535,
          "end_line": 547,
          "is_async": true
        },
        {
          "name": "comprehensive_test_agent_fixture",
          "signature": "def comprehensive_test_agent_fixture(server: SyncServer, default_user, print_tool, default_source, default_block)",
          "parameters": "(server: SyncServer, default_user, print_tool, default_source, default_block)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 551,
          "end_line": 575,
          "is_async": true
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 579,
          "end_line": 585,
          "is_async": false
        },
        {
          "name": "default_archive",
          "signature": "def default_archive(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 589,
          "end_line": 591,
          "is_async": true
        },
        {
          "name": "agent_passages_setup",
          "signature": "def agent_passages_setup(server, default_archive, default_source, default_file, default_user, sarah_agent)",
          "parameters": "(server, default_archive, default_source, default_file, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Setup fixture for agent passages tests",
          "decorators": [
            "@pytest.fixture",
            "@pytest.mark.asyncio"
          ],
          "start_line": 596,
          "end_line": 643,
          "is_async": true
        },
        {
          "name": "agent_with_tags",
          "signature": "def agent_with_tags(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Fixture to create agents with specific tags.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 647,
          "end_line": 685,
          "is_async": true
        },
        {
          "name": "dummy_llm_config",
          "signature": "def dummy_llm_config() -> LLMConfig",
          "parameters": "()",
          "return_type": "LLMConfig",
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 689,
          "end_line": 690,
          "is_async": false
        },
        {
          "name": "dummy_tool_rules_solver",
          "signature": "def dummy_tool_rules_solver() -> ToolRulesSolver",
          "parameters": "()",
          "return_type": "ToolRulesSolver",
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 694,
          "end_line": 695,
          "is_async": false
        },
        {
          "name": "dummy_step_state",
          "signature": "def dummy_step_state(dummy_tool_rules_solver: ToolRulesSolver) -> AgentStepState",
          "parameters": "(dummy_tool_rules_solver: ToolRulesSolver)",
          "return_type": "AgentStepState",
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 699,
          "end_line": 700,
          "is_async": false
        },
        {
          "name": "dummy_successful_response",
          "signature": "def dummy_successful_response() -> BetaMessageBatchIndividualResponse",
          "parameters": "()",
          "return_type": "BetaMessageBatchIndividualResponse",
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 704,
          "end_line": 719,
          "is_async": false
        },
        {
          "name": "letta_batch_job",
          "signature": "def letta_batch_job(server: SyncServer, default_user) -> Job",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": "Job",
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 723,
          "end_line": 724,
          "is_async": false
        },
        {
          "name": "file_attachment",
          "signature": "def file_attachment(server, default_user, sarah_agent, default_file)",
          "parameters": "(server, default_user, sarah_agent, default_file)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 728,
          "end_line": 738,
          "is_async": true
        },
        {
          "name": "another_file",
          "signature": "def another_file(server, default_source, default_user, default_organization)",
          "parameters": "(server, default_source, default_user, default_organization)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 742,
          "end_line": 748,
          "is_async": true
        },
        {
          "name": "test_validate_agent_exists_async",
          "signature": "def test_validate_agent_exists_async(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": "Test the validate_agent_exists_async helper function",
          "decorators": [],
          "start_line": 754,
          "end_line": 766,
          "is_async": true
        },
        {
          "name": "test_create_get_list_agent",
          "signature": "def test_create_get_list_agent(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 770,
          "end_line": 791,
          "is_async": true
        },
        {
          "name": "test_create_agent_include_base_tools",
          "signature": "def test_create_agent_include_base_tools(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test agent creation with include_default_source=True",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 795,
          "end_line": 820,
          "is_async": true
        },
        {
          "name": "test_create_agent_base_tool_rules_excluded_providers",
          "signature": "def test_create_agent_base_tool_rules_excluded_providers(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that include_base_tool_rules is overridden to False for excluded providers",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 824,
          "end_line": 849,
          "is_async": true
        },
        {
          "name": "test_create_agent_base_tool_rules_non_excluded_providers",
          "signature": "def test_create_agent_base_tool_rules_non_excluded_providers(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test that include_base_tool_rules is NOT overridden for non-excluded providers",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 853,
          "end_line": 883,
          "is_async": true
        },
        {
          "name": "test_calculate_multi_agent_tools",
          "signature": "def test_calculate_multi_agent_tools(set_letta_environment)",
          "parameters": "(set_letta_environment)",
          "return_type": null,
          "docstring": "Test that calculate_multi_agent_tools excludes local-only tools in production.",
          "decorators": [],
          "start_line": 886,
          "end_line": 908,
          "is_async": false
        },
        {
          "name": "test_upsert_base_tools_excludes_local_only_in_production",
          "signature": "def test_upsert_base_tools_excludes_local_only_in_production(server: SyncServer, default_user, set_letta_environment)",
          "parameters": "(server: SyncServer, default_user, set_letta_environment)",
          "return_type": null,
          "docstring": "Test that upsert_base_tools excludes local-only multi-agent tools in production.",
          "decorators": [],
          "start_line": 911,
          "end_line": 929,
          "is_async": true
        },
        {
          "name": "test_upsert_multi_agent_tools_only",
          "signature": "def test_upsert_multi_agent_tools_only(server: SyncServer, default_user, set_letta_environment)",
          "parameters": "(server: SyncServer, default_user, set_letta_environment)",
          "return_type": null,
          "docstring": "Test that upserting only multi-agent tools respects production filtering.",
          "decorators": [],
          "start_line": 932,
          "end_line": 948,
          "is_async": true
        },
        {
          "name": "test_create_agent_with_default_source",
          "signature": "def test_create_agent_with_default_source(server: SyncServer, default_user, print_tool, default_block)",
          "parameters": "(server: SyncServer, default_user, print_tool, default_block)",
          "return_type": null,
          "docstring": "Test agent creation with include_default_source=True",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 952,
          "end_line": 1016,
          "is_async": true
        },
        {
          "name": "set_letta_environment",
          "signature": "def set_letta_environment(request, monkeypatch)",
          "parameters": "(request, monkeypatch)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(params=[None, \"PRODUCTION\"])"
          ],
          "start_line": 1020,
          "end_line": 1026,
          "is_async": false
        },
        {
          "name": "test_get_context_window_basic",
          "signature": "def test_get_context_window_basic(\n    server: SyncServer, comprehensive_test_agent_fixture, default_user, default_file, set_letta_environment\n)",
          "parameters": "(\n    server: SyncServer, comprehensive_test_agent_fixture, default_user, default_file, set_letta_environment\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1029,
          "end_line": 1053,
          "is_async": true
        },
        {
          "name": "test_create_agent_passed_in_initial_messages",
          "signature": "def test_create_agent_passed_in_initial_messages(server: SyncServer, default_user, default_block)",
          "parameters": "(server: SyncServer, default_user, default_block)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1057,
          "end_line": 1082,
          "is_async": true
        },
        {
          "name": "test_create_agent_default_initial_message",
          "signature": "def test_create_agent_default_initial_message(server: SyncServer, default_user, default_block)",
          "parameters": "(server: SyncServer, default_user, default_block)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1086,
          "end_line": 1106,
          "is_async": true
        },
        {
          "name": "test_create_agent_with_json_in_system_message",
          "signature": "def test_create_agent_with_json_in_system_message(server: SyncServer, default_user, default_block)",
          "parameters": "(server: SyncServer, default_user, default_block)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1110,
          "end_line": 1136,
          "is_async": true
        },
        {
          "name": "test_update_agent",
          "signature": "def test_update_agent(server: SyncServer, comprehensive_test_agent_fixture, other_tool, other_source, other_block, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, other_tool, other_source, other_block, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1139,
          "end_line": 1162,
          "is_async": true
        },
        {
          "name": "test_agent_file_defaults_based_on_context_window",
          "signature": "def test_agent_file_defaults_based_on_context_window(server: SyncServer, default_user, default_block)",
          "parameters": "(server: SyncServer, default_user, default_block)",
          "return_type": null,
          "docstring": "Test that file-related defaults are set based on the model's context window size",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1166,
          "end_line": 1227,
          "is_async": true
        },
        {
          "name": "test_agent_file_defaults_explicit_values",
          "signature": "def test_agent_file_defaults_explicit_values(server: SyncServer, default_user, default_block)",
          "parameters": "(server: SyncServer, default_user, default_block)",
          "return_type": null,
          "docstring": "Test that explicitly set file-related values are respected",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1231,
          "end_line": 1252,
          "is_async": true
        },
        {
          "name": "test_update_agent_file_fields",
          "signature": "def test_update_agent_file_fields(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": "Test updating file-related fields on an existing agent",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1256,
          "end_line": 1269,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_empty",
          "signature": "def test_list_agents_select_fields_empty(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1278,
          "end_line": 1292,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_none",
          "signature": "def test_list_agents_select_fields_none(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1296,
          "end_line": 1310,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_specific",
          "signature": "def test_list_agents_select_fields_specific(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1314,
          "end_line": 1327,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_invalid",
          "signature": "def test_list_agents_select_fields_invalid(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1331,
          "end_line": 1342,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_duplicates",
          "signature": "def test_list_agents_select_fields_duplicates(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1346,
          "end_line": 1357,
          "is_async": true
        },
        {
          "name": "test_list_agents_select_fields_mixed",
          "signature": "def test_list_agents_select_fields_mixed(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "parameters": "(server: SyncServer, comprehensive_test_agent_fixture, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1361,
          "end_line": 1373,
          "is_async": true
        },
        {
          "name": "test_list_agents_ascending",
          "signature": "def test_list_agents_ascending(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1377,
          "end_line": 1406,
          "is_async": true
        },
        {
          "name": "test_list_agents_descending",
          "signature": "def test_list_agents_descending(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1410,
          "end_line": 1439,
          "is_async": true
        },
        {
          "name": "test_list_agents_ordering_and_pagination",
          "signature": "def test_list_agents_ordering_and_pagination(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1443,
          "end_line": 1499,
          "is_async": true
        },
        {
          "name": "test_attach_tool",
          "signature": "def test_attach_tool(server: SyncServer, sarah_agent, print_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test attaching a tool to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1508,
          "end_line": 1520,
          "is_async": true
        },
        {
          "name": "test_detach_tool",
          "signature": "def test_detach_tool(server: SyncServer, sarah_agent, print_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test detaching a tool from an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1524,
          "end_line": 1541,
          "is_async": true
        },
        {
          "name": "test_bulk_detach_tools",
          "signature": "def test_bulk_detach_tools(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk detaching multiple tools from an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1545,
          "end_line": 1562,
          "is_async": true
        },
        {
          "name": "test_bulk_detach_tools_partial",
          "signature": "def test_bulk_detach_tools_partial(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk detaching tools when some are not attached.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1566,
          "end_line": 1578,
          "is_async": true
        },
        {
          "name": "test_bulk_detach_tools_empty_list",
          "signature": "def test_bulk_detach_tools_empty_list(server: SyncServer, sarah_agent, print_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk detaching empty list of tools.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1582,
          "end_line": 1592,
          "is_async": true
        },
        {
          "name": "test_bulk_detach_tools_idempotent",
          "signature": "def test_bulk_detach_tools_idempotent(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test that bulk detach is idempotent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1596,
          "end_line": 1614,
          "is_async": true
        },
        {
          "name": "test_bulk_detach_tools_nonexistent_agent",
          "signature": "def test_bulk_detach_tools_nonexistent_agent(server: SyncServer, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk detaching tools from a nonexistent agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1618,
          "end_line": 1624,
          "is_async": true
        },
        {
          "name": "test_attach_tool_nonexistent_agent",
          "signature": "def test_attach_tool_nonexistent_agent(server: SyncServer, print_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test attaching a tool to a nonexistent agent.",
          "decorators": [],
          "start_line": 1627,
          "end_line": 1630,
          "is_async": true
        },
        {
          "name": "test_attach_tool_nonexistent_tool",
          "signature": "def test_attach_tool_nonexistent_tool(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test attaching a nonexistent tool to an agent.",
          "decorators": [],
          "start_line": 1633,
          "end_line": 1636,
          "is_async": true
        },
        {
          "name": "test_detach_tool_nonexistent_agent",
          "signature": "def test_detach_tool_nonexistent_agent(server: SyncServer, print_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test detaching a tool from a nonexistent agent.",
          "decorators": [],
          "start_line": 1639,
          "end_line": 1642,
          "is_async": true
        },
        {
          "name": "test_list_attached_tools",
          "signature": "def test_list_attached_tools(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test listing tools attached to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1646,
          "end_line": 1661,
          "is_async": true
        },
        {
          "name": "test_bulk_attach_tools",
          "signature": "def test_bulk_attach_tools(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk attaching multiple tools to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1665,
          "end_line": 1675,
          "is_async": true
        },
        {
          "name": "test_bulk_attach_tools_with_duplicates",
          "signature": "def test_bulk_attach_tools_with_duplicates(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk attaching tools handles duplicates correctly.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1679,
          "end_line": 1695,
          "is_async": true
        },
        {
          "name": "test_bulk_attach_tools_empty_list",
          "signature": "def test_bulk_attach_tools_empty_list(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test bulk attaching empty list of tools.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1699,
          "end_line": 1706,
          "is_async": true
        },
        {
          "name": "test_bulk_attach_tools_nonexistent_tool",
          "signature": "def test_bulk_attach_tools_nonexistent_tool(server: SyncServer, sarah_agent, print_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk attaching tools with a nonexistent tool ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1710,
          "end_line": 1724,
          "is_async": true
        },
        {
          "name": "test_bulk_attach_tools_nonexistent_agent",
          "signature": "def test_bulk_attach_tools_nonexistent_agent(server: SyncServer, print_tool, other_tool, default_user)",
          "parameters": "(server: SyncServer, print_tool, other_tool, default_user)",
          "return_type": null,
          "docstring": "Test bulk attaching tools to a nonexistent agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1728,
          "end_line": 1734,
          "is_async": true
        },
        {
          "name": "test_attach_missing_files_tools_async",
          "signature": "def test_attach_missing_files_tools_async(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test attaching missing file tools to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1738,
          "end_line": 1755,
          "is_async": true
        },
        {
          "name": "test_attach_missing_files_tools_async_partial",
          "signature": "def test_attach_missing_files_tools_async_partial(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test attaching missing file tools when some are already attached.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1759,
          "end_line": 1784,
          "is_async": true
        },
        {
          "name": "test_attach_missing_files_tools_async_idempotent",
          "signature": "def test_attach_missing_files_tools_async_idempotent(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that attach_missing_files_tools is idempotent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1788,
          "end_line": 1808,
          "is_async": true
        },
        {
          "name": "test_detach_all_files_tools_async",
          "signature": "def test_detach_all_files_tools_async(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test detaching all file tools from an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1812,
          "end_line": 1834,
          "is_async": true
        },
        {
          "name": "test_detach_all_files_tools_async_empty",
          "signature": "def test_detach_all_files_tools_async_empty(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test detaching all file tools when no file tools are attached.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1838,
          "end_line": 1853,
          "is_async": true
        },
        {
          "name": "test_detach_all_files_tools_async_with_other_tools",
          "signature": "def test_detach_all_files_tools_async_with_other_tools(server: SyncServer, sarah_agent, print_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, print_tool, default_user)",
          "return_type": null,
          "docstring": "Test detaching all file tools preserves non-file tools.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1857,
          "end_line": 1881,
          "is_async": true
        },
        {
          "name": "test_detach_all_files_tools_async_idempotent",
          "signature": "def test_detach_all_files_tools_async_idempotent(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that detach_all_files_tools is idempotent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1885,
          "end_line": 1906,
          "is_async": true
        },
        {
          "name": "test_attach_tool_with_default_requires_approval",
          "signature": "def test_attach_tool_with_default_requires_approval(server: SyncServer, sarah_agent, bash_tool, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, bash_tool, default_user)",
          "return_type": null,
          "docstring": "Test that attaching a tool with default requires_approval adds associated tool rule.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1910,
          "end_line": 1928,
          "is_async": true
        },
        {
          "name": "test_attach_tool_with_default_requires_approval_on_creation",
          "signature": "def test_attach_tool_with_default_requires_approval_on_creation(server: SyncServer, bash_tool, default_user)",
          "parameters": "(server: SyncServer, bash_tool, default_user)",
          "return_type": null,
          "docstring": "Test that attaching a tool with default requires_approval adds associated tool rule.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1932,
          "end_line": 1976,
          "is_async": true
        },
        {
          "name": "test_attach_source",
          "signature": "def test_attach_source(server: SyncServer, sarah_agent, default_source, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_source, default_user)",
          "return_type": null,
          "docstring": "Test attaching a source to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1985,
          "end_line": 1997,
          "is_async": true
        },
        {
          "name": "test_list_attached_source_ids",
          "signature": "def test_list_attached_source_ids(server: SyncServer, sarah_agent, default_source, other_source, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_source, other_source, default_user)",
          "return_type": null,
          "docstring": "Test listing source IDs attached to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2001,
          "end_line": 2016,
          "is_async": true
        },
        {
          "name": "test_detach_source",
          "signature": "def test_detach_source(server: SyncServer, sarah_agent, default_source, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_source, default_user)",
          "return_type": null,
          "docstring": "Test detaching a source from an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2020,
          "end_line": 2037,
          "is_async": true
        },
        {
          "name": "test_attach_source_nonexistent_agent",
          "signature": "def test_attach_source_nonexistent_agent(server: SyncServer, default_source, default_user)",
          "parameters": "(server: SyncServer, default_source, default_user)",
          "return_type": null,
          "docstring": "Test attaching a source to a nonexistent agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2041,
          "end_line": 2044,
          "is_async": true
        },
        {
          "name": "test_attach_source_nonexistent_source",
          "signature": "def test_attach_source_nonexistent_source(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test attaching a nonexistent source to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2048,
          "end_line": 2051,
          "is_async": true
        },
        {
          "name": "test_detach_source_nonexistent_agent",
          "signature": "def test_detach_source_nonexistent_agent(server: SyncServer, default_source, default_user)",
          "parameters": "(server: SyncServer, default_source, default_user)",
          "return_type": null,
          "docstring": "Test detaching a source from a nonexistent agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2055,
          "end_line": 2058,
          "is_async": true
        },
        {
          "name": "test_list_attached_source_ids_nonexistent_agent",
          "signature": "def test_list_attached_source_ids_nonexistent_agent(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test listing sources for a nonexistent agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2062,
          "end_line": 2065,
          "is_async": true
        },
        {
          "name": "test_list_attached_agents",
          "signature": "def test_list_attached_agents(server: SyncServer, sarah_agent, charles_agent, default_source, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_source, default_user)",
          "return_type": null,
          "docstring": "Test listing agents that have a particular source attached.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2069,
          "end_line": 2099,
          "is_async": true
        },
        {
          "name": "test_list_attached_agents_nonexistent_source",
          "signature": "def test_list_attached_agents_nonexistent_source(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": "Test listing agents for a nonexistent source.",
          "decorators": [],
          "start_line": 2102,
          "end_line": 2105,
          "is_async": true
        },
        {
          "name": "test_list_agents_matching_all_tags",
          "signature": "def test_list_agents_matching_all_tags(server: SyncServer, default_user, agent_with_tags)",
          "parameters": "(server: SyncServer, default_user, agent_with_tags)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2114,
          "end_line": 2121,
          "is_async": true
        },
        {
          "name": "test_list_agents_matching_some_tags",
          "signature": "def test_list_agents_matching_some_tags(server: SyncServer, default_user, agent_with_tags)",
          "parameters": "(server: SyncServer, default_user, agent_with_tags)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2125,
          "end_line": 2132,
          "is_async": true
        },
        {
          "name": "test_list_agents_matching_all_and_some_tags",
          "signature": "def test_list_agents_matching_all_and_some_tags(server: SyncServer, default_user, agent_with_tags)",
          "parameters": "(server: SyncServer, default_user, agent_with_tags)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2136,
          "end_line": 2143,
          "is_async": true
        },
        {
          "name": "test_list_agents_matching_no_tags",
          "signature": "def test_list_agents_matching_no_tags(server: SyncServer, default_user, agent_with_tags)",
          "parameters": "(server: SyncServer, default_user, agent_with_tags)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2147,
          "end_line": 2153,
          "is_async": true
        },
        {
          "name": "test_list_agents_by_tags_match_all",
          "signature": "def test_list_agents_by_tags_match_all(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing agents that have ALL specified tags.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2157,
          "end_line": 2173,
          "is_async": true
        },
        {
          "name": "test_list_agents_by_tags_match_any",
          "signature": "def test_list_agents_by_tags_match_any(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing agents that have ANY of the specified tags.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2177,
          "end_line": 2193,
          "is_async": true
        },
        {
          "name": "test_list_agents_by_tags_no_matches",
          "signature": "def test_list_agents_by_tags_no_matches(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": "Test listing agents when no tags match.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2197,
          "end_line": 2208,
          "is_async": true
        },
        {
          "name": "test_list_agents_by_tags_with_other_filters",
          "signature": "def test_list_agents_by_tags_with_other_filters(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_user)",
          "return_type": null,
          "docstring": "Test combining tag search with other filters.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2212,
          "end_line": 2227,
          "is_async": true
        },
        {
          "name": "test_list_agents_by_tags_pagination",
          "signature": "def test_list_agents_by_tags_pagination(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test pagination when listing agents by tags.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2231,
          "end_line": 2285,
          "is_async": true
        },
        {
          "name": "test_list_agents_query_text_pagination",
          "signature": "def test_list_agents_query_text_pagination(server: SyncServer, default_user, default_organization)",
          "parameters": "(server: SyncServer, default_user, default_organization)",
          "return_type": null,
          "docstring": "Test listing agents with query text filtering and pagination.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2289,
          "end_line": 2369,
          "is_async": true
        },
        {
          "name": "test_reset_messages_no_messages",
          "signature": "def test_reset_messages_no_messages(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that resetting messages on an agent that has zero messages\n    does not fail and clears out message_ids if somehow it's non-empty.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2378,
          "end_line": 2391,
          "is_async": true
        },
        {
          "name": "test_reset_messages_default_messages",
          "signature": "def test_reset_messages_default_messages(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that resetting messages on an agent that has zero messages\n    does not fail and clears out message_ids if somehow it's non-empty.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2395,
          "end_line": 2413,
          "is_async": true
        },
        {
          "name": "test_reset_messages_with_existing_messages",
          "signature": "def test_reset_messages_with_existing_messages(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that resetting messages on an agent with actual messages\n    deletes them from the database and clears message_ids.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2417,
          "end_line": 2453,
          "is_async": true
        },
        {
          "name": "test_reset_messages_idempotency",
          "signature": "def test_reset_messages_idempotency(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that calling reset_messages multiple times has no adverse effect.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2457,
          "end_line": 2481,
          "is_async": true
        },
        {
          "name": "test_reset_messages_preserves_system_message_id",
          "signature": "def test_reset_messages_preserves_system_message_id(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that resetting messages preserves the original system message ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2485,
          "end_line": 2512,
          "is_async": true
        },
        {
          "name": "test_reset_messages_preserves_system_message_content",
          "signature": "def test_reset_messages_preserves_system_message_content(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test that resetting messages preserves the original system message content.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2516,
          "end_line": 2545,
          "is_async": true
        },
        {
          "name": "test_modify_letta_message",
          "signature": "def test_modify_letta_message(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test updating a message.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2549,
          "end_line": 2613,
          "is_async": true
        },
        {
          "name": "test_attach_block",
          "signature": "def test_attach_block(server: SyncServer, sarah_agent, default_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_block, default_user)",
          "return_type": null,
          "docstring": "Test attaching a block to an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2622,
          "end_line": 2631,
          "is_async": true
        },
        {
          "name": "test_attach_block_duplicate_label",
          "signature": "def test_attach_block_duplicate_label(server: SyncServer, sarah_agent, default_block, other_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_block, other_block, default_user)",
          "return_type": null,
          "docstring": "Test attempting to attach a block with a duplicate label.",
          "decorators": [],
          "start_line": 2635,
          "end_line": 2646,
          "is_async": false
        },
        {
          "name": "test_detach_block",
          "signature": "def test_detach_block(server: SyncServer, sarah_agent, default_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_block, default_user)",
          "return_type": null,
          "docstring": "Test detaching a block by ID.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2650,
          "end_line": 2664,
          "is_async": true
        },
        {
          "name": "test_detach_nonexistent_block",
          "signature": "def test_detach_nonexistent_block(server: SyncServer, sarah_agent, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test detaching a block that isn't attached.",
          "decorators": [],
          "start_line": 2667,
          "end_line": 2670,
          "is_async": false
        },
        {
          "name": "test_update_block_label",
          "signature": "def test_update_block_label(server: SyncServer, sarah_agent, default_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_block, default_user)",
          "return_type": null,
          "docstring": "Test updating a block's label updates the relationship.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2674,
          "end_line": 2687,
          "is_async": true
        },
        {
          "name": "test_update_block_label_multiple_agents",
          "signature": "def test_update_block_label_multiple_agents(server: SyncServer, sarah_agent, charles_agent, default_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, charles_agent, default_block, default_user)",
          "return_type": null,
          "docstring": "Test updating a block's label updates relationships for all agents.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2691,
          "end_line": 2706,
          "is_async": true
        },
        {
          "name": "test_get_block_with_label",
          "signature": "def test_get_block_with_label(server: SyncServer, sarah_agent, default_block, default_user)",
          "parameters": "(server: SyncServer, sarah_agent, default_block, default_user)",
          "return_type": null,
          "docstring": "Test retrieving a block by its label.",
          "decorators": [],
          "start_line": 2709,
          "end_line": 2718,
          "is_async": false
        },
        {
          "name": "test_refresh_memory_async",
          "signature": "def test_refresh_memory_async(server: SyncServer, default_user)",
          "parameters": "(server: SyncServer, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2722,
          "end_line": 2759,
          "is_async": true
        },
        {
          "name": "test_agent_list_passages_basic",
          "signature": "def test_agent_list_passages_basic(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test basic listing functionality of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2768,
          "end_line": 2775,
          "is_async": true
        },
        {
          "name": "test_agent_list_passages_ordering",
          "signature": "def test_agent_list_passages_ordering(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test ordering of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2779,
          "end_line": 2792,
          "is_async": true
        },
        {
          "name": "test_agent_list_passages_pagination",
          "signature": "def test_agent_list_passages_pagination(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test pagination of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2796,
          "end_line": 2833,
          "is_async": true
        },
        {
          "name": "test_agent_list_passages_text_search",
          "signature": "def test_agent_list_passages_text_search(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test text search functionality of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2837,
          "end_line": 2850,
          "is_async": true
        },
        {
          "name": "test_agent_list_passages_agent_only",
          "signature": "def test_agent_list_passages_agent_only(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test text search functionality of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2854,
          "end_line": 2859,
          "is_async": true
        },
        {
          "name": "test_agent_list_passages_filtering",
          "signature": "def test_agent_list_passages_filtering(server, default_user, sarah_agent, default_source, agent_passages_setup, disable_turbopuffer)",
          "parameters": "(server, default_user, sarah_agent, default_source, agent_passages_setup, disable_turbopuffer)",
          "return_type": null,
          "docstring": "Test filtering functionality of agent passages",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2863,
          "end_line": 2880,
          "is_async": true
        },
        {
          "name": "mock_embeddings",
          "signature": "def mock_embeddings()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Load mock embeddings from JSON file",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 2884,
          "end_line": 2888,
          "is_async": false
        },
        {
          "name": "mock_embed_model",
          "signature": "def mock_embed_model(mock_embeddings)",
          "parameters": "(mock_embeddings)",
          "return_type": null,
          "docstring": "Mock embedding model that returns predefined embeddings",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 2892,
          "end_line": 2896,
          "is_async": false
        },
        {
          "name": "test_agent_list_passages_vector_search",
          "signature": "def test_agent_list_passages_vector_search(\n    server, default_user, sarah_agent, default_source, default_file, mock_embed_model, disable_turbopuffer\n)",
          "parameters": "(\n    server, default_user, sarah_agent, default_source, default_file, mock_embed_model, disable_turbopuffer\n)",
          "return_type": null,
          "docstring": "Test vector search functionality of agent passages",
          "decorators": [],
          "start_line": 2899,
          "end_line": 2978,
          "is_async": true
        },
        {
          "name": "test_list_source_passages_only",
          "signature": "def test_list_source_passages_only(server: SyncServer, default_user, default_source, agent_passages_setup)",
          "parameters": "(server: SyncServer, default_user, default_source, agent_passages_setup)",
          "return_type": null,
          "docstring": "Test listing passages from a source without specifying an agent.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2982,
          "end_line": 2994,
          "is_async": true
        },
        {
          "name": "test_list_organizations",
          "signature": "def test_list_organizations(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 3001,
          "end_line": 3013,
          "is_async": true
        },
        {
          "name": "test_create_default_organization",
          "signature": "def test_create_default_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 3017,
          "end_line": 3020,
          "is_async": true
        },
        {
          "name": "test_update_organization_name",
          "signature": "def test_update_organization_name(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 3024,
          "end_line": 3030,
          "is_async": true
        },
        {
          "name": "test_update_organization_privileged_tools",
          "signature": "def test_update_organization_privileged_tools(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 3034,
          "end_line": 3039,
          "is_async": true
        },
        {
          "name": "test_list_organizations_pagination",
          "signature": "def test_list_organizations_pagination(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 3043,
          "end_line": 3055,
          "is_async": true
        },
        {
          "name": "test_passage_create_agentic",
          "signature": "def test_passage_create_agentic(server: SyncServer, agent_passage_fixture, default_user)",
          "parameters": "(server: SyncServer, agent_passage_fixture, default_user)",
          "return_type": null,
          "docstring": "Test creating a passage using agent_passage_fixture fixture",
          "decorators": [],
          "start_line": 3063,
          "end_line": 3075,
          "is_async": false
        },
        {
          "name": "test_passage_create_source",
          "signature": "def test_passage_create_source(server: SyncServer, source_passage_fixture, default_user)",
          "parameters": "(server: SyncServer, source_passage_fixture, default_user)",
          "return_type": null,
          "docstring": "Test creating a source passage.",
          "decorators": [],
          "start_line": 3078,
          "end_line": 3090,
          "is_async": false
        },
        {
          "name": "test_passage_create_invalid",
          "signature": "def test_passage_create_invalid(server: SyncServer, agent_passage_fixture, default_user)",
          "parameters": "(server: SyncServer, agent_passage_fixture, default_user)",
          "return_type": null,
          "docstring": "Test creating an agent passage.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 3094,
          "end_line": 3111,
          "is_async": true
        },
        {
          "name": "test_passage_get_by_id",
          "signature": "def test_passage_get_by_id(server: SyncServer, agent_passage_fixture, source_passage_fixture, default_user)",
          "parameters": "(server: SyncServer, agent_passage_fixture, source_passage_fixture, default_user)",
          "return_type": null,
          "docstring": "Test retrieving a passage by ID",
          "decorators": [],
          "start_line": 3114,
          "end_line": 3124,
          "is_async": false
        },
        {
          "name": "test_passage_cascade_deletion",
          "signature": "def test_passage_cascade_deletion(\n    server: SyncServer, agent_passage_fixture, source_passage_fixture, default_user, default_source, sarah_agent\n)",
          "parameters": "(\n    server: SyncServer, agent_passage_fixture, source_passage_fixture, default_user, default_source, sarah_agent\n)",
          "return_type": null,
          "docstring": "Test that passages are deleted when their parent (agent or source) is deleted.",
          "decorators": [],
          "start_line": 3127,
          "end_line": 3140,
          "is_async": true
        },
        {
          "name": "test_create_agent_passage_specific",
          "signature": "def test_create_agent_passage_specific(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test creating an agent passage using the new agent-specific method.",
          "decorators": [],
          "start_line": 3143,
          "end_line": 3167,
          "is_async": false
        },
        {
          "name": "test_create_source_passage_specific",
          "signature": "def test_create_source_passage_specific(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Test creating a source passage using the new source-specific method.",
          "decorators": [],
          "start_line": 3170,
          "end_line": 3191,
          "is_async": false
        },
        {
          "name": "test_create_agent_passage_validation",
          "signature": "def test_create_agent_passage_validation(server: SyncServer, default_user, default_source, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, default_source, sarah_agent)",
          "return_type": null,
          "docstring": "Test that agent passage creation validates inputs correctly.",
          "decorators": [],
          "start_line": 3194,
          "end_line": 3225,
          "is_async": false
        },
        {
          "name": "test_create_source_passage_validation",
          "signature": "def test_create_source_passage_validation(server: SyncServer, default_user, default_file, default_source, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source, sarah_agent)",
          "return_type": null,
          "docstring": "Test that source passage creation validates inputs correctly.",
          "decorators": [],
          "start_line": 3228,
          "end_line": 3261,
          "is_async": false
        },
        {
          "name": "test_get_agent_passage_by_id_specific",
          "signature": "def test_get_agent_passage_by_id_specific(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test retrieving an agent passage using the new agent-specific method.",
          "decorators": [],
          "start_line": 3264,
          "end_line": 3288,
          "is_async": false
        },
        {
          "name": "test_get_source_passage_by_id_specific",
          "signature": "def test_get_source_passage_by_id_specific(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Test retrieving a source passage using the new source-specific method.",
          "decorators": [],
          "start_line": 3291,
          "end_line": 3312,
          "is_async": false
        },
        {
          "name": "test_get_wrong_passage_type_fails",
          "signature": "def test_get_wrong_passage_type_fails(server: SyncServer, default_user, sarah_agent, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, sarah_agent, default_file, default_source)",
          "return_type": null,
          "docstring": "Test that trying to get the wrong passage type with specific methods fails.",
          "decorators": [],
          "start_line": 3315,
          "end_line": 3354,
          "is_async": false
        },
        {
          "name": "test_update_agent_passage_specific",
          "signature": "def test_update_agent_passage_specific(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test updating an agent passage using the new agent-specific method.",
          "decorators": [],
          "start_line": 3357,
          "end_line": 3391,
          "is_async": false
        },
        {
          "name": "test_update_source_passage_specific",
          "signature": "def test_update_source_passage_specific(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Test updating a source passage using the new source-specific method.",
          "decorators": [],
          "start_line": 3394,
          "end_line": 3426,
          "is_async": false
        },
        {
          "name": "test_delete_agent_passage_specific",
          "signature": "def test_delete_agent_passage_specific(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test deleting an agent passage using the new agent-specific method.",
          "decorators": [],
          "start_line": 3429,
          "end_line": 3458,
          "is_async": false
        },
        {
          "name": "test_delete_source_passage_specific",
          "signature": "def test_delete_source_passage_specific(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Test deleting a source passage using the new source-specific method.",
          "decorators": [],
          "start_line": 3461,
          "end_line": 3487,
          "is_async": false
        },
        {
          "name": "test_create_many_agent_passages_async",
          "signature": "def test_create_many_agent_passages_async(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test creating multiple agent passages using the new batch method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 3491,
          "end_line": 3518,
          "is_async": true
        },
        {
          "name": "test_create_many_source_passages_async",
          "signature": "def test_create_many_source_passages_async(server: SyncServer, default_user, default_file, default_source)",
          "parameters": "(server: SyncServer, default_user, default_file, default_source)",
          "return_type": null,
          "docstring": "Test creating multiple source passages using the new batch method.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 3522,
          "end_line": 3544,
          "is_async": true
        },
        {
          "name": "test_agent_passage_size",
          "signature": "def test_agent_passage_size(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test counting agent passages using the new agent-specific size method.",
          "decorators": [],
          "start_line": 3547,
          "end_line": 3570,
          "is_async": false
        },
        {
          "name": "test_deprecated_methods_show_warnings",
          "signature": "def test_deprecated_methods_show_warnings(server: SyncServer, default_user, sarah_agent)",
          "parameters": "(server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test that deprecated methods show deprecation warnings.",
          "decorators": [],
          "start_line": 3573,
          "end_line": 3607,
          "is_async": false
        },
        {
          "name": "test_passage_tags_functionality",
          "signature": "def test_passage_tags_functionality(disable_turbopuffer, server: SyncServer, default_user, sarah_agent)",
          "parameters": "(disable_turbopuffer, server: SyncServer, default_user, sarah_agent)",
          "return_type": null,
          "docstring": "Test comprehensive tag functionality for passages.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 3611,
          "end_line": 3675,
          "is_async": true
        },
        {
          "name": "test_comprehensive_tag_functionality",
          "signature": "def test_comprehensive_tag_functionality(disable_turbopuffer, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(disable_turbopuffer, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Comprehensive test for tag functionality including dual storage and junction table.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 3679,
          "end_line": 3892,
          "is_async": true
        },
        {
          "name": "test_tag_edge_cases",
          "signature": "def test_tag_edge_cases(disable_turbopuffer, server: SyncServer, sarah_agent, default_user)",
          "parameters": "(disable_turbopuffer, server: SyncServer, sarah_agent, default_user)",
          "return_type": null,
          "docstring": "Test edge cases for tag functionality.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 3896,
          "end_line": 3975,
          "is_async": true
        },
        {
          "name": "rch_agent_archival_memory_async(disable",
          "signature": "def rch_agent_archival_memory_async(disable_turbopuffer, server: SyncServer, default_user, sarah_agent):\n    \"\"",
          "parameters": "_turbopuffer, server: SyncServer, default_user, sarah_agent):\n    \"\"",
          "return_type": null,
          "docstring": "the search_agent_archival_memory_async method that powers both the agent tool and API endpoint.\"\"\"\n    # G",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 3979,
          "end_line": 4131,
          "is_async": true
        },
        {
          "name": "hive_manager_delete_archive_async(server:",
          "signature": "def hive_manager_delete_archive_async(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "the delete_archive_async function.\"\"\"\n    arc",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4138,
          "end_line": 4150,
          "is_async": true
        },
        {
          "name": "hive_manager_get_agents_for_archive_async(server:",
          "signature": "def hive_manager_get_agents_for_archive_async(server: SyncServer, default_user, sarah_agent):\n    \"\"",
          "parameters": " SyncServer, default_user, sarah_agent):\n    \"\"",
          "return_type": null,
          "docstring": "getting all agents that have access to an archive.\"\"\"\n    arc",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4154,
          "end_line": 4187,
          "is_async": true
        },
        {
          "name": "hive_manager_race_condition_handling(server:",
          "signature": "def hive_manager_race_condition_handling(server: SyncServer, default_user, sarah_agent):\n    \"\"",
          "parameters": " SyncServer, default_user, sarah_agent):\n    \"\"",
          "return_type": null,
          "docstring": "that the race condition fix in get_or_create_default_archive_for_agent_async works.\"\"\"\n    fro",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4191,
          "end_line": 4255,
          "is_async": true
        },
        {
          "name": "hive_manager_get_agent_from_passage_async(server:",
          "signature": "def hive_manager_get_agent_from_passage_async(server: SyncServer, default_user, sarah_agent):\n    \"\"",
          "parameters": " SyncServer, default_user, sarah_agent):\n    \"\"",
          "return_type": null,
          "docstring": "getting the agent ID that owns a passage through its archive.\"\"\"\n    arc",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4259,
          "end_line": 4301,
          "is_async": true
        },
        {
          "name": "t_users(server:",
          "signature": "def t_users(server: SyncServer):\n    # ",
          "parameters": " SyncServer):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4308,
          "end_line": 4321,
          "is_async": true
        },
        {
          "name": "ate_default_user(server:",
          "signature": "def ate_default_user(server: SyncServer):\n    or",
          "parameters": " SyncServer):\n    or",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4325,
          "end_line": 4329,
          "is_async": true
        },
        {
          "name": "ate_user(server:",
          "signature": "def ate_user(server: SyncServer):\n    # ",
          "parameters": " SyncServer):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4333,
          "end_line": 4353,
          "is_async": true
        },
        {
          "name": "r_caching(server:",
          "signature": "def r_caching(server: SyncServer, default_user, performance_pct=0.4):\n    if",
          "parameters": " SyncServer, default_user, performance_pct=0.4):\n    if",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 4356,
          "end_line": 4389,
          "is_async": true
        },
        {
          "name": "ate_tool(server:",
          "signature": "def ate_tool(server: SyncServer, print_tool, default_user, default_organization):\n    # ",
          "parameters": " SyncServer, print_tool, default_user, default_organization):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 4397,
          "end_line": 4400,
          "is_async": false
        },
        {
          "name": "ate_composio_tool(server:",
          "signature": "def ate_composio_tool(server: SyncServer, composio_github_star_tool, default_user, default_organization):\n    # ",
          "parameters": " SyncServer, composio_github_star_tool, default_user, default_organization):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 4403,
          "end_line": 4406,
          "is_async": false
        },
        {
          "name": "ate_mcp_tool(server:",
          "signature": "def ate_mcp_tool(server: SyncServer, mcp_tool, default_user, default_organization):\n    # ",
          "parameters": " SyncServer, mcp_tool, default_user, default_organization):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 4409,
          "end_line": 4414,
          "is_async": false
        },
        {
          "name": "ate_tool_duplicate_name(server:",
          "signature": "def ate_tool_duplicate_name(server: SyncServer, print_tool, default_user, default_organization):\n    da",
          "parameters": " SyncServer, print_tool, default_user, default_organization):\n    da",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 4418,
          "end_line": 4423,
          "is_async": false
        },
        {
          "name": "ate_tool_requires_approval(server:",
          "signature": "def ate_tool_requires_approval(server: SyncServer, bash_tool, default_user, default_organization):\n    # ",
          "parameters": " SyncServer, bash_tool, default_user, default_organization):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 4426,
          "end_line": 4430,
          "is_async": false
        },
        {
          "name": "t_tools(server:",
          "signature": "def t_tools(server: SyncServer, print_tool, default_user):\n    # ",
          "parameters": " SyncServer, print_tool, default_user):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4464,
          "end_line": 4470,
          "is_async": true
        },
        {
          "name": "t_tools_with_tool_types(server:",
          "signature": "def t_tools_with_tool_types(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "filtering tools by tool_types parameter.\"\"\"\n\n    #",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4474,
          "end_line": 4537,
          "is_async": true
        },
        {
          "name": "t_tools_with_exclude_tool_types(server:",
          "signature": "def t_tools_with_exclude_tool_types(server: SyncServer, default_user, print_tool):\n    \"\"",
          "parameters": " SyncServer, default_user, print_tool):\n    \"\"",
          "return_type": null,
          "docstring": "excluding tools by exclude_tool_types parameter.\"\"\"\n    # w",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4541,
          "end_line": 4577,
          "is_async": true
        },
        {
          "name": "t_tools_with_names(server:",
          "signature": "def t_tools_with_names(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "filtering tools by names parameter.\"\"\"\n\n    #",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4581,
          "end_line": 4633,
          "is_async": true
        },
        {
          "name": "t_tools_with_tool_ids(server:",
          "signature": "def t_tools_with_tool_ids(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "filtering tools by tool_ids parameter.\"\"\"\n\n    #",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4637,
          "end_line": 4689,
          "is_async": true
        },
        {
          "name": "t_tools_with_search(server:",
          "signature": "def t_tools_with_search(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "searching tools by partial name match.\"\"\"\n\n    #",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4693,
          "end_line": 4754,
          "is_async": true
        },
        {
          "name": "t_tools_return_only_letta_tools(server:",
          "signature": "def t_tools_return_only_letta_tools(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "filtering for only Letta tools.\"\"\"\n    # f",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4758,
          "end_line": 4794,
          "is_async": true
        },
        {
          "name": "t_tools_combined_filters(server:",
          "signature": "def t_tools_combined_filters(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "combining multiple filters.\"\"\"\n\n    #",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4798,
          "end_line": 4870,
          "is_async": true
        },
        {
          "name": "nt_tools_async(server:",
          "signature": "def nt_tools_async(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "counting tools with various filters.\"\"\"\n\n    #",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 4874,
          "end_line": 4951,
          "is_async": true
        },
        {
          "name": "ate_tool_by_id(server:",
          "signature": "def ate_tool_by_id(server: SyncServer, print_tool, default_user):\n    up",
          "parameters": " SyncServer, print_tool, default_user):\n    up",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 4954,
          "end_line": 4975,
          "is_async": false
        },
        {
          "name": "ate_tool_source_code_refreshes_schema_and_name(server:",
          "signature": "def ate_tool_source_code_refreshes_schema_and_name(server: SyncServer, print_tool, default_user):\n    de",
          "parameters": " SyncServer, print_tool, default_user):\n    de",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 4978,
          "end_line": 5012,
          "is_async": false
        },
        {
          "name": "ate_tool_source_code_refreshes_schema_only(server:",
          "signature": "def ate_tool_source_code_refreshes_schema_only(server: SyncServer, print_tool, default_user):\n    de",
          "parameters": " SyncServer, print_tool, default_user):\n    de",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 5015,
          "end_line": 5051,
          "is_async": false
        },
        {
          "name": "ate_tool_multi_user(server:",
          "signature": "def ate_tool_multi_user(server: SyncServer, print_tool, default_user, other_user):\n    up",
          "parameters": " SyncServer, print_tool, default_user, other_user):\n    up",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 5054,
          "end_line": 5068,
          "is_async": false
        },
        {
          "name": "ete_tool_by_id(server:",
          "signature": "def ete_tool_by_id(server: SyncServer, print_tool, default_user):\n    # ",
          "parameters": " SyncServer, print_tool, default_user):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 5072,
          "end_line": 5077,
          "is_async": true
        },
        {
          "name": "ert_base_tools(server:",
          "signature": "def ert_base_tools(server: SyncServer, default_user):\n    to",
          "parameters": " SyncServer, default_user):\n    to",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 5081,
          "end_line": 5117,
          "is_async": true
        },
        {
          "name": "ert_filtered_base_tools(server:",
          "signature": "def ert_filtered_base_tools(server: SyncServer, default_user, tool_type, expected_names):\n    to",
          "parameters": " SyncServer, default_user, tool_type, expected_names):\n    to",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "mark.parametrize(\n    \"tool_type,expected_names\",\n    [\n        (ToolType.LETTA_CORE, BASE_TOOLS),\n        (ToolType.LETTA_MEMORY_CORE, BASE_MEMORY_TOOLS),\n        (ToolType.LETTA_MULTI_AGENT_CORE, MULTI_AGENT_TOOLS),\n        (ToolType.LETTA_SLEEPTIME_CORE, BASE_SLEEPTIME_TOOLS),\n        (ToolType.LETTA_VOICE_SLEEPTIME_CORE, sorted(set(BASE_VOICE_SLEEPTIME_TOOLS + BASE_VOICE_SLEEPTIME_CHAT_TOOLS) - {\"send_message\"})),\n        (ToolType.LETTA_BUILTIN, BUILTIN_TOOLS),\n        (ToolType.LETTA_FILES_CORE, FILES_TOOLS),\n    ],\n)\nasync d"
          ],
          "start_line": 5132,
          "end_line": 5143,
          "is_async": true
        },
        {
          "name": "ert_multiple_tool_types(server:",
          "signature": "def ert_multiple_tool_types(server: SyncServer, default_user):\n    al",
          "parameters": " SyncServer, default_user):\n    al",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 5146,
          "end_line": 5153,
          "is_async": true
        },
        {
          "name": "ert_base_tools_with_empty_type_filter(server:",
          "signature": "def ert_base_tools_with_empty_type_filter(server: SyncServer, default_user):\n    to",
          "parameters": " SyncServer, default_user):\n    to",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 5156,
          "end_line": 5158,
          "is_async": true
        },
        {
          "name": "k_upsert_tools_async(server:",
          "signature": "def k_upsert_tools_async(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "bulk upserting multiple tools at once\"\"\"\n    # c",
          "decorators": [],
          "start_line": 5161,
          "end_line": 5214,
          "is_async": true
        },
        {
          "name": "k_upsert_tools_name_conflict(server:",
          "signature": "def k_upsert_tools_name_conflict(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "bulk upserting tools handles name+org_id unique constraint correctly\"\"\"\n\n    #",
          "decorators": [],
          "start_line": 5217,
          "end_line": 5256,
          "is_async": true
        },
        {
          "name": "k_upsert_tools_mixed_create_update(server:",
          "signature": "def k_upsert_tools_mixed_create_update(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "bulk upserting with mix of new tools and updates to existing ones\"\"\"\n\n    #",
          "decorators": [],
          "start_line": 5259,
          "end_line": 5339,
          "is_async": true
        },
        {
          "name": "k_upsert_tools_override_existing_true(server:",
          "signature": "def k_upsert_tools_override_existing_true(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "bulk_upsert_tools_async with override_existing_tools=True (default behavior)\"\"\"\n\n    #",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 5343,
          "end_line": 5377,
          "is_async": true
        },
        {
          "name": "k_upsert_tools_override_existing_false(server:",
          "signature": "def k_upsert_tools_override_existing_false(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "bulk_upsert_tools_async with override_existing_tools=False (skip existing)\"\"\"\n\n    #",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 5381,
          "end_line": 5415,
          "is_async": true
        },
        {
          "name": "k_upsert_tools_override_mixed_scenario(server:",
          "signature": "def k_upsert_tools_override_mixed_scenario(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "bulk_upsert_tools_async with override_existing_tools=False in mixed create/update scenario\"\"\"\n\n    #",
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 5419,
          "end_line": 5479,
          "is_async": true
        },
        {
          "name": "ate_tool_with_pip_requirements(server:",
          "signature": "def ate_tool_with_pip_requirements(server: SyncServer, default_user, default_organization):\n    de",
          "parameters": " SyncServer, default_user, default_organization):\n    de",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 5483,
          "end_line": 5522,
          "is_async": true
        },
        {
          "name": "ate_tool_without_pip_requirements(server:",
          "signature": "def ate_tool_without_pip_requirements(server: SyncServer, print_tool):\n    # ",
          "parameters": " SyncServer, print_tool):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 5525,
          "end_line": 5527,
          "is_async": true
        },
        {
          "name": "ate_tool_pip_requirements(server:",
          "signature": "def ate_tool_pip_requirements(server: SyncServer, print_tool, default_user):\n    # ",
          "parameters": " SyncServer, print_tool, default_user):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 5530,
          "end_line": 5549,
          "is_async": true
        },
        {
          "name": "ate_tool_clear_pip_requirements(server:",
          "signature": "def ate_tool_clear_pip_requirements(server: SyncServer, default_user, default_organization):\n    de",
          "parameters": " SyncServer, default_user, default_organization):\n    de",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 5552,
          "end_line": 5594,
          "is_async": true
        },
        {
          "name": "ate_default_requires_approval(server:",
          "signature": "def ate_default_requires_approval(server: SyncServer, bash_tool, default_user):\n    # ",
          "parameters": " SyncServer, bash_tool, default_user):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 5647,
          "end_line": 5666,
          "is_async": true
        },
        {
          "name": "sage_create(server:",
          "signature": "def sage_create(server: SyncServer, hello_world_message_fixture, default_user):\n    \"\"",
          "parameters": " SyncServer, hello_world_message_fixture, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "creating a message using hello_world_message_fixture fixture\"\"\"\n    ass",
          "decorators": [],
          "start_line": 5674,
          "end_line": 5688,
          "is_async": false
        },
        {
          "name": "sage_get_by_id(server:",
          "signature": "def sage_get_by_id(server: SyncServer, hello_world_message_fixture, default_user):\n    \"\"",
          "parameters": " SyncServer, hello_world_message_fixture, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "retrieving a message by ID\"\"\"\n    ret",
          "decorators": [],
          "start_line": 5691,
          "end_line": 5696,
          "is_async": false
        },
        {
          "name": "sage_update(server:",
          "signature": "def sage_update(server: SyncServer, hello_world_message_fixture, default_user, other_user):\n    \"\"",
          "parameters": " SyncServer, hello_world_message_fixture, default_user, other_user):\n    \"\"",
          "return_type": null,
          "docstring": "updating a message\"\"\"\n    new",
          "decorators": [],
          "start_line": 5699,
          "end_line": 5710,
          "is_async": false
        },
        {
          "name": "sage_delete(server:",
          "signature": "def sage_delete(server: SyncServer, hello_world_message_fixture, default_user):\n    \"\"",
          "parameters": " SyncServer, hello_world_message_fixture, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "deleting a message\"\"\"\n    ser",
          "decorators": [],
          "start_line": 5713,
          "end_line": 5717,
          "is_async": false
        },
        {
          "name": "sage_size(server:",
          "signature": "def sage_size(server: SyncServer, hello_world_message_fixture, default_user):\n    \"\"",
          "parameters": " SyncServer, hello_world_message_fixture, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "counting messages with filters\"\"\"\n    bas",
          "decorators": [],
          "start_line": 5720,
          "end_line": 5750,
          "is_async": false
        },
        {
          "name": "est_messages(server:",
          "signature": "def est_messages(server: SyncServer, base_message: PydanticMessage, default_user) -> list -> anticMessage]:\n    \"\"",
          "parameters": " SyncServer, base_message: PydanticMessage, default_user) -> list",
          "return_type": "anticMessage]:\n    \"\"",
          "docstring": "r function to create test messages for all tests\"\"\"\n    mes",
          "decorators": [],
          "start_line": 5753,
          "end_line": 5764,
          "is_async": false
        },
        {
          "name": "sage_listing_basic(server:",
          "signature": "def sage_listing_basic(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent):\n    \"\"",
          "parameters": " SyncServer, hello_world_message_fixture, default_user, sarah_agent):\n    \"\"",
          "return_type": null,
          "docstring": "basic message listing with limit\"\"\"\n    cre",
          "decorators": [],
          "start_line": 5776,
          "end_line": 5781,
          "is_async": false
        },
        {
          "name": "sage_listing_cursor(server:",
          "signature": "def sage_listing_cursor(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent):\n    \"\"",
          "parameters": " SyncServer, hello_world_message_fixture, default_user, sarah_agent):\n    \"\"",
          "return_type": null,
          "docstring": "cursor-based pagination functionality\"\"\"\n    cre",
          "decorators": [],
          "start_line": 5784,
          "end_line": 5819,
          "is_async": false
        },
        {
          "name": "sage_listing_filtering(server:",
          "signature": "def sage_listing_filtering(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent):\n    \"\"",
          "parameters": " SyncServer, hello_world_message_fixture, default_user, sarah_agent):\n    \"\"",
          "return_type": null,
          "docstring": "filtering messages by agent ID\"\"\"\n    cre",
          "decorators": [],
          "start_line": 5822,
          "end_line": 5828,
          "is_async": false
        },
        {
          "name": "sage_listing_text_search(server:",
          "signature": "def sage_listing_text_search(server: SyncServer, hello_world_message_fixture, default_user, sarah_agent):\n    \"\"",
          "parameters": " SyncServer, hello_world_message_fixture, default_user, sarah_agent):\n    \"\"",
          "return_type": null,
          "docstring": "searching messages by text content\"\"\"\n    cre",
          "decorators": [],
          "start_line": 5831,
          "end_line": 5845,
          "is_async": false
        },
        {
          "name": "ate_block(server:",
          "signature": "def ate_block(server: SyncServer, default_user):\n    bl",
          "parameters": " SyncServer, default_user):\n    bl",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 5853,
          "end_line": 5876,
          "is_async": false
        },
        {
          "name": "ch_create_blocks_async(server:",
          "signature": "def ch_create_blocks_async(server: SyncServer, default_user):\n    \"\"",
          "parameters": " SyncServer, default_user):\n    \"\"",
          "return_type": null,
          "docstring": "batch creating multiple blocks at once\"\"\"\n    blo",
          "decorators": [],
          "start_line": 5879,
          "end_line": 5940,
          "is_async": true
        },
        {
          "name": "ate_block(server:",
          "signature": "def ate_block(server: SyncServer, default_user):\n    bl",
          "parameters": " SyncServer, default_user):\n    bl",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 6020,
          "end_line": 6033,
          "is_async": false
        },
        {
          "name": "ate_block_limit(server:",
          "signature": "def ate_block_limit(server: SyncServer, default_user):\n    bl",
          "parameters": " SyncServer, default_user):\n    bl",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 6036,
          "end_line": 6055,
          "is_async": false
        },
        {
          "name": "ate_block_limit_does_not_reset(server:",
          "signature": "def ate_block_limit_does_not_reset(server: SyncServer, default_user):\n    bl",
          "parameters": " SyncServer, default_user):\n    bl",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 6058,
          "end_line": 6070,
          "is_async": false
        },
        {
          "name": "ete_block(server:",
          "signature": "def ete_block(server: SyncServer, default_user):\n    bl",
          "parameters": " SyncServer, default_user):\n    bl",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 6074,
          "end_line": 6083,
          "is_async": true
        },
        {
          "name": "ete_block_detaches_from_agent(server:",
          "signature": "def ete_block_detaches_from_agent(server: SyncServer, sarah_agent, default_user):\n    # ",
          "parameters": " SyncServer, sarah_agent, default_user):\n    # ",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 6087,
          "end_line": 6104,
          "is_async": true
        },
        {
          "name": "ch_create_multiple_blocks(server:",
          "signature": "def ch_create_multiple_blocks(server: SyncServer, default_user):\n    bl",
          "parameters": " SyncServer, default_user):\n    bl",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "mark.asyncio\nasync d"
          ],
          "start_line": 6129,
          "end_line": 6155,
          "is_async": true
        },
        {
          "name": "k_update_skips_missing_and_truncates_then_returns_none(server:",
          "signature": "def k_update_skips_missing_and_truncates_then_returns_none(server: SyncServer, default_user: PydanticUser, caplog):\n    mg",
          "parameters": " SyncServer, default_user: PydanticUser, caplog):\n    mg",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 6158,
          "end_line": 6186,
          "is_async": true
        },
        {
          "name": "date_return_hydrated_true(server: Syn",
          "signature": "def date_return_hydrated_true(server: SyncServer, default_user: PydanticUser):\n    mgr = ",
          "parameters": "cServer, default_user: PydanticUser):\n    mgr = ",
          "return_type": null,
          "docstring": null,
          "decorators": [
            ".skip(reason=\"TODO: implement for async\")\nasync def t"
          ],
          "start_line": 6190,
          "end_line": 6205,
          "is_async": true
        },
        {
          "name": "date_respects_org_scoping(\n    server",
          "signature": "def date_respects_org_scoping(\n    server: SyncServer, default_user: PydanticUser, other_user_different_org: PydanticUser, caplog\n):\n    mgr = ",
          "parameters": ": SyncServer, default_user: PydanticUser, other_user_different_org: PydanticUser, caplog\n):\n    mgr = ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 6208,
          "end_line": 6240,
          "is_async": true
        },
        {
          "name": "int_creates_history(server: Syn",
          "signature": "def int_creates_history(server: SyncServer, default_user):\n    \"\"\"\n  ",
          "parameters": "cServer, default_user):\n    \"\"\"\n  ",
          "return_type": null,
          "docstring": "res that calling checkpoint_block creates a BlockHistory row and updates\n    the block's current_history_entry_id appropriately.\n    \"\"\"\n\n    block_",
          "decorators": [],
          "start_line": 6248,
          "end_line": 6276,
          "is_async": false
        },
        {
          "name": "e_checkpoints(server: Syn",
          "signature": "def e_checkpoints(server: SyncServer, default_user):\n    block_",
          "parameters": "cServer, default_user):\n    block_",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 6279,
          "end_line": 6312,
          "is_async": false
        },
        {
          "name": "int_with_agent_id(server: Syn",
          "signature": "def int_with_agent_id(server: SyncServer, default_user, sarah_agent):\n    \"\"\"\n  ",
          "parameters": "cServer, default_user, sarah_agent):\n    \"\"\"\n  ",
          "return_type": null,
          "docstring": "res that if we pass agent_id to checkpoint_block, we get\n    actor_type=LETTA_AGENT, actor_id=<agent.id> in BlockHistory.\n    \"\"\"\n    block_m",
          "decorators": [],
          "start_line": 6315,
          "end_line": 6332,
          "is_async": false
        },
        {
          "name": "int_with_no_state_change(server: Syn",
          "signature": "def int_with_no_state_change(server: SyncServer, default_user):\n    \"\"\"\n  ",
          "parameters": "cServer, default_user):\n    \"\"\"\n  ",
          "return_type": null,
          "docstring": "e call checkpoint_block twice without any edits,\n    we expect two entries or only one, depending on your policy.\n    \"\"\"\n    block_m",
          "decorators": [],
          "start_line": 6335,
          "end_line": 6352,
          "is_async": false
        },
        {
          "name": "int_concurrency_stale(server: Syn",
          "signature": "def int_concurrency_stale(server: SyncServer, default_user):\n    block_",
          "parameters": "cServer, default_user):\n    block_",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 6355,
          "end_line": 6387,
          "is_async": false
        },
        {
          "name": "int_no_future_states(server: Syn",
          "signature": "def int_no_future_states(server: SyncServer, default_user):\n    \"\"\"\n  ",
          "parameters": "cServer, default_user):\n    \"\"\"\n  ",
          "return_type": null,
          "docstring": "res that if the block is already at the highest sequence,\n    creating a new checkpoint does NOT delete anything.\n    \"\"\"\n\n    block_",
          "decorators": [],
          "start_line": 6390,
          "end_line": 6423,
          "is_async": false
        },
        {
          "name": "eckpoint_block(server: Syn",
          "signature": "def eckpoint_block(server: SyncServer, default_user):\n    \"\"\"\n  ",
          "parameters": "cServer, default_user):\n    \"\"\"\n  ",
          "return_type": null,
          "docstring": "fies that we can undo to the previous checkpoint:\n      1) Create a block and checkpoint -> sequence_number=1\n      2) Update block content and checkpoint -> sequence_number=2\n      3) Undo -> should revert block to sequence_number=1's content\n    \"\"\"\n    block_m",
          "decorators": [],
          "start_line": 6431,
          "end_line": 6460,
          "is_async": false
        },
        {
          "name": "int_deletes_future_states_after_undo(server: Syn",
          "signature": "def int_deletes_future_states_after_undo(server: SyncServer, default_user):\n    \"\"\"\n  ",
          "parameters": "cServer, default_user):\n    \"\"\"\n  ",
          "return_type": null,
          "docstring": "fies that once we've undone to an earlier checkpoint, creating a new\n    checkpoint removes any leftover 'future' states that existed beyond that sequence.\n    \"\"\"\n    block_m",
          "decorators": [],
          "start_line": 6463,
          "end_line": 6525,
          "is_async": false
        },
        {
          "name": "rst_checkpoint(server: Syn",
          "signature": "def rst_checkpoint(server: SyncServer, default_user):\n    \"\"\"\n  ",
          "parameters": "cServer, default_user):\n    \"\"\"\n  ",
          "return_type": null,
          "docstring": "he block is at the first checkpoint (sequence_number=1),\n    undo should fail because there's no prior checkpoint.\n    \"\"\"\n    block_m",
          "decorators": [],
          "start_line": 6543,
          "end_line": 6559,
          "is_async": false
        },
        {
          "name": "ltiple_checkpoints(server: Syn",
          "signature": "def ltiple_checkpoints(server: SyncServer, default_user):\n    \"\"\"\n  ",
          "parameters": "cServer, default_user):\n    \"\"\"\n  ",
          "return_type": null,
          "docstring": "s multiple checkpoints in a row, then undo repeatedly\n    from seq=3 -> seq=2 -> seq=1, verifying each revert.\n    \"\"\"\n    block_m",
          "decorators": [],
          "start_line": 6562,
          "end_line": 6598,
          "is_async": false
        },
        {
          "name": "ncurrency_stale(server: Syn",
          "signature": "def ncurrency_stale(server: SyncServer, default_user):\n    \"\"\"\n  ",
          "parameters": "cServer, default_user):\n    \"\"\"\n  ",
          "return_type": null,
          "docstring": "nstrate concurrency: both sessions start with the block at seq=2,\n    one session undoes first -> block now seq=1, version increments,\n    the other session tries to undo with stale data -> StaleDataError.\n    \"\"\"\n    block_m",
          "decorators": [],
          "start_line": 6601,
          "end_line": 6642,
          "is_async": false
        },
        {
          "name": "eckpoint_block(server: Syn",
          "signature": "def eckpoint_block(server: SyncServer, default_user):\n    \"\"\"\n  ",
          "parameters": "cServer, default_user):\n    \"\"\"\n  ",
          "return_type": null,
          "docstring": "reate a block with value v1 -> checkpoint => seq=1\n    2) Update to v2 -> checkpoint => seq=2\n    3) Update to v3 -> checkpoint => seq=3\n    4) Undo once (seq=3 -> seq=2)\n    5) Redo once (seq=2 -> seq=3)\n    \"\"\"\n\n    block_",
          "decorators": [],
          "start_line": 6650,
          "end_line": 6683,
          "is_async": false
        },
        {
          "name": "ter_multiple_undo(server: Syn",
          "signature": "def ter_multiple_undo(server: SyncServer, default_user):\n    \"\"\"\n  ",
          "parameters": "cServer, default_user):\n    \"\"\"\n  ",
          "return_type": null,
          "docstring": "reate and checkpoint versions: v1 -> seq=1, v2 -> seq=2, v3 -> seq=3, v4 -> seq=4\n    2) Undo thrice => from seq=4 to seq=1\n    3) Redo thrice => from seq=1 back to seq=4\n    \"\"\"\n    block_m",
          "decorators": [],
          "start_line": 6724,
          "end_line": 6764,
          "is_async": false
        },
        {
          "name": "ncurrency_stale(server: Syn",
          "signature": "def ncurrency_stale(server: SyncServer, default_user):\n    block_",
          "parameters": "cServer, default_user):\n    block_",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 6767,
          "end_line": 6808,
          "is_async": false
        },
        {
          "name": "and_upsert_identity(server: Syn",
          "signature": "def and_upsert_identity(server: SyncServer, default_user):\n    identi",
          "parameters": "cServer, default_user):\n    identi",
          "return_type": null,
          "docstring": null,
          "decorators": [
            ".asyncio\nasync def t"
          ],
          "start_line": 6817,
          "end_line": 6855,
          "is_async": true
        },
        {
          "name": "ntities(server, def",
          "signature": "def ntities(server, default_user):\n    # Crea",
          "parameters": "ault_user):\n    # Crea",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 6858,
          "end_line": 6880,
          "is_async": true
        },
        {
          "name": "identity(server: Syn",
          "signature": "def identity(server: SyncServer, sarah_agent, charles_agent, default_user):\n    identi",
          "parameters": "cServer, sarah_agent, charles_agent, default_user):\n    identi",
          "return_type": null,
          "docstring": null,
          "decorators": [
            ".asyncio\nasync def t"
          ],
          "start_line": 6884,
          "end_line": 6908,
          "is_async": true
        },
        {
          "name": "detach_identity_from_agent(server: Syn",
          "signature": "def detach_identity_from_agent(server: SyncServer, sarah_agent, default_user):\n    # Crea",
          "parameters": "cServer, sarah_agent, default_user):\n    # Crea",
          "return_type": null,
          "docstring": null,
          "decorators": [
            ".asyncio\nasync def t"
          ],
          "start_line": 6912,
          "end_line": 6933,
          "is_async": true
        },
        {
          "name": "properties(server: Syn",
          "signature": "def properties(server: SyncServer, default_user):\n    identi",
          "parameters": "cServer, default_user):\n    identi",
          "return_type": null,
          "docstring": null,
          "decorators": [
            ".asyncio\nasync def t"
          ],
          "start_line": 7002,
          "end_line": 7027,
          "is_async": true
        },
        {
          "name": "detach_identity_from_block(server: Syn",
          "signature": "def detach_identity_from_block(server: SyncServer, default_block, default_user):\n    # Crea",
          "parameters": "cServer, default_block, default_user):\n    # Crea",
          "return_type": null,
          "docstring": null,
          "decorators": [
            ".asyncio\nasync def t"
          ],
          "start_line": 7031,
          "end_line": 7051,
          "is_async": true
        },
        {
          "name": "properties(server: Syn",
          "signature": "def properties(server: SyncServer, default_user):\n    identi",
          "parameters": "cServer, default_user):\n    identi",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 7103,
          "end_line": 7128,
          "is_async": true
        },
        {
          "name": "sting_source_names(server: Syn",
          "signature": "def sting_source_names(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "fast batch check for existing source names.\"\"\"\n    # Creat",
          "decorators": [
            ".asyncio\nasync def t"
          ],
          "start_line": 7137,
          "end_line": 7186,
          "is_async": true
        },
        {
          "name": "source(server: Syn",
          "signature": "def source(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "ting a new source.\"\"\"\n    source_",
          "decorators": [
            ".asyncio\nasync def t"
          ],
          "start_line": 7190,
          "end_line": 7204,
          "is_async": true
        },
        {
          "name": "vector_db_provider_with_tpuf(server: Syn",
          "signature": "def vector_db_provider_with_tpuf(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "vector_db_provider is correctly set based on should_use_tpuf.\"\"\"\n    from le",
          "decorators": [],
          "start_line": 7207,
          "end_line": 7255,
          "is_async": true
        },
        {
          "name": "sources_with_same_name_raises_error(server: Syn",
          "signature": "def sources_with_same_name_raises_error(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "creating sources with the same name raises an IntegrityError due to unique constraint.\"\"\"\n    name =",
          "decorators": [],
          "start_line": 7258,
          "end_line": 7277,
          "is_async": true
        },
        {
          "name": "source(server: Syn",
          "signature": "def source(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "ting an existing source.\"\"\"\n    source_",
          "decorators": [],
          "start_line": 7280,
          "end_line": 7292,
          "is_async": true
        },
        {
          "name": "source(server: Syn",
          "signature": "def source(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "ting a source.\"\"\"\n    source_",
          "decorators": [],
          "start_line": 7295,
          "end_line": 7310,
          "is_async": true
        },
        {
          "name": "attached_source(server: Syn",
          "signature": "def attached_source(server: SyncServer, sarah_agent, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, sarah_agent, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "ting a source.\"\"\"\n    source_",
          "decorators": [
            ".asyncio\nasync def t"
          ],
          "start_line": 7314,
          "end_line": 7335,
          "is_async": true
        },
        {
          "name": "urces(server: Syn",
          "signature": "def urces(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "ing sources with pagination.\"\"\"\n    # Creat",
          "decorators": [],
          "start_line": 7338,
          "end_line": 7361,
          "is_async": true
        },
        {
          "name": "rce_by_id(server: Syn",
          "signature": "def rce_by_id(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "ieving a source by ID.\"\"\"\n    source_",
          "decorators": [],
          "start_line": 7364,
          "end_line": 7377,
          "is_async": true
        },
        {
          "name": "rce_by_name(server: Syn",
          "signature": "def rce_by_name(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "ieving a source by name.\"\"\"\n    source_",
          "decorators": [],
          "start_line": 7380,
          "end_line": 7392,
          "is_async": true
        },
        {
          "name": "source_no_changes(server: Syn",
          "signature": "def source_no_changes(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "te_source with no actual changes to verify logging and response.\"\"\"\n    source_",
          "decorators": [],
          "start_line": 7395,
          "end_line": 7407,
          "is_async": true
        },
        {
          "name": "sert_sources_async(server: Syn",
          "signature": "def sert_sources_async(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "upserting sources.\"\"\"\n    sources",
          "decorators": [],
          "start_line": 7410,
          "end_line": 7443,
          "is_async": true
        },
        {
          "name": "sert_sources_name_conflict(server: Syn",
          "signature": "def sert_sources_name_conflict(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "upserting sources with name conflicts.\"\"\"\n    # Creat",
          "decorators": [],
          "start_line": 7446,
          "end_line": 7489,
          "is_async": true
        },
        {
          "name": "sert_sources_mixed_create_update(server: Syn",
          "signature": "def sert_sources_mixed_create_update(server: SyncServer, default_user):\n    \"\"\"Tes",
          "parameters": "cServer, default_user):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "upserting with a mix of creates and updates.\"\"\"\n    # Creat",
          "decorators": [],
          "start_line": 7492,
          "end_line": 7562,
          "is_async": true
        },
        {
          "name": "e_by_id(server: Syn",
          "signature": "def e_by_id(server: SyncServer, default_user, default_source):\n    \"\"\"Tes",
          "parameters": "cServer, default_user, default_source):\n    \"\"\"Tes",
          "return_type": null,
          "docstring": "ieving a file by ID.\"\"\"\n    file_me",
          "decorators": [],
          "start_line": 7570,
          "end_line": 7588,
          "is_async": true
        },
        {
          "name": "and_retrieve_file_with_content(server, def",
          "signature": "def and_retrieve_file_with_content(server, default_user, default_source, async_session):\n    text_b",
          "parameters": "ault_user, default_source, async_session):\n    text_b",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 7591,
          "end_line": 7616,
          "is_async": true
        },
        {
          "name": "file_without_content(server, def",
          "signature": "def file_without_content(server, default_user, default_source, async_session):\n    meta =",
          "parameters": "ault_user, default_source, async_session):\n    meta =",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 7619,
          "end_line": 7634,
          "is_async": true
        },
        {
          "name": "ise_guard(server, def",
          "signature": "def ise_guard(server, default_user, default_source, async_session):\n    text_b",
          "parameters": "ault_user, default_source, async_session):\n    text_b",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 7637,
          "end_line": 7654,
          "is_async": true
        },
        {
          "name": "s_content_none(server, defau",
          "signature": "def s_content_none(server, default_user, default_source):\n    files = ",
          "parameters": "lt_user, default_source):\n    files = ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 7657,
          "end_line": 7659,
          "is_async": true
        },
        {
          "name": "scades_to_content(server, defau",
          "signature": "def scades_to_content(server, default_user, default_source, async_session):\n    text_bod",
          "parameters": "lt_user, default_source, async_session):\n    text_bod",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 7662,
          "end_line": 7680,
          "is_async": true
        },
        {
          "name": "by_original_name_and_source_found(server: SyncS",
          "signature": "def by_original_name_and_source_found(server: SyncServer, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "erver, default_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ving a file by original filename and source when it exists.\"\"\"\n    original_",
          "decorators": [],
          "start_line": 7683,
          "end_line": 7705,
          "is_async": true
        },
        {
          "name": "by_original_name_and_source_not_found(server: SyncS",
          "signature": "def by_original_name_and_source_not_found(server: SyncServer, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "erver, default_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ving a file by original filename and source when it doesn't exist.\"\"\"\n    non_exist",
          "decorators": [],
          "start_line": 7708,
          "end_line": 7718,
          "is_async": true
        },
        {
          "name": "by_original_name_and_source_different_sources(server: SyncS",
          "signature": "def by_original_name_and_source_different_sources(server: SyncServer, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "erver, default_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "iles with same original name in different sources are handled correctly.\"\"\"\n    from lett",
          "decorators": [],
          "start_line": 7721,
          "end_line": 7775,
          "is_async": true
        },
        {
          "name": "by_original_name_and_source_ignores_deleted(server: SyncS",
          "signature": "def by_original_name_and_source_ignores_deleted(server: SyncServer, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "erver, default_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "eleted files are ignored when searching by original name and source.\"\"\"\n    original_",
          "decorators": [],
          "start_line": 7778,
          "end_line": 7807,
          "is_async": true
        },
        {
          "name": "s(server: SyncS",
          "signature": "def s(server: SyncServer, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "erver, default_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "g files with pagination.\"\"\"\n    # Create",
          "decorators": [],
          "start_line": 7810,
          "end_line": 7835,
          "is_async": true
        },
        {
          "name": "le(server: SyncS",
          "signature": "def le(server: SyncServer, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "erver, default_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ng a file.\"\"\"\n    file_meta",
          "decorators": [],
          "start_line": 7838,
          "end_line": 7853,
          "is_async": true
        },
        {
          "name": "le_status_basic(server, defau",
          "signature": "def le_status_basic(server, default_user, default_source):\n    \"\"\"Updat",
          "parameters": "lt_user, default_source):\n    \"\"\"Updat",
          "return_type": null,
          "docstring": "essing status and error message for a file.\"\"\"\n    meta = Py",
          "decorators": [],
          "start_line": 7856,
          "end_line": 7884,
          "is_async": true
        },
        {
          "name": "le_status_error_only(server, defau",
          "signature": "def le_status_error_only(server, default_user, default_source):\n    \"\"\"Updat",
          "parameters": "lt_user, default_source):\n    \"\"\"Updat",
          "return_type": null,
          "docstring": "the error message, leave status unchanged.\"\"\"\n    meta = Py",
          "decorators": [],
          "start_line": 7887,
          "end_line": 7904,
          "is_async": true
        },
        {
          "name": "le_status_with_chunks(server, defau",
          "signature": "def le_status_with_chunks(server, default_user, default_source):\n    \"\"\"Updat",
          "parameters": "lt_user, default_source):\n    \"\"\"Updat",
          "return_type": null,
          "docstring": "k progress fields along with status.\"\"\"\n    meta = Py",
          "decorators": [],
          "start_line": 7907,
          "end_line": 7946,
          "is_async": true
        },
        {
          "name": "us_valid_transitions(server, defau",
          "signature": "def us_valid_transitions(server, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "lt_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "state transitions follow the expected flow.\"\"\"\n    meta = Py",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 7950,
          "end_line": 7984,
          "is_async": true
        },
        {
          "name": "us_invalid_transitions(server, defau",
          "signature": "def us_invalid_transitions(server, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "lt_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "nvalid state transitions are blocked.\"\"\"\n    # Test PE",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 7988,
          "end_line": 8044,
          "is_async": true
        },
        {
          "name": "us_terminal_states(server, defau",
          "signature": "def us_terminal_states(server, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "lt_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "erminal states (COMPLETED and ERROR) cannot be updated.\"\"\"\n    # Test CO",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8048,
          "end_line": 8104,
          "is_async": true
        },
        {
          "name": "us_error_transitions(server, defau",
          "signature": "def us_error_transitions(server, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "lt_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ny non-terminal state can transition to ERROR.\"\"\"\n    # PENDING",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8108,
          "end_line": 8172,
          "is_async": true
        },
        {
          "name": "us_terminal_state_non_status_updates(server, defau",
          "signature": "def us_terminal_state_non_status_updates(server, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "lt_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "erminal states block ALL updates, not just status changes.\"\"\"\n    # Create",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8176,
          "end_line": 8238,
          "is_async": true
        },
        {
          "name": "us_race_condition_prevention(server, defau",
          "signature": "def us_race_condition_prevention(server, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "lt_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ace conditions are prevented when multiple updates happen.\"\"\"\n    meta = Py",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8242,
          "end_line": 8284,
          "is_async": true
        },
        {
          "name": "us_backwards_transitions(server, defau",
          "signature": "def us_backwards_transitions(server, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "lt_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ackwards transitions are not allowed.\"\"\"\n    meta = Py",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8288,
          "end_line": 8317,
          "is_async": true
        },
        {
          "name": "us_update_with_chunks_progress(server, defau",
          "signature": "def us_update_with_chunks_progress(server, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "lt_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ng chunk progress during EMBEDDING state.\"\"\"\n    meta = Py",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8321,
          "end_line": 8368,
          "is_async": true
        },
        {
          "name": "e_transitions_allowed(server, defau",
          "signature": "def e_transitions_allowed(server, default_user, default_source):\n    \"\"\"Test ",
          "parameters": "lt_user, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ame-state transitions are allowed to prevent race conditions.\"\"\"\n    # Create",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8372,
          "end_line": 8405,
          "is_async": true
        },
        {
          "name": "le_content_basic(server: SyncS",
          "signature": "def le_content_basic(server: SyncServer, default_user, default_source, async_session):\n    \"\"\"Test ",
          "parameters": "erver, default_user, default_source, async_session):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ng and updating file content with upsert_file_content().\"\"\"\n    initial_t",
          "decorators": [],
          "start_line": 8408,
          "end_line": 8450,
          "is_async": true
        },
        {
          "name": "ization_sources_metadata(server, defau",
          "signature": "def ization_sources_metadata(server, default_user):\n    \"\"\"Test ",
          "parameters": "lt_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "g organization sources metadata with aggregated file information.\"\"\"\n    # Create",
          "decorators": [],
          "start_line": 8453,
          "end_line": 8553,
          "is_async": true
        },
        {
          "name": "cal_sandbox_config_defaults(server: SyncS",
          "signature": "def cal_sandbox_config_defaults(server: SyncServer, default_user):\n    sandbox_",
          "parameters": "erver, default_user):\n    sandbox_",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8575,
          "end_line": 8585,
          "is_async": true
        },
        {
          "name": "2b_settings_sandbox_config(server: SyncS",
          "signature": "def 2b_settings_sandbox_config(server: SyncServer, default_user):\n    created_",
          "parameters": "erver, default_user):\n    created_",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8589,
          "end_line": 8597,
          "is_async": true
        },
        {
          "name": "isting_sandbox_config(server: SyncS",
          "signature": "def isting_sandbox_config(server: SyncServer, sandbox_config_fixture, default_user):\n    update_d",
          "parameters": "erver, sandbox_config_fixture, default_user):\n    update_d",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8601,
          "end_line": 8609,
          "is_async": true
        },
        {
          "name": "ndbox_config(server: SyncS",
          "signature": "def ndbox_config(server: SyncServer, sandbox_config_fixture, default_user):\n    deleted_",
          "parameters": "erver, sandbox_config_fixture, default_user):\n    deleted_",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8613,
          "end_line": 8621,
          "is_async": true
        },
        {
          "name": "ox_config_by_type(server: SyncS",
          "signature": "def ox_config_by_type(server: SyncServer, sandbox_config_fixture, default_user):\n    retrieve",
          "parameters": "erver, sandbox_config_fixture, default_user):\n    retrieve",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8625,
          "end_line": 8630,
          "is_async": true
        },
        {
          "name": "box_configs(server: SyncS",
          "signature": "def box_configs(server: SyncServer, default_user):\n    # Creati",
          "parameters": "erver, default_user):\n    # Creati",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8634,
          "end_line": 8666,
          "is_async": true
        },
        {
          "name": "ndbox_env_var(server: SyncS",
          "signature": "def ndbox_env_var(server: SyncServer, sandbox_config_fixture, default_user):\n    env_var_",
          "parameters": "erver, sandbox_config_fixture, default_user):\n    env_var_",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8675,
          "end_line": 8684,
          "is_async": true
        },
        {
          "name": "ndbox_env_var(server: SyncS",
          "signature": "def ndbox_env_var(server: SyncServer, sandbox_env_var_fixture, default_user):\n    update_d",
          "parameters": "erver, sandbox_env_var_fixture, default_user):\n    update_d",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8688,
          "end_line": 8696,
          "is_async": true
        },
        {
          "name": "ndbox_env_var(server: SyncS",
          "signature": "def ndbox_env_var(server: SyncServer, sandbox_config_fixture, sandbox_env_var_fixture, default_user):\n    deleted_",
          "parameters": "erver, sandbox_config_fixture, sandbox_env_var_fixture, default_user):\n    deleted_",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8700,
          "end_line": 8710,
          "is_async": true
        },
        {
          "name": "box_env_vars(server: SyncS",
          "signature": "def box_env_vars(server: SyncServer, sandbox_config_fixture, default_user):\n    # Creati",
          "parameters": "erver, sandbox_config_fixture, default_user):\n    # Creati",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8714,
          "end_line": 8743,
          "is_async": true
        },
        {
          "name": "ox_env_var_by_key(server: SyncS",
          "signature": "def ox_env_var_by_key(server: SyncServer, sandbox_env_var_fixture, default_user):\n    retrieve",
          "parameters": "erver, sandbox_env_var_fixture, default_user):\n    retrieve",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8747,
          "end_line": 8754,
          "is_async": true
        },
        {
          "name": "b(server: SyncS",
          "signature": "def b(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ng a job.\"\"\"\n    job_data",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8763,
          "end_line": 8775,
          "is_async": true
        },
        {
          "name": "y_id(server: SyncS",
          "signature": "def y_id(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ng a job by ID.\"\"\"\n    # Create",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8779,
          "end_line": 8794,
          "is_async": true
        },
        {
          "name": "(server: SyncS",
          "signature": "def (server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "g jobs.\"\"\"\n    # Create",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8798,
          "end_line": 8814,
          "is_async": true
        },
        {
          "name": "b_by_id(server: SyncS",
          "signature": "def b_by_id(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ng a job by its ID.\"\"\"\n    # Create",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8828,
          "end_line": 8845,
          "is_async": true
        },
        {
          "name": "b_by_id(server: SyncS",
          "signature": "def b_by_id(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ng a job by its ID.\"\"\"\n    # Create",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8849,
          "end_line": 8863,
          "is_async": true
        },
        {
          "name": "b_auto_complete(server: SyncS",
          "signature": "def b_auto_complete(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "pdating a job's status to 'completed' automatically sets completed_at.\"\"\"\n    # Create",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8867,
          "end_line": 8882,
          "is_async": true
        },
        {
          "name": "ot_found(server: SyncS",
          "signature": "def ot_found(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ng a non-existent job.\"\"\"\n    non_exist",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8886,
          "end_line": 8890,
          "is_async": true
        },
        {
          "name": "b_not_found(server: SyncS",
          "signature": "def b_not_found(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ng a non-existent job.\"\"\"\n    non_exist",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 8894,
          "end_line": 8898,
          "is_async": true
        },
        {
          "name": "allback(monkeypatch, ",
          "signature": "def allback(monkeypatch, server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "server: SyncServer, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ob callbacks are properly dispatched when a job is completed.\"\"\"\n    captured",
          "decorators": [],
          "start_line": 9033,
          "end_line": 9079,
          "is_async": true
        },
        {
          "name": "ges_add(server: SyncS",
          "signature": "def ges_add(server: SyncServer, default_run, hello_world_message_fixture, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_run, hello_world_message_fixture, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "a message to a job.\"\"\"\n    # Add mes",
          "decorators": [],
          "start_line": 9087,
          "end_line": 9103,
          "is_async": false
        },
        {
          "name": "ges_pagination(server: SyncS",
          "signature": "def ges_pagination(server: SyncServer, default_run, default_user, sarah_agent):\n    \"\"\"Test ",
          "parameters": "erver, default_run, default_user, sarah_agent):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "tion of job messages.\"\"\"\n    # Create",
          "decorators": [],
          "start_line": 9106,
          "end_line": 9211,
          "is_async": false
        },
        {
          "name": "ges_ordering(server: SyncS",
          "signature": "def ges_ordering(server: SyncServer, default_run, default_user, sarah_agent):\n    \"\"\"Test ",
          "parameters": "erver, default_run, default_user, sarah_agent):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "essages are ordered by created_at.\"\"\"\n    # Create",
          "decorators": [],
          "start_line": 9214,
          "end_line": 9259,
          "is_async": false
        },
        {
          "name": "ges_empty(server: SyncS",
          "signature": "def ges_empty(server: SyncServer, default_run, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_run, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "g messages for a job with no messages.\"\"\"\n    messages",
          "decorators": [],
          "start_line": 9262,
          "end_line": 9268,
          "is_async": false
        },
        {
          "name": "ges_add_duplicate(server: SyncS",
          "signature": "def ges_add_duplicate(server: SyncServer, default_run, hello_world_message_fixture, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_run, hello_world_message_fixture, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "the same message to a job twice.\"\"\"\n    # Add mes",
          "decorators": [],
          "start_line": 9271,
          "end_line": 9286,
          "is_async": false
        },
        {
          "name": "ges_filter(server: SyncS",
          "signature": "def ges_filter(server: SyncServer, default_run, default_user, sarah_agent):\n    \"\"\"Test ",
          "parameters": "erver, default_run, default_user, sarah_agent):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "g messages associated with a job.\"\"\"\n    # Create",
          "decorators": [],
          "start_line": 9289,
          "end_line": 9336,
          "is_async": false
        },
        {
          "name": "essages(server: SyncS",
          "signature": "def essages(server: SyncServer, default_user: PydanticUser, sarah_agent):\n    \"\"\"Test ",
          "parameters": "erver, default_user: PydanticUser, sarah_agent):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "g messages for a run with request config.\"\"\"\n    # Create",
          "decorators": [],
          "start_line": 9339,
          "end_line": 9386,
          "is_async": false
        },
        {
          "name": "essages_with_assistant_message(server: SyncS",
          "signature": "def essages_with_assistant_message(server: SyncServer, default_user: PydanticUser, sarah_agent):\n    \"\"\"Test ",
          "parameters": "erver, default_user: PydanticUser, sarah_agent):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "g messages for a run with request config.\"\"\"\n    # Create",
          "decorators": [],
          "start_line": 9389,
          "end_line": 9437,
          "is_async": false
        },
        {
          "name": "ger_error_tracking(server: SyncS",
          "signature": "def ger_error_tracking(server: SyncServer, sarah_agent, default_job, default_user):\n    \"\"\"Test ",
          "parameters": "erver, sarah_agent, default_job, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "anager error tracking functionality.\"\"\"\n    step_mana",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 9573,
          "end_line": 9690,
          "is_async": true
        },
        {
          "name": "ger_error_tracking_edge_cases(server: SyncS",
          "signature": "def ger_error_tracking_edge_cases(server: SyncServer, sarah_agent, default_job, default_user):\n    \"\"\"Test ",
          "parameters": "erver, sarah_agent, default_job, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ases for step manager error tracking.\"\"\"\n    step_mana",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 9694,
          "end_line": 9825,
          "is_async": true
        },
        {
          "name": "ger_list_steps_with_status_filter(server: SyncS",
          "signature": "def ger_list_steps_with_status_filter(server: SyncServer, sarah_agent, default_job, default_user):\n    \"\"\"Test ",
          "parameters": "erver, sarah_agent, default_job, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "g steps with status filters.\"\"\"\n    step_mana",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 9829,
          "end_line": 9871,
          "is_async": true
        },
        {
          "name": "ger_record_metrics(server: SyncS",
          "signature": "def ger_record_metrics(server: SyncServer, sarah_agent, default_job, default_user):\n    \"\"\"Test ",
          "parameters": "erver, sarah_agent, default_job, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ing step metrics functionality.\"\"\"\n    step_mana",
          "decorators": [],
          "start_line": 9874,
          "end_line": 9924,
          "is_async": true
        },
        {
          "name": "ger_record_metrics_nonexistent_step(server: SyncS",
          "signature": "def ger_record_metrics_nonexistent_step(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ing metrics for a nonexistent step.\"\"\"\n    step_mana",
          "decorators": [],
          "start_line": 9927,
          "end_line": 9939,
          "is_async": true
        },
        {
          "name": "ft(server: SyncS",
          "signature": "def ft(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ing time to first token for a job.\"\"\"\n    # Create",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 9951,
          "end_line": 9966,
          "is_async": true
        },
        {
          "name": "sponse_duration(server: SyncS",
          "signature": "def sponse_duration(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ing total response duration for a job.\"\"\"\n    # Create",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 9970,
          "end_line": 9985,
          "is_async": true
        },
        {
          "name": "ming_metrics_together(server: SyncS",
          "signature": "def ming_metrics_together(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ing both TTFT and response duration for a job.\"\"\"\n    # Create",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 9989,
          "end_line": 10008,
          "is_async": true
        },
        {
          "name": "ming_invalid_job(server: SyncS",
          "signature": "def ming_invalid_job(server: SyncServer, default_user):\n    \"\"\"Test ",
          "parameters": "erver, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ing timing metrics for non-existent job fails gracefully.\"\"\"\n    # Try to",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 10012,
          "end_line": 10018,
          "is_async": true
        },
        {
          "name": "(server: SyncS",
          "signature": "def (server: SyncServer, default_user, default_organization):\n    \"\"\"Test ",
          "parameters": "erver, default_user, default_organization):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "g tags functionality.\"\"\"\n    # Create",
          "decorators": [],
          "start_line": 10021,
          "end_line": 10072,
          "is_async": false
        },
        {
          "name": "d_get_batch_request(server, defau",
          "signature": "def d_get_batch_request(server, default_user, dummy_beta_message_batch, letta_batch_job):\n    batch = ",
          "parameters": "lt_user, dummy_beta_message_batch, letta_batch_job):\n    batch = ",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 10081,
          "end_line": 10092,
          "is_async": true
        },
        {
          "name": "tch_status(server, defau",
          "signature": "def tch_status(server, default_user, dummy_beta_message_batch, letta_batch_job):\n    batch = ",
          "parameters": "lt_user, dummy_beta_message_batch, letta_batch_job):\n    batch = ",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 10096,
          "end_line": 10121,
          "is_async": true
        },
        {
          "name": "d_get_batch_item(\n    server, ",
          "signature": "def d_get_batch_item(\n    server, default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    batch = ",
          "parameters": "default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    batch = ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10124,
          "end_line": 10147,
          "is_async": true
        },
        {
          "name": "tch_item(\n    server,\n",
          "signature": "def tch_item(\n    server,\n    default_user,\n    sarah_agent,\n    dummy_beta_message_batch,\n    dummy_llm_config,\n    dummy_step_state,\n    dummy_successful_response,\n    letta_batch_job,\n):\n    batch = ",
          "parameters": "    default_user,\n    sarah_agent,\n    dummy_beta_message_batch,\n    dummy_llm_config,\n    dummy_step_state,\n    dummy_successful_response,\n    letta_batch_job,\n):\n    batch = ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10150,
          "end_line": 10189,
          "is_async": true
        },
        {
          "name": "tch_item(\n    server, ",
          "signature": "def tch_item(\n    server, default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    batch = ",
          "parameters": "default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    batch = ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10192,
          "end_line": 10214,
          "is_async": true
        },
        {
          "name": "ing_batches(server, defau",
          "signature": "def ing_batches(server, default_user, dummy_beta_message_batch, letta_batch_job):\n    # Create",
          "parameters": "lt_user, dummy_beta_message_batch, letta_batch_job):\n    # Create",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 10218,
          "end_line": 10261,
          "is_async": true
        },
        {
          "name": "te_batch_statuses(server, defau",
          "signature": "def te_batch_statuses(server, default_user, dummy_beta_message_batch, letta_batch_job):\n    batch = ",
          "parameters": "lt_user, dummy_beta_message_batch, letta_batch_job):\n    batch = ",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 10265,
          "end_line": 10278,
          "is_async": true
        },
        {
          "name": "te_batch_items_results_by_agent(\n    server,\n",
          "signature": "def te_batch_items_results_by_agent(\n    server,\n    default_user,\n    sarah_agent,\n    dummy_beta_message_batch,\n    dummy_llm_config,\n    dummy_step_state,\n    dummy_successful_response,\n    letta_batch_job,\n):\n    batch = ",
          "parameters": "    default_user,\n    sarah_agent,\n    dummy_beta_message_batch,\n    dummy_llm_config,\n    dummy_step_state,\n    dummy_successful_response,\n    letta_batch_job,\n):\n    batch = ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10281,
          "end_line": 10311,
          "is_async": true
        },
        {
          "name": "te_batch_items_step_status_by_agent(\n    server, ",
          "signature": "def te_batch_items_step_status_by_agent(\n    server, default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    batch = ",
          "parameters": "default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    batch = ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10314,
          "end_line": 10336,
          "is_async": true
        },
        {
          "name": "h_items_limit_and_filter(\n    server, ",
          "signature": "def h_items_limit_and_filter(\n    server, default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    batch = ",
          "parameters": "default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    batch = ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10339,
          "end_line": 10362,
          "is_async": true
        },
        {
          "name": "h_items_pagination(\n    server, ",
          "signature": "def h_items_pagination(\n    server, default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    # Create",
          "parameters": "default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    # Create",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10365,
          "end_line": 10426,
          "is_async": true
        },
        {
          "name": "te_batch_items_request_status_by_agent(\n    server, ",
          "signature": "def te_batch_items_request_status_by_agent(\n    server, default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    # Create",
          "parameters": "default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    # Create",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10429,
          "end_line": 10456,
          "is_async": true
        },
        {
          "name": "te_nonexistent_items_should_error(\n    server,\n",
          "signature": "def te_nonexistent_items_should_error(\n    server,\n    default_user,\n    dummy_beta_message_batch,\n    dummy_successful_response,\n    letta_batch_job,\n):\n    # Create",
          "parameters": "    default_user,\n    dummy_beta_message_batch,\n    dummy_successful_response,\n    letta_batch_job,\n):\n    # Create",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10459,
          "end_line": 10497,
          "is_async": true
        },
        {
          "name": "te_nonexistent_items(server, defau",
          "signature": "def te_nonexistent_items(server, default_user, dummy_beta_message_batch, dummy_successful_response, letta_batch_job):\n    # Create",
          "parameters": "lt_user, dummy_beta_message_batch, dummy_successful_response, letta_batch_job):\n    # Create",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10500,
          "end_line": 10532,
          "is_async": true
        },
        {
          "name": "tch_items_bulk(\n    server, ",
          "signature": "def tch_items_bulk(\n    server, default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    # Create",
          "parameters": "default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    # Create",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10535,
          "end_line": 10585,
          "is_async": true
        },
        {
          "name": "ch_items(\n    server, ",
          "signature": "def ch_items(\n    server, default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    # Create",
          "parameters": "default_user, sarah_agent, dummy_beta_message_batch, dummy_llm_config, dummy_step_state, letta_batch_job\n):\n    # Create",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10588,
          "end_line": 10615,
          "is_async": true
        },
        {
          "name": "p_server(mock_get_clie",
          "signature": "def p_server(mock_get_client, server, default_user):\n    from let",
          "parameters": "nt, server, default_user):\n    from let",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "syncio\n@patch(\"letta",
            "services.mcp_manager.MCPManager.get_mcp_client\")\nasync def tes"
          ],
          "start_line": 10625,
          "end_line": 10710,
          "is_async": true
        },
        {
          "name": "p_server_with_tools(mock_get_clie",
          "signature": "def p_server_with_tools(mock_get_client, server, default_user):\n    \"\"\"Test ",
          "parameters": "nt, server, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "reating an MCP server automatically syncs and persists its tools.\"\"\"\n    from lett",
          "decorators": [
            "services.mcp_manager.MCPManager.get_mcp_client\")\nasync def tes"
          ],
          "start_line": 10714,
          "end_line": 10834,
          "is_async": true
        },
        {
          "name": "p_server_with_tools_connection_failure(mock_get_clie",
          "signature": "def p_server_with_tools_connection_failure(mock_get_client, server, default_user):\n    \"\"\"Test ",
          "parameters": "nt, server, default_user):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "CP server creation succeeds even when tool sync fails (optimistic approach).\"\"\"\n    from lett",
          "decorators": [
            "services.mcp_manager.MCPManager.get_mcp_client\")\nasync def tes"
          ],
          "start_line": 10838,
          "end_line": 10883,
          "is_async": true
        },
        {
          "name": "ervers_by_ids(server, defau",
          "signature": "def ervers_by_ids(server, default_user):\n    from let",
          "parameters": "lt_user):\n    from let",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 10886,
          "end_line": 10960,
          "is_async": true
        },
        {
          "name": "r_deletion_cascades_oauth_sessions(server, defau",
          "signature": "def r_deletion_cascades_oauth_sessions(server, default_organization, default_user):\n    \"\"\"Delet",
          "parameters": "lt_organization, default_user):\n    \"\"\"Delet",
          "return_type": null,
          "docstring": "MCP server deletes associated OAuth sessions (same user + URL).\"\"\"\n\n    from let",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 10965,
          "end_line": 11003,
          "is_async": true
        },
        {
          "name": "sions_with_different_url_persist(server, defau",
          "signature": "def sions_with_different_url_persist(server, default_organization, default_user):\n    \"\"\"Sessi",
          "parameters": "lt_organization, default_user):\n    \"\"\"Sessi",
          "return_type": null,
          "docstring": "th different URL should not be deleted when deleting the server for another URL.\"\"\"\n\n    from let",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 11007,
          "end_line": 11042,
          "is_async": true
        },
        {
          "name": "r_creation_links_orphaned_sessions(server, defau",
          "signature": "def r_creation_links_orphaned_sessions(server, default_organization, default_user):\n    \"\"\"Creat",
          "parameters": "lt_organization, default_user):\n    \"\"\"Creat",
          "return_type": null,
          "docstring": "server should link any existing orphaned sessions (same user + URL).\"\"\"\n\n    from let",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 11046,
          "end_line": 11086,
          "is_async": true
        },
        {
          "name": "r_delete_removes_all_sessions_for_url_and_user(server, defau",
          "signature": "def r_delete_removes_all_sessions_for_url_and_user(server, default_organization, default_user):\n    \"\"\"Delet",
          "parameters": "lt_organization, default_user):\n    \"\"\"Delet",
          "return_type": null,
          "docstring": "server removes both linked and orphaned sessions for same user+URL.\"\"\"\n\n    from let",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 11090,
          "end_line": 11123,
          "is_async": true
        },
        {
          "name": "r_resync_tools(server, defau",
          "signature": "def r_resync_tools(server, default_user, default_organization):\n    \"\"\"Test ",
          "parameters": "lt_user, default_organization):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "esyncing MCP server tools correctly handles added, deleted, and updated tools.\"\"\"\n    from unit",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 11127,
          "end_line": 11234,
          "is_async": true
        },
        {
          "name": "eates_association(server, defau",
          "signature": "def eates_association(server, default_user, sarah_agent, default_file):\n    assoc, c",
          "parameters": "lt_user, sarah_agent, default_file):\n    assoc, c",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 11242,
          "end_line": 11261,
          "is_async": true
        },
        {
          "name": "le_agent(server, file_",
          "signature": "def le_agent(server, file_attachment, default_user):\n    updated ",
          "parameters": "attachment, default_user):\n    updated ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 11298,
          "end_line": 11307,
          "is_async": true
        },
        {
          "name": "le_agent_by_file_name(server, file_",
          "signature": "def le_agent_by_file_name(server, file_attachment, default_user):\n    updated ",
          "parameters": "attachment, default_user):\n    updated ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 11310,
          "end_line": 11321,
          "is_async": true
        },
        {
          "name": "t_line_tracking(server, defau",
          "signature": "def t_line_tracking(server, default_user, sarah_agent, default_source):\n    \"\"\"Test ",
          "parameters": "lt_user, sarah_agent, default_source):\n    \"\"\"Test ",
          "return_type": null,
          "docstring": "ine information is captured when opening files with line ranges\"\"\"\n    from lett",
          "decorators": [
            "syncio\nasync def tes"
          ],
          "start_line": 11325,
          "end_line": 11384,
          "is_async": true
        },
        {
          "name": "ss(server, file_",
          "signature": "def ss(server, file_attachment, default_user):\n    old_ts =",
          "parameters": "attachment, default_user):\n    old_ts =",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 11387,
          "end_line": 11404,
          "is_async": true
        },
        {
          "name": "s_and_agents(\n    server,\n",
          "signature": "def s_and_agents(\n    server,\n    default_user,\n    sarah_agent,\n    charles_agent,\n    default_file,\n    another_file,\n):\n    # defaul",
          "parameters": "    default_user,\n    sarah_agent,\n    charles_agent,\n    default_file,\n    another_file,\n):\n    # defaul",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 11407,
          "end_line": 11464,
          "is_async": true
        },
        {
          "name": "agent_paginated_basic(\n    server,\n    de",
          "signature": "def agent_paginated_basic(\n    server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    \"\"\"Test basic ",
          "parameters": "fault_user,\n    sarah_agent,\n    default_source,\n):\n    \"\"\"Test basic ",
          "return_type": null,
          "docstring": "tion functionality.\"\"\"\n    # create 5 file",
          "decorators": [
            "\nasync def test_list"
          ],
          "start_line": 11468,
          "end_line": 11516,
          "is_async": true
        },
        {
          "name": "agent_paginated_filter_open(\n    server,\n    de",
          "signature": "def agent_paginated_filter_open(\n    server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    \"\"\"Test pagina",
          "parameters": "fault_user,\n    sarah_agent,\n    default_source,\n):\n    \"\"\"Test pagina",
          "return_type": null,
          "docstring": "ith is_open=True filter.\"\"\"\n    # create files:",
          "decorators": [
            "\nasync def test_list"
          ],
          "start_line": 11520,
          "end_line": 11554,
          "is_async": true
        },
        {
          "name": "agent_paginated_filter_closed(\n    server,\n    de",
          "signature": "def agent_paginated_filter_closed(\n    server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    \"\"\"Test pagina",
          "parameters": "fault_user,\n    sarah_agent,\n    default_source,\n):\n    \"\"\"Test pagina",
          "return_type": null,
          "docstring": "ith is_open=False filter.\"\"\"\n    # create files:",
          "decorators": [
            "\nasync def test_list"
          ],
          "start_line": 11558,
          "end_line": 11604,
          "is_async": true
        },
        {
          "name": "agent_paginated_empty(\n    server,\n    de",
          "signature": "def agent_paginated_empty(\n    server,\n    default_user,\n    charles_agent,\n):\n    \"\"\"Test pagina",
          "parameters": "fault_user,\n    charles_agent,\n):\n    \"\"\"Test pagina",
          "return_type": null,
          "docstring": "ith agent that has no files.\"\"\"\n    # charles_agent",
          "decorators": [
            "\nasync def test_list"
          ],
          "start_line": 11608,
          "end_line": 11622,
          "is_async": true
        },
        {
          "name": "agent_paginated_large_limit(\n    server,\n    de",
          "signature": "def agent_paginated_large_limit(\n    server,\n    default_user,\n    sarah_agent,\n    default_source,\n):\n    \"\"\"Test that l",
          "parameters": "fault_user,\n    sarah_agent,\n    default_source,\n):\n    \"\"\"Test that l",
          "return_type": null,
          "docstring": "imit returns all files without pagination.\"\"\"\n    # create 3 file",
          "decorators": [
            "\nasync def test_list"
          ],
          "start_line": 11626,
          "end_line": 11658,
          "is_async": true
        },
        {
          "name": "ver, file_attach",
          "signature": "def ver, file_attachment, default_user):\n    await server.f",
          "parameters": "ment, default_user):\n    await server.f",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "\nasync def test_deta"
          ],
          "start_line": 11662,
          "end_line": 11673,
          "is_async": true
        },
        {
          "name": "k(\n    server,\n    de",
          "signature": "def k(\n    server,\n    default_user,\n    sarah_agent,\n    charles_agent,\n    default_source,\n):\n    \"\"\"Test bulk d",
          "parameters": "fault_user,\n    sarah_agent,\n    charles_agent,\n    default_source,\n):\n    \"\"\"Test bulk d",
          "return_type": null,
          "docstring": "n of multiple agent-file associations.\"\"\"\n    # Create multip",
          "decorators": [],
          "start_line": 11676,
          "end_line": 11761,
          "is_async": true
        },
        {
          "name": "  server,\n    de",
          "signature": "def   server,\n    default_user,\n    other_user_different_org,\n    sarah_agent,\n    default_file,\n):\n    # attach as de",
          "parameters": "fault_user,\n    other_user_different_org,\n    sarah_agent,\n    default_file,\n):\n    # attach as de",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 11764,
          "end_line": 11785,
          "is_async": true
        },
        {
          "name": "k(server, default_use",
          "signature": "def k(server, default_user, sarah_agent, default_source):\n    \"\"\"Test that m",
          "parameters": "r, sarah_agent, default_source):\n    \"\"\"Test that m",
          "return_type": null,
          "docstring": "cess_bulk updates last_accessed_at for multiple files.\"\"\"\n    import time",
          "decorators": [],
          "start_line": 11793,
          "end_line": 11842,
          "is_async": true
        },
        {
          "name": "t_updates_correctly(server, default_use",
          "signature": "def t_updates_correctly(server, default_user, sarah_agent, default_source):\n    \"\"\"Test that l",
          "parameters": "r, sarah_agent, default_source):\n    \"\"\"Test that l",
          "return_type": null,
          "docstring": "cessed_at is updated in the correct scenarios.\"\"\"\n    import time",
          "decorators": [],
          "start_line": 12066,
          "end_line": 12113,
          "is_async": true
        },
        {
          "name": "lk_basic(server, default_use",
          "signature": "def lk_basic(server, default_user, sarah_agent, default_source):\n    \"\"\"Test basic ",
          "parameters": "r, sarah_agent, default_source):\n    \"\"\"Test basic ",
          "return_type": null,
          "docstring": "onality of attach_files_bulk method.\"\"\"\n    # Create multip",
          "decorators": [],
          "start_line": 12116,
          "end_line": 12157,
          "is_async": true
        },
        {
          "name": "lk_deduplication(server, default_use",
          "signature": "def lk_deduplication(server, default_user, sarah_agent, default_source):\n    \"\"\"Test that a",
          "parameters": "r, sarah_agent, default_source):\n    \"\"\"Test that a",
          "return_type": null,
          "docstring": "files_bulk properly deduplicates files with same names.\"\"\"\n    # Create files",
          "decorators": [],
          "start_line": 12160,
          "end_line": 12195,
          "is_async": true
        },
        {
          "name": "lk_lru_eviction(server, default_use",
          "signature": "def lk_lru_eviction(server, default_user, sarah_agent, default_source):\n    \"\"\"Test that a",
          "parameters": "r, sarah_agent, default_source):\n    \"\"\"Test that a",
          "return_type": null,
          "docstring": "files_bulk properly handles LRU eviction without duplicates.\"\"\"\n    import time",
          "decorators": [],
          "start_line": 12198,
          "end_line": 12274,
          "is_async": true
        },
        {
          "name": "lk_mixed_existing_new(server, default_use",
          "signature": "def lk_mixed_existing_new(server, default_user, sarah_agent, default_source):\n    \"\"\"Test bulk a",
          "parameters": "r, sarah_agent, default_source):\n    \"\"\"Test bulk a",
          "return_type": null,
          "docstring": "with mix of existing and new files.\"\"\"\n    # Create and at",
          "decorators": [],
          "start_line": 12277,
          "end_line": 12339,
          "is_async": true
        },
        {
          "name": "lk_empty_list(server, default_use",
          "signature": "def lk_empty_list(server, default_user, sarah_agent):\n    \"\"\"Test attach",
          "parameters": "r, sarah_agent):\n    \"\"\"Test attach",
          "return_type": null,
          "docstring": "_bulk with empty file list.\"\"\"\n    closed_files =",
          "decorators": [],
          "start_line": 12342,
          "end_line": 12354,
          "is_async": true
        },
        {
          "name": "lk_oversized_bulk(server, default_use",
          "signature": "def lk_oversized_bulk(server, default_user, sarah_agent, default_source):\n    \"\"\"Test bulk a",
          "parameters": "r, sarah_agent, default_source):\n    \"\"\"Test bulk a",
          "return_type": null,
          "docstring": "when trying to attach more files than max_files_open allows.\"\"\"\n    max_files_open",
          "decorators": [],
          "start_line": 12357,
          "end_line": 12399,
          "is_async": true
        },
        {
          "name": "ert True\n",
          "signature": "def ert True\n()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "\nasync def test_wipe"
          ],
          "start_line": 12708,
          "end_line": 12709,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317308
    },
    "tests/test_mcp_encryption.py": {
      "path": "tests/test_mcp_encryption.py",
      "contentHash": "6bf57baa7d7aee1c491d795bb495a8e3",
      "mtime": 1768610518550.2007,
      "functions": [
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to create and return a SyncServer instance with MCP manager.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 34,
          "end_line": 39,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317308
    },
    "tests/test_memory.py": {
      "path": "tests/test_memory.py",
      "contentHash": "ed376929aa9c0ee825459feb91dde611",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "make_source",
          "signature": "def make_source(id_: str, name: str, description: str | None = None, instructions: str | None = None)",
          "parameters": "(id_: str, name: str, description: str | None = None, instructions: str | None = None)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 11,
          "end_line": 12,
          "is_async": false
        },
        {
          "name": "chat_memory",
          "signature": "def chat_memory()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 16,
          "end_line": 17,
          "is_async": false
        },
        {
          "name": "test_chat_memory_init_and_utils",
          "signature": "def test_chat_memory_init_and_utils(chat_memory: Memory)",
          "parameters": "(chat_memory: Memory)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 20,
          "end_line": 23,
          "is_async": false
        },
        {
          "name": "test_memory_limit_validation",
          "signature": "def test_memory_limit_validation(chat_memory: Memory)",
          "parameters": "(chat_memory: Memory)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 26,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "test_get_block_not_found",
          "signature": "def test_get_block_not_found(chat_memory: Memory)",
          "parameters": "(chat_memory: Memory)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 33,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "test_update_block_value_type_error",
          "signature": "def test_update_block_value_type_error(chat_memory: Memory)",
          "parameters": "(chat_memory: Memory)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 38,
          "end_line": 40,
          "is_async": false
        },
        {
          "name": "test_update_block_value_success",
          "signature": "def test_update_block_value_success(chat_memory: Memory)",
          "parameters": "(chat_memory: Memory)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 43,
          "end_line": 45,
          "is_async": false
        },
        {
          "name": "test_compile_standard_blocks_metadata_and_values",
          "signature": "def test_compile_standard_blocks_metadata_and_values()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 48,
          "end_line": 61,
          "is_async": false
        },
        {
          "name": "test_compile_line_numbered_blocks_sleeptime",
          "signature": "def test_compile_line_numbered_blocks_sleeptime()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 64,
          "end_line": 71,
          "is_async": false
        },
        {
          "name": "pile_line_numbered_blocks_with_anthropic():\n    ",
          "signature": "def pile_line_numbered_blocks_with_anthropic():\n    \"\"",
          "parameters": "\"\"",
          "return_type": null,
          "docstring": "that line numbers appear when using Anthropic models.\"\"\"\n    fro",
          "decorators": [],
          "start_line": 82,
          "end_line": 91,
          "is_async": false
        },
        {
          "name": "ty_returns_empty_string():\n    m = Memo",
          "signature": "def ty_returns_empty_string():\n    m = Memory",
          "parameters": "ry",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 107,
          "end_line": 109,
          "is_async": false
        },
        {
          "name": "rules_inclusion_and_order():\n    m = Memo",
          "signature": "def rules_inclusion_and_order():\n    m = Memory",
          "parameters": "ry",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 112,
          "end_line": 118,
          "is_async": false
        },
        {
          "name": "as_string_equivalent_behavior():\n    src = ma",
          "signature": "def as_string_equivalent_behavior():\n    src = make",
          "parameters": "ke",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 168,
          "end_line": 173,
          "is_async": false
        },
        {
          "name": "nc_matches_sync():\n    m = Memo",
          "signature": "def nc_matches_sync():\n    m = Memory",
          "parameters": "ry",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "ncio\nasync def test_"
          ],
          "start_line": 190,
          "end_line": 192,
          "is_async": true
        },
        {
          "name": "late_deprecated_noop():\n    m = Memo",
          "signature": "def late_deprecated_noop():\n    m = Memory",
          "parameters": "ry",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 195,
          "end_line": 198,
          "is_async": false
        },
        {
          "name": "hout_descriptions_or_instructions():\n    src = ma",
          "signature": "def hout_descriptions_or_instructions():\n    src = make",
          "parameters": "ke",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 201,
          "end_line": 207,
          "is_async": false
        },
        {
          "name": "etadata_in_file_and_block():\n    src = ma",
          "signature": "def etadata_in_file_and_block():\n    src = make",
          "parameters": "ke",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 210,
          "end_line": 215,
          "is_async": false
        },
        {
          "name": "es_open_counts_truthy_only():\n    src = ma",
          "signature": "def es_open_counts_truthy_only():\n    src = make",
          "parameters": "ke",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 218,
          "end_line": 225,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317309
    },
    "tests/test_message_serialization.py": {
      "path": "tests/test_message_serialization.py",
      "contentHash": "d62c434e6aba67bec23695c9da0e0075",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "test_to_openai_responses_dicts_handles_image_first_content",
          "signature": "def test_to_openai_responses_dicts_handles_image_first_content()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 12,
          "end_line": 17,
          "is_async": false
        },
        {
          "name": "test_fill_image_content_in_responses_input_includes_image_parts",
          "signature": "def test_fill_image_content_in_responses_input_includes_image_parts()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 20,
          "end_line": 24,
          "is_async": false
        },
        {
          "name": "test_to_openai_responses_dicts_handles_image_only_content",
          "signature": "def test_to_openai_responses_dicts_handles_image_only_content()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 27,
          "end_line": 32,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317309
    },
    "tests/test_multi_agent.py": {
      "path": "tests/test_multi_agent.py",
      "contentHash": "415d5f0629e91b6f59f12f004dee959a",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 22,
          "end_line": 29,
          "is_async": false
        },
        {
          "name": "default_organization",
          "signature": "def default_organization(server: SyncServer)",
          "parameters": "(server: SyncServer)",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 33,
          "end_line": 35,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(server: SyncServer, default_organization)",
          "parameters": "(server: SyncServer, default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 39,
          "end_line": 41,
          "is_async": true
        },
        {
          "name": "four_participant_agents",
          "signature": "def four_participant_agents(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 45,
          "end_line": 102,
          "is_async": true
        },
        {
          "name": "manager_agent",
          "signature": "def manager_agent(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 106,
          "end_line": 125,
          "is_async": true
        },
        {
          "name": "test_empty_group",
          "signature": "def test_empty_group(server, default_user)",
          "parameters": "(server, default_user)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 128,
          "end_line": 149,
          "is_async": true
        },
        {
          "name": "test_modify_group_pattern",
          "signature": "def test_modify_group_pattern(server, default_user, four_participant_agents, manager_agent)",
          "parameters": "(server, default_user, four_participant_agents, manager_agent)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 152,
          "end_line": 172,
          "is_async": true
        },
        {
          "name": "test_list_agent_groups",
          "signature": "def test_list_agent_groups(server, default_user, four_participant_agents)",
          "parameters": "(server, default_user, four_participant_agents)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 175,
          "end_line": 197,
          "is_async": true
        },
        {
          "name": "test_round_robin",
          "signature": "def test_round_robin(server, default_user, four_participant_agents)",
          "parameters": "(server, default_user, four_participant_agents)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 200,
          "end_line": 308,
          "is_async": true
        },
        {
          "name": "test_supervisor",
          "signature": "def test_supervisor(server, default_user, four_participant_agents)",
          "parameters": "(server, default_user, four_participant_agents)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 311,
          "end_line": 371,
          "is_async": true
        },
        {
          "name": "test_dynamic_group_chat",
          "signature": "def test_dynamic_group_chat(server, default_user, manager_agent, four_participant_agents)",
          "parameters": "(server, default_user, manager_agent, four_participant_agents)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.flaky(max_runs=2)"
          ],
          "start_line": 375,
          "end_line": 437,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317309
    },
    "tests/test_optimistic_json_parser.py": {
      "path": "tests/test_optimistic_json_parser.py",
      "contentHash": "46a2f9ab5a9c4837ce7db29c21036343",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "strict_parser",
          "signature": "def strict_parser()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Provides a fresh OptimisticJSONParser instance in strict mode.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 10,
          "end_line": 12,
          "is_async": false
        },
        {
          "name": "lenient_parser",
          "signature": "def lenient_parser()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Provides a fresh OptimisticJSONParser instance in non-strict mode.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 16,
          "end_line": 18,
          "is_async": false
        },
        {
          "name": "test_parse_empty_input",
          "signature": "def test_parse_empty_input(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test parsing an empty string. Should fall back to parsing \"{}\".",
          "decorators": [],
          "start_line": 21,
          "end_line": 26,
          "is_async": false
        },
        {
          "name": "test_parse_valid_json",
          "signature": "def test_parse_valid_json(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test parsing a valid JSON string using the standard json.loads logic.",
          "decorators": [],
          "start_line": 29,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "test_parse_valid_json_array",
          "signature": "def test_parse_valid_json_array(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test parsing a valid JSON array.",
          "decorators": [],
          "start_line": 38,
          "end_line": 44,
          "is_async": false
        },
        {
          "name": "test_parse_partial_json_object",
          "signature": "def test_parse_partial_json_object(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test parsing a JSON object with extra trailing characters.\n    The extra characters should trigger on_extra_token.",
          "decorators": [],
          "start_line": 47,
          "end_line": 58,
          "is_async": false
        },
        {
          "name": "test_parse_partial_json_array",
          "signature": "def test_parse_partial_json_array(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test parsing a JSON array with extra tokens.",
          "decorators": [],
          "start_line": 61,
          "end_line": 68,
          "is_async": false
        },
        {
          "name": "test_parse_number_cases",
          "signature": "def test_parse_number_cases(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test various number formats.",
          "decorators": [],
          "start_line": 71,
          "end_line": 93,
          "is_async": false
        },
        {
          "name": "test_parse_boolean_true",
          "signature": "def test_parse_boolean_true(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 96,
          "end_line": 99,
          "is_async": false
        },
        {
          "name": "test_parse_boolean_false",
          "signature": "def test_parse_boolean_false(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 102,
          "end_line": 103,
          "is_async": false
        },
        {
          "name": "test_parse_null",
          "signature": "def test_parse_null(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 106,
          "end_line": 107,
          "is_async": false
        },
        {
          "name": "test_parse_invalid_booleans",
          "signature": "def test_parse_invalid_booleans(strict_parser, invalid_boolean)",
          "parameters": "(strict_parser, invalid_boolean)",
          "return_type": null,
          "docstring": "Test some invalid booleans. The parser tries to parse them as partial if possible.\n    If it fails, it may raise an exception or parse partially based on the code.",
          "decorators": [
            "@pytest.mark.parametrize(\"invalid_boolean\", [\"tru\", \"fa\", \"fal\", \"True\", \"False\"])"
          ],
          "start_line": 111,
          "end_line": 124,
          "is_async": false
        },
        {
          "name": "test_parse_string_with_escapes",
          "signature": "def test_parse_string_with_escapes(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test a string containing escaped quotes.",
          "decorators": [],
          "start_line": 127,
          "end_line": 133,
          "is_async": false
        },
        {
          "name": "test_parse_incomplete_string_strict",
          "signature": "def test_parse_incomplete_string_strict(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test how a strict parser handles an incomplete string.",
          "decorators": [],
          "start_line": 136,
          "end_line": 145,
          "is_async": false
        },
        {
          "name": "test_parse_incomplete_string_lenient",
          "signature": "def test_parse_incomplete_string_lenient(lenient_parser)",
          "parameters": "(lenient_parser)",
          "return_type": null,
          "docstring": "In non-strict mode, incomplete strings may be returned as-is.",
          "decorators": [],
          "start_line": 148,
          "end_line": 154,
          "is_async": false
        },
        {
          "name": "test_parse_incomplete_number_strict",
          "signature": "def test_parse_incomplete_number_strict(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test how a strict parser handles an incomplete number, like '-' or '.'.\n    In strict mode, the parser now raises JSONDecodeError rather than\n    returning the partial string.",
          "decorators": [],
          "start_line": 157,
          "end_line": 165,
          "is_async": false
        },
        {
          "name": "test_object_with_missing_colon",
          "signature": "def test_object_with_missing_colon(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test parsing an object missing a colon. Should raise or partially parse.",
          "decorators": [],
          "start_line": 168,
          "end_line": 177,
          "is_async": false
        },
        {
          "name": "test_object_with_missing_value",
          "signature": "def test_object_with_missing_value(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test parsing an object with a key but no value before a comma or brace.",
          "decorators": [],
          "start_line": 180,
          "end_line": 188,
          "is_async": false
        },
        {
          "name": "test_array_with_trailing_comma",
          "signature": "def test_array_with_trailing_comma(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test array that might have a trailing comma before closing.",
          "decorators": [],
          "start_line": 191,
          "end_line": 199,
          "is_async": false
        },
        {
          "name": "test_callback_invocation",
          "signature": "def test_callback_invocation(strict_parser, capsys)",
          "parameters": "(strict_parser, capsys)",
          "return_type": null,
          "docstring": "Verify that on_extra_token callback is invoked and prints expected content.",
          "decorators": [],
          "start_line": 202,
          "end_line": 209,
          "is_async": false
        },
        {
          "name": "test_unknown_token",
          "signature": "def test_unknown_token(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test parser behavior when encountering an unknown first character.\n    Should raise JSONDecodeError in strict mode.",
          "decorators": [],
          "start_line": 212,
          "end_line": 219,
          "is_async": false
        },
        {
          "name": "test_array_nested_objects",
          "signature": "def test_array_nested_objects(lenient_parser)",
          "parameters": "(lenient_parser)",
          "return_type": null,
          "docstring": "Test parsing a complex structure with nested arrays/objects.",
          "decorators": [],
          "start_line": 222,
          "end_line": 230,
          "is_async": false
        },
        {
          "name": "test_multiple_parse_calls",
          "signature": "def test_multiple_parse_calls(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test calling parse() multiple times to ensure leftover is reset properly.",
          "decorators": [],
          "start_line": 233,
          "end_line": 248,
          "is_async": false
        },
        {
          "name": "test_parse_incomplete_string_streaming_strict",
          "signature": "def test_parse_incomplete_string_streaming_strict(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test how a strict parser handles an incomplete string received in chunks.",
          "decorators": [],
          "start_line": 251,
          "end_line": 270,
          "is_async": false
        },
        {
          "name": "test_unescaped_control_characters_strict",
          "signature": "def test_unescaped_control_characters_strict(strict_parser)",
          "parameters": "(strict_parser)",
          "return_type": null,
          "docstring": "Test parsing JSON containing unescaped control characters in strict mode.",
          "decorators": [],
          "start_line": 273,
          "end_line": 280,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317309
    },
    "tests/test_otel_tracing.py": {
      "path": "tests/test_otel_tracing.py",
      "contentHash": "8ad1e550bd0fc1613e3f88c6fdc2fbb8",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "span_processor",
          "signature": "def span_processor()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Setup OTEL tracing with span capture.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 50,
          "end_line": 65,
          "is_async": false
        },
        {
          "name": "clear_spans",
          "signature": "def clear_spans(span_processor)",
          "parameters": "(span_processor)",
          "return_type": null,
          "docstring": "Clear captured spans before each test.",
          "decorators": [
            "@pytest.fixture(scope=\"function\", autouse=True)"
          ],
          "start_line": 69,
          "end_line": 72,
          "is_async": false
        },
        {
          "name": "create_large_messages",
          "signature": "def create_large_messages(size_mb=5)",
          "parameters": "(size_mb=5)",
          "return_type": null,
          "docstring": "Create large message list simulating production data.",
          "decorators": [],
          "start_line": 75,
          "end_line": 92,
          "is_async": false
        },
        {
          "name": "get_span_attributes",
          "signature": "def get_span_attributes(span)",
          "parameters": "(span)",
          "return_type": null,
          "docstring": "Extract parameter attributes from a span.",
          "decorators": [],
          "start_line": 95,
          "end_line": 98,
          "is_async": false
        },
        {
          "name": "test_messages_parameter_excluded",
          "signature": "def test_messages_parameter_excluded(span_processor)",
          "parameters": "(span_processor)",
          "return_type": null,
          "docstring": "Test that large messages parameter is excluded from span attributes.",
          "decorators": [],
          "start_line": 101,
          "end_line": 128,
          "is_async": false
        },
        {
          "name": "test_content_parameter_excluded",
          "signature": "def test_content_parameter_excluded(span_processor)",
          "parameters": "(span_processor)",
          "return_type": null,
          "docstring": "Test that large content parameter is excluded from span attributes.",
          "decorators": [],
          "start_line": 131,
          "end_line": 152,
          "is_async": false
        },
        {
          "name": "test_source_code_parameter_excluded",
          "signature": "def test_source_code_parameter_excluded(span_processor)",
          "parameters": "(span_processor)",
          "return_type": null,
          "docstring": "Test that large source_code parameter is excluded from span attributes.",
          "decorators": [],
          "start_line": 155,
          "end_line": 188,
          "is_async": false
        },
        {
          "name": "test_large_parameter_truncated",
          "signature": "def test_large_parameter_truncated(span_processor)",
          "parameters": "(span_processor)",
          "return_type": null,
          "docstring": "Test that non-excluded large parameters are truncated.",
          "decorators": [],
          "start_line": 191,
          "end_line": 217,
          "is_async": false
        },
        {
          "name": "test_small_parameters_kept",
          "signature": "def test_small_parameters_kept(span_processor)",
          "parameters": "(span_processor)",
          "return_type": null,
          "docstring": "Test that small parameters are kept in full.",
          "decorators": [],
          "start_line": 220,
          "end_line": 241,
          "is_async": false
        },
        {
          "name": "test_total_span_size_reasonable",
          "signature": "def test_total_span_size_reasonable(span_processor)",
          "parameters": "(span_processor)",
          "return_type": null,
          "docstring": "Test that total span attribute size remains reasonable with multiple large params.",
          "decorators": [],
          "start_line": 244,
          "end_line": 271,
          "is_async": false
        },
        {
          "name": "test_serialization_failure_handled",
          "signature": "def test_serialization_failure_handled(span_processor)",
          "parameters": "(span_processor)",
          "return_type": null,
          "docstring": "Test that serialization failures are handled gracefully.",
          "decorators": [],
          "start_line": 274,
          "end_line": 301,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317309
    },
    "tests/test_plugins.py": {
      "path": "tests/test_plugins.py",
      "contentHash": "c891c6244b11bd8d28670f1fe6cd3277",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "test_default_experimental_decorator",
          "signature": "def test_default_experimental_decorator()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 9,
          "end_line": 17,
          "is_async": true
        },
        {
          "name": "test_overwrite_arg_success",
          "signature": "def test_overwrite_arg_success()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 21,
          "end_line": 30,
          "is_async": true
        },
        {
          "name": "test_overwrite_arg_fail",
          "signature": "def test_overwrite_arg_fail()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 34,
          "end_line": 60,
          "is_async": true
        },
        {
          "name": "test_redis_flag",
          "signature": "def test_redis_flag()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 64,
          "end_line": 96,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317309
    },
    "tests/test_prompt_caching.py": {
      "path": "tests/test_prompt_caching.py",
      "contentHash": "0686c1eeaed753e95759fbac7e53b5a3",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "r:\n    \"",
          "signature": "def r:\n    \"\"\" -> the",
          "parameters": "\"\"",
          "return_type": "the",
          "docstring": "server URL from environment or use default.\"\"\"\n    return os.g",
          "decorators": [
            "def base_url() "
          ],
          "start_line": 246,
          "end_line": 248,
          "is_async": false
        },
        {
          "name": "e_url: str) ",
          "signature": "def e_url: str) -> AsyncLetta:\n -> \"\"\"Create ",
          "parameters": "-> AsyncLetta:\n",
          "return_type": "\"\"\"Create ",
          "docstring": "nc Letta client.\"\"\"\n    return Asyn",
          "decorators": [
            "async def async"
          ],
          "start_line": 252,
          "end_line": 254,
          "is_async": true
        },
        {
          "name": "h_large_memory(client: AsyncLe",
          "signature": "def h_large_memory(client: AsyncLetta, model: str, model_settings: dict, suffix: str):\n    \"\"\"\n    Cr",
          "parameters": "tta, model: str, model_settings: dict, suffix: str):\n    \"\"\"\n    Cr",
          "return_type": null,
          "docstring": "n agent with a large memory block to exceed caching thresholds.\n\n    Uses DEFAULT agent configuration (thinking enabled, base tools included) to test\n    real-world caching behavior, not artificial simplified scenarios.\n\n    If tests fail, that reveals actual caching issues with production configurations.\n    \"\"\"\n    from letta_",
          "decorators": [],
          "start_line": 262,
          "end_line": 289,
          "is_async": true
        },
        {
          "name": "ient: AsyncLe",
          "signature": "def ient: AsyncLetta, agent_id: str):\n    \"\"\"Delete ",
          "parameters": "tta, agent_id: str):\n    \"\"\"Delete ",
          "return_type": null,
          "docstring": "agent.\"\"\"\n    try:",
          "decorators": [],
          "start_line": 292,
          "end_line": 298,
          "is_async": true
        },
        {
          "name": "ity(usage, context:",
          "signature": "def ity(usage, context: str = \"\"):\n    \"\"\"\n    Sa",
          "parameters": " str = \"\"):\n    \"\"\"\n    Sa",
          "return_type": null,
          "docstring": "hecks for usage data to catch obviously wrong values.\n\n    These catch bugs like:\n    - output_tokens=1 (impossible for real responses)\n    - Cumulative values being accumulated instead of assigned\n    - Token counts exceeding model limits\n    \"\"\"\n    prefix = f\"",
          "decorators": [],
          "start_line": 301,
          "end_line": 344,
          "is_async": false
        },
        {
          "name": "ing_cache_write_then_read(\n    async_clie",
          "signature": "def ing_cache_write_then_read(\n    async_client: AsyncLetta,\n    model: str,\n    model_settings: dict,\n    min_tokens: int,\n    read_field: str,\n    write_field: str,\n):\n    \"\"\"\n    Te",
          "parameters": "nt: AsyncLetta,\n    model: str,\n    model_settings: dict,\n    min_tokens: int,\n    read_field: str,\n    write_field: str,\n):\n    \"\"\"\n    Te",
          "return_type": null,
          "docstring": "t prompt caching properly creates cache on first message and hits cache on second message.\n\n    This test validates that our LLM clients are correctly enabling caching:\n    - OpenAI: Should automatically cache (no config needed)\n    - Anthropic: Should add cache_control breakpoints\n    - Gemini: Should benefit from implicit caching on 2.5 models\n\n    Args:\n        model: Model handle (e.g., \"openai/gpt-4o\")\n        model_settings: Additional model settings\n        min_tokens: Minimum token threshold for this provider\n        read_field: Field name in prompt_tokens_details for cache reads\n        write_field: Field name in prompt_tokens_details for cache writes (None if no separate field)\n    \"\"\"\n    agent = awa",
          "decorators": [
            "ncio\n@pytest.mark.pa",
            "ametrize(\"model,model_settings,min_tokens,read_field,write_field\", CACHING_TEST_CONFIGS)\nasync def test_"
          ],
          "start_line": 354,
          "end_line": 456,
          "is_async": true
        },
        {
          "name": "g_multiple_messages(\n    async_client",
          "signature": "def g_multiple_messages(\n    async_client: AsyncLetta,\n    model: str,\n    model_settings: dict,\n    min_tokens: int,\n    read_field: str,\n    write_field: str,\n):\n    \"\"\"\n    Test",
          "parameters": ": AsyncLetta,\n    model: str,\n    model_settings: dict,\n    min_tokens: int,\n    read_field: str,\n    write_field: str,\n):\n    \"\"\"\n    Test",
          "return_type": null,
          "docstring": "prompt caching continues to work across multiple messages in a conversation.\n\n    After the initial cache write, subsequent messages should continue to hit the cache\n    as long as the context remains similar.\n    \"\"\"\n    agent = await",
          "decorators": [
            "io\n@pytest.mark.para",
            "etrize(\"model,model_settings,min_tokens,read_field,write_field\", CACHING_TEST_CONFIGS)\nasync def test_pr"
          ],
          "start_line": 461,
          "end_line": 517,
          "is_async": true
        },
        {
          "name": "g_cache_invalidation_on_memory_update(\n    async_client",
          "signature": "def g_cache_invalidation_on_memory_update(\n    async_client: AsyncLetta,\n    model: str,\n    model_settings: dict,\n    min_tokens: int,\n    read_field: str,\n    write_field: str,\n):\n    \"\"\"\n    Test",
          "parameters": ": AsyncLetta,\n    model: str,\n    model_settings: dict,\n    min_tokens: int,\n    read_field: str,\n    write_field: str,\n):\n    \"\"\"\n    Test",
          "return_type": null,
          "docstring": "updating memory blocks invalidates the cache.\n\n    When memory is modified, the prompt changes, so the cache should miss\n    and a new cache should be created.\n    \"\"\"\n    agent = await",
          "decorators": [
            "io\n@pytest.mark.para",
            "etrize(\"model,model_settings,min_tokens,read_field,write_field\", CACHING_TEST_CONFIGS)\nasync def test_pr"
          ],
          "start_line": 522,
          "end_line": 596,
          "is_async": true
        },
        {
          "name": "tem_prompt_stability(async_client: Asy",
          "signature": "def tem_prompt_stability(async_client: AsyncLetta):\n    \"\"\"\n    Chec",
          "parameters": "ncLetta):\n    \"\"\"\n    Chec",
          "return_type": null,
          "docstring": "nthropic system prompt is actually stable between REAL requests.\n\n    Uses provider traces from actual messages sent to Anthropic to compare\n    what was really sent, not what the preview endpoint generates.\n    \"\"\"\n    import diffli",
          "decorators": [
            "io\nasync def test_an"
          ],
          "start_line": 605,
          "end_line": 693,
          "is_async": true
        },
        {
          "name": "sync_client: AsyncLetta):\n    \"\"\"\n",
          "signature": "def sync_client: AsyncLetta):\n    \"\"\"\n    Debug test to inspect ",
          "parameters": "    Debug test to inspect ",
          "return_type": null,
          "docstring": "w Anthropic request and see where cache_control is placed.\n    \"\"\"\n    model = \"anthropic/claude-sonne",
          "decorators": [
            "anthropic_inspect_ra"
          ],
          "start_line": 697,
          "end_line": 772,
          "is_async": true
        },
        {
          "name": "ints(async_client: AsyncLetta):\n    \"\"\"\n",
          "signature": "def ints(async_client: AsyncLetta):\n    \"\"\"\n    Anthropic-specific tes",
          "parameters": "    Anthropic-specific tes",
          "return_type": null,
          "docstring": "erify we're adding cache_control breakpoints.\n\n    If this test fails, it means cache_control isn't working properly - either:\n    - Breakpoints aren't being added at all\n    - Breakpoints are positioned incorrectly\n    - Something in the prompt is changing between messages\n\n    We send multiple messages to account for any timing/routing issues.\n    \"\"\"\n    model = \"anthropic/claude-sonne",
          "decorators": [
            "anthropic_cache_cont"
          ],
          "start_line": 776,
          "end_line": 838,
          "is_async": true
        },
        {
          "name": "ient: AsyncLetta):\n    \"\"\"\n  ",
          "signature": "def ient: AsyncLetta):\n    \"\"\"\n    OpenAI-specific test to ",
          "parameters": "  OpenAI-specific test to ",
          "return_type": null,
          "docstring": "automatic caching works.\n\n    OpenAI caching is automatic, so this should just work if we have 1024 tokens.\n    \"\"\"\n    model = \"openai/gpt-4o\"\n    agent =",
          "decorators": [
            "enai_automatic_cachi"
          ],
          "start_line": 842,
          "end_line": 879,
          "is_async": true
        },
        {
          "name": "nc_client: AsyncLetta):\n    \"\"\"\n    Ge",
          "signature": "def nc_client: AsyncLetta):\n    \"\"\"\n    Gemini-specific test to veri",
          "parameters": "mini-specific test to veri",
          "return_type": null,
          "docstring": "licit caching works on 2.5 Flash.\n\n    Gemini 2.5 Flash has implicit caching (automatic) with 1024 token threshold.\n    \"\"\"\n    model = \"google_ai/gemini-2.5-flash\"",
          "decorators": [
            "_2_5_flash_implicit_"
          ],
          "start_line": 883,
          "end_line": 916,
          "is_async": true
        },
        {
          "name": "nc_client: AsyncLetta):\n    \"\"\"\n    Gemini",
          "signature": "def nc_client: AsyncLetta):\n    \"\"\"\n    Gemini-specific test to verify i",
          "parameters": "-specific test to verify i",
          "return_type": null,
          "docstring": "t caching works on 3 Pro Preview.\n\n    Gemini 3 Pro Preview has implicit caching (automatic) with 2048 token threshold.\n\n    Since implicit caching is stochastic (depends on routing, timing, etc.), we send\n    multiple messages in quick succession and check if ANY of them hit the cache.\n    \"\"\"\n    model = \"google_ai/gemini-3-pro-preview\"",
          "decorators": [
            "ro_preview_implicit_"
          ],
          "start_line": 920,
          "end_line": 972,
          "is_async": true
        },
        {
          "name": " AsyncLetta):\n    \"\"\"\n    Check if G",
          "signature": "def  AsyncLetta):\n    \"\"\"\n    Check if Gemini requests have stable",
          "parameters": "emini requests have stable",
          "return_type": null,
          "docstring": "xes between REAL requests.\n\n    Gemini implicit caching requires the PREFIX of the request to be identical.\n    This test compares actual requests sent to Gemini to see what's changing.\n\n    Key things to check:\n    - System instruction (should be identical)\n    - Tool definitions (order must be same)\n    - Early contents (must be identical prefix)\n    \"\"\"\n    import difflib\n    import json\n\n    model = \"",
          "decorators": [
            "_prefix_stability(as"
          ],
          "start_line": 976,
          "end_line": 1140,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317310
    },
    "tests/test_provider_api.py": {
      "path": "tests/test_provider_api.py",
      "contentHash": "65d51ff373297415fdd19b508012a345",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "run_server",
          "signature": "def run_server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 15,
          "end_line": 21,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(request)",
          "parameters": "(request)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 25,
          "end_line": 39,
          "is_async": false
        },
        {
          "name": "test_provider",
          "signature": "def test_provider(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Create a test provider for testing.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 43,
          "end_line": 59,
          "is_async": false
        },
        {
          "name": "test_check_existing_provider_success",
          "signature": "def test_check_existing_provider_success(client: Letta, test_provider)",
          "parameters": "(client: Letta, test_provider)",
          "return_type": null,
          "docstring": "Test checking an existing provider with valid credentials.",
          "decorators": [],
          "start_line": 62,
          "end_line": 74,
          "is_async": false
        },
        {
          "name": "test_check_existing_provider_not_found",
          "signature": "def test_check_existing_provider_not_found(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Test checking a provider that doesn't exist.",
          "decorators": [],
          "start_line": 77,
          "end_line": 85,
          "is_async": false
        },
        {
          "name": "test_check_existing_provider_unauthorized",
          "signature": "def test_check_existing_provider_unauthorized(client: Letta, test_provider)",
          "parameters": "(client: Letta, test_provider)",
          "return_type": null,
          "docstring": "Test checking an existing provider with invalid API key.",
          "decorators": [],
          "start_line": 88,
          "end_line": 96,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317310
    },
    "tests/test_provider_trace.py": {
      "path": "tests/test_provider_trace.py",
      "contentHash": "1ad92a2a2c595c89ad31847100750b20",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "server_url",
          "signature": "def server_url()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensures a server is running and returns its base URL.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 26,
          "end_line": 35,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client(server_url)",
          "parameters": "(server_url)",
          "return_type": null,
          "docstring": "Creates a REST client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 40,
          "end_line": 43,
          "is_async": false
        },
        {
          "name": "event_loop",
          "signature": "def event_loop(request)",
          "parameters": "(request)",
          "return_type": null,
          "docstring": "Create an instance of the default event loop for each test case.",
          "decorators": [
            "@pytest.fixture(scope=\"session\")"
          ],
          "start_line": 47,
          "end_line": 51,
          "is_async": false
        },
        {
          "name": "roll_dice_tool",
          "signature": "def roll_dice_tool(client, roll_dice_tool_func)",
          "parameters": "(client, roll_dice_tool_func)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 55,
          "end_line": 57,
          "is_async": false
        },
        {
          "name": "weather_tool",
          "signature": "def weather_tool(client, weather_tool_func)",
          "parameters": "(client, weather_tool_func)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 61,
          "end_line": 63,
          "is_async": false
        },
        {
          "name": "print_tool",
          "signature": "def print_tool(client, print_tool_func)",
          "parameters": "(client, print_tool_func)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 67,
          "end_line": 69,
          "is_async": false
        },
        {
          "name": "agent_state",
          "signature": "def agent_state(client, roll_dice_tool, weather_tool)",
          "parameters": "(client, roll_dice_tool, weather_tool)",
          "return_type": null,
          "docstring": "Creates an agent and ensures cleanup after tests.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 73,
          "end_line": 93,
          "is_async": false
        },
        {
          "name": "test_provider_trace_experimental_step",
          "signature": "def test_provider_trace_experimental_step(client, message, agent_state)",
          "parameters": "(client, message, agent_state)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"message\", [\"Get the weather in San Francisco.\"])"
          ],
          "start_line": 98,
          "end_line": 108,
          "is_async": true
        },
        {
          "name": "test_provider_trace_experimental_step_stream",
          "signature": "def test_provider_trace_experimental_step_stream(client, message, agent_state)",
          "parameters": "(client, message, agent_state)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio",
            "@pytest.mark.parametrize(\"message\", [\"Get the weather in San Francisco.\"])"
          ],
          "start_line": 113,
          "end_line": 126,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317310
    },
    "tests/test_providers.py": {
      "path": "tests/test_providers.py",
      "contentHash": "6f93de76aac9eaf1c9c17c2d713eb2bf",
      "mtime": 1768610518550.2007,
      "functions": [
        {
          "name": "test_openai",
          "signature": "def test_openai()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 24,
          "end_line": 36,
          "is_async": false
        },
        {
          "name": "test_openai_async",
          "signature": "def test_openai_async()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 40,
          "end_line": 52,
          "is_async": true
        },
        {
          "name": "test_anthropic",
          "signature": "def test_anthropic()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 56,
          "end_line": 63,
          "is_async": true
        },
        {
          "name": "test_googleai",
          "signature": "def test_googleai()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 67,
          "end_line": 80,
          "is_async": true
        },
        {
          "name": "test_google_vertex",
          "signature": "def test_google_vertex()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 84,
          "end_line": 96,
          "is_async": true
        },
        {
          "name": "test_deepseek",
          "signature": "def test_deepseek()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.skipif(model_settings.deepseek_api_key is None, reason=\"Only run if DEEPSEEK_API_KEY is set.\")",
            "@pytest.mark.asyncio"
          ],
          "start_line": 101,
          "end_line": 105,
          "is_async": true
        },
        {
          "name": "test_zai",
          "signature": "def test_zai()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.skipif(model_settings.zai_api_key is None, reason=\"Only run if ZAI_API_KEY is set.\")",
            "@pytest.mark.asyncio"
          ],
          "start_line": 110,
          "end_line": 118,
          "is_async": true
        },
        {
          "name": "test_groq",
          "signature": "def test_groq()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.skipif(model_settings.groq_api_key is None, reason=\"Only run if GROQ_API_KEY is set.\")",
            "@pytest.mark.asyncio"
          ],
          "start_line": 123,
          "end_line": 130,
          "is_async": true
        },
        {
          "name": "test_azure",
          "signature": "def test_azure()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.skipif(model_settings.azure_api_key is None, reason=\"Only run if AZURE_API_KEY is set.\")",
            "@pytest.mark.asyncio"
          ],
          "start_line": 135,
          "end_line": 148,
          "is_async": true
        },
        {
          "name": "test_together",
          "signature": "def test_together()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.skipif(model_settings.together_api_key is None, reason=\"Only run if TOGETHER_API_KEY is set.\")",
            "@pytest.mark.asyncio"
          ],
          "start_line": 153,
          "end_line": 169,
          "is_async": true
        },
        {
          "name": "test_ollama",
          "signature": "def test_ollama()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.skipif(model_settings.ollama_base_url is None, reason=\"Only run if OLLAMA_BASE_URL is set.\")",
            "@pytest.mark.asyncio"
          ],
          "start_line": 175,
          "end_line": 187,
          "is_async": true
        },
        {
          "name": "test_vllm",
          "signature": "def test_vllm()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.skipif(model_settings.vllm_api_base is None, reason=\"Only run if VLLM_API_BASE is set.\")",
            "@pytest.mark.asyncio"
          ],
          "start_line": 192,
          "end_line": 199,
          "is_async": true
        },
        {
          "name": "test_custom_anthropic",
          "signature": "def test_custom_anthropic()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 217,
          "end_line": 224,
          "is_async": true
        },
        {
          "name": "test_provider_context_window",
          "signature": "def test_provider_context_window()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that providers implement context window methods correctly.",
          "decorators": [],
          "start_line": 227,
          "end_line": 239,
          "is_async": false
        },
        {
          "name": "test_provider_context_window_async",
          "signature": "def test_provider_context_window_async()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that providers implement async context window methods correctly.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 243,
          "end_line": 254,
          "is_async": true
        },
        {
          "name": "test_provider_handle_generation",
          "signature": "def test_provider_handle_generation()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that providers generate handles correctly.",
          "decorators": [],
          "start_line": 257,
          "end_line": 271,
          "is_async": false
        },
        {
          "name": "test_provider_casting",
          "signature": "def test_provider_casting()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that providers can be cast to their specific subtypes.",
          "decorators": [],
          "start_line": 274,
          "end_line": 290,
          "is_async": false
        },
        {
          "name": "test_provider_embedding_models_consistency",
          "signature": "def test_provider_embedding_models_consistency()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that providers return consistent embedding model formats.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 294,
          "end_line": 310,
          "is_async": true
        },
        {
          "name": "test_provider_llm_models_consistency",
          "signature": "def test_provider_llm_models_consistency()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that providers return consistent LLM model formats.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 314,
          "end_line": 335,
          "is_async": true
        },
        {
          "name": "test_reasoning_toggle_by_provider",
          "signature": "def test_reasoning_toggle_by_provider(\n    handle: str,\n    agent_type: AgentType,\n    reasoning: bool,\n    expected_enable_reasoner: bool,\n    expected_put_inner_thoughts_in_kwargs: bool,\n    expected_max_reasoning_tokens: int,\n    expected_reasoning_effort: Optional[Literal[\"none\", \"minimal\", \"low\", \"medium\", \"high\", \"xhigh\"]],\n)",
          "parameters": "(\n    handle: str,\n    agent_type: AgentType,\n    reasoning: bool,\n    expected_enable_reasoner: bool,\n    expected_put_inner_thoughts_in_kwargs: bool,\n    expected_max_reasoning_tokens: int,\n    expected_reasoning_effort: Optional[Literal[\"none\", \"minimal\", \"low\", \"medium\", \"high\", \"xhigh\"]],\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"handle, agent_type, reasoning, expected_enable_reasoner, expected_put_inner_thoughts_in_kwargs, expected_max_reasoning_tokens, expected_reasoning_effort\",\n    [\n        # send message agent loop\n        (\"openai/gpt-4o-mini\", AgentType.memgpt_v2_agent, True, True, True, 0, None),\n        (\"openai/gpt-4o-mini\", AgentType.memgpt_v2_agent, False, False, False, 0, None),\n        (\"openai/o3-mini\", AgentType.memgpt_v2_agent, True, True, False, 0, \"medium\"),\n        (\"openai/o3-mini\", AgentType.memgpt_v2_agent, False, True, False, 0, \"medium\"),\n        (\"anthropic/claude-3.5-sonnet\", AgentType.memgpt_v2_agent, True, True, True, 0, None),\n        (\"anthropic/claude-3.5-sonnet\", AgentType.memgpt_v2_agent, False, False, False, 0, None),\n        (\"anthropic/claude-3-7-sonnet\", AgentType.memgpt_v2_agent, True, True, False, 1024, None),\n        (\"anthropic/claude-3-7-sonnet\", AgentType.memgpt_v2_agent, False, False, False, 0, None),\n        (\"anthropic/claude-sonnet-4\", AgentType.memgpt_v2_agent, True, True, False, 1024, None),\n        (\"anthropic/claude-sonnet-4\", AgentType.memgpt_v2_agent, False, False, False, 0, None),\n        (\"google_vertex/gemini-2.0-flash\", AgentType.memgpt_v2_agent, True, True, True, 0, None),\n        (\"google_vertex/gemini-2.0-flash\", AgentType.memgpt_v2_agent, False, False, False, 0, None),\n        (\"google_vertex/gemini-2.5-flash\", AgentType.memgpt_v2_agent, True, True, True, 1024, None),\n        (\"google_vertex/gemini-2.5-flash\", AgentType.memgpt_v2_agent, False, False, False, 0, None),\n        (\"google_vertex/gemini-2.5-pro\", AgentType.memgpt_v2_agent, True, True, True, 1024, None),\n        (\"google_vertex/gemini-2.5-pro\", AgentType.memgpt_v2_agent, True, True, True, 1024, None),\n        # letta_v1_agent loop\n        (\"openai/gpt-4o-mini\", AgentType.letta_v1_agent, True, False, False, 0, None),\n        (\"openai/gpt-4o-mini\", AgentType.letta_v1_agent, False, False, False, 0, None),\n        (\"openai/o3-mini\", AgentType.letta_v1_agent, True, True, False, 0, \"medium\"),\n        (\"openai/o3-mini\", AgentType.letta_v1_agent, False, True, False, 0, \"medium\"),\n        (\"anthropic/claude-3.5-sonnet\", AgentType.letta_v1_agent, True, False, False, 0, None),\n        (\"anthropic/claude-3.5-sonnet\", AgentType.letta_v1_agent, False, False, False, 0, None),\n        (\"anthropic/claude-3-7-sonnet\", AgentType.letta_v1_agent, True, True, False, 1024, None),\n        (\"anthropic/claude-3-7-sonnet\", AgentType.letta_v1_agent, False, False, False, 0, None),\n        (\"anthropic/claude-sonnet-4\", AgentType.letta_v1_agent, True, True, False, 1024, None),\n        (\"anthropic/claude-sonnet-4\", AgentType.letta_v1_agent, False, False, False, 0, None),\n        (\"google_vertex/gemini-2.0-flash\", AgentType.letta_v1_agent, True, False, False, 0, None),\n        (\"google_vertex/gemini-2.0-flash\", AgentType.letta_v1_agent, False, False, False, 0, None),\n        (\"google_vertex/gemini-2.5-flash\", AgentType.letta_v1_agent, True, True, False, 1024, None),\n        (\"google_vertex/gemini-2.5-flash\", AgentType.letta_v1_agent, False, False, False, 0, None),\n        (\"google_vertex/gemini-2.5-pro\", AgentType.letta_v1_agent, True, True, False, 1024, None),\n        (\"google_vertex/gemini-2.5-pro\", AgentType.letta_v1_agent, False, True, False, 1024, None),\n    ],\n)"
          ],
          "start_line": 377,
          "end_line": 398,
          "is_async": false
        },
        {
          "name": "test_codex_default_reasoning_effort",
          "signature": "def test_codex_default_reasoning_effort()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that gpt-5-codex defaults to 'medium' reasoning effort, not 'minimal'.",
          "decorators": [],
          "start_line": 401,
          "end_line": 420,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317310
    },
    "tests/test_redis_client.py": {
      "path": "tests/test_redis_client.py",
      "contentHash": "9706c025cce49b4f0fef2e602cf0acc2",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "test_redis_client",
          "signature": "def test_redis_client()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 7,
          "end_line": 26,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317310
    },
    "tests/test_run_status_conversion.py": {
      "path": "tests/test_run_status_conversion.py",
      "contentHash": "cb84b52f208c6fe973fb2a96f82ed142",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "test_convert_statuses_to_enum_with_none",
          "signature": "def test_convert_statuses_to_enum_with_none()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that convert_statuses_to_enum returns None when input is None.",
          "decorators": [],
          "start_line": 13,
          "end_line": 16,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_single_status",
          "signature": "def test_convert_statuses_to_enum_with_single_status()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test converting a single status string to RunStatus enum.",
          "decorators": [],
          "start_line": 19,
          "end_line": 23,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_multiple_statuses",
          "signature": "def test_convert_statuses_to_enum_with_multiple_statuses()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test converting multiple status strings to RunStatus enums.",
          "decorators": [],
          "start_line": 26,
          "end_line": 30,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_all_statuses",
          "signature": "def test_convert_statuses_to_enum_with_all_statuses()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test converting all possible status strings.",
          "decorators": [],
          "start_line": 33,
          "end_line": 38,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_empty_list",
          "signature": "def test_convert_statuses_to_enum_with_empty_list()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test converting an empty list.",
          "decorators": [],
          "start_line": 41,
          "end_line": 44,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_invalid_status",
          "signature": "def test_convert_statuses_to_enum_with_invalid_status()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that invalid status strings raise ValueError.",
          "decorators": [],
          "start_line": 47,
          "end_line": 50,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_preserves_order",
          "signature": "def test_convert_statuses_to_enum_preserves_order()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that the order of statuses is preserved.",
          "decorators": [],
          "start_line": 53,
          "end_line": 57,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_duplicate_statuses",
          "signature": "def test_convert_statuses_to_enum_with_duplicate_statuses()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that duplicate statuses are preserved.",
          "decorators": [],
          "start_line": 60,
          "end_line": 65,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_case_sensitivity",
          "signature": "def test_convert_statuses_to_enum_case_sensitivity()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that the function is case-sensitive and requires exact matches.",
          "decorators": [],
          "start_line": 68,
          "end_line": 74,
          "is_async": false
        },
        {
          "name": "test_convert_statuses_to_enum_with_mixed_valid_invalid",
          "signature": "def test_convert_statuses_to_enum_with_mixed_valid_invalid()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that if any status is invalid, the entire conversion fails.",
          "decorators": [],
          "start_line": 77,
          "end_line": 80,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317310
    },
    "tests/test_schema_validator.py": {
      "path": "tests/test_schema_validator.py",
      "contentHash": "152578bdab0c3ba8df5950653eecbd20",
      "mtime": 1767315072156.5488,
      "functions": [
        {
          "name": "test_user_example_schema_now_strict",
          "signature": "def test_user_example_schema_now_strict()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that schemas with optional fields are now considered STRICT_COMPLIANT (will be healed).",
          "decorators": [],
          "start_line": 8,
          "end_line": 28,
          "is_async": false
        },
        {
          "name": "test_all_properties_required_is_strict",
          "signature": "def test_all_properties_required_is_strict()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that schemas with all properties required are STRICT_COMPLIANT.",
          "decorators": [],
          "start_line": 31,
          "end_line": 47,
          "is_async": false
        },
        {
          "name": "test_nested_object_missing_required_now_strict",
          "signature": "def test_nested_object_missing_required_now_strict()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that nested objects with optional fields are now STRICT_COMPLIANT (will be healed).",
          "decorators": [],
          "start_line": 50,
          "end_line": 74,
          "is_async": false
        },
        {
          "name": "test_nested_object_all_required_is_strict",
          "signature": "def test_nested_object_all_required_is_strict()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that nested objects with all properties required are STRICT_COMPLIANT.",
          "decorators": [],
          "start_line": 77,
          "end_line": 101,
          "is_async": false
        },
        {
          "name": "test_empty_object_no_properties_is_strict",
          "signature": "def test_empty_object_no_properties_is_strict()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that objects with no properties are STRICT_COMPLIANT.",
          "decorators": [],
          "start_line": 104,
          "end_line": 117,
          "is_async": false
        },
        {
          "name": "test_missing_additionalproperties_not_strict",
          "signature": "def test_missing_additionalproperties_not_strict()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that missing additionalProperties makes schema NON_STRICT_ONLY.",
          "decorators": [],
          "start_line": 120,
          "end_line": 135,
          "is_async": false
        },
        {
          "name": "test_additionalproperties_true_not_strict",
          "signature": "def test_additionalproperties_true_not_strict()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that additionalProperties: true makes schema NON_STRICT_ONLY.",
          "decorators": [],
          "start_line": 138,
          "end_line": 153,
          "is_async": false
        },
        {
          "name": "test_complex_schema_with_arrays",
          "signature": "def test_complex_schema_with_arrays()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test a complex schema with arrays and nested objects.",
          "decorators": [],
          "start_line": 156,
          "end_line": 187,
          "is_async": false
        },
        {
          "name": "test_fastmcp_tool_schema_now_strict",
          "signature": "def test_fastmcp_tool_schema_now_strict()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that a schema from FastMCP with optional field 'b' is now STRICT_COMPLIANT.",
          "decorators": [],
          "start_line": 190,
          "end_line": 207,
          "is_async": false
        },
        {
          "name": "test_union_types_with_anyof",
          "signature": "def test_union_types_with_anyof()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that anyOf unions are handled correctly.",
          "decorators": [],
          "start_line": 210,
          "end_line": 231,
          "is_async": false
        },
        {
          "name": "test_healed_schema_with_type_array",
          "signature": "def test_healed_schema_with_type_array()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that healed schemas with type arrays including null are STRICT_COMPLIANT.",
          "decorators": [],
          "start_line": 234,
          "end_line": 251,
          "is_async": false
        },
        {
          "name": "test_healed_nested_schema",
          "signature": "def test_healed_nested_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that healed nested schemas are STRICT_COMPLIANT.",
          "decorators": [],
          "start_line": 254,
          "end_line": 278,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317310
    },
    "tests/test_sdk_client.py": {
      "path": "tests/test_sdk_client.py",
      "contentHash": "51f635bb12d328b20b48b5933b24475e",
      "mtime": 1768610518554.2007,
      "functions": [
        {
          "name": "extract_archive_id",
          "signature": "def extract_archive_id(archive) -> str",
          "parameters": "(archive)",
          "return_type": "str",
          "docstring": "Helper function to extract archive ID, handling cases where it might be a list or string representation.",
          "decorators": [],
          "start_line": 41,
          "end_line": 84,
          "is_async": false
        },
        {
          "name": "pytest_configure",
          "signature": "def pytest_configure(config)",
          "parameters": "(config)",
          "return_type": null,
          "docstring": "Override asyncio settings for this test file",
          "decorators": [],
          "start_line": 87,
          "end_line": 90,
          "is_async": false
        },
        {
          "name": "run_server",
          "signature": "def run_server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 93,
          "end_line": 99,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client() -> LettaSDKClient",
          "parameters": "()",
          "return_type": "LettaSDKClient",
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 103,
          "end_line": 114,
          "is_async": false
        },
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Creates a SyncServer instance for testing.\n\n    Loads and saves config to ensure proper initialization.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 118,
          "end_line": 128,
          "is_async": false
        },
        {
          "name": "agent",
          "signature": "def agent(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 132,
          "end_line": 146,
          "is_async": false
        },
        {
          "name": "fibonacci_tool",
          "signature": "def fibonacci_tool(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Fixture providing Fibonacci calculation tool.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 150,
          "end_line": 174,
          "is_async": false
        },
        {
          "name": "preferences_tool",
          "signature": "def preferences_tool(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Fixture providing user preferences tool.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 178,
          "end_line": 195,
          "is_async": false
        },
        {
          "name": "data_analysis_tool",
          "signature": "def data_analysis_tool(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Fixture providing data analysis tool.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 199,
          "end_line": 221,
          "is_async": false
        },
        {
          "name": "persona_block",
          "signature": "def persona_block(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Fixture providing persona memory block.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 225,
          "end_line": 233,
          "is_async": false
        },
        {
          "name": "human_block",
          "signature": "def human_block(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Fixture providing human memory block.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 237,
          "end_line": 245,
          "is_async": false
        },
        {
          "name": "context_block",
          "signature": "def context_block(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Fixture providing project context memory block.",
          "decorators": [
            "@pytest.fixture(scope=\"function\")"
          ],
          "start_line": 249,
          "end_line": 257,
          "is_async": false
        },
        {
          "name": "test_shared_blocks",
          "signature": "def test_shared_blocks(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 260,
          "end_line": 322,
          "is_async": false
        },
        {
          "name": "test_read_only_block",
          "signature": "def test_read_only_block(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 325,
          "end_line": 361,
          "is_async": false
        },
        {
          "name": "test_add_and_manage_tags_for_agent",
          "signature": "def test_add_and_manage_tags_for_agent(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Comprehensive happy path test for adding, retrieving, and managing tags on an agent.",
          "decorators": [],
          "start_line": 364,
          "end_line": 417,
          "is_async": false
        },
        {
          "name": "test_reset_messages",
          "signature": "def test_reset_messages(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test resetting messages for an agent.",
          "decorators": [],
          "start_line": 420,
          "end_line": 478,
          "is_async": false
        },
        {
          "name": "test_list_folders_for_agent",
          "signature": "def test_list_folders_for_agent(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test listing folders for an agent.",
          "decorators": [],
          "start_line": 481,
          "end_line": 513,
          "is_async": false
        },
        {
          "name": "test_list_files_for_agent",
          "signature": "def test_list_files_for_agent(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test listing files for an agent.",
          "decorators": [],
          "start_line": 516,
          "end_line": 595,
          "is_async": false
        },
        {
          "name": "test_modify_message",
          "signature": "def test_modify_message(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test modifying a message.",
          "decorators": [],
          "start_line": 598,
          "end_line": 651,
          "is_async": false
        },
        {
          "name": "test_list_groups_for_agent",
          "signature": "def test_list_groups_for_agent(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test listing groups for an agent.",
          "decorators": [],
          "start_line": 654,
          "end_line": 677,
          "is_async": false
        },
        {
          "name": "test_agent_tags",
          "signature": "def test_agent_tags(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test creating agents with tags and retrieving tags via the API.",
          "decorators": [],
          "start_line": 680,
          "end_line": 754,
          "is_async": false
        },
        {
          "name": "test_update_agent_memory_label",
          "signature": "def test_update_agent_memory_label(client: LettaSDKClient, agent: AgentState)",
          "parameters": "(client: LettaSDKClient, agent: AgentState)",
          "return_type": null,
          "docstring": "Test that we can update the label of a block in an agent's memory",
          "decorators": [],
          "start_line": 757,
          "end_line": 771,
          "is_async": false
        },
        {
          "name": "test_add_remove_agent_memory_block",
          "signature": "def test_add_remove_agent_memory_block(client: LettaSDKClient, agent: AgentState)",
          "parameters": "(client: LettaSDKClient, agent: AgentState)",
          "return_type": null,
          "docstring": "Test that we can add and remove a block from an agent's memory",
          "decorators": [],
          "start_line": 774,
          "end_line": 805,
          "is_async": false
        },
        {
          "name": "test_update_agent_memory_limit",
          "signature": "def test_update_agent_memory_limit(client: LettaSDKClient, agent: AgentState)",
          "parameters": "(client: LettaSDKClient, agent: AgentState)",
          "return_type": null,
          "docstring": "Test that we can update the limit of a block in an agent's memory",
          "decorators": [],
          "start_line": 808,
          "end_line": 837,
          "is_async": false
        },
        {
          "name": "test_messages",
          "signature": "def test_messages(client: LettaSDKClient, agent: AgentState)",
          "parameters": "(client: LettaSDKClient, agent: AgentState)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 840,
          "end_line": 856,
          "is_async": false
        },
        {
          "name": "test_send_system_message",
          "signature": "def test_send_system_message(client: LettaSDKClient, agent: AgentState)",
          "parameters": "(client: LettaSDKClient, agent: AgentState)",
          "return_type": null,
          "docstring": "Important unit test since the Letta API exposes sending system messages, but some backends don't natively support it (eg Anthropic)",
          "decorators": [],
          "start_line": 859,
          "end_line": 870,
          "is_async": false
        },
        {
          "name": "test_function_return_limit",
          "signature": "def test_function_return_limit(disable_e2b_api_key, client: LettaSDKClient, agent: AgentState)",
          "parameters": "(disable_e2b_api_key, client: LettaSDKClient, agent: AgentState)",
          "return_type": null,
          "docstring": "Test to see if the function return limit works",
          "decorators": [],
          "start_line": 873,
          "end_line": 909,
          "is_async": false
        },
        {
          "name": "test_function_always_error",
          "signature": "def test_function_always_error(client: LettaSDKClient, agent: AgentState)",
          "parameters": "(client: LettaSDKClient, agent: AgentState)",
          "return_type": null,
          "docstring": "Test to see if function that errors works correctly",
          "decorators": [
            "@pytest.mark.flaky(max_runs=3)"
          ],
          "start_line": 913,
          "end_line": 947,
          "is_async": false
        },
        {
          "name": "test_agent_creation",
          "signature": "def test_agent_creation(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test that block IDs are properly attached when creating an agent.",
          "decorators": [],
          "start_line": 990,
          "end_line": 1048,
          "is_async": false
        },
        {
          "name": "test_many_blocks",
          "signature": "def test_many_blocks(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1051,
          "end_line": 1105,
          "is_async": false
        },
        {
          "name": "test_include_return_message_types",
          "signature": "def test_include_return_message_types(client: LettaSDKClient, agent: AgentState, message_create: str)",
          "parameters": "(client: LettaSDKClient, agent: AgentState, message_create: str)",
          "return_type": null,
          "docstring": "Test that the include_return_message_types parameter works",
          "decorators": [
            "@pytest.mark.parametrize(\"message_create\", [\"stream_step\", \"token_stream\", \"sync\", \"async\"])"
          ],
          "start_line": 1110,
          "end_line": 1192,
          "is_async": false
        },
        {
          "name": "test_base_tools_upsert_on_list",
          "signature": "def test_base_tools_upsert_on_list(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test that base tools are automatically upserted when missing on tools list call",
          "decorators": [],
          "start_line": 1195,
          "end_line": 1236,
          "is_async": false
        },
        {
          "name": "test_pydantic_inventory_management_tool",
          "signature": "def test_pydantic_inventory_management_tool(e2b_sandbox_mode, client: LettaSDKClient)",
          "parameters": "(e2b_sandbox_mode, client: LettaSDKClient)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\"e2b_sandbox_mode\", [True, False], indirect=True)"
          ],
          "start_line": 1240,
          "end_line": 1338,
          "is_async": false
        },
        {
          "name": "test_pydantic_task_planning_tool",
          "signature": "def test_pydantic_task_planning_tool(e2b_sandbox_mode, client: LettaSDKClient)",
          "parameters": "(e2b_sandbox_mode, client: LettaSDKClient)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\"e2b_sandbox_mode\", [False], indirect=True)"
          ],
          "start_line": 1342,
          "end_line": 1428,
          "is_async": false
        },
        {
          "name": "test_create_tool_from_function_with_docstring",
          "signature": "def test_create_tool_from_function_with_docstring(e2b_sandbox_mode, client: LettaSDKClient)",
          "parameters": "(e2b_sandbox_mode, client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test creating a tool from a function with a docstring using create_from_function",
          "decorators": [
            "@pytest.mark.parametrize(\"e2b_sandbox_mode\", [True, False], indirect=True)"
          ],
          "start_line": 1432,
          "end_line": 1463,
          "is_async": false
        },
        {
          "name": "test_preview_payload",
          "signature": "def test_preview_payload(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.skip(reason=\"Not compatible with 1.0 SDK\")"
          ],
          "start_line": 1467,
          "end_line": 1559,
          "is_async": false
        },
        {
          "name": "test_agent_tools_list",
          "signature": "def test_agent_tools_list(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test the optimized agent tools list endpoint for correctness.",
          "decorators": [],
          "start_line": 1562,
          "end_line": 1593,
          "is_async": false
        },
        {
          "name": "test_agent_tool_rules_deduplication",
          "signature": "def test_agent_tool_rules_deduplication(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test that duplicate tool rules are properly deduplicated when creating/updating agents.",
          "decorators": [],
          "start_line": 1596,
          "end_line": 1646,
          "is_async": false
        },
        {
          "name": "test_add_tool_with_multiple_functions_in_source_code",
          "signature": "def test_add_tool_with_multiple_functions_in_source_code(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test adding a tool with multiple functions in the source code",
          "decorators": [],
          "start_line": 1649,
          "end_line": 1728,
          "is_async": false
        },
        {
          "name": "test_tool_rename_with_json_schema_and_source_code",
          "signature": "def test_tool_rename_with_json_schema_and_source_code(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test that passing both new JSON schema AND source code still renames the tool based on source code",
          "decorators": [],
          "start_line": 1871,
          "end_line": 1937,
          "is_async": false
        },
        {
          "name": "test_export_import_agent_with_files",
          "signature": "def test_export_import_agent_with_files(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test exporting and importing an agent with files attached.",
          "decorators": [],
          "start_line": 1940,
          "end_line": 2051,
          "is_async": false
        },
        {
          "name": "test_upsert_tools",
          "signature": "def test_upsert_tools(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test upserting tools with complex schemas.",
          "decorators": [],
          "start_line": 2054,
          "end_line": 2106,
          "is_async": false
        },
        {
          "name": "test_run_list",
          "signature": "def test_run_list(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test listing runs.",
          "decorators": [],
          "start_line": 2109,
          "end_line": 2147,
          "is_async": false
        },
        {
          "name": "test_create_batch",
          "signature": "def test_create_batch(client: LettaSDKClient, server: SyncServer)",
          "parameters": "(client: LettaSDKClient, server: SyncServer)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2151,
          "end_line": 2211,
          "is_async": true
        },
        {
          "name": "test_create_agent",
          "signature": "def test_create_agent(client: LettaSDKClient) -> None",
          "parameters": "(client: LettaSDKClient)",
          "return_type": "None",
          "docstring": "Test creating an agent and streaming messages with tokens",
          "decorators": [],
          "start_line": 2214,
          "end_line": 2265,
          "is_async": false
        },
        {
          "name": "test_list_all_messages",
          "signature": "def test_list_all_messages(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test listing all messages across multiple agents.",
          "decorators": [
            "@pytest.mark.skip(reason=\"Not compatible with 1.0 SDK\")"
          ],
          "start_line": 2269,
          "end_line": 2360,
          "is_async": false
        },
        {
          "name": "test_create_agent_with_tools",
          "signature": "def test_create_agent_with_tools(client: LettaSDKClient) -> None",
          "parameters": "(client: LettaSDKClient)",
          "return_type": "None",
          "docstring": "Test creating an agent with custom inventory management tools",
          "decorators": [],
          "start_line": 2363,
          "end_line": 2439,
          "is_async": false
        },
        {
          "name": "test_calling_tools",
          "signature": "def test_calling_tools(client: LettaSDKClient, agent: AgentState) -> None",
          "parameters": "(client: LettaSDKClient, agent: AgentState)",
          "return_type": "None",
          "docstring": "Test to make sure calling tools through the SDK works as expected",
          "decorators": [],
          "start_line": 2442,
          "end_line": 2459,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317311
    },
    "tests/test_server.py": {
      "path": "tests/test_server.py",
      "contentHash": "9602dcb078730278dc44fcfd79196d7d",
      "mtime": 1767315072160.5488,
      "functions": [
        {
          "name": "server",
          "signature": "def server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 40,
          "end_line": 47,
          "is_async": true
        },
        {
          "name": "org_id",
          "signature": "def org_id(server)",
          "parameters": "(server)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 51,
          "end_line": 58,
          "is_async": true
        },
        {
          "name": "user",
          "signature": "def user(server, org_id)",
          "parameters": "(server, org_id)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 62,
          "end_line": 64,
          "is_async": true
        },
        {
          "name": "user_id",
          "signature": "def user_id(server, user)",
          "parameters": "(server, user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 68,
          "end_line": 70,
          "is_async": false
        },
        {
          "name": "custom_anthropic_provider",
          "signature": "def custom_anthropic_provider(server: SyncServer, user_id: str)",
          "parameters": "(server: SyncServer, user_id: str)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 77,
          "end_line": 100,
          "is_async": true
        },
        {
          "name": "agent",
          "signature": "def agent(server: SyncServer, user: User)",
          "parameters": "(server: SyncServer, user: User)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 104,
          "end_line": 111,
          "is_async": true
        },
        {
          "name": "test_messages_with_provider_override",
          "signature": "def test_messages_with_provider_override(server: SyncServer, custom_anthropic_provider: PydanticProvider, user)",
          "parameters": "(server: SyncServer, custom_anthropic_provider: PydanticProvider, user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 115,
          "end_line": 211,
          "is_async": true
        },
        {
          "name": "test_messages_with_provider_override_legacy_agent",
          "signature": "def test_messages_with_provider_override_legacy_agent(server: SyncServer, custom_anthropic_provider: PydanticProvider, user)",
          "parameters": "(server: SyncServer, custom_anthropic_provider: PydanticProvider, user)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 215,
          "end_line": 287,
          "is_async": true
        },
        {
          "name": "test_unique_handles_for_provider_configs",
          "signature": "def test_unique_handles_for_provider_configs(server: SyncServer, user: User)",
          "parameters": "(server: SyncServer, user: User)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 291,
          "end_line": 297,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317311
    },
    "tests/test_server_providers.py": {
      "path": "tests/test_server_providers.py",
      "contentHash": "de411bdd3beee584b15f492757d78211",
      "mtime": 1768610518554.2007,
      "functions": [
        {
          "name": "unique_provider_name",
          "signature": "def unique_provider_name(base_name=\"test-provider\")",
          "parameters": "(base_name=\"test-provider\")",
          "return_type": null,
          "docstring": "Generate a unique provider name for testing.",
          "decorators": [],
          "start_line": 20,
          "end_line": 22,
          "is_async": false
        },
        {
          "name": "generate_test_id",
          "signature": "def generate_test_id()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Generate a unique test ID for handles and names.",
          "decorators": [],
          "start_line": 25,
          "end_line": 27,
          "is_async": false
        },
        {
          "name": "default_organization",
          "signature": "def default_organization()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to create and return the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 31,
          "end_line": 35,
          "is_async": true
        },
        {
          "name": "default_user",
          "signature": "def default_user(default_organization)",
          "parameters": "(default_organization)",
          "return_type": null,
          "docstring": "Fixture to create and return the default user within the default organization.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 39,
          "end_line": 43,
          "is_async": true
        },
        {
          "name": "provider_manager",
          "signature": "def provider_manager()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to create and return a ProviderManager instance.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 47,
          "end_line": 49,
          "is_async": true
        },
        {
          "name": "org_manager",
          "signature": "def org_manager()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Fixture to create and return an OrganizationManager instance.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 53,
          "end_line": 55,
          "is_async": true
        },
        {
          "name": "test_sync_base_providers_creates_new_providers",
          "signature": "def test_sync_base_providers_creates_new_providers(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that sync_base_providers creates providers that don't exist.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 59,
          "end_line": 80,
          "is_async": true
        },
        {
          "name": "test_sync_base_providers_skips_existing_providers",
          "signature": "def test_sync_base_providers_skips_existing_providers(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that sync_base_providers skips providers that already exist.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 84,
          "end_line": 99,
          "is_async": true
        },
        {
          "name": "test_sync_base_providers_handles_race_condition",
          "signature": "def test_sync_base_providers_handles_race_condition(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that sync_base_providers handles race conditions gracefully.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 103,
          "end_line": 131,
          "is_async": true
        },
        {
          "name": "test_sync_base_providers_handles_none_api_key",
          "signature": "def test_sync_base_providers_handles_none_api_key(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that sync_base_providers handles providers with None api_key.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 135,
          "end_line": 148,
          "is_async": true
        },
        {
          "name": "test_sync_provider_models_async",
          "signature": "def test_sync_provider_models_async(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that sync_provider_models_async persists LLM and embedding models to database.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 152,
          "end_line": 229,
          "is_async": true
        },
        {
          "name": "test_sync_provider_models_idempotent",
          "signature": "def test_sync_provider_models_idempotent(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that sync_provider_models_async is idempotent and doesn't duplicate models.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 233,
          "end_line": 282,
          "is_async": true
        },
        {
          "name": "test_get_model_by_handle_async_org_scoped",
          "signature": "def test_get_model_by_handle_async_org_scoped(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that get_model_by_handle_async returns both base and BYOK providers/models.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 286,
          "end_line": 422,
          "is_async": true
        },
        {
          "name": "test_get_model_by_handle_async_unique_handles",
          "signature": "def test_get_model_by_handle_async_unique_handles(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that handles are unique within each organization scope.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 426,
          "end_line": 536,
          "is_async": true
        },
        {
          "name": "test_list_models_async_combines_global_and_org",
          "signature": "def test_list_models_async_combines_global_and_org(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that list_models_async returns both global and org-scoped models with org-scoped taking precedence.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 540,
          "end_line": 624,
          "is_async": true
        },
        {
          "name": "test_list_models_async_filters",
          "signature": "def test_list_models_async_filters(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that list_models_async properly applies filters.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 628,
          "end_line": 718,
          "is_async": true
        },
        {
          "name": "test_model_metadata_persistence",
          "signature": "def test_model_metadata_persistence(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that model metadata like context window, streaming, and tool calling are properly persisted.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 722,
          "end_line": 763,
          "is_async": true
        },
        {
          "name": "test_model_enabled_filter",
          "signature": "def test_model_enabled_filter(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that enabled filter works properly in list_models_async.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 767,
          "end_line": 824,
          "is_async": true
        },
        {
          "name": "test_get_llm_config_from_handle_uses_cached_models",
          "signature": "def test_get_llm_config_from_handle_uses_cached_models(default_user)",
          "parameters": "(default_user)",
          "return_type": null,
          "docstring": "Test that get_llm_config_from_handle_async uses cached models from database instead of querying provider.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 828,
          "end_line": 874,
          "is_async": true
        },
        {
          "name": "test_get_embedding_config_from_handle_uses_cached_models",
          "signature": "def test_get_embedding_config_from_handle_uses_cached_models(default_user)",
          "parameters": "(default_user)",
          "return_type": null,
          "docstring": "Test that get_embedding_config_from_handle_async uses cached models from database instead of querying provider.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 878,
          "end_line": 917,
          "is_async": true
        },
        {
          "name": "test_server_sync_provider_models_on_init",
          "signature": "def test_server_sync_provider_models_on_init(default_user)",
          "parameters": "(default_user)",
          "return_type": null,
          "docstring": "Test that the server syncs provider models to database during initialization.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 921,
          "end_line": 1002,
          "is_async": true
        },
        {
          "name": "test_provider_model_unique_constraint_per_org",
          "signature": "def test_provider_model_unique_constraint_per_org(default_user, provider_manager, org_manager, default_organization)",
          "parameters": "(default_user, provider_manager, org_manager, default_organization)",
          "return_type": null,
          "docstring": "Test that provider models have unique handles within each organization (not globally).",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1006,
          "end_line": 1129,
          "is_async": true
        },
        {
          "name": "test_sync_provider_models_add_remove_models",
          "signature": "def test_sync_provider_models_add_remove_models(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that sync_provider_models_async correctly handles:\n    1. Adding new models to an existing provider\n    2. Removing models from an existing provider\n    3. Not dropping non-base (BYOK) provider models during sync",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1133,
          "end_line": 1297,
          "is_async": true
        },
        {
          "name": "test_sync_provider_models_mixed_llm_and_embedding",
          "signature": "def test_sync_provider_models_mixed_llm_and_embedding(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that sync_provider_models_async correctly handles adding/removing both LLM and embedding models,\n    ensuring that changes to one model type don't affect the other.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1301,
          "end_line": 1410,
          "is_async": true
        },
        {
          "name": "test_provider_name_uniqueness_within_org",
          "signature": "def test_provider_name_uniqueness_within_org(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that provider names must be unique within an organization, including conflicts with base provider names.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1414,
          "end_line": 1453,
          "is_async": true
        },
        {
          "name": "test_model_name_uniqueness_within_provider",
          "signature": "def test_model_name_uniqueness_within_provider(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that model names must be unique within a provider.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1457,
          "end_line": 1582,
          "is_async": true
        },
        {
          "name": "test_handle_uniqueness_per_org",
          "signature": "def test_handle_uniqueness_per_org(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that handles must be unique within organizations but can be duplicated across different orgs.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1586,
          "end_line": 1744,
          "is_async": true
        },
        {
          "name": "test_delete_provider_cascades_to_models",
          "signature": "def test_delete_provider_cascades_to_models(default_user, provider_manager, monkeypatch)",
          "parameters": "(default_user, provider_manager, monkeypatch)",
          "return_type": null,
          "docstring": "Test that deleting a provider also soft-deletes its associated models.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1748,
          "end_line": 1851,
          "is_async": true
        },
        {
          "name": "test_get_llm_config_from_handle_includes_max_tokens",
          "signature": "def test_get_llm_config_from_handle_includes_max_tokens(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that get_llm_config_from_handle includes max_tokens from provider's get_default_max_output_tokens.\n\n    This test verifies that:\n    1. The max_tokens field is populated when retrieving LLMConfig from a handle\n    2. The max_tokens value comes from the provider's get_default_max_output_tokens method\n    3. Different providers return different default max_tokens values (e.g., OpenAI returns 16384)",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1855,
          "end_line": 1930,
          "is_async": true
        },
        {
          "name": "test_server_list_llm_models_async_reads_from_database",
          "signature": "def test_server_list_llm_models_async_reads_from_database(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that the server's list_llm_models_async reads models from database, not in-memory.\n\n    This test verifies that:\n    1. Models synced to the database are returned by list_llm_models_async\n    2. The LLMConfig objects are correctly constructed from database-cached models\n    3. Provider filtering works correctly when reading from database",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 1934,
          "end_line": 2009,
          "is_async": true
        },
        {
          "name": "test_get_enabled_providers_async_queries_database",
          "signature": "def test_get_enabled_providers_async_queries_database(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that get_enabled_providers_async queries providers from database, not in-memory list.\n\n    This test verifies that:\n    1. Providers created in the database are returned by get_enabled_providers_async\n    2. The method queries the database, not an in-memory _enabled_providers list\n    3. Provider filtering by category works correctly from database",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2013,
          "end_line": 2093,
          "is_async": true
        },
        {
          "name": "test_list_providers_filters_by_category",
          "signature": "def test_list_providers_filters_by_category(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that list_providers_async correctly filters by provider_category.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2102,
          "end_line": 2146,
          "is_async": true
        },
        {
          "name": "test_base_provider_api_key_not_stored_in_db",
          "signature": "def test_base_provider_api_key_not_stored_in_db(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that sync_base_providers does NOT store API keys for base providers.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2150,
          "end_line": 2170,
          "is_async": true
        },
        {
          "name": "test_byok_provider_api_key_stored_in_db",
          "signature": "def test_byok_provider_api_key_stored_in_db(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that BYOK providers DO have their API keys stored in the database.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2174,
          "end_line": 2196,
          "is_async": true
        },
        {
          "name": "test_server_list_llm_models_base_from_db",
          "signature": "def test_server_list_llm_models_base_from_db(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that server.list_llm_models_async fetches base models from database.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2200,
          "end_line": 2250,
          "is_async": true
        },
        {
          "name": "test_server_list_llm_models_byok_from_provider_api",
          "signature": "def test_server_list_llm_models_byok_from_provider_api(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that server.list_llm_models_async fetches BYOK models from provider API, not DB.\n\n    Note: BYOK models are fetched by calling the provider's list_llm_models_async() method,\n    which hits the actual provider API. This test uses mocking to verify that flow.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2254,
          "end_line": 2309,
          "is_async": true
        },
        {
          "name": "test_server_list_embedding_models_base_from_db",
          "signature": "def test_server_list_embedding_models_base_from_db(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that server.list_embedding_models_async fetches base models from database.\n\n    Note: Similar to LLM models, base embedding models are stored in DB while BYOK\n    embedding models would be fetched from provider API.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2313,
          "end_line": 2357,
          "is_async": true
        },
        {
          "name": "test_provider_ordering_matches_constants",
          "signature": "def test_provider_ordering_matches_constants(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that provider ordering in model listing matches PROVIDER_ORDER in constants.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2361,
          "end_line": 2431,
          "is_async": true
        },
        {
          "name": "test_create_agent_with_byok_handle_dynamic_fetch",
          "signature": "def test_create_agent_with_byok_handle_dynamic_fetch(default_user, provider_manager)",
          "parameters": "(default_user, provider_manager)",
          "return_type": null,
          "docstring": "Test that creating an agent with a BYOK model handle works via dynamic fetch.\n\n    This tests the case where BYOK models are NOT synced to the database, but are\n    instead fetched dynamically from the provider when resolving the handle.\n    This is the expected behavior after the provider models persistence refactor.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 2435,
          "end_line": 2527,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317312
    },
    "tests/test_sonnet_nonnative_reasoning_buffering.py": {
      "path": "tests/test_sonnet_nonnative_reasoning_buffering.py",
      "contentHash": "39f1f78d1f854ce4cc76a148262d8b84",
      "mtime": 1767315072160.5488,
      "functions": [
        {
          "name": "run_server",
          "signature": "def run_server()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Start the Letta server.",
          "decorators": [],
          "start_line": 23,
          "end_line": 31,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Create a Letta client for testing.",
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 35,
          "end_line": 52,
          "is_async": false
        },
        {
          "name": "agent_factory",
          "signature": "def agent_factory(client: Letta)",
          "parameters": "(client: Letta)",
          "return_type": null,
          "docstring": "Factory fixture to create agents with different models.",
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 56,
          "end_line": 88,
          "is_async": false
        },
        {
          "name": "detect_burst_chunks",
          "signature": "def detect_burst_chunks(chunks: List[Tuple[float, any]], burst_threshold: float = 0.05) -> List[List[int]]",
          "parameters": "(chunks: List[Tuple[float, any]], burst_threshold: float = 0.05)",
          "return_type": "List[List[int]]",
          "docstring": "Detect bursts of chunks arriving close together in time.\n\n    Args:\n        chunks: List of (timestamp, chunk) tuples\n        burst_threshold: Maximum time difference (in seconds) to consider chunks as part of the same burst\n\n    Returns:\n        List of bursts, where each burst is a list of chunk indices",
          "decorators": [],
          "start_line": 91,
          "end_line": 123,
          "is_async": false
        },
        {
          "name": "test_streaming_buffering_behavior",
          "signature": "def test_streaming_buffering_behavior(client: Letta, agent_factory, model: str, expected_buffering: bool)",
          "parameters": "(client: Letta, agent_factory, model: str, expected_buffering: bool)",
          "return_type": null,
          "docstring": "Test streaming behavior for different models.\n\n    With fine-grained-tool-streaming beta header:\n    - Sonnet 3.5 (20241022) should now stream progressively (beta feature improves tool streaming)\n    - Sonnet 4 (20250514) with native reasoning should stream progressively without buffering\n    - GPT-4.1 should stream progressively without buffering",
          "decorators": [
            "@pytest.mark.parametrize(\n    \"model,expected_buffering\",\n    [\n        (\"anthropic/claude-sonnet-4-20250514\", False),  # With fine-grained streaming beta, should stream better\n        (\"anthropic/claude-sonnet-4-20250514\", False),  # Sonnet 4 should NOT show buffering (has native reasoning)\n        (\"openai/gpt-4.1\", False),  # GPT-4.1 should NOT show buffering (uses native reasoning)\n    ],\n)"
          ],
          "start_line": 134,
          "end_line": 305,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317312
    },
    "tests/test_sources.py": {
      "path": "tests/test_sources.py",
      "contentHash": "b5305397eac1b282b2d8a1d400dabd3d",
      "mtime": 1768610518554.2007,
      "functions": [
        {
          "name": "get_raw_system_message",
          "signature": "def get_raw_system_message(client: LettaSDKClient, agent_id: str) -> str",
          "parameters": "(client: LettaSDKClient, agent_id: str)",
          "return_type": "str",
          "docstring": "Helper function to get the raw system message from an agent's preview payload.",
          "decorators": [],
          "start_line": 30,
          "end_line": 44,
          "is_async": false
        },
        {
          "name": "clear_sources",
          "signature": "def clear_sources(client: LettaSDKClient)",
          "parameters": "(client: LettaSDKClient)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 48,
          "end_line": 51,
          "is_async": false
        },
        {
          "name": "run_server",
          "signature": "def run_server()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 54,
          "end_line": 60,
          "is_async": false
        },
        {
          "name": "client",
          "signature": "def client() -> LettaSDKClient",
          "parameters": "()",
          "return_type": "LettaSDKClient",
          "docstring": null,
          "decorators": [
            "@pytest.fixture(scope=\"module\")"
          ],
          "start_line": 64,
          "end_line": 74,
          "is_async": false
        },
        {
          "name": "agent_state",
          "signature": "def agent_state(disable_pinecone, client: LettaSDKClient)",
          "parameters": "(disable_pinecone, client: LettaSDKClient)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 78,
          "end_line": 95,
          "is_async": false
        },
        {
          "name": "test_auto_attach_detach_files_tools",
          "signature": "def test_auto_attach_detach_files_tools(disable_pinecone, disable_turbopuffer, client: LettaSDKClient)",
          "parameters": "(disable_pinecone, disable_turbopuffer, client: LettaSDKClient)",
          "return_type": null,
          "docstring": "Test automatic attachment and detachment of file tools when managing agent sources.",
          "decorators": [],
          "start_line": 101,
          "end_line": 156,
          "is_async": false
        },
        {
          "name": "test_file_upload_creates_source_blocks_correctly",
          "signature": "def test_file_upload_creates_source_blocks_correctly(\n    disable_pinecone,\n    disable_turbopuffer,\n    client: LettaSDKClient,\n    agent_state: AgentState,\n    file_path: str,\n    expected_value: str,\n    expected_label_regex: str,\n    use_mistral_parser: bool,\n)",
          "parameters": "(\n    disable_pinecone,\n    disable_turbopuffer,\n    client: LettaSDKClient,\n    agent_state: AgentState,\n    file_path: str,\n    expected_value: str,\n    expected_label_regex: str,\n    use_mistral_parser: bool,\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\"use_mistral_parser\", [True, False])",
            "@pytest.mark.parametrize(\n    \"file_path, expected_value, expected_label_regex\",\n    [\n        (\"tests/data/test.txt\", \"test\", r\"test_source/test\\.txt\"),\n        (\"tests/data/memgpt_paper.pdf\", \"MemGPT\", r\"test_source/memgpt_paper\\.pdf\"),\n        (\"tests/data/toy_chat_fine_tuning.jsonl\", '{\"messages\"', r\"test_source/toy_chat_fine_tuning\\.jsonl\"),\n        (\"tests/data/test.md\", \"h2 Heading\", r\"test_source/test\\.md\"),\n        (\"tests/data/test.json\", \"glossary\", r\"test_source/test\\.json\"),\n        (\"tests/data/react_component.jsx\", \"UserProfile\", r\"test_source/react_component\\.jsx\"),\n        (\"tests/data/task_manager.java\", \"TaskManager\", r\"test_source/task_manager\\.java\"),\n        (\"tests/data/data_structures.cpp\", \"BinarySearchTree\", r\"test_source/data_structures\\.cpp\"),\n        (\"tests/data/api_server.go\", \"UserService\", r\"test_source/api_server\\.go\"),\n        (\"tests/data/data_analysis.py\", \"StatisticalAnalyzer\", r\"test_source/data_analysis\\.py\"),\n        (\"tests/data/test.csv\", \"Smart Fridge Plus\", r\"test_source/test\\.csv\"),\n    ],\n)"
          ],
          "start_line": 176,
          "end_line": 245,
          "is_async": false
        },
        {
          "name": "test_attach_existing_files_creates_source_blocks_correctly",
          "signature": "def test_attach_existing_files_creates_source_blocks_correctly(\n    disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState\n)",
          "parameters": "(\n    disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 248,
          "end_line": 312,
          "is_async": false
        },
        {
          "name": "test_delete_source_removes_source_blocks_correctly",
          "signature": "def test_delete_source_removes_source_blocks_correctly(\n    disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState\n)",
          "parameters": "(\n    disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 315,
          "end_line": 372,
          "is_async": false
        },
        {
          "name": "test_agent_uses_open_close_file_correctly",
          "signature": "def test_agent_uses_open_close_file_correctly(disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState)",
          "parameters": "(disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 375,
          "end_line": 476,
          "is_async": false
        },
        {
          "name": "st_agent_uses_search_files_correctly(d",
          "signature": "def st_agent_uses_search_files_correctly(disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n",
          "parameters": "isable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 479,
          "end_line": 522,
          "is_async": false
        },
        {
          "name": "st_agent_uses_grep_correctly_basic(d",
          "signature": "def st_agent_uses_grep_correctly_basic(disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n",
          "parameters": "isable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 525,
          "end_line": 566,
          "is_async": false
        },
        {
          "name": "st_agent_uses_grep_correctly_advanced(d",
          "signature": "def st_agent_uses_grep_correctly_advanced(disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n",
          "parameters": "isable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 569,
          "end_line": 616,
          "is_async": false
        },
        {
          "name": "st_create_agent_with_source_ids_creates_source_blocks_correctly(d",
          "signature": "def st_create_agent_with_source_ids_creates_source_blocks_correctly(disable_pinecone, disable_turbopuffer, client: LettaSDKClient):\n",
          "parameters": "isable_pinecone, disable_turbopuffer, client: LettaSDKClient):\n",
          "return_type": null,
          "docstring": "\"Test that creating an agent with source_ids parameter correctly creates source blocks.\"\"\"",
          "decorators": [],
          "start_line": 619,
          "end_line": 659,
          "is_async": false
        },
        {
          "name": "st_view_ranges_have_metadata(d",
          "signature": "def st_view_ranges_have_metadata(disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n",
          "parameters": "isable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 662,
          "end_line": 722,
          "is_async": false
        },
        {
          "name": "st_duplicate_file_renaming(d",
          "signature": "def st_duplicate_file_renaming(disable_pinecone, disable_turbopuffer, client: LettaSDKClient):\n",
          "parameters": "isable_pinecone, disable_turbopuffer, client: LettaSDKClient):\n",
          "return_type": null,
          "docstring": "\"Test that duplicate files are renamed with count-based suffixes (e.g., file.txt, file (1).txt, file (2).txt)\"\"\"",
          "decorators": [],
          "start_line": 725,
          "end_line": 761,
          "is_async": false
        },
        {
          "name": "uplicate_file_handling_replace(disab",
          "signature": "def uplicate_file_handling_replace(disable_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    ",
          "parameters": "le_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    ",
          "return_type": null,
          "docstring": "t that DuplicateFileHandling.REPLACE replaces existing files with same name\"\"\"\n    #",
          "decorators": [],
          "start_line": 764,
          "end_line": 841,
          "is_async": false
        },
        {
          "name": "oad_file_with_custom_name(disable",
          "signature": "def oad_file_with_custom_name(disable_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "parameters": "_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "that uploading a file with a custom name overrides the original filename\"\"\"\n    # C",
          "decorators": [],
          "start_line": 844,
          "end_line": 924,
          "is_async": false
        },
        {
          "name": "n_files_schema_descriptions(disable",
          "signature": "def n_files_schema_descriptions(disable_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "parameters": "_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "that open_files tool schema contains correct descriptions from docstring\"\"\"\n\n    #",
          "decorators": [],
          "start_line": 927,
          "end_line": 1007,
          "is_async": false
        },
        {
          "name": "p_files_schema_descriptions(disable",
          "signature": "def p_files_schema_descriptions(disable_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "parameters": "_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "that grep_files tool schema contains correct descriptions from docstring\"\"\"\n\n    #",
          "decorators": [],
          "start_line": 1010,
          "end_line": 1093,
          "is_async": false
        },
        {
          "name": "nt_open_file(disable",
          "signature": "def nt_open_file(disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n    \"\"",
          "parameters": "_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n    \"\"",
          "return_type": null,
          "docstring": "client.agents.open_file() function\"\"\"\n    # C",
          "decorators": [],
          "start_line": 1096,
          "end_line": 1116,
          "is_async": false
        },
        {
          "name": "nt_close_file(disable",
          "signature": "def nt_close_file(disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n    \"\"",
          "parameters": "_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n    \"\"",
          "return_type": null,
          "docstring": "client.agents.close_file() function\"\"\"\n    # C",
          "decorators": [],
          "start_line": 1119,
          "end_line": 1140,
          "is_async": false
        },
        {
          "name": "nt_close_all_open_files(disable",
          "signature": "def nt_close_all_open_files(disable_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n    \"\"",
          "parameters": "_pinecone, disable_turbopuffer, client: LettaSDKClient, agent_state: AgentState):\n    \"\"",
          "return_type": null,
          "docstring": "client.agents.close_all_open_files() function\"\"\"\n    # C",
          "decorators": [],
          "start_line": 1143,
          "end_line": 1173,
          "is_async": false
        },
        {
          "name": "e_processing_timeout(disable",
          "signature": "def e_processing_timeout(disable_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "parameters": "_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "that files in non-terminal states are moved to error after timeout\"\"\"\n    # C",
          "decorators": [],
          "start_line": 1176,
          "end_line": 1217,
          "is_async": false
        },
        {
          "name": "e_processing_timeout_logic():\n    ",
          "signature": "def e_processing_timeout_logic():\n    \"\"",
          "parameters": "\"\"",
          "return_type": null,
          "docstring": "the timeout logic directly without server dependencies\"\"\"\n    fro",
          "decorators": [
            "mark.unit\ndef tes"
          ],
          "start_line": 1221,
          "end_line": 1242,
          "is_async": false
        },
        {
          "name": "nai_embedding(disable",
          "signature": "def nai_embedding(disable_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "parameters": "_pinecone, disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "creating a source with OpenAI embeddings and uploading a file\"\"\"\n    sou",
          "decorators": [],
          "start_line": 1245,
          "end_line": 1269,
          "is_async": false
        },
        {
          "name": "econe_search_files_tool(disable",
          "signature": "def econe_search_files_tool(disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "parameters": "_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "that search_files tool uses Pinecone when enabled\"\"\"\n    fro",
          "decorators": [],
          "start_line": 1273,
          "end_line": 1321,
          "is_async": false
        },
        {
          "name": "econe_list_files_status(disable",
          "signature": "def econe_list_files_status(disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "parameters": "_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "that list_source_files properly syncs embedding status with Pinecone\"\"\"\n    if",
          "decorators": [],
          "start_line": 1324,
          "end_line": 1360,
          "is_async": false
        },
        {
          "name": "econe_lifecycle_file_and_source_deletion(disable",
          "signature": "def econe_lifecycle_file_and_source_deletion(disable_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "parameters": "_turbopuffer, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "that file and source deletion removes records from Pinecone\"\"\"\n    fro",
          "decorators": [],
          "start_line": 1363,
          "end_line": 1431,
          "is_async": false
        },
        {
          "name": "bopuffer_search_files_tool(disable",
          "signature": "def bopuffer_search_files_tool(disable_pinecone, client: LettaSDKClient):\n    \"\"",
          "parameters": "_pinecone, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "that search_files tool uses Turbopuffer when enabled\"\"\"\n    age",
          "decorators": [],
          "start_line": 1438,
          "end_line": 1475,
          "is_async": false
        },
        {
          "name": "bopuffer_file_processing_status(disable",
          "signature": "def bopuffer_file_processing_status(disable_pinecone, client: LettaSDKClient):\n    \"\"",
          "parameters": "_pinecone, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "that file processing completes successfully with Turbopuffer\"\"\"\n    pri",
          "decorators": [],
          "start_line": 1478,
          "end_line": 1507,
          "is_async": false
        },
        {
          "name": "bopuffer_lifecycle_file_and_source_deletion(disable",
          "signature": "def bopuffer_lifecycle_file_and_source_deletion(disable_pinecone, client: LettaSDKClient):\n    \"\"",
          "parameters": "_pinecone, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "that file and source deletion removes records from Turbopuffer\"\"\"\n    sou",
          "decorators": [],
          "start_line": 1510,
          "end_line": 1579,
          "is_async": false
        },
        {
          "name": "bopuffer_multiple_sources(disable",
          "signature": "def bopuffer_multiple_sources(disable_pinecone, client: LettaSDKClient):\n    \"\"",
          "parameters": "_pinecone, client: LettaSDKClient):\n    \"\"",
          "return_type": null,
          "docstring": "that Turbopuffer correctly isolates passages by source in org-scoped namespace\"\"\"\n    sou",
          "decorators": [],
          "start_line": 1582,
          "end_line": 1627,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317313
    },
    "tests/test_static_buffer_summarize.py": {
      "path": "tests/test_static_buffer_summarize.py",
      "contentHash": "3e3f6faeb9082041f0aa6d393c86f970",
      "mtime": 1767315072160.5488,
      "functions": [
        {
          "name": "mock_summarizer_agent",
          "signature": "def mock_summarizer_agent()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 21,
          "end_line": 25,
          "is_async": false
        },
        {
          "name": "messages",
          "signature": "def messages()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.fixture"
          ],
          "start_line": 29,
          "end_line": 37,
          "is_async": false
        },
        {
          "name": "test_static_buffer_summarization_no_trim_needed",
          "signature": "def test_static_buffer_summarization_no_trim_needed(mock_summarizer_agent, messages)",
          "parameters": "(mock_summarizer_agent, messages)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 41,
          "end_line": 46,
          "is_async": true
        },
        {
          "name": "test_static_buffer_summarization_trim_needed",
          "signature": "def test_static_buffer_summarization_trim_needed(mock_summarizer_agent, messages)",
          "parameters": "(mock_summarizer_agent, messages)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 50,
          "end_line": 61,
          "is_async": true
        },
        {
          "name": "test_static_buffer_summarization_trim_user_message",
          "signature": "def test_static_buffer_summarization_trim_user_message(mock_summarizer_agent, messages)",
          "parameters": "(mock_summarizer_agent, messages)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 65,
          "end_line": 80,
          "is_async": true
        },
        {
          "name": "test_static_buffer_summarization_no_trim_no_summarization",
          "signature": "def test_static_buffer_summarization_no_trim_no_summarization(mock_summarizer_agent, messages)",
          "parameters": "(mock_summarizer_agent, messages)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 84,
          "end_line": 90,
          "is_async": true
        },
        {
          "name": "test_static_buffer_summarization_json_parsing_failure",
          "signature": "def test_static_buffer_summarization_json_parsing_failure(mock_summarizer_agent, messages)",
          "parameters": "(mock_summarizer_agent, messages)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 94,
          "end_line": 109,
          "is_async": true
        },
        {
          "name": "test_static_buffer_summarization_all_user_messages_trimmed",
          "signature": "def test_static_buffer_summarization_all_user_messages_trimmed(mock_summarizer_agent, messages)",
          "parameters": "(mock_summarizer_agent, messages)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 113,
          "end_line": 129,
          "is_async": true
        },
        {
          "name": "test_static_buffer_summarization_no_assistant_messages_trimmed",
          "signature": "def test_static_buffer_summarization_no_assistant_messages_trimmed(mock_summarizer_agent, messages)",
          "parameters": "(mock_summarizer_agent, messages)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 133,
          "end_line": 150,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317313
    },
    "tests/test_stream_buffer_readers.py": {
      "path": "tests/test_stream_buffer_readers.py",
      "contentHash": "3989fcf39d1bb7bb43a41e81c8aa3707",
      "mtime": 1767315072160.5488,
      "functions": [
        {
          "name": "test_inner_thoughts_in_args_simple",
          "signature": "def test_inner_thoughts_in_args_simple(wait_for_first_key)",
          "parameters": "(wait_for_first_key)",
          "return_type": null,
          "docstring": "Test case where the function_delta.arguments contains inner_thoughts\n\n    Correct output should be inner_thoughts VALUE (not KEY) being written to one buffer\n    And everything else (omiting inner_thoughts KEY) being written to the other buffer",
          "decorators": [
            "@pytest.mark.parametrize(\"wait_for_first_key\", [True, False])"
          ],
          "start_line": 9,
          "end_line": 83,
          "is_async": false
        },
        {
          "name": "s_in_args_trailing_quote(wait_for_first_ke",
          "signature": "def s_in_args_trailing_quote(wait_for_first_key):\n    # Another te",
          "parameters": "y):\n    # Another te",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "etrize(\"wait_for_first_key\", [True, False])\ndef test_inner_th"
          ],
          "start_line": 87,
          "end_line": 196,
          "is_async": false
        },
        {
          "name": "s_not_in_args():\n    \"\"\"Test ca",
          "signature": "def s_not_in_args():\n    \"\"\"Test case",
          "parameters": "se",
          "return_type": null,
          "docstring": "the function_delta.arguments does not contain inner_thoughts\n\n    Correct output should be everything being written to the main_json buffer\n    \"\"\"\n    print(\"Runnin",
          "decorators": [],
          "start_line": 199,
          "end_line": 246,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317313
    },
    "tests/test_temporal_metrics_local.py": {
      "path": "tests/test_temporal_metrics_local.py",
      "contentHash": "af8a354e88d27fc3d593a42c3d022970",
      "mtime": 1767315072160.5488,
      "functions": [
        {
          "name": "setup_metrics",
          "signature": "def setup_metrics()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Setup metrics for testing.",
          "decorators": [
            "@pytest.fixture(autouse=True)"
          ],
          "start_line": 21,
          "end_line": 36,
          "is_async": false
        },
        {
          "name": "test_metrics_initialization",
          "signature": "def test_metrics_initialization()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that metrics initialize correctly.",
          "decorators": [
            "@pytest.mark.asyncio"
          ],
          "start_line": 40,
          "end_line": 45,
          "is_async": true
        },
        {
          "name": "st_workflow_metrics()",
          "signature": "def st_workflow_metrics():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test workflow metrics recording.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 49,
          "end_line": 81,
          "is_async": true
        },
        {
          "name": "etrics_with_real_dogstatsd():\n  ",
          "signature": "def etrics_with_real_dogstatsd():\n    ",
          "parameters": "  ",
          "return_type": null,
          "docstring": "Test metrics with real DogStatsD connection (requires Datadog agent running).\n    This test will skip if the agent is not available.\n    \"\"\"\n    i",
          "decorators": [
            "t.mark.asyncio\nasync"
          ],
          "start_line": 105,
          "end_line": 134,
          "is_async": true
        }
      ],
      "parsedAt": 1769610317313
    },
    "tests/test_tool_rule_solver.py": {
      "path": "tests/test_tool_rule_solver.py",
      "contentHash": "3f8ab140a89599050da706b90487c7b0",
      "mtime": 1767315072160.5488,
      "functions": [
        {
          "name": "test_get_allowed_tool_names_with_init_rules",
          "signature": "def test_get_allowed_tool_names_with_init_rules()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 34,
          "end_line": 41,
          "is_async": false
        },
        {
          "name": "test_get_allowed_tool_names_with_subsequent_rule",
          "signature": "def test_get_allowed_tool_names_with_subsequent_rule()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 44,
          "end_line": 52,
          "is_async": false
        },
        {
          "name": "test_is_terminal_tool",
          "signature": "def test_is_terminal_tool()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 55,
          "end_line": 61,
          "is_async": false
        },
        {
          "name": "test_is_requires_approval_tool",
          "signature": "def test_is_requires_approval_tool()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 64,
          "end_line": 72,
          "is_async": false
        },
        {
          "name": "test_get_allowed_tool_names_no_matching_rule_error",
          "signature": "def test_get_allowed_tool_names_no_matching_rule_error()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 75,
          "end_line": 81,
          "is_async": false
        },
        {
          "name": "test_update_tool_usage_and_get_allowed_tool_names_combined",
          "signature": "def test_update_tool_usage_and_get_allowed_tool_names_combined()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 84,
          "end_line": 99,
          "is_async": false
        },
        {
          "name": "test_conditional_tool_rule",
          "signature": "def test_conditional_tool_rule()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 102,
          "end_line": 118,
          "is_async": false
        },
        {
          "name": "test_invalid_conditional_tool_rule",
          "signature": "def test_invalid_conditional_tool_rule()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 121,
          "end_line": 123,
          "is_async": false
        },
        {
          "name": "test_tool_rules_with_invalid_path",
          "signature": "def test_tool_rules_with_invalid_path()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 126,
          "end_line": 141,
          "is_async": false
        },
        {
          "name": "test_max_count_per_step_tool_rule",
          "signature": "def test_max_count_per_step_tool_rule()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 144,
          "end_line": 157,
          "is_async": false
        },
        {
          "name": "test_max_count_per_step_tool_rule_allows_usage_up_to_limit",
          "signature": "def test_max_count_per_step_tool_rule_allows_usage_up_to_limit()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensure the tool is allowed exactly max_count_limit times.",
          "decorators": [],
          "start_line": 160,
          "end_line": 174,
          "is_async": false
        },
        {
          "name": "test_max_count_per_step_tool_rule_does_not_affect_other_tools",
          "signature": "def test_max_count_per_step_tool_rule_does_not_affect_other_tools()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensure exceeding max count for one tool does not impact others.",
          "decorators": [],
          "start_line": 177,
          "end_line": 188,
          "is_async": false
        },
        {
          "name": "test_max_count_per_step_tool_rule_resets_on_clear",
          "signature": "def test_max_count_per_step_tool_rule_resets_on_clear()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensure clearing tool history resets the rule's limit.",
          "decorators": [],
          "start_line": 191,
          "end_line": 203,
          "is_async": false
        },
        {
          "name": "test_tool_rule_equality_and_hashing",
          "signature": "def test_tool_rule_equality_and_hashing()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test __eq__ and __hash__ methods for all tool rule types.",
          "decorators": [],
          "start_line": 206,
          "end_line": 293,
          "is_async": false
        },
        {
          "name": "test_tool_rule_deduplication_in_set",
          "signature": "def test_tool_rule_deduplication_in_set()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that duplicate tool rules are properly deduplicated when used in sets.",
          "decorators": [],
          "start_line": 296,
          "end_line": 325,
          "is_async": false
        },
        {
          "name": "test_parent_tool_rule_equality",
          "signature": "def test_parent_tool_rule_equality()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test ParentToolRule equality and hashing.",
          "decorators": [],
          "start_line": 328,
          "end_line": 339,
          "is_async": false
        },
        {
          "name": "test_continue_tool_rule_equality_and_hashing",
          "signature": "def test_continue_tool_rule_equality_and_hashing()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 342,
          "end_line": 350,
          "is_async": false
        },
        {
          "name": "test_prompt_template_ignored",
          "signature": "def test_prompt_template_ignored(rule_factory, kwargs_a, kwargs_b)",
          "parameters": "(rule_factory, kwargs_a, kwargs_b)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"rule_factory, kwargs_a, kwargs_b\",\n    [\n        (lambda **kw: InitToolRule(**kw), dict(tool_name=\"t\"), dict(tool_name=\"t\")),\n        (lambda **kw: TerminalToolRule(**kw), dict(tool_name=\"t\"), dict(tool_name=\"t\")),\n        (lambda **kw: ContinueToolRule(**kw), dict(tool_name=\"t\"), dict(tool_name=\"t\")),\n        (lambda **kw: RequiredBeforeExitToolRule(**kw), dict(tool_name=\"t\"), dict(tool_name=\"t\")),\n        (lambda **kw: MaxCountPerStepToolRule(**kw), dict(tool_name=\"t\", max_count_limit=2), dict(tool_name=\"t\", max_count_limit=2)),\n        (lambda **kw: ChildToolRule(**kw), dict(tool_name=\"t\", children=[\"a\", \"b\"]), dict(tool_name=\"t\", children=[\"a\", \"b\"])),\n        (lambda **kw: ParentToolRule(**kw), dict(tool_name=\"t\", children=[\"a\", \"b\"]), dict(tool_name=\"t\", children=[\"a\", \"b\"])),\n        (\n            lambda **kw: ConditionalToolRule(**kw),\n            dict(tool_name=\"t\", child_output_mapping={\"x\": \"a\"}, default_child=None, require_output_mapping=False),\n            dict(tool_name=\"t\", child_output_mapping={\"x\": \"a\"}, default_child=None, require_output_mapping=False),\n        ),\n    ],\n)"
          ],
          "start_line": 370,
          "end_line": 374,
          "is_async": false
        },
        {
          "name": "test_cross_type_hash_distinguishes_types",
          "signature": "def test_cross_type_hash_distinguishes_types(a, b)",
          "parameters": "(a, b)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"a,b\",\n    [\n        (InitToolRule(tool_name=\"same\"), TerminalToolRule(tool_name=\"same\")),\n        (ContinueToolRule(tool_name=\"same\"), RequiredBeforeExitToolRule(tool_name=\"same\")),\n        (ChildToolRule(tool_name=\"same\", children=[\"x\"]), ParentToolRule(tool_name=\"same\", children=[\"x\"])),\n    ],\n)"
          ],
          "start_line": 385,
          "end_line": 387,
          "is_async": false
        },
        {
          "name": "test_equality_with_non_rule_objects",
          "signature": "def test_equality_with_non_rule_objects(rule)",
          "parameters": "(rule)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"rule\",\n    [\n        InitToolRule(tool_name=\"x\"),\n        TerminalToolRule(tool_name=\"x\"),\n        ContinueToolRule(tool_name=\"x\"),\n        RequiredBeforeExitToolRule(tool_name=\"x\"),\n        MaxCountPerStepToolRule(tool_name=\"x\", max_count_limit=1),\n        ChildToolRule(tool_name=\"x\", children=[\"a\"]),\n        ParentToolRule(tool_name=\"x\", children=[\"a\"]),\n        ConditionalToolRule(tool_name=\"x\", child_output_mapping={\"k\": \"a\"}, default_child=None, require_output_mapping=False),\n    ],\n)"
          ],
          "start_line": 403,
          "end_line": 405,
          "is_async": false
        },
        {
          "name": "test_conditional_tool_rule_mapping_order_and_hash",
          "signature": "def test_conditional_tool_rule_mapping_order_and_hash()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 408,
          "end_line": 416,
          "is_async": false
        },
        {
          "name": "test_conditional_tool_rule_mapping_numeric_and_bool_keys_equivalence_current_behavior",
          "signature": "def test_conditional_tool_rule_mapping_numeric_and_bool_keys_equivalence_current_behavior()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 419,
          "end_line": 428,
          "is_async": false
        },
        {
          "name": "test_conditional_tool_rule_mapping_string_vs_numeric_not_equal",
          "signature": "def test_conditional_tool_rule_mapping_string_vs_numeric_not_equal()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 431,
          "end_line": 435,
          "is_async": false
        },
        {
          "name": "test_child_and_parent_order_invariance_multiple_permutations",
          "signature": "def test_child_and_parent_order_invariance_multiple_permutations()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 438,
          "end_line": 457,
          "is_async": false
        },
        {
          "name": "test_conditional_order_invariance_multiple_permutations",
          "signature": "def test_conditional_order_invariance_multiple_permutations()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 460,
          "end_line": 469,
          "is_async": false
        },
        {
          "name": "test_dedup_in_set_with_continue_and_required_and_terminal",
          "signature": "def test_dedup_in_set_with_continue_and_required_and_terminal()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 475,
          "end_line": 484,
          "is_async": false
        },
        {
          "name": "test_required_before_exit_tool_rule_has_required_tools_been_called",
          "signature": "def test_required_before_exit_tool_rule_has_required_tools_been_called()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test has_required_tools_been_called() with no required tools.",
          "decorators": [],
          "start_line": 487,
          "end_line": 491,
          "is_async": false
        },
        {
          "name": "test_required_before_exit_tool_rule_single_required_tool",
          "signature": "def test_required_before_exit_tool_rule_single_required_tool()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test with a single required-before-exit tool.",
          "decorators": [],
          "start_line": 494,
          "end_line": 505,
          "is_async": false
        },
        {
          "name": "test_required_before_exit_tool_rule_multiple_required_tools",
          "signature": "def test_required_before_exit_tool_rule_multiple_required_tools()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test with multiple required-before-exit tools.",
          "decorators": [],
          "start_line": 508,
          "end_line": 538,
          "is_async": false
        },
        {
          "name": "test_required_before_exit_tool_rule_mixed_with_other_tools",
          "signature": "def test_required_before_exit_tool_rule_mixed_with_other_tools()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test required-before-exit tools mixed with other tool calls.",
          "decorators": [],
          "start_line": 541,
          "end_line": 557,
          "is_async": false
        },
        {
          "name": "test_required_before_exit_tool_rule_clear_history",
          "signature": "def test_required_before_exit_tool_rule_clear_history()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that clearing history resets the required tools state.",
          "decorators": [],
          "start_line": 560,
          "end_line": 573,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_no_rules",
          "signature": "def test_should_force_tool_call_no_rules()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call with no tool rules.",
          "decorators": [],
          "start_line": 576,
          "end_line": 579,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_init_rule_no_history",
          "signature": "def test_should_force_tool_call_init_rule_no_history()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call with InitToolRule and no history.",
          "decorators": [],
          "start_line": 582,
          "end_line": 586,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_init_rule_after_first_call",
          "signature": "def test_should_force_tool_call_init_rule_after_first_call()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call with InitToolRule after first tool call.",
          "decorators": [],
          "start_line": 589,
          "end_line": 595,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_child_rule_active",
          "signature": "def test_should_force_tool_call_child_rule_active()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call when ChildToolRule is active.",
          "decorators": [],
          "start_line": 598,
          "end_line": 604,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_child_rule_inactive",
          "signature": "def test_should_force_tool_call_child_rule_inactive()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call when ChildToolRule is not active.",
          "decorators": [],
          "start_line": 607,
          "end_line": 613,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_conditional_rule_active",
          "signature": "def test_should_force_tool_call_conditional_rule_active()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call when ConditionalToolRule is active.",
          "decorators": [],
          "start_line": 616,
          "end_line": 624,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_parent_rule_active",
          "signature": "def test_should_force_tool_call_parent_rule_active()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call when ParentToolRule is active.",
          "decorators": [],
          "start_line": 627,
          "end_line": 633,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_max_count_rule",
          "signature": "def test_should_force_tool_call_max_count_rule()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call with MaxCountPerStepToolRule (non-constraining).",
          "decorators": [],
          "start_line": 636,
          "end_line": 642,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_terminal_rule",
          "signature": "def test_should_force_tool_call_terminal_rule()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call with TerminalToolRule.",
          "decorators": [],
          "start_line": 645,
          "end_line": 651,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_continue_rule",
          "signature": "def test_should_force_tool_call_continue_rule()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call with ContinueToolRule.",
          "decorators": [],
          "start_line": 654,
          "end_line": 660,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_required_before_exit_rule",
          "signature": "def test_should_force_tool_call_required_before_exit_rule()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call with RequiredBeforeExitToolRule.",
          "decorators": [],
          "start_line": 663,
          "end_line": 669,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_requires_approval_rule",
          "signature": "def test_should_force_tool_call_requires_approval_rule()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call with RequiresApprovalToolRule.",
          "decorators": [],
          "start_line": 672,
          "end_line": 678,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_multiple_constrained_rules_one_active",
          "signature": "def test_should_force_tool_call_multiple_constrained_rules_one_active()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call with multiple constrained rules where one is active.",
          "decorators": [],
          "start_line": 681,
          "end_line": 695,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_after_clear_with_init_rule",
          "signature": "def test_should_force_tool_call_after_clear_with_init_rule()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call after clearing history with InitToolRule.",
          "decorators": [],
          "start_line": 698,
          "end_line": 710,
          "is_async": false
        },
        {
          "name": "test_should_force_tool_call_mixed_rules",
          "signature": "def test_should_force_tool_call_mixed_rules()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test should_force_tool_call with a mix of constraining and non-constraining rules.",
          "decorators": [],
          "start_line": 713,
          "end_line": 728,
          "is_async": false
        },
        {
          "name": "make_tool",
          "signature": "def make_tool(name: str, properties: dict) -> Tool",
          "parameters": "(name: str, properties: dict)",
          "return_type": "Tool",
          "docstring": "Helper to build a minimal custom Tool with a JSON schema.",
          "decorators": [],
          "start_line": 731,
          "end_line": 745,
          "is_async": false
        },
        {
          "name": "test_init_rule_args_are_cached_in_solver",
          "signature": "def test_init_rule_args_are_cached_in_solver()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 748,
          "end_line": 755,
          "is_async": false
        },
        {
          "name": "test_cached_provenance_format",
          "signature": "def test_cached_provenance_format()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 758,
          "end_line": 762,
          "is_async": false
        },
        {
          "name": "test_cache_empty_when_no_args",
          "signature": "def test_cache_empty_when_no_args()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 765,
          "end_line": 771,
          "is_async": false
        },
        {
          "name": "test_cache_recomputed_on_next_call",
          "signature": "def test_cache_recomputed_on_next_call()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 774,
          "end_line": 784,
          "is_async": false
        },
        {
          "name": "test_merge_and_validate_prefilled_args_overrides_llm_values",
          "signature": "def test_merge_and_validate_prefilled_args_overrides_llm_values()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 787,
          "end_line": 793,
          "is_async": false
        },
        {
          "name": "test_merge_and_validate_prefilled_args_type_validation",
          "signature": "def test_merge_and_validate_prefilled_args_type_validation()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 796,
          "end_line": 804,
          "is_async": false
        },
        {
          "name": "test_merge_and_validate_prefilled_args_unknown_key_fails",
          "signature": "def test_merge_and_validate_prefilled_args_unknown_key_fails()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 807,
          "end_line": 811,
          "is_async": false
        },
        {
          "name": "test_merge_and_validate_prefilled_args_enum_const_anyof_oneof",
          "signature": "def test_merge_and_validate_prefilled_args_enum_const_anyof_oneof()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 814,
          "end_line": 859,
          "is_async": false
        },
        {
          "name": "test_merge_and_validate_prefilled_args_union_with_null",
          "signature": "def test_merge_and_validate_prefilled_args_union_with_null()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 862,
          "end_line": 872,
          "is_async": false
        },
        {
          "name": "test_merge_and_validate_prefilled_args_object_and_array_types",
          "signature": "def test_merge_and_validate_prefilled_args_object_and_array_types()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 875,
          "end_line": 893,
          "is_async": false
        },
        {
          "name": "test_multiple_rules_args_last_write_wins_and_provenance",
          "signature": "def test_multiple_rules_args_last_write_wins_and_provenance()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 896,
          "end_line": 906,
          "is_async": false
        },
        {
          "name": "test_child_rule_args_cached_only_when_parent_last_tool",
          "signature": "def test_child_rule_args_cached_only_when_parent_last_tool()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 909,
          "end_line": 928,
          "is_async": false
        },
        {
          "name": "test_init_then_child_args_applied_in_correct_phases",
          "signature": "def test_init_then_child_args_applied_in_correct_phases()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 931,
          "end_line": 950,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317314
    },
    "tests/test_tool_sandbox/restaurant_management_system/adjust_menu_prices.py": {
      "path": "tests/test_tool_sandbox/restaurant_management_system/adjust_menu_prices.py",
      "contentHash": "672eda741d3941e70ef17f009b5901b9",
      "mtime": 1767315072160.5488,
      "functions": [
        {
          "name": "adjust_menu_prices",
          "signature": "def adjust_menu_prices(percentage: float) -> str",
          "parameters": "(percentage: float)",
          "return_type": "str",
          "docstring": "Tool: Adjust Menu Prices\n    Description: Adjusts the prices of all menu items by a given percentage.\n    Args:\n        percentage (float): The percentage by which to adjust prices. Positive for an increase, negative for a decrease.\n    Returns:\n        str: A formatted string summarizing the price adjustments.",
          "decorators": [],
          "start_line": 1,
          "end_line": 34,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317314
    },
    "tests/test_tool_sandbox/restaurant_management_system/core/utils.py": {
      "path": "tests/test_tool_sandbox/restaurant_management_system/core/utils.py",
      "contentHash": "423a0cddec7ce6f6d991c005c1b9eff2",
      "mtime": 1767315072160.5488,
      "functions": [
        {
          "name": "format_currency",
          "signature": "def format_currency(value: float) -> str",
          "parameters": "(value: float)",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 1,
          "end_line": 2,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317314
    },
    "tests/test_tool_sandbox/restaurant_management_system/test.py": {
      "path": "tests/test_tool_sandbox/restaurant_management_system/test.py",
      "contentHash": "602c5c59180f10ba34e8e49737620a7e",
      "mtime": 1767315072160.5488,
      "functions": [
        {
          "name": "generate_and_execute_tool",
          "signature": "def generate_and_execute_tool(tool_name: str, args: dict)",
          "parameters": "(tool_name: str, args: dict)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 5,
          "end_line": 22,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317314
    },
    "tests/test_tool_schema_parsing.py": {
      "path": "tests/test_tool_schema_parsing.py",
      "contentHash": "409c8fb5ea39658444dba57022d97be1",
      "mtime": 1767315072164.549,
      "functions": [
        {
          "name": "test_derive_openai_json_schema",
          "signature": "def test_derive_openai_json_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that the schema generator works across a variety of example source code inputs.",
          "decorators": [],
          "start_line": 89,
          "end_line": 125,
          "is_async": false
        },
        {
          "name": "test_valid_schemas_via_openai",
          "signature": "def test_valid_schemas_via_openai(openai_model: str, structured_output: bool)",
          "parameters": "(openai_model: str, structured_output: bool)",
          "return_type": null,
          "docstring": "Test that we can send the schemas to OpenAI and get a tool call back.",
          "decorators": [
            "@pytest.mark.parametrize(\"openai_model\", [\"gpt-4o\"])",
            "@pytest.mark.parametrize(\"structured_output\", [True, False])"
          ],
          "start_line": 199,
          "end_line": 236,
          "is_async": false
        },
        {
          "name": "test_valid_schemas_with_pydantic_args_schema",
          "signature": "def test_valid_schemas_with_pydantic_args_schema(openai_model: str, structured_output: bool)",
          "parameters": "(openai_model: str, structured_output: bool)",
          "return_type": null,
          "docstring": "Test that we can send the schemas to OpenAI and get a tool call back.",
          "decorators": [
            "@pytest.mark.parametrize(\"openai_model\", [\"gpt-4o\"])",
            "@pytest.mark.parametrize(\"structured_output\", [True, False])"
          ],
          "start_line": 317,
          "end_line": 352,
          "is_async": false
        },
        {
          "name": "good_function",
          "signature": "def good_function(file_requests: list, close_all_others: bool = False) -> str",
          "parameters": "(file_requests: list, close_all_others: bool = False)",
          "return_type": "str",
          "docstring": "Open files.\n\n    Args:\n        file_requests (list): Requests.\n        close_all_others (bool): Flag.\n\n    Returns:\n        str: Status.",
          "decorators": [],
          "start_line": 369,
          "end_line": 379,
          "is_async": false
        },
        {
          "name": "good_function_no_return",
          "signature": "def good_function_no_return(file_requests: list, close_all_others: bool = False) -> str",
          "parameters": "(file_requests: list, close_all_others: bool = False)",
          "return_type": "str",
          "docstring": "Open files.\n\n    Args:\n        file_requests (list): Requests.\n        close_all_others (bool): Flag.",
          "decorators": [],
          "start_line": 382,
          "end_line": 389,
          "is_async": false
        },
        {
          "name": "agent_state_ok",
          "signature": "def agent_state_ok(agent_state, value: int) -> str",
          "parameters": "(agent_state, value: int)",
          "return_type": "str",
          "docstring": "Ignores agent_state param.\n\n    Args:\n        value (int): Some value.\n\n    Returns:\n        str: Status.",
          "decorators": [],
          "start_line": 392,
          "end_line": 401,
          "is_async": false
        },
        {
          "name": "no_doc",
          "signature": "def no_doc(x: int) -> str",
          "parameters": "(x: int)",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 418,
          "end_line": 419,
          "is_async": false
        },
        {
          "name": "no_args",
          "signature": "def no_args(x: int) -> str",
          "parameters": "(x: int)",
          "return_type": "str",
          "docstring": "Missing Args.\n\n    Returns:\n        str: Status.",
          "decorators": [],
          "start_line": 422,
          "end_line": 428,
          "is_async": false
        },
        {
          "name": "missing_param_doc",
          "signature": "def missing_param_doc(x: int, y: int) -> str",
          "parameters": "(x: int, y: int)",
          "return_type": "str",
          "docstring": "Only one param documented.\n\n    Args:\n        x (int): X.\n\n    Returns:\n        str: Status.",
          "decorators": [],
          "start_line": 431,
          "end_line": 440,
          "is_async": false
        },
        {
          "name": "test_google_style_docstring_validation",
          "signature": "def test_google_style_docstring_validation(fn, regex)",
          "parameters": "(fn, regex)",
          "return_type": null,
          "docstring": null,
          "decorators": [
            "@pytest.mark.parametrize(\n    \"fn, regex\",\n    [\n        (good_function, None),\n        (agent_state_ok, None),\n        (Dummy.method, None),  # unbound method keeps `self`\n        (good_function_no_return, None),\n        (no_doc, \"has no docstring\"),\n        (no_args, \"must have 'Args:' section\"),\n        (missing_param_doc, \"parameter 'y' not documented\"),\n    ],\n)"
          ],
          "start_line": 456,
          "end_line": 457,
          "is_async": false
        },
        {
          "name": "test_reserved_params_excluded_from_schema",
          "signature": "def test_reserved_params_excluded_from_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that reserved params (agent_state) are excluded from generated schema.",
          "decorators": [],
          "start_line": 460,
          "end_line": 468,
          "is_async": false
        },
        {
          "name": "test_complex_nested_anyof_schema_to_structured_output",
          "signature": "def test_complex_nested_anyof_schema_to_structured_output()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that complex nested anyOf schemas with inlined $refs can be converted to structured outputs.\n\n    This test verifies that convert_to_structured_output properly handles:\n    - Simple anyOf (primitives) - flattened to type arrays\n    - Complex anyOf (with objects) - preserved as anyOf\n    - Nested structures with recursion",
          "decorators": [],
          "start_line": 471,
          "end_line": 673,
          "is_async": false
        }
      ],
      "parsedAt": 1769610317314
    },
    "tests/test_tool_schema_parsing_files/all_python_complex.py": {
      "path": "tests/test_tool_schema_parsing_files/all_python_complex.py",
      "contentHash": "ca941f496287c2d4045ff954be0e5a77",
      "mtime": 1767315072164.549,
      "functions": [
        {
          "name": "check_order_status",
          "signature": "def check_order_status(\n    order_number: int,\n    customer_name: str,\n    related_tickets: List[str],\n    related_ticket_reasons: dict,\n    severity: float,\n    metadata: Optional[dict],\n)",
          "parameters": "(\n    order_number: int,\n    customer_name: str,\n    related_tickets: List[str],\n    related_ticket_reasons: dict,\n    severity: float,\n    metadata: Optional[dict],\n)",
          "return_type": null,
          "docstring": "Check the status for an order number (integer value).\n\n    Args:\n        order_number (int): The order number to check on.\n        customer_name (str): The name of the customer who placed the order.\n        related_tickets (List[str]): A list of ticket numbers related to the order.\n        related_ticket_reasons (dict): A dictionary of reasons for the related tickets.\n        severity (float): The severity of the request (between 0 and 1).\n        metadata (Optional[dict]): Additional metadata about the order.\n\n    Returns:\n        str: The status of the order (e.g. cancelled, refunded, processed, processing, shipping).",
          "decorators": [],
          "start_line": 33,
          "end_line": 57,
          "is_async": false
        }
      ],
      "parsedAt": 1769611338484
    },
    "tests/test_tool_schema_parsing_files/all_python_complex_nodict.py": {
      "path": "tests/test_tool_schema_parsing_files/all_python_complex_nodict.py",
      "contentHash": "ef9e53cd08eebf7df15cd0edd809c1dc",
      "mtime": 1767315072164.549,
      "functions": [
        {
          "name": "check_order_status",
          "signature": "def check_order_status(\n    order_number: int,\n    customer_name: str,\n    related_tickets: List[str],\n    severity: float,\n    metadata: Optional[str],\n)",
          "parameters": "(\n    order_number: int,\n    customer_name: str,\n    related_tickets: List[str],\n    severity: float,\n    metadata: Optional[str],\n)",
          "return_type": null,
          "docstring": "Check the status for an order number (integer value).\n\n    Args:\n        order_number (int): The order number to check on.\n        customer_name (str): The name of the customer who placed the order.\n        related_tickets (List[str]): A list of ticket numbers related to the order.\n        severity (float): The severity of the request (between 0 and 1).\n        metadata (Optional[str]): Additional metadata about the order.\n\n    Returns:\n        str: The status of the order (e.g. cancelled, refunded, processed, processing, shipping).",
          "decorators": [],
          "start_line": 29,
          "end_line": 51,
          "is_async": false
        }
      ],
      "parsedAt": 1769611338484
    },
    "tests/test_tool_schema_parsing_files/expected_base_tool_schemas.py": {
      "path": "tests/test_tool_schema_parsing_files/expected_base_tool_schemas.py",
      "contentHash": "3cf5bd98cf59ddd2b40e3452cd1b024c",
      "mtime": 1767315072164.549,
      "functions": [
        {
          "name": "get_rethink_user_memory_schema",
          "signature": "def get_rethink_user_memory_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 1,
          "end_line": 24,
          "is_async": false
        },
        {
          "name": "get_finish_rethinking_memory_schema",
          "signature": "def get_finish_rethinking_memory_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 27,
          "end_line": 36,
          "is_async": false
        },
        {
          "name": "get_store_memories_schema",
          "signature": "def get_store_memories_schema()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 39,
          "end_line": 65,
          "is_async": false
        },
        {
          "name": "search_memory_schema():\n",
          "signature": "def search_memory_schema():\n  ",
          "parameters": "  ",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 68,
          "end_line": 95,
          "is_async": false
        }
      ],
      "parsedAt": 1769611338484
    },
    "tests/test_tool_schema_parsing_files/list_of_pydantic_example.py": {
      "path": "tests/test_tool_schema_parsing_files/list_of_pydantic_example.py",
      "contentHash": "cfd1a37d723cc29d7941ea52385e6512",
      "mtime": 1767315072164.549,
      "functions": [
        {
          "name": "create_task_plan",
          "signature": "def create_task_plan(steps: list[Step]) -> str",
          "parameters": "(steps: list[Step])",
          "return_type": "str",
          "docstring": "Creates a task plan for the current task.\n    It takes in a list of steps, and updates the task with the new steps provided.\n    If there are any current steps, they will be overwritten.\n    Each step in the list should have the following format:\n    {\n        \"name\": <string> -- Name of the step.\n        \"key\": <string> -- Unique identifier for the step.\n        \"description\": <string> -- An exhaustic description of what this step is trying to achieve and accomplish.\n    }\n\n    Args:\n        steps: List of steps to add to the task plan.\n\n    Returns:\n        str: A summary of the updated task plan after deletion",
          "decorators": [],
          "start_line": 26,
          "end_line": 45,
          "is_async": false
        }
      ],
      "parsedAt": 1769611338484
    },
    "tests/test_tool_schema_parsing_files/nested_pydantic_as_arg_example.py": {
      "path": "tests/test_tool_schema_parsing_files/nested_pydantic_as_arg_example.py",
      "contentHash": "af6c53eb8c993c4c8bdffc2a46a79a4c",
      "mtime": 1767315072164.549,
      "functions": [
        {
          "name": "create_task_plan",
          "signature": "def create_task_plan(steps: Steps, completed: int) -> str",
          "parameters": "(steps: Steps, completed: int)",
          "return_type": "str",
          "docstring": "Creates a task plan for the current task.\n    It takes in a list of steps, and updates the task with the new steps provided.\n    If there are any current steps, they will be overwritten.\n    Each step in the list should have the following format:\n    {\n        \"name\": <string> -- Name of the step.\n        \"key\": <string> -- Unique identifier for the step.\n        \"description\": <string> -- An exhaustic description of what this step is trying to achieve and accomplish.\n    }\n\n    Args:\n        steps: List of steps to add to the task plan.\n        completed: The number of steps to add as completed to the task plan.\n\n    Returns:\n        str: A summary of the updated task plan after deletion",
          "decorators": [],
          "start_line": 39,
          "end_line": 59,
          "is_async": false
        }
      ],
      "parsedAt": 1769611338484
    },
    "tests/test_tool_schema_parsing_files/pydantic_as_single_arg_example.py": {
      "path": "tests/test_tool_schema_parsing_files/pydantic_as_single_arg_example.py",
      "contentHash": "fb4960e48bd7280e11d29142782ffa0c",
      "mtime": 1767315072164.549,
      "functions": [
        {
          "name": "create_step",
          "signature": "def create_step(step: Step) -> str",
          "parameters": "(step: Step)",
          "return_type": "str",
          "docstring": "Creates a step for the current task.\n\n    Args:\n        step: A step to add to the task plan.\n\n    Returns:\n        str: A summary of the updated task plan after deletion",
          "decorators": [],
          "start_line": 26,
          "end_line": 37,
          "is_async": false
        }
      ],
      "parsedAt": 1769611338484
    },
    "tests/test_tool_schema_parsing_files/simple_d20.py": {
      "path": "tests/test_tool_schema_parsing_files/simple_d20.py",
      "contentHash": "d708cf6b6d7907c14d078f80a4d4487f",
      "mtime": 1767315072164.549,
      "functions": [
        {
          "name": "roll_d20",
          "signature": "def roll_d20()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Simulate the roll of a 20-sided die (d20).\n\n    This function generates a random integer between 1 and 20, inclusive,\n    which represents the outcome of a single roll of a d20.\n\n    Returns:\n        str: The result of the die roll.",
          "decorators": [],
          "start_line": 1,
          "end_line": 15,
          "is_async": false
        }
      ],
      "parsedAt": 1769611338484
    },
    "tests/test_utils.py": {
      "path": "tests/test_utils.py",
      "contentHash": "f883331899835b2117b5cee97e044fb6",
      "mtime": 1768610518554.2007,
      "functions": [
        {
          "name": "test_get_function_annotations_found",
          "signature": "def test_get_function_annotations_found()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test that we correctly parse annotations for a function\n    that includes multiple argument types and a custom class.",
          "decorators": [],
          "start_line": 45,
          "end_line": 58,
          "is_async": false
        },
        {
          "name": "test_get_function_annotations_not_found",
          "signature": "def test_get_function_annotations_not_found()",
          "parameters": "()",
          "return_type": null,
          "docstring": "If the requested function name doesn't exist exactly,\n    we should raise a ValueError.",
          "decorators": [],
          "start_line": 61,
          "end_line": 67,
          "is_async": false
        },
        {
          "name": "test_get_function_annotations_no_args",
          "signature": "def test_get_function_annotations_no_args()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Check that a function without arguments returns an empty annotations dict.",
          "decorators": [],
          "start_line": 70,
          "end_line": 75,
          "is_async": false
        },
        {
          "name": "test_get_function_annotations_with_default_values",
          "signature": "def test_get_function_annotations_with_default_values()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensure that a function with default arguments still captures the annotations.",
          "decorators": [],
          "start_line": 78,
          "end_line": 83,
          "is_async": false
        },
        {
          "name": "test_get_function_annotations_partial_name_collision",
          "signature": "def test_get_function_annotations_partial_name_collision()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Ensure we only match the exact function name, not partial collisions.",
          "decorators": [],
          "start_line": 86,
          "end_line": 93,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_success",
          "signature": "def test_coerce_dict_args_success()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Basic success scenario with standard types:\n      int, float, str, list, dict.",
          "decorators": [],
          "start_line": 99,
          "end_line": 112,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_invalid_type",
          "signature": "def test_coerce_dict_args_invalid_type()",
          "parameters": "()",
          "return_type": null,
          "docstring": "If the value cannot be coerced into the annotation,\n    a ValueError should be raised.",
          "decorators": [],
          "start_line": 115,
          "end_line": 124,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_no_annotations",
          "signature": "def test_coerce_dict_args_no_annotations()",
          "parameters": "()",
          "return_type": null,
          "docstring": "If there are no annotations, we do no coercion.",
          "decorators": [],
          "start_line": 127,
          "end_line": 134,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_partial_annotations",
          "signature": "def test_coerce_dict_args_partial_annotations()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Only coerce annotated arguments; leave unannotated ones unchanged.",
          "decorators": [],
          "start_line": 137,
          "end_line": 145,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_with_missing_args",
          "signature": "def test_coerce_dict_args_with_missing_args()",
          "parameters": "()",
          "return_type": null,
          "docstring": "If function_args lacks some keys listed in annotations,\n    those are simply not coerced. (We do not add them.)",
          "decorators": [],
          "start_line": 148,
          "end_line": 157,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_unexpected_keys",
          "signature": "def test_coerce_dict_args_unexpected_keys()",
          "parameters": "()",
          "return_type": null,
          "docstring": "If function_args has extra keys not in annotations,\n    we leave them alone.",
          "decorators": [],
          "start_line": 160,
          "end_line": 169,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_unsupported_custom_class",
          "signature": "def test_coerce_dict_args_unsupported_custom_class()",
          "parameters": "()",
          "return_type": null,
          "docstring": "If someone tries to pass an annotation that isn't supported (like a custom class),\n    we should raise a ValueError (or similarly handle the error) rather than silently\n    accept it.",
          "decorators": [],
          "start_line": 172,
          "end_line": 181,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_with_complex_types",
          "signature": "def test_coerce_dict_args_with_complex_types()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Confirm the ability to parse built-in complex data (lists, dicts, etc.)\n    when given as strings.",
          "decorators": [],
          "start_line": 184,
          "end_line": 197,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_non_string_keys",
          "signature": "def test_coerce_dict_args_non_string_keys()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Validate behavior if `function_args` includes non-string keys.\n    (We should simply skip annotation checks for them.)",
          "decorators": [],
          "start_line": 200,
          "end_line": 211,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_non_parseable_list_or_dict",
          "signature": "def test_coerce_dict_args_non_parseable_list_or_dict()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test passing incorrectly formatted JSON for a 'list' or 'dict' annotation.",
          "decorators": [],
          "start_line": 214,
          "end_line": 222,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_with_complex_list_annotation",
          "signature": "def test_coerce_dict_args_with_complex_list_annotation()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test coercion when list with type annotation (e.g., list[int]) is used.",
          "decorators": [],
          "start_line": 225,
          "end_line": 233,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_with_complex_dict_annotation",
          "signature": "def test_coerce_dict_args_with_complex_dict_annotation()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test coercion when dict with type annotation (e.g., dict[str, int]) is used.",
          "decorators": [],
          "start_line": 236,
          "end_line": 244,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_unsupported_complex_annotation",
          "signature": "def test_coerce_dict_args_unsupported_complex_annotation()",
          "parameters": "()",
          "return_type": null,
          "docstring": "If an unsupported complex annotation is used (e.g., a custom class),\n    a ValueError should be raised.",
          "decorators": [],
          "start_line": 247,
          "end_line": 258,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_with_nested_complex_annotation",
          "signature": "def test_coerce_dict_args_with_nested_complex_annotation()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test coercion with complex nested types like list[dict[str, int]].",
          "decorators": [],
          "start_line": 261,
          "end_line": 269,
          "is_async": false
        },
        {
          "name": "test_coerce_dict_args_with_default_arguments",
          "signature": "def test_coerce_dict_args_with_default_arguments()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Test coercion with default arguments, where some arguments have defaults in the source code.",
          "decorators": [],
          "start_line": 272,
          "end_line": 283,
          "is_async": false
        },
        {
          "name": "test_valid_filename",
          "signature": "def test_valid_filename()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 286,
          "end_line": 290,
          "is_async": false
        },
        {
          "name": "test_filename_with_special_characters",
          "signature": "def test_filename_with_special_characters()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 293,
          "end_line": 297,
          "is_async": false
        },
        {
          "name": "st_null_byte_in_filename()",
          "signature": "def st_null_byte_in_filename():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 300,
          "end_line": 305,
          "is_async": false
        },
        {
          "name": "st_path_traversal_characters()",
          "signature": "def st_path_traversal_characters():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 308,
          "end_line": 312,
          "is_async": false
        },
        {
          "name": "st_empty_filename()",
          "signature": "def st_empty_filename():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 315,
          "end_line": 317,
          "is_async": false
        },
        {
          "name": "st_dot_as_filename()",
          "signature": "def st_dot_as_filename():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 320,
          "end_line": 322,
          "is_async": false
        },
        {
          "name": "st_dotdot_as_filename()",
          "signature": "def st_dotdot_as_filename():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 325,
          "end_line": 327,
          "is_async": false
        },
        {
          "name": "st_long_filename()",
          "signature": "def st_long_filename():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 330,
          "end_line": 334,
          "is_async": false
        },
        {
          "name": "st_unique_filenames()",
          "signature": "def st_unique_filenames():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 337,
          "end_line": 345,
          "is_async": false
        },
        {
          "name": "st_basic_sanitization_no_suffix()",
          "signature": "def st_basic_sanitization_no_suffix():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test the new behavior - basic sanitization without UUID suffix\"\"\"",
          "decorators": [],
          "start_line": 348,
          "end_line": 357,
          "is_async": false
        },
        {
          "name": "st_formatter()",
          "signature": "def st_formatter():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 360,
          "end_line": 411,
          "is_async": false
        },
        {
          "name": "st_line_chunker_valid_range()",
          "signature": "def st_line_chunker_valid_range():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that LineChunker works correctly with valid ranges\"\"\"",
          "decorators": [],
          "start_line": 417,
          "end_line": 427,
          "is_async": false
        },
        {
          "name": "st_line_chunker_valid_range_no_validation()",
          "signature": "def st_line_chunker_valid_range_no_validation():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that LineChunker works the same without validation for valid ranges\"\"\"",
          "decorators": [],
          "start_line": 430,
          "end_line": 439,
          "is_async": false
        },
        {
          "name": "st_line_chunker_out_of_range_start()",
          "signature": "def st_line_chunker_out_of_range_start():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that LineChunker throws error when start is out of range\"\"\"",
          "decorators": [],
          "start_line": 442,
          "end_line": 449,
          "is_async": false
        },
        {
          "name": "st_line_chunker_out_of_range_end()",
          "signature": "def st_line_chunker_out_of_range_end():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that LineChunker clamps end when it extends beyond file bounds\"\"\"",
          "decorators": [],
          "start_line": 452,
          "end_line": 464,
          "is_async": false
        },
        {
          "name": "st_line_chunker_edge_case_empty_file()",
          "signature": "def st_line_chunker_edge_case_empty_file():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that LineChunker handles empty files correctly\"\"\"",
          "decorators": [],
          "start_line": 467,
          "end_line": 473,
          "is_async": false
        },
        {
          "name": "st_line_chunker_edge_case_single_line()",
          "signature": "def st_line_chunker_edge_case_single_line():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that LineChunker handles single line files correctly\"\"\"",
          "decorators": [],
          "start_line": 476,
          "end_line": 487,
          "is_async": false
        },
        {
          "name": "st_line_chunker_validation_disabled_allows_out_of_range()",
          "signature": "def st_line_chunker_validation_disabled_allows_out_of_range():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that out-of-bounds start always raises error, but invalid ranges (start>=end) are allowed when validation is off\"\"\"",
          "decorators": [],
          "start_line": 490,
          "end_line": 502,
          "is_async": false
        },
        {
          "name": "st_line_chunker_only_start_parameter()",
          "signature": "def st_line_chunker_only_start_parameter():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test validation with only start parameter specified\"\"\"",
          "decorators": [],
          "start_line": 505,
          "end_line": 518,
          "is_async": false
        },
        {
          "name": "st_get_latest_alembic_revision()",
          "signature": "def st_get_latest_alembic_revision():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that get_latest_alembic_revision returns a valid revision ID from the database.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 525,
          "end_line": 540,
          "is_async": true
        },
        {
          "name": "st_get_latest_alembic_revision_consistency()",
          "signature": "def st_get_latest_alembic_revision_consistency():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that get_latest_alembic_revision returns the same value on multiple calls.\"\"\"",
          "decorators": [
            "ytest.mark.asyncio\na"
          ],
          "start_line": 544,
          "end_line": 553,
          "is_async": true
        },
        {
          "name": "st_validate_function_response_string_input()",
          "signature": "def st_validate_function_response_string_input():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that string inputs are returned unchanged when within limit\"\"\"",
          "decorators": [],
          "start_line": 559,
          "end_line": 562,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_none_input()",
          "signature": "def st_validate_function_response_none_input():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that None inputs are converted to 'None' string\"\"\"",
          "decorators": [],
          "start_line": 565,
          "end_line": 568,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_dict_input()",
          "signature": "def st_validate_function_response_dict_input():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that dict inputs are returned as-is (not pre-serialized) to avoid double JSON encoding\"\"\"",
          "decorators": [],
          "start_line": 571,
          "end_line": 577,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_other_types()",
          "signature": "def st_validate_function_response_other_types():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that other types are converted to strings\"\"\"",
          "decorators": [],
          "start_line": 580,
          "end_line": 592,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_strict_mode_string()",
          "signature": "def st_validate_function_response_strict_mode_string():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test strict mode allows strings\"\"\"",
          "decorators": [],
          "start_line": 595,
          "end_line": 598,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_strict_mode_none()",
          "signature": "def st_validate_function_response_strict_mode_none():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test strict mode allows None\"\"\"",
          "decorators": [],
          "start_line": 601,
          "end_line": 604,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_strict_mode_violation()",
          "signature": "def st_validate_function_response_strict_mode_violation():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test strict mode raises ValueError for non-string/None types\"\"\"",
          "decorators": [],
          "start_line": 607,
          "end_line": 613,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_truncation()",
          "signature": "def st_validate_function_response_truncation():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that long responses are truncated when truncate=True\"\"\"",
          "decorators": [],
          "start_line": 616,
          "end_line": 623,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_no_truncation()",
          "signature": "def st_validate_function_response_no_truncation():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that long responses are not truncated when truncate=False\"\"\"",
          "decorators": [],
          "start_line": 626,
          "end_line": 631,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_exact_limit()",
          "signature": "def st_validate_function_response_exact_limit():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test response exactly at the character limit\"\"\"",
          "decorators": [],
          "start_line": 634,
          "end_line": 638,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_complex_dict()",
          "signature": "def st_validate_function_response_complex_dict():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test with complex nested dictionary - should be returned as-is\"\"\"",
          "decorators": [],
          "start_line": 641,
          "end_line": 647,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_dict_truncation()",
          "signature": "def st_validate_function_response_dict_truncation():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that serialized dict gets truncated properly\"\"\"",
          "decorators": [],
          "start_line": 650,
          "end_line": 656,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_empty_string()",
          "signature": "def st_validate_function_response_empty_string():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test empty string handling\"\"\"",
          "decorators": [],
          "start_line": 659,
          "end_line": 662,
          "is_async": false
        },
        {
          "name": "st_validate_function_response_whitespace()",
          "signature": "def st_validate_function_response_whitespace():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test whitespace-only string handling\"\"\"",
          "decorators": [],
          "start_line": 665,
          "end_line": 668,
          "is_async": false
        },
        {
          "name": "st_sdk_version_check()",
          "signature": "def st_sdk_version_check():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test SDK version check\"\"\"",
          "decorators": [],
          "start_line": 671,
          "end_line": 680,
          "is_async": false
        },
        {
          "name": "st_sanitize_null_bytes_string()",
          "signature": "def st_sanitize_null_bytes_string():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that null bytes are removed from strings\"\"\"",
          "decorators": [],
          "start_line": 686,
          "end_line": 706,
          "is_async": false
        },
        {
          "name": "st_sanitize_null_bytes_dict()",
          "signature": "def st_sanitize_null_bytes_dict():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that null bytes are removed from dictionary values\"\"\"",
          "decorators": [],
          "start_line": 709,
          "end_line": 723,
          "is_async": false
        },
        {
          "name": "st_sanitize_null_bytes_list()",
          "signature": "def st_sanitize_null_bytes_list():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that null bytes are removed from list elements\"\"\"",
          "decorators": [],
          "start_line": 726,
          "end_line": 731,
          "is_async": false
        },
        {
          "name": "st_sanitize_null_bytes_tuple()",
          "signature": "def st_sanitize_null_bytes_tuple():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that null bytes are removed from tuple elements\"\"\"",
          "decorators": [],
          "start_line": 734,
          "end_line": 739,
          "is_async": false
        },
        {
          "name": "st_sanitize_null_bytes_preserves_other_types()",
          "signature": "def st_sanitize_null_bytes_preserves_other_types():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that non-string types are preserved unchanged\"\"\"",
          "decorators": [],
          "start_line": 742,
          "end_line": 750,
          "is_async": false
        },
        {
          "name": "st_json_dumps_sanitizes_null_bytes()",
          "signature": "def st_json_dumps_sanitizes_null_bytes():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that json_dumps sanitizes null bytes before serialization\"\"\"",
          "decorators": [],
          "start_line": 753,
          "end_line": 760,
          "is_async": false
        },
        {
          "name": "st_json_dumps_with_complex_nested_null_bytes()",
          "signature": "def st_json_dumps_with_complex_nested_null_bytes():\n",
          "parameters": ":\n",
          "return_type": null,
          "docstring": "\"Test that json_dumps handles complex nested structures with null bytes\"\"\"",
          "decorators": [],
          "start_line": 763,
          "end_line": 779,
          "is_async": false
        }
      ],
      "parsedAt": 1769611338485
    },
    "tests/utils.py": {
      "path": "tests/utils.py",
      "contentHash": "aa30b6791b14877c47f71477ce875bef",
      "mtime": 1767315072164.549,
      "functions": [
        {
          "name": "wipe_config",
          "signature": "def wipe_config()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 48,
          "end_line": 53,
          "is_async": false
        },
        {
          "name": "wipe_letta_home",
          "signature": "def wipe_letta_home()",
          "parameters": "()",
          "return_type": null,
          "docstring": "Wipes ~/.letta (moves to a backup), and initializes a new ~/.letta dir",
          "decorators": [],
          "start_line": 56,
          "end_line": 72,
          "is_async": false
        },
        {
          "name": "configure_letta_localllm",
          "signature": "def configure_letta_localllm()",
          "parameters": "()",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 75,
          "end_line": 121,
          "is_async": false
        },
        {
          "name": "configure_letta",
          "signature": "def configure_letta(enable_openai=False, enable_azure=False)",
          "parameters": "(enable_openai=False, enable_azure=False)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 124,
          "end_line": 130,
          "is_async": false
        },
        {
          "name": "wait_for_incoming_message",
          "signature": "def wait_for_incoming_message(\n    client: Letta,\n    agent_id: str,\n    substring: str = \"[Incoming message from agent with ID\",\n    max_wait_seconds: float = 10.0,\n    sleep_interval: float = 0.5,\n) -> bool",
          "parameters": "(\n    client: Letta,\n    agent_id: str,\n    substring: str = \"[Incoming message from agent with ID\",\n    max_wait_seconds: float = 10.0,\n    sleep_interval: float = 0.5,\n)",
          "return_type": "bool",
          "docstring": "Polls for up to `max_wait_seconds` to see if the agent's message list\n    contains a system message with `substring`.\n    Returns True if found, otherwise False after timeout.",
          "decorators": [],
          "start_line": 133,
          "end_line": 158,
          "is_async": false
        },
        {
          "name": "wait_for_server",
          "signature": "def wait_for_server(url, timeout=30, interval=0.5)",
          "parameters": "(url, timeout=30, interval=0.5)",
          "return_type": null,
          "docstring": "Wait for server to become available by polling the given URL.",
          "decorators": [],
          "start_line": 161,
          "end_line": 176,
          "is_async": false
        },
        {
          "name": "random_string",
          "signature": "def random_string(length: int) -> str",
          "parameters": "(length: int)",
          "return_type": "str",
          "docstring": null,
          "decorators": [],
          "start_line": 179,
          "end_line": 180,
          "is_async": false
        },
        {
          "name": "create_tool_from_func",
          "signature": "def create_tool_from_func(\n    func,\n    tags: Optional[List[str]] = None,\n    description: Optional[str] = None,\n)",
          "parameters": "(\n    func,\n    tags: Optional[List[str]] = None,\n    description: Optional[str] = None,\n)",
          "return_type": null,
          "docstring": null,
          "decorators": [],
          "start_line": 183,
          "end_line": 198,
          "is_async": false
        }
      ],
      "parsedAt": 1769611338485
    }
  }
}